
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>IT Monkey Life</title>
	<meta name="author" content="Rick">

	
	<meta name="description" content="Apr 9th, 2014 iOS Comments 并发编程：API以及挑战 并发所描述的概念就是同时运行多个任务。这些任务可能是以在单核 CPU 上分时（时间共享）的形式同时运行，也可能是在多核 CPU 上以真正的并行方式来运行。 OS X 和 iOS 提供了几种不同的 API &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/Blog/atom.xml" rel="alternate" title="IT Monkey Life" type="application/atom+xml">
	
	<link rel="canonical" href="http://ITMonkeyLife.github.io/Blog/">
	<link href="/Blog/favicon.png" rel="shortcut icon">
	<link href="/Blog/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/Blog/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/Blog/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("382542165@qq.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>

<nav id="main-nav">
<section class="aboutme">
  <p class = "subtitle">
    心无所恃，随遇而安
  </p>
</section>

<ul class="main">
    <li><a href="/Blog/">我的Blog</a></li>
    <li><a href="/Blog/about/">关于我</a></li>
    <li><a href="/Blog/blog/archives">全部文章</a></li>
</ul></nav>
<nav id="sub-nav">
	<div class="social">
    	
			<a class="sina" href="http://weibo.com/1651400041" title="Sina">Sina</a>
		
		
			<a class="email" href="mailto:382542165@qq.com" title="Email">Email</a>
		
		
		
		
		
		
		
		
		
		
		
		
			<a class="douban" href="https://www.douban.com/people/47445127" title="Douban">Douban</a>
		
		
		
    	
    	
			<a class="rss" href="/Blog/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-09T15:29:37+08:00" data-updated="true" itemprop="datePublished">Apr 9<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/09/bing-fa-bian-cheng-%3Aapiyi-ji-tiao-zhan/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/09/bing-fa-bian-cheng-%3Aapiyi-ji-tiao-zhan/" itemprop="url">并发编程：API以及挑战</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><a href="http://en.wikipedia.org/wiki/Concurrency_%28computer_science%29">并发</a>所描述的概念就是同时运行多个任务。这些任务可能是以在单核 CPU 上<a href="http://en.wikipedia.org/wiki/Preemption_%28computing%29">分时（时间共享）</a>的形式同时运行，也可能是在多核 CPU 上以真正的并行方式来运行。</p>

<p>OS X 和 iOS 提供了几种不同的 API 来支持并发编程。每一个 API 都具有不同的功能和使用限制，这使它们适合不同的任务。同时，这些 API 处在不同的抽象层级上。我们有可能用其进行非常深入底层的操作，但是这也意味着背负起将任务进行良好处理的巨大责任。</p>

<p>实际上，并发编程是一个很有挑战的主题，它有许多错综复杂的问题和陷阱。当开发者在使用类似 <code>Grand Central Dispatch</code>（GCD）或 <code>NSOperationQueue</code> 的 API 时，很容易遗忘这些问题和陷阱。本文首先对 OS X 和 iOS 中不同的并发编程 API 进行一些介绍，然后再深入了解并发编程中独立于与你所使用的特定 API 的一些内在挑战。</p>

<h2 id="osxios">OS X 和 iOS 中的并发编程</h2>

<p>苹果的移动和桌面操作系统中提供了相同的并发编程API。 本文会介绍 <code>pthread</code> 、 <code>NSThread</code> 、<code>GCD</code> 、<code>NSOperationQueue</code>，以及 <code>NSRunLoop</code>。实际上把 run loop 也列在其中是有点奇怪，因为它并不能实现真正的并行，不过因为它与并发编程有莫大的关系，因此值得我们进行一些深入了解。</p>

<p>由于高层 API 是基于底层 API 构建的，所以我们首先将从底层的 API 开始介绍，然后逐步扩展到高层 API。不过在具体编程中，选择 API 的顺序刚好相反：因为大多数情况下，选择高层的 API 不仅可以完成底层 API 能完成的任务，而且能够让并发模型变得简单。</p>

<p>如果你对我们为何坚持推荐使用高抽象层级以及简单的并行代码有所疑问的话，那么你可以看看这篇文章的第二部分<a href="#challenges">并发编程中面临的挑战</a>，以及 Peter Steinberger 写的关于<a href="http://objccn.io/issue-2-4/">线程安全</a>的文章。</p>

<h3>线程</h3>

<p><a href="http://zh.wikipedia.org/wiki/线程">线程</a>（thread）是组成进程的子单元，操作系统的调度器可以对线程进行单独的调度。实际上，所有的并发编程 API 都是构建于线程之上的 —— 包括 GCD 和操作队列（operation queues）。</p>

<p>多线程可以在单核 CPU 上同时（或者至少看作同时）运行。操作系统将小的时间片分配给每一个线程，这样就能够让用户感觉到有多个任务在同时进行。如果 CPU 是多核的，那么线程就可以真正的以并发方式被执行，从而减少了完成某项操作所需要的总时间。</p>

<p>你可以通过 Instrument 中的 <a href="http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/AnalysingCPUUsageinYourOSXApp/AnalysingCPUUsageinYourOSXApp.html">CPU strategy view</a> 来观察你的代码或者你所使用的框架的代码被执行时，它们在多核 CPU 中的被调度的情况。</p>

<p>需要重点关注的是，你无法控制你的代码在什么地方以及什么时候被调度，以及无法控制执行多长时间后将被暂停，以便轮换执行别的任务。这种线程调度是非常强大的一种技术，但是也非常复杂，我们稍后研究。</p>

<p>先把线程调度的复杂情况放一边，开发者可以使用 <a href="http://en.wikipedia.org/wiki/POSIX_Threads">POSIX 线程</a> API，或者 Objective-C 中提供的对该 API 的封装 <code>NSThread</code>，来创建自己的线程。下面这个小示例利用 <code>pthread</code> 来在一百万个数字中查找最小值和最大值。其中并发执行了 4 个线程。从该示例复杂的代码中，应该可以看出为什么你不会希望直接使用 pthread 。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">struct</span> <span class="n">threadInfo</span> <span class="p">{</span>
</span><span class="line">    <span class="n">uint32_t</span> <span class="o">*</span> <span class="n">inputValues</span><span class="p">;</span>
</span><span class="line">    <span class="n">size_t</span> <span class="n">count</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">threadResult</span> <span class="p">{</span>
</span><span class="line">    <span class="n">uint32_t</span> <span class="n">min</span><span class="p">;</span>
</span><span class="line">    <span class="n">uint32_t</span> <span class="n">max</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="o">*</span> <span class="nf">findMinAndMax</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">threadInfo</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">threadInfo</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
</span><span class="line">    <span class="n">uint32_t</span> <span class="n">min</span> <span class="o">=</span> <span class="n">UINT32_MAX</span><span class="p">;</span>
</span><span class="line">    <span class="n">uint32_t</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">info</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">uint32_t</span> <span class="n">v</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">inputValues</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">        <span class="n">min</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</span><span class="line">        <span class="n">max</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">max</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">free</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">threadResult</span> <span class="o">*</span> <span class="k">const</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">threadResult</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">));</span>
</span><span class="line">    <span class="n">result</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">min</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>
</span><span class="line">    <span class="n">result</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">max</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">size_t</span> <span class="k">const</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span>
</span><span class="line">    <span class="n">uint32_t</span> <span class="n">inputValues</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 使用随机数字填充 inputValues</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">inputValues</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arc4random</span><span class="p">();</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 开始4个寻找最小值和最大值的线程</span>
</span><span class="line">    <span class="n">size_t</span> <span class="k">const</span> <span class="n">threadCount</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class="line">    <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">[</span><span class="n">threadCount</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">threadCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">struct</span> <span class="n">threadInfo</span> <span class="o">*</span> <span class="k">const</span> <span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">threadInfo</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">));</span>
</span><span class="line">        <span class="n">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">/</span> <span class="n">threadCount</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">        <span class="n">info</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">inputValues</span> <span class="o">=</span> <span class="n">inputValues</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
</span><span class="line">        <span class="n">info</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">count</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span> <span class="o">/</span> <span class="n">threadCount</span><span class="p">);</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="n">tid</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">findMinAndMax</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
</span><span class="line">        <span class="n">NSCAssert</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">@&quot;pthread_create() failed: %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">// 等待线程退出</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">threadResult</span> <span class="o">*</span> <span class="n">results</span><span class="p">[</span><span class="n">threadCount</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">threadCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
</span><span class="line">        <span class="n">NSCAssert</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">@&quot;pthread_join() failed: %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">// 寻找 min 和 max</span>
</span><span class="line">    <span class="n">uint32_t</span> <span class="n">min</span> <span class="o">=</span> <span class="n">UINT32_MAX</span><span class="p">;</span>
</span><span class="line">    <span class="n">uint32_t</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">threadCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">min</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">min</span><span class="p">);</span>
</span><span class="line">        <span class="n">max</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">max</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">max</span><span class="p">);</span>
</span><span class="line">        <span class="n">free</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class="line">        <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;min = %u&quot;</span><span class="p">,</span> <span class="n">min</span><span class="p">);</span>
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;max = %u&quot;</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>NSThread</code> 是 Objective-C 对 pthread 的一个封装。通过封装，在 Cocoa 环境中，可以让代码看起来更加亲切。例如，开发者可以利用 NSThread 的一个子类来定义一个线程，在这个子类的中封装需要在后台线程运行的代码。针对上面的那个例子，我们可以定义一个这样的 <code>NSThread</code> 子类：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">FindMinMaxThread</span> : <span class="nc">NSThread</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSUInteger</span> <span class="n">min</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSUInteger</span> <span class="n">max</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithNumbers:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">numbers</span><span class="p">;</span>
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">FindMinMaxThread</span> <span class="p">{</span>
</span><span class="line">    <span class="n">NSArray</span> <span class="o">*</span><span class="n">_numbers</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="o">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nl">initWithNumbers:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="n">numbers</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">_numbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">main</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSUInteger</span> <span class="n">min</span><span class="p">;</span>
</span><span class="line">    <span class="n">NSUInteger</span> <span class="n">max</span><span class="p">;</span>
</span><span class="line">    <span class="c1">// 进行相关数据的处理</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>要想启动一个新的线程，需要创建一个线程对象，然后调用它的 <code>start</code> 方法：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSSet</span> <span class="o">*</span><span class="n">threads</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableSet</span> <span class="n">set</span><span class="p">];</span>
</span><span class="line"><span class="n">NSUInteger</span> <span class="n">numberCount</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">numbers</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
</span><span class="line"><span class="n">NSUInteger</span> <span class="n">threadCount</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="n">NSUInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">threadCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">NSUInteger</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">/</span> <span class="n">threadCount</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">    <span class="n">NSUInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">numberCount</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">numberCount</span> <span class="o">/</span> <span class="n">threadCount</span><span class="p">);</span>
</span><span class="line">    <span class="n">NSRange</span> <span class="n">range</span> <span class="o">=</span> <span class="n">NSMakeRange</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
</span><span class="line">    <span class="n">NSArray</span> <span class="o">*</span><span class="n">subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">numbers</span> <span class="nl">subarrayWithRange:</span><span class="n">range</span><span class="p">];</span>
</span><span class="line">    <span class="n">FindMinMaxThread</span> <span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="p">[[</span><span class="n">FindMinMaxThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithNumbers:</span><span class="n">subset</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">threads</span> <span class="nl">addObject:</span><span class="kr">thread</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="kr">thread</span> <span class="n">start</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在，我们可以通过检测到线程的 <code>isFinished</code> 属性来检测新生成的线程是否已经结束，并获取结果。我们将这个练习留给感兴趣的读者，这主要是因为不论使用 <code>pthread</code> 还是 <code>NSThread</code> 来直接对线程操作，都是相对糟糕的编程体验，这种方式并不适合我们以写出良好代码为目标的编码精神。</p>

<p>直接使用线程可能会引发的一个问题是，如果你的代码和所基于的框架代码都创建自己的线程时，那么活动的线程数量有可能以指数级增长。这在大型工程中是一个常见问题。例如，在 8 核 CPU 中，你创建了 8 个线程来完全发挥 CPU 性能。然而在这些线程中你的代码所调用的框架代码也做了同样事情（因为它并不知道你已经创建的这些线程），这样会很快产生成成百上千的线程。代码的每个部分自身都没有问题，然而最后却还是导致了问题。使用线程并不是没有代价的，每个线程都会消耗一些内存和内核资源。</p>

<p>接下来，我们将介绍两个基于队列的并发编程 API ：GCD 和 operation queue 。它们通过集中管理一个被大家协同使用的<a href="http://en.wikipedia.org/wiki/Thread_pool_pattern">线程池</a>，来解决上面遇到的问题。</p>

<h3 id="grandcentraldispatch">Grand Central Dispatch</h3>

<p>为了让开发者更加容易的使用设备上的多核CPU，苹果在 OS X 10.6 和 iOS 4 中引入了 Grand Central Dispatch（GCD）。在下一篇关于<a href="http://objccn.io/issue-2-3/">底层并发 API</a> 的文章中，我们将更深入地介绍 GCD。</p>

<p>通过 GCD，开发者不用再直接跟线程打交道了，只需要向队列中添加代码块即可，GCD 在后端管理着一个<a href="http://en.wikipedia.org/wiki/Thread_pool_pattern">线程池</a>。GCD 不仅决定着你的代码块将在哪个线程被执行，它还根据可用的系统资源对这些线程进行管理。这样可以将开发者从线程管理的工作中解放出来，通过集中的管理线程，来缓解大量线程被创建的问题。</p>

<p>GCD 带来的另一个重要改变是，作为开发者可以将工作考虑为一个队列，而不是一堆线程，这种并行的抽象模型更容易掌握和使用。</p>

<p>GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。 <br />
另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。</p>

<p><img src="http://img.objccn.io/issue-2/gcd-queues.png" alt="GCD queues" title="" /></p>

<p>使用不同优先级的若干个队列乍听起来非常直接，不过，我们强烈建议，在绝大多数情况下使用默认的优先级队列就可以了。如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。更多相关内容，在本文的<a href="#Priority-Inversion">优先级反转</a>部分中会有介绍。</p>

<p>虽然 GCD 是一个低层级的 C API ，但是它使用起来非常的直接。不过这也容易使开发者忘记并发编程中的许多注意事项和陷阱。读者可以阅读本文后面的<a href="#challenges">并发编程中面临的挑战</a>，这样可以注意到一些潜在的问题。本期的另外一篇优秀文章：<a href="http://objccn.io/issue-2-3/">底层并发 API</a> 中，包含了很多深入的解释和一些有价值的提示。</p>

<h3 id="operationqueues">Operation Queues</h3>

<p>操作队列（operation queue）是由 GCD 提供的一个队列模型的 Cocoa 抽象。GCD 提供了更加底层的控制，而操作队列则在 GCD 之上实现了一些方便的功能，这些功能对于 app 的开发者来说通常是最好最安全的选择。</p>

<p><code>NSOperationQueue</code> 有两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。在两种类型中，这些队列所处理的任务都使用 <code>NSOperation</code> 的子类来表述。</p>

<p>你可以通过重写 <code>main</code> 或者 <code>start</code> 方法 来定义自己的 <code>operations</code> 。前一种方法非常简单，开发者不需要管理一些状态属性（例如 <code>isExecuting</code> 和 <code>isFinished</code>），当 <code>main</code> 方法返回的时候，这个 operation 就结束了。这种方式使用起来非常简单，但是灵活性相对重写 <code>start</code> 来说要少一些。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">YourOperation</span>
</span><span class="line">    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">main</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="c1">// 进行处理 ...</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果你希望拥有更多的控制权，以及在一个操作中可以执行异步任务，那么就重写 <code>start</code> 方法：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">YourOperation</span>
</span><span class="line">    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">start</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">isExecuting</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">isFinished</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class="line">        <span class="c1">// 开始处理，在结束时应该调用 finished ...</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">finished</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">isExecuting</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">isFinished</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意：这种情况下，你必须手动管理操作的状态。 为了让操作队列能够捕获到操作的改变，需要将状态的属性以配合 KVO 的方式进行实现。如果你不使用它们默认的 setter 来进行设置的话，你就需要在合适的时候发送合适的 KVO 消息。</p>

<p>为了能使用操作队列所提供的取消功能，你需要在长时间操作中时不时地检查 <code>isCancelled</code> 属性：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">main</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">while</span> <span class="p">(</span><span class="n">notDone</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="c1">// 进行处理</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当你定义好 operation 类之后，就可以很容易的将一个 operation 添加到队列中：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="n">YourOperation</span> <span class="o">*</span><span class="n">operation</span> <span class="o">=</span> <span class="p">[[</span><span class="n">YourOperation</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">queue</span>  <span class="nl">addOperation:</span><span class="n">operation</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>另外，你也可以将 block 添加到操作队列中。这有时候会非常的方便，比如你希望在主队列中调度一个一次性任务：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[[</span><span class="n">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">]</span> <span class="nl">addOperationWithBlock:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">    <span class="c1">// 代码...</span>
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>虽然通过这种的方式在队列中添加操作会非常方便，但是定义你自己的 NSOperation 子类会在调试时很有帮助。如果你重写 operation 的<code>description</code> 方法，就可以很容易的标示出在某个队列中当前被调度的所有操作 。</p>

<p>除了提供基本的调度操作或 block 外，操作队列还提供了在 GCD 中不太容易处理好的特性的功能。例如，你可以通过 <code>maxConcurrentOperationCount</code> 属性来控制一个特定队列中可以有多少个操作参与并发执行。将其设置为 1 的话，你将得到一个串行队列，这在以隔离为目的的时候会很有用。</p>

<p>另外还有一个方便的功能就是根据队列中 <code>operation</code> 的优先级对其进行排序，这不同于 GCD 的队列优先级，它只影响当前队列中所有被调度的 operation 的执行先后。如果你需要进一步在除了 5 个标准的优先级以外对 operation 的执行顺序进行控制的话，还可以在 operation 之间指定依赖关系，如下：</p>

<pre><code>[intermediateOperation addDependency:operation1];
[intermediateOperation addDependency:operation2];
[finishedOperation addDependency:intermediateOperation];
</code></pre>

<p>这些简单的代码可以确保 <code>operation1</code> 和 <code>operation2</code> 在 <code>intermediateOperation</code> 之前执行，当然，也会在 <code>finishOperation</code> 之前被执行。对于需要明确的执行顺序时，操作依赖是非常强大的一个机制。它可以让你创建一些操作组，并确保这些操作组在依赖它们的操作被执行之前执行，或者在并发队列中以串行的方式执行操作。</p>

<p>从本质上来看，操作队列的性能比 GCD 要低那么一点，不过，大多数情况下这点负面影响可以忽略不计，操作队列是并发编程的首选工具。</p>

<h3 id="runloops">Run Loops</h3>

<p>实际上，Run loop并不像 GCD 或者操作队列那样是一种并发机制，因为它并不能并行执行任务。不过在主 dispatch/operation 队列中， run loop 将直接配合任务的执行，它提供了一种异步执行代码的机制。</p>

<p>Run loop 比起操作队列或者 GCD 来说容易使用得多，因为通过 run loop ，你不必处理并发中的复杂情况，就能异步地执行任务。</p>

<p>一个 run loop 总是绑定到某个特定的线程中。main run loop 是与主线程相关的，在每一个 Cocoa 和 CocoaTouch 程序中，这个 main run loop 都扮演了一个核心角色，它负责处理 UI 事件、计时器，以及其它内核相关事件。无论你什么时候设置计时器、使用 <code>NSURLConnection</code> 或者调用 <code>performSelector:withObject:afterDelay:</code>，其实背后都是 run loop 在处理这些异步任务。</p>

<p>无论何时你使用 run loop 来执行一个方法的时候，都需要记住一点：run loop 可以运行在不同的模式中，每种模式都定义了一组事件，供 run loop 做出响应。这在对应 main run loop 中暂时性的将某个任务优先执行这种任务上是一种聪明的做法。</p>

<p>关于这点，在 iOS 中非常典型的一个示例就是滚动。在进行滚动时，run loop 并不是运行在默认模式中的，因此， run loop 此时并不会响应比如滚动前设置的计时器。一旦滚动停止了，run loop 会回到默认模式，并执行添加到队列中的相关事件。如果在滚动时，希望计时器能被触发，需要将其设为 <code>NSRunLoopCommonModes</code> 的模式，并添加到 run loop 中。</p>

<p>主线程一般来说都已经配置好了 main run loop。然而其他线程默认情况下都没有设置 run loop。你也可以自行为其他线程设置 run loop ，但是一般来说我们很少需要这么做。大多数时间使用 main run loop 会容易得多。如果你需要处理一些很重的工作，但是又不想在主线程里做，你仍然可以在你的代码在 main run loop 中被调用后将工作分配给其他队列。Chris 在他关于<a href="http://objccn.io/issue-2-2/">常见的后台实践</a>的文章里阐述了一些关于这种模式的很好的例子。</p>

<p>如果你真需要在别的线程中添加一个 run loop ，那么不要忘记在 run loop 中至少添加一个 input source 。如果 run loop 中没有设置好的 input source，那么每次运行这个 run loop ，它都会立即退出。</p>

<p><a name="challenges" id="challenges"> </a></p>

<h2>并发编程中面临的挑战</h2>

<p>使用并发编程会带来许多陷阱。只要一旦你做的事情超过了最基本的情况，对于并发执行的多任务之间的相互影响的不同状态的监视就会变得异常困难。 问题往往发生在一些不确定性（不可预见性）的地方，这使得在调试相关并发代码时更加困难。</p>

<p>关于并发编程的不可预见性有一个非常有名的例子：在1995年， NASA (美国宇航局)发送了开拓者号火星探测器，但是当探测器成功着陆在我们红色的邻居星球后不久，任务<a href="http://research.microsoft.com/en-us/um/people/mbj/Mars_Pathfinder/Mars_Pathfinder.html">嘎然而止</a>，火星探测器莫名其妙的不停重启，在计算机领域内，遇到的这种现象被定为为<a href="#Priority-Inversion">优先级反转</a>，也就是说低优先级的线程一直阻塞着高优先级的线程。稍后我们会看到关于这个问题的更多细节。在这里我们想说明的是，即使拥有丰富的资源和大量优秀工程师的智慧，并发也还是会在不少情况下反咬你你一口。</p>

<h3>资源共享</h3>

<p>并发编程中许多问题的根源就是在多线程中访问共享资源。资源可以是一个属性、一个对象，通用的内存、网络设备或者一个文件等等。在多线程中任何一个共享的资源都可能是一个潜在的冲突点，你必须精心设计以防止这种冲突的发生。</p>

<p>为了演示这类问题，我们举一个关于资源的简单示例：比如仅仅用一个整型值来做计数器。在程序运行过程中，我们有两个并行线程 A 和 B，这两个线程都尝试着同时增加计数器的值。问题来了，你通过 C 语言或 Objective-C 写的代码大多数情况下对于 CPU 来说不会仅仅是一条机器指令。要想增加计数器的值，当前的必须被从内存中读出，然后增加计数器的值，最后还需要将这个增加后的值写回内存中。</p>

<p>我们可以试着想一下，如果两个线程同时做上面涉及到的操作，会发生怎样的偶然。例如，线程 A 和 B 都从内存中读取出了计数器的值，假设为 <code>17</code> ，然后线程A将计数器的值加1，并将结果 <code>18</code> 写回到内存中。同时，线程B也将计数器的值加 1 ，并将结果 <code>18</code> 写回到内存中。实际上，此时计数器的值已经被破坏掉了，因为计数器的值 <code>17</code> 被加 1 了两次，而它的值却是 <code>18</code>。</p>

<p><img src="http://img.objccn.io/issue-2/race-condition.png" alt="竞态条件" title="" /></p>

<p>这个问题被叫做<a href="http://en.wikipedia.org/wiki/Race_conditions#Software">竞态条件</a>，在多线程里面访问一个共享的资源，如果没有一种机制来确保在线程 A 结束访问一个共享资源之前，线程 B 就不会开始访问该共享资源的话，资源竞争的问题就总是会发生。如果你所写入内存的并不是一个简单的整数，而是一个更复杂的数据结构，可能会发生这样的现象：当第一个线程正在写入这个数据结构时，第二个线程却尝试读取这个数据结构，那么获取到的数据可能是新旧参半或者没有初始化。为了防止出现这样的问题，多线程需要一种互斥的机制来访问共享资源。</p>

<p>在实际的开发中，情况甚至要比上面介绍的更加复杂，因为现代 CPU 为了优化目的，往往会改变向内存读写数据的顺序（<a href="http://en.wikipedia.org/wiki/Out-of-order_execution">乱序执行</a>）。</p>

<h3>互斥锁</h3>

<p><a href="http://en.wikipedia.org/wiki/Mutex">互斥</a>访问的意思就是同一时刻，只允许一个线程访问某个特定资源。为了保证这一点，每个希望访问共享资源的线程，首先需要获得一个共享资源的<a href="http://en.wikipedia.org/wiki/Lock_%28computer_science%29">互斥锁</a>，一旦某个线程对资源完成了操作，就释放掉这个互斥锁，这样别的线程就有机会访问该共享资源了。</p>

<p><img src="http://img.objccn.io/issue-2/locking.png" alt="互斥锁" title="" /></p>

<p>除了确保互斥访问，还需要解决代码无序执行所带来的问题。如果不能确保 CPU 访问内存的顺序跟编程时的代码指令一样，那么仅仅依靠互斥访问是不够的。为了解决由 CPU 的优化策略引起的副作用，还需要引入<a href="http://en.wikipedia.org/wiki/Memory_barrier">内存屏障</a>。通过设置内存屏障，来确保没有无序执行的指令能跨过屏障而执行。</p>

<p>当然，互斥锁自身的实现是需要没有竞争条件的。这实际上是非常重要的一个保证，并且需要在现代 CPU 上使用特殊的指令。更多关于原子操作（atomic operation）的信息，请阅读 Daniel 写的文章：<a href="http://objccn.io/issue-2-3/">底层并发技术</a>。</p>

<p>从语言层面来说，在 Objective-C 中将属性以 atomic 的形式来声明，就能支持互斥锁了。事实上在默认情况下，属性就是 atomic 的。将一个属性声明为 atomic 表示每次访问该属性都会进行隐式的加锁和解锁操作。虽然最把稳的做法就是将所有的属性都声明为 atomic，但是加解锁这也会付出一定的代价。</p>

<p>在资源上的加锁会引发一定的性能代价。获取锁和释放锁的操作本身也需要没有竞态条件，这在多核系统中是很重要的。另外，在获取锁的时候，线程有时候需要等待，因为可能其它的线程已经获取过资源的锁了。这种情况下，线程会进入休眠状态。当其它线程释放掉相关资源的锁时，休眠的线程会得到通知。所有这些相关操作都是非常昂贵且复杂的。</p>

<p>锁也有不同的类型。当没有竞争时，有些锁在没有锁竞争的情况下性能很好，但是在有锁的竞争情况下，性能就会大打折扣。另外一些锁则在基本层面上就比较耗费资源，但是在竞争情况下，性能的恶化会没那么厉害。(<a href="http://en.wikipedia.org/wiki/Lock_%28computer_science%29#Granularity">锁的竞争</a>是这样产生的：当一个或者多个线程尝试获取一个已经被别的线程获取过了的锁)。</p>

<p>在这里有一个东西需要进行权衡：获取和释放锁所是要带来开销的，因此你需要确保你不会频繁地进入和退出<a href="http://en.wikipedia.org/wiki/Critical_section">临界区段</a>（比如获取和释放锁）。同时，如果你获取锁之后要执行一大段代码，这将带来锁竞争的风险：其它线程可能必须等待获取资源锁而无法工作。这并不是一项容易解决的任务。</p>

<p>我们经常能看到本来计划并行运行的代码，但实际上由于共享资源中配置了相关的锁，所以同一时间只有一个线程是处于激活状态的。对于你的代码会如何在多核上运行的预测往往十分重要，你可以使用 Instrument 的 <a href="http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/AnalysingCPUUsageinYourOSXApp/AnalysingCPUUsageinYourOSXApp.html">CPU strategy view</a> 来检查是否有效的利用了 CPU 的可用核数，进而得出更好的想法，以此来优化代码。</p>

<h3>死锁</h3>

<p>互斥锁解决了竞态条件的问题，但很不幸同时这也引入了一些<a href="http://en.wikipedia.org/wiki/Lock_%28computer_science%29#The_problems_with_locks">其他问题</a>，其中一个就是<a href="http://en.wikipedia.org/wiki/Deadlock">死锁</a>。当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住。</p>

<p><img src="http://img.objccn.io/issue-2/dead-lock.png" alt="死锁" title="" /></p>

<p>看看下面的代码，它交换两个变量的值：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">lock</span><span class="p">(</span><span class="n">lockA</span><span class="p">);</span>
</span><span class="line">    <span class="n">lock</span><span class="p">(</span><span class="n">lockB</span><span class="p">);</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">;</span>
</span><span class="line">    <span class="n">A</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line">    <span class="n">B</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span><span class="line">    <span class="n">unlock</span><span class="p">(</span><span class="n">lockB</span><span class="p">);</span>
</span><span class="line">    <span class="n">unlock</span><span class="p">(</span><span class="n">lockA</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>大多数时候，这能够正常运行。但是当两个线程使用相反的值来同时调用上面这个方法时：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">swap</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">);</span> <span class="c1">// 线程 1</span>
</span><span class="line"><span class="n">swap</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span> <span class="c1">// 线程 2</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>此时程序可能会由于死锁而被终止。线程 1 获得了 X 的一个锁，线程 2 获得了 Y 的一个锁。 接着它们会同时等待另外一把锁，但是永远都不会获得。</p>

<p>再说一次，你在线程之间共享的资源越多，你使用的锁也就越多，同时程序被死锁的概率也会变大。这也是为什么我们需要尽量减少线程间资源共享，并确保共享的资源尽量简单的原因之一。建议阅读一下<a href="http://objccn.io/issue-2-3/">底层并发编程 API</a> 中的<a href="http://objccn.io/issue-2-3/#async">全部使用异步分发</a>一节。</p>

<h3 id="starvation">资源饥饿（Starvation）</h3>

<p>当你认为已经足够了解并发编程面临的问题时，又出现了一个新的问题。锁定的共享资源会引起<a href="http://en.wikipedia.org/wiki/Readers-writers_problem">读写问题</a>。大多数情况下，限制资源一次只能有一个线程进行读取访问其实是非常浪费的。因此，在资源上没有写入锁的时候，持有一个读取锁是被允许的。这种情况下，如果一个持有读取锁的线程在等待获取写入锁的时候，其他希望读取资源的线程则因为无法获得这个读取锁而导致<a href="http://en.wikipedia.org/wiki/Resource_starvation">资源饥饿</a>的发生。</p>

<p>为了解决这个问题，我们需要使用一个比简单的读/写锁更聪明的方法，例如给定一个 <a href="http://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">writer preference</a>，或者使用 <a href="http://en.wikipedia.org/wiki/Read-copy-update">read-copy-update</a> 算法。Daniel 在<a href="http://objccn.io/issue-2-3/#multiple-readers-single-writer">底层并发编程 API </a>中有介绍了如何用 GCD 实现一个多读取单写入的模式，这样就不会被写入资源饥饿的问题困扰了。</p>

<p><a name="priority-inversion" id="priority-inversion"> </a></p>

<h2>优先级反转</h2>

<p>本节开头介绍了美国宇航局发射的开拓者号火星探测器在火星上遇到的并发问题。现在我们就来看看为什么开拓者号几近失败，以及为什么有时候我们的程序也会遇到相同的问题，该死的<a href="http://en.wikipedia.org/wiki/Priority_inversion">优先级反转</a>。</p>

<p>优先级反转是指程序在运行时低优先级的任务阻塞了高优先级的任务，有效的反转了任务的优先级。由于 GCD 提供了拥有不同优先级的后台队列，甚至包括一个 I/O 队列，所以我们最好了解一下优先级反转的可能性。</p>

<p>高优先级和低优先级的任务之间共享资源时，就可能发生优先级反转。当低优先级的任务获得了共享资源的锁时，该任务应该迅速完成，并释放掉锁，这样高优先级的任务就可以在没有明显延时的情况下继续执行。然而高优先级任务会在低优先级的任务持有锁的期间被阻塞。如果这时候有一个中优先级的任务(该任务不需要那个共享资源)，那么它就有可能会抢占低优先级任务而被执行，因为此时高优先级任务是被阻塞的，所以中优先级任务是目前所有可运行任务中优先级最高的。此时，中优先级任务就会阻塞着低优先级任务，导致低优先级任务不能释放掉锁，这也就会引起高优先级任务一直在等待锁的释放。</p>

<p><img src="http://img.objccn.io/issue-2/priority-inversion.png" alt="优先级反转" title="" /></p>

<p>在你的实际代码中，可能不会像发生在火星的事情那样戏剧性地不停重启。遇到优先级反转时，一般没那么严重。</p>

<p>解决这个问题的方法，通常就是不要使用不同的优先级。通常最后你都会以让高优先级的代码等待低优先级的代码来解决问题。当你使用 GCD 时，总是使用默认的优先级队列（直接使用，或者作为目标队列）。如果你使用不同的优先级，很可能实际情况会让事情变得更糟糕。</p>

<p>从中得到的教训是，使用不同优先级的多个队列听起来虽然不错，但毕竟是纸上谈兵。它将让本来就复杂的并行编程变得更加复杂和不可预见。如果你在编程中，遇到高优先级的任务突然没理由地卡住了，可能你会想起本文，以及那个美国宇航局的工程师也遇到过的被称为优先级反转的问题。</p>

<h2>总结</h2>

<p>我们希望通过本文你能够了解到并发编程带来的复杂性和相关问题。并发编程中，无论是看起来多么简单的 API ，它们所能产生的问题会变得非常的难以观测，而且要想调试这类问题往往也都是非常困难的。</p>

<p>但另一方面，并发实际上是一个非常棒的工具。它充分利用了现代多核 CPU 的强大计算能力。在开发中，关键的一点就是尽量让并发模型保持简单，这样可以限制所需要的锁的数量。</p>

<p>我们建议采纳的安全模式是这样的：从主线程中提取出要使用到的数据，并利用一个操作队列在后台处理相关的数据，最后回到主队列中来发送你在后台队列中得到的结果。使用这种方式，你不需要自己做任何锁操作，这也就大大减少了犯错误的几率。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-08T18:23:21+08:00" data-updated="true" itemprop="datePublished">Apr 8<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/08/UIView-%E7%BB%98%E5%88%B6%E5%83%8F%E7%B4%A0%E5%88%B0%E5%B1%8F%E5%B9%95/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/08/UIView-%E7%BB%98%E5%88%B6%E5%83%8F%E7%B4%A0%E5%88%B0%E5%B1%8F%E5%B9%95/" itemprop="url">绘制像素到屏幕</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>一个像素是如何绘制到屏幕上去的？有很多种方式将一些东西映射到显示屏上，他们需要调用不同的框架、许多功能和方法的结合体。这里我们大概的看一下屏幕之后发生的事情。当你想要弄清楚什么时候、怎么去查明并解决问题时，我希望这篇文章能帮助你理解哪一个 API 可以更好的帮你解决问题。我们将聚焦于 iOS，然而我讨论的大多数问题也同样适用于 OS X。</p>

<h2>图形堆栈</h2>

<p>当像素映射到屏幕上的时候，后台发生了很多事情。但一旦他们显示到屏幕上，每一个像素均由三个颜色组件构成：红，绿，蓝。三个独立的颜色单元会根据给定的颜色显示到一个像素上。在 iPhone5 的<a href="https://zh.wikipedia.org/wiki/%E6%A9%AB%E5%90%91%E9%9B%BB%E5%A0%B4%E6%95%88%E6%87%89%E9%A1%AF%E7%A4%BA%E6%8A%80%E8%A1%93">液晶显示器</a>上有1,136×640=727,040个像素，因此有2,181,120个颜色单元。在15寸视网膜屏的 MacBook Pro 上，这一数字达到15.5百万以上。所有的图形堆栈一起工作以确保每次正确的显示。当你滚动整个屏幕的时候，数以百万计的颜色单元必须以每秒60次的速度刷新，这是一个很大的工作量。</p>

<h2>软件组成</h2>

<p>从简单的角度来看，软件堆栈看起来有点像这样：</p>

<p><img src="http://img.objccn.io/issue-3/pixels-software-stack.png" alt="软件堆栈" title="" /></p>

<p>Display 的上一层便是图形处理单元 GPU，GPU 是一个专门为图形高迸发计算而量身定做的处理单元。这也是为什么它能同时更新所有的像素，并呈现到显示器上。它迸发的本性让它能高效的将不同纹理合成起来。我们将有一小块内容来更详细的讨论图形合成。关键的是，GPU 是非常专业的，因此在某些工作上非常高效。比如，GPU 非常快，并且比 CPU 使用更少的电来完成工作。通常 CPU 都有一个普遍的目的，它可以做很多不同的事情，但是合成图像在 CPU 上却显得比较慢。</p>

<p>GPU Driver 是直接和 GPU 交流的代码块。不同的GPU是不同的性能怪兽，但是驱动使他们在下一个层级上显示的更为统一，典型的驱动有 OpenGL/OpenGL ES.</p>

<p>OpenGL(<a href="http://zh.wikipedia.org/wiki/OpenGL">Open Graphics Library</a>) 是一个提供了 2D 和 3D 图形渲染的 API。GPU 是一块非常特殊的硬件，OpenGL  和 GPU 密切的工作以提高GPU的能力，并实现硬件加速渲染。对大多数人来说，OpenGL 看起来非常底层，但是当它在1992年第一次发布的时候(20多年前的事了)是第一个和图形硬件(GPU)交流的标准化方式，这是一个重大的飞跃，程序员不再需要为每个GPU重写他们的应用了。</p>

<p>OpenGL 之上扩展出很多东西。在 iOS 上，几乎所有的东西都是通过 Core Animation 绘制出来，然而在 OS X 上，绕过 Core Animation 直接使用 Core Graphics 绘制的情况并不少见。对于一些专门的应用，尤其是游戏，程序可能直接和 OpenGL/OpenGL ES 交流。事情变得使人更加困惑，因为 Core Animation 使用 Core Graphics 来做一些渲染。像 AVFoundation，Core Image 框架，和其他一些混合的入口。</p>

<p>要记住一件事情，GPU 是一个非常强大的图形硬件，并且在显示像素方面起着核心作用。它连接到 CPU。从硬件上讲两者之间存在某种类型的<a href="https://zh.wikipedia.org/wiki/I/O%E6%80%BB%E7%BA%BF">总线</a>，并且有像 OpenGL，Core Animation 和 Core Graphics 这样的框架来在 GPU 和 CPU 之间精心安排数据的传输。为了将像素显示到屏幕上，一些处理将在 CPU 上进行。然后数据将会传送到 GPU，这也需要做一些相应的操作，最终像素显示到屏幕上。</p>

<p>这个过程的每一部分都有各自的挑战，并且许多时候需要做出折中的选择。</p>

<h2>硬件参与者</h2>

<p><img src="http://img.objccn.io/issue-3/pixels%2C%20hardware.png" alt="挑战" title="" /></p>

<p>正如上面这张简单的图片显示那些挑战：GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)。每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1/60s)内能做的工作也是有限的。</p>

<p>下一个挑战就是将数据传输到 GPU 上。为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。这就是提及到的上传数据到 GPU。这看起来貌似微不足道，但是一些大型的纹理却会非常耗时。</p>

<p>最终，CPU 开始运行你的程序。你可能会让 CPU 从 bundle 加载一张 PNG 的图片并且解压它。这所有的事情都在 CPU 上进行。然后当你需要显示解压缩后的图片时，它需要以某种方式上传到 GPU。一些看似平凡的，比如显示文本，对 CPU 来说却是一件非常复杂的事情，这会促使 Core Text 和 Core Graphics 框架更紧密的集成来根据文本生成一个位图。一旦准备好，它将会被作为一个纹理上传到 GPU 并准备显示出来。当你滚动或者在屏幕上移动文本时，不管怎么样，同样的纹理能够被复用，CPU 只需简单的告诉 GPU 新的位置就行了,所以 GPU 就可以重用存在的纹理了。CPU 并不需要重新渲染文本，并且位图也不需要重新上传到 GPU。</p>

<p>这张图涉及到一些错综复杂的方面，我们将会把这些方面提取出来并深一步了解。</p>

<h2>合成</h2>

<p>在图形世界中，合成是一个描述不同位图如何放到一起来创建你最终在屏幕上看到图像的过程。在许多方面显得显而易见，而让人忘了背后错综复杂的计算。</p>

<p>让我们忽略一些难懂的事例并且假定屏幕上一切事物皆纹理。一个纹理就是一个包含 RGBA 值的长方形，比如，每一个像素里面都包含红、绿、蓝和透明度的值。在 Core Animation 世界中这就相当于一个 CALayer。</p>

<p>在这个简化的设置中，每一个 layer 是一个纹理，所有的纹理都以某种方式堆叠在彼此的顶部。对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值。这就是合成大概的意思。</p>

<p>如果我们所拥有的是一个和屏幕大小一样并且和屏幕像素对齐的单一纹理，那么屏幕上每一个像素相当于纹理中的一个像素，纹理的最后一个像素也就是屏幕的最后一个像素。</p>

<p>如果我们有第二个纹理放在第一个纹理之上，然后GPU将会把第二个纹理合成到第一个纹理中。有很多种不同的合成方法，但是如果我们假定两个纹理的像素对齐，并且使用正常的混合模式，我们便可以用下面这个公式来计算每一个像素：</p>

<pre><code>R = S + D * ( 1 – Sa )
</code></pre>

<p>结果的颜色是源色彩(顶端纹理)+目标颜色(低一层的纹理)*(1-源颜色的透明度)。在这个公式中所有的颜色都假定已经预先乘以了他们的透明度。</p>

<p>显然相当多的事情在这发生了。让我们进行第二个假定，两个纹理都完全不透明，比如 alpha=1.如果目标纹理(低一层的纹理)是蓝色(RGB=0,0,1)，并且源纹理(顶层的纹理)颜色是红色(RGB=1,0,0)，因为 Sa 为1，所以结果为：</p>

<pre><code>R = S
</code></pre>

<p>结果是源颜色的红色。这正是我们所期待的(红色覆盖了蓝色)。</p>

<p>如果源颜色层为50%的透明，比如 alpha=0.5，既然 alpha 组成部分需要预先乘进 RGB 的值中，那么 S 的 RGB 值为(0.5, 0, 0)，公式看起来便会像这样:</p>

<pre><code>                       0.5   0               0.5
R = S + D * (1 - Sa) = 0   + 0 * (1 - 0.5) = 0
                       0     1               0.5
</code></pre>

<p>我们最终得到RGB值为(0.5, 0, 0.5),是一个紫色。这正是我们所期望将透明红色合成到蓝色背景上所得到的。</p>

<p>记住我们刚刚只是将纹理中的一个像素合成到另一个纹理的像素上。当两个纹理覆盖在一起的时候，GPU需要为所有像素做这种操作。正如你所知道的一样，许多程序都有很多层，因此所有的纹理都需要合成到一起。尽管GPU是一块高度优化的硬件来做这种事情，但这还是会让它非常忙碌，</p>

<h2 id="vs">不透明 VS 透明</h2>

<p>当源纹理是完全不透明的时候，目标像素就等于源纹理。这可以省下 GPU 很大的工作量，这样只需简单的拷贝源纹理而不需要合成所有的像素值。但是没有方法能告诉 GPU 纹理上的像素是透明还是不透明的。只有当你作为一名开发者知道你放什么到 CALayer 上了。这也是为什么 CALayer 有一个叫做 opaque 的属性了。如果这个属性为 YES，GPU 将不会做任何合成，而是简单从这个层拷贝，不需要考虑它下方的任何东西(因为都被它遮挡住了)。这节省了 GPU 相当大的工作量。这也正是 Instruments 中 color blended layers 选项中所涉及的。(这在模拟器中的Debug菜单中也可用).它允许你看到哪一个 layers(纹理) 被标注为透明的，比如 GPU 正在为哪一个 layers 做合成。合成不透明的 layers 因为需要更少的数学计算而更廉价。</p>

<p>所以如果你知道你的 layer 是不透明的，最好确定设置它的 opaque 为 YES。如果你加载一个没有 alpha 通道的图片，并且将它显示在 UIImageView 上，这将会自动发生。但是要记住如果一个图片没有 alpha 通道和一个图片每个地方的 alpha 都是100%，这将会产生很大的不同。在后一种情况下，Core Animation 需要假定是否存在像素的 alpha 值不为100%。在 Finder 中，你可以使用 Get Info 并且检查 More Info 部分。它将告诉你这张图片是否拥有 alpha 通道。</p>

<h2 id="vs">像素对齐 VS 不重合在一起</h2>

<p>到现在我们都在考虑像素完美重合在一起的 layers。当所有的像素是对齐的时候我们得到相对简单的计算公式。每当 GPU 需要计算出屏幕上一个像素是什么颜色的时候，它只需要考虑在这个像素之上的所有 layer 中对应的单个像素，并把这些像素合并到一起。或者，如果最顶层的纹理是不透明的(即图层树的最底层)，这时候 GPU 就可以简单的拷贝它的像素到屏幕上。</p>

<p>当一个 layer 上所有的像素和屏幕上的像素完美的对应整齐，那这个 layer 就是像素对齐的。主要有两个原因可能会造成不对齐。第一个便是滚动；当一个纹理上下滚动的时候，纹理的像素便不会和屏幕的像素排列对齐。另一个原因便是当纹理的起点不在一个像素的边界上。</p>

<p>在这两种情况下，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。当所有的像素都是对齐的时候，GPU 只剩下很少的工作要做。</p>

<p>Core Animation 工具和模拟器有一个叫做 color misaligned images 的选项，当这些在你的 CALayer 实例中发生的时候，这个功能便可向你展示。</p>

<h2 id="masks">Masks</h2>

<p>一个图层可以有一个和它相关联的 mask(蒙板)，mask 是一个拥有 alpha 值的位图，当像素要和它下面包含的像素合并之前都会把 mask 应用到图层的像素上去。当你要设置一个图层的圆角半径时，你可以有效的在图层上面设置一个 mask。但是也可以指定任意一个蒙板。比如，一个字母 A 形状的 mask。最终只有在 mask 中显示出来的(即图层中的部分)才会被渲染出来。</p>

<h2 id="offscreenrendering">离屏渲染(Offscreen Rendering)</h2>

<p>离屏渲染可以被 Core Animation 自动触发，或者被应用程序强制触发。屏幕外的渲染会合并/渲染图层树的一部分到一个新的缓冲区，然后该缓冲区被渲染到屏幕上。</p>

<p>离屏渲染合成计算是非常昂贵的, 但有时你也许希望强制这种操作。一种好的方法就是缓存合成的纹理/图层。如果你的渲染树非常复杂(所有的纹理，以及如何组合在一起)，你可以强制离屏渲染缓存那些图层，然后可以用缓存作为合成的结果放到屏幕上。</p>

<p>如果你的程序混合了很多图层，并且想要他们一起做动画，GPU 通常会为每一帧(1/60s)重复合成所有的图层。当使用离屏渲染时，GPU 第一次会混合所有图层到一个基于新的纹理的位图缓存上，然后使用这个纹理来绘制到屏幕上。现在，当这些图层一起移动的时候，GPU 便可以复用这个位图缓存，并且只需要做很少的工作。需要注意的是，只有当那些图层不改变时，这才可以用。如果那些图层改变了，GPU 需要重新创建位图缓存。你可以通过设置 shouldRasterize 为 YES 来触发这个行为。</p>

<p>然而，这是一个权衡。第一，这可能会使事情变得更慢。创建额外的屏幕外缓冲区是 GPU 需要多做的一步操作，特殊情况下这个位图可能再也不需要被复用，这便是一个无用功了。然而，可以被复用的位图，GPU 也有可能将它卸载了。所以你需要计算 GPU 的利用率和帧的速率来判断这个位图是否有用。</p>

<p>离屏渲染也可能产生副作用。如果你正在直接或者间接的将mask应用到一个图层上，Core Animation 为了应用这个 mask，会强制进行屏幕外渲染。这会对 GPU 产生重负。通常情况下 mask 只能被直接渲染到帧的缓冲区中(在屏幕内)。</p>

<p>Instrument 的 Core Animation 工具有一个叫做 <em>Color Offscreen-Rendered Yellow</em> 的选项，它会将已经被渲染到屏幕外缓冲区的区域标注为黄色(这个选项在模拟器中也可以用)。同时记得检查 <em>Color Hits Green and Misses Red</em> 选项。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。</p>

<p>一般情况下，你需要避免离屏渲染，因为这是很大的消耗。直接将图层合成到帧的缓冲区中(在屏幕上)比先创建屏幕外缓冲区，然后渲染到纹理中，最后将结果渲染到帧的缓冲区中要廉价很多。因为这其中涉及两次昂贵的环境转换(转换环境到屏幕外缓冲区，然后转换环境到帧缓冲区)。</p>

<p>所以当你打开 <em>Color Offscreen-Rendered Yellow</em> 后看到黄色，这便是一个警告，但这不一定是不好的。如果 Core Animation 能够复用屏幕外渲染的结果，这便能够提升性能。</p>

<p>同时还要注意，rasterized layer 的空间是有限的。苹果暗示大概有屏幕大小两倍的空间来存储 rasterized layer/屏幕外缓冲区。</p>

<p>如果你使用 layer 的方式会通过屏幕外渲染，你最好摆脱这种方式。为 layer 使用蒙板或者设置圆角半径会造成屏幕外渲染，产生阴影也会如此。</p>

<p>至于 mask，圆角半径(特殊的mask)和 clipsToBounds/masksToBounds，你可以简单的为一个已经拥有 mask 的 layer 创建内容，比如，已经应用了 mask 的 layer 使用一张图片。如果你想根据 layer 的内容为其应用一个长方形 mask，你可以使用 contentsRect 来代替蒙板。</p>

<p>如果你最后设置了 shouldRasterize 为 YES，那也要记住设置 rasterizationScale 为 contentsScale。</p>

<h2>更多的关于合成</h2>

<p>像往常一样，维基百科上有更多关于<a href="https://en.wikipedia.org/wiki/Alpha_compositing">透明合成</a>的基础公式。当我们谈完像素后，我们将更深入一点的谈论红，绿，蓝和 alpha 是怎么在内存中表现的。</p>

<h2 id="osx">OS X</h2>

<p>如果你是在 OS X 上工作，你将会发现大多数 debugging 选项在一个叫做 <em>Quartz Debug</em> 的独立程序中，而不是在 Instruments 中。Quartz Debug 是 Graphics Tools 中的一部分，这可以在苹果的 <a href="https://developer.apple.com/downloads/">developer portal</a> 中下载到。</p>

<h2 id="coreanimationopengles">Core Animation  OpenGL ES</h2>

<p>正如名字所建议的那样，Core Animation 让你在屏幕上实现动画。我们将跳过动画部分，而集中在绘图上。需要注意的是，Core Animation 允许你做非常高效的渲染。这也是为什么当你使用 Core Animation 时可以实现每秒 60 帧的动画。</p>

<p>Core Animation 的核心是 OpenGL ES 的一个抽象物，简而言之，它让你直接使用 OpenGL ES 的功能，却不需要处理 OpenGL ES 做的复杂的事情。当我们上面谈论合成的时候，我们把 layer 和 texture 当做等价的，但是他们不是同一物体，可又是如此的类似。</p>

<p>Core Animation 的 layer 可以有子 layer，所以最终你得到的是一个图层树。Core Animation 所需要做的最繁重的任务便是判断出哪些图层需要被(重新)绘制，而 OpenGL ES 需要做的便是将图层合并、显示到屏幕上。</p>

<p>举个例子，当你设置一个 layer 的内容为 CGImageRef 时，Core Animation 会创建一个 OpenGL 纹理，并确保在这个图层中的位图被上传到对应的纹理中。以及当你重写 <code>-drawInContext</code> 方法时，Core Animation 会请求分配一个纹理，同时确保 Core Graphics 会将你所做的(即你在<code>drawInContext</code>中绘制的东西)放入到纹理的位图数据中。一个图层的性质和 CALayer 的子类会影响到 OpenGL 的渲染结果，许多低等级的 OpenGL ES 行为被简单易懂地封装到 CALayer 概念中。</p>

<p>Core Animation 通过 Core Graphics 的一端和 OpenGL ES 的另一端，精心策划基于 CPU 的位图绘制。因为 Core Animation 处在渲染过程中的重要位置上，所以你如何使用 Core Animation 将会对性能产生极大的影响。</p>

<h2 id="cpuvsgpu">CPU限制 VS GPU限制</h2>

<p>当你在屏幕上显示东西的时候，有许多组件参与了其中的工作。其中，CPU 和 GPU 在硬件中扮演了重要的角色。在他们命名中 P 和 U 分别代表了”处理”和”单元”，当需要在屏幕上进行绘制时，他们都需要做处理，同时他们都有资源限制(即 CPU 和 GPU 的硬件资源)。</p>

<p>为了每秒达到 60 帧，你需要确定 CPU 和 GPU 不能过载。此外，即使你当前能达到 60fps(frame per second),你还是要尽可能多的绘制工作交给 GPU 做，而让 CPU 尽可能的来执行应用程序。通常，GPU 的渲染性能要比 CPU 高效很多，同时对系统的负载和消耗也更低一些。</p>

<p>既然绘图性能是基于 CPU 和 GPU 的，那么你需要找出是哪一个限制你绘图性能的。如果你用尽了 GPU 所有的资源，也就是说，是 GPU 限制了你的性能，同样的，如果你用尽了 CPU，那就是 CPU 限制了你的性能。</p>

<p>要告诉你，如果是 GPU 限制了你的性能，你可以使用 OpenGL ES Driver instrument。点击上面那个小的 i 按钮，配置一下，同时注意查看 Device Utilization %。现在，当你运行你的 app 时，你可以看到你 GPU 的负荷。如果这个值靠近 100%，那么你就需要把你工作的重心放在GPU方面了。</p>

<h2 id="coregraphicsquartz2d">Core Graphics / Quartz 2D</h2>

<p>通过 Core Graphics 这个框架，Quartz 2D 被更为广泛的知道。</p>

<p>Quartz 2D 拥有比我们这里谈到更多的装饰。我们这里不会过多的讨论关于 PDF 的创建，渲染，解析，或者打印。只需要注意的是，PDF 的打印、创建和在屏幕上绘制位图的操作是差不多的。因为他们都是基于 Quartz 2D。</p>

<p>让我们简单的了解一下 <a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html">Quartz 2D</a> 主要的概念。有关详细信息可以到苹果的官方文档中了解。</p>

<p>放心，当Quartz 2D 涉及到 2D 绘制的时候，它是非常强大的。有基于路径的绘制，反锯齿渲染，透明图层，分辨率，并且设备独立，可以说出很多特色。这可能会让人产生畏惧，主要因为这是一个低级并且基于 C 的 API。</p>

<p>主要的概念当对简单，UIKit 和 AppKit 都包含了 Quartz 2D 的一些简单 API，一旦你熟练了，一些简单 C 的 API 也是很容易理解的。最终你学会了一个能实现 Photoshop 和 Illustrator 大部分功能的绘图引擎。苹果把 iOS 程序里面的<a href="https://developer.apple.com/videos/wwdc/2011/?id=129">股票应用</a>作为讲解 Quartz 2D 在代码中实现动态渲染的一个例子。</p>

<p>当你的程序进行位图绘制时，不管使用哪种方式，都是基于 Quartz 2D 的。也就是说，CPU 部分实现的绘制是通过 Quartz 2D 实现的。尽管 Quartz 可以做其它的事情，但是我们这里还是集中于位图绘制，在缓冲区(一块内存)绘制位图会包括 RGBA 数据。</p>

<p>比方说，我们要画一个<a href="https://zh.wikipedia.org/wiki/%E5%85%AB%E8%BE%B9%E5%BD%A2">八角形</a>，我们通过 UIKit 能做到这一点</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">UIBezierPath</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBezierPath</span> <span class="n">bezierPath</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">path</span> <span class="nl">moveToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mf">16.72</span><span class="p">,</span> <span class="mf">7.22</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">path</span> <span class="nl">addLineToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mf">3.29</span><span class="p">,</span> <span class="mf">20.83</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">path</span> <span class="nl">addLineToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">18.05</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">path</span> <span class="nl">addLineToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mf">18.8</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.47</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">path</span> <span class="nl">addLineToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mf">37.21</span><span class="p">,</span> <span class="mf">18.05</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">path</span> <span class="nl">addLineToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mf">34.31</span><span class="p">,</span> <span class="mf">20.83</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">path</span> <span class="nl">addLineToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mf">20.88</span><span class="p">,</span> <span class="mf">7.22</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">path</span> <span class="nl">addLineToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mf">20.88</span><span class="p">,</span> <span class="mf">42.18</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">path</span> <span class="nl">addLineToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mf">16.72</span><span class="p">,</span> <span class="mf">42.18</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">path</span> <span class="nl">addLineToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mf">16.72</span><span class="p">,</span> <span class="mf">7.22</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">path</span> <span class="n">closePath</span><span class="p">];</span>
</span><span class="line"><span class="n">path</span><span class="p">.</span><span class="n">lineWidth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">[[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">]</span> <span class="n">setStroke</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">path</span> <span class="n">stroke</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>相对应的 Core Graphics 代码：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGContextBeginPath</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mf">16.72</span><span class="p">,</span> <span class="mf">7.22</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mf">3.29</span><span class="p">,</span> <span class="mf">20.83</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">18.05</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mf">18.8</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.47</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mf">37.21</span><span class="p">,</span> <span class="mf">18.05</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mf">34.31</span><span class="p">,</span> <span class="mf">20.83</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mf">20.88</span><span class="p">,</span> <span class="mf">7.22</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mf">20.88</span><span class="p">,</span> <span class="mf">42.18</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mf">16.72</span><span class="p">,</span> <span class="mf">42.18</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mf">16.72</span><span class="p">,</span> <span class="mf">7.22</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextClosePath</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextSetLineWidth</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextSetStrokeColorWithColor</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextStrokePath</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>需要问的问题是:这个绘制到哪儿去了？这正好引出所谓的 CGContext 登场。我们传过去的ctx参数正是在那个上下文中。而这个上下文定义了我们需要绘制的地方。如果我们实现了 CALayer 的 <code>-drawInContext:</code> 这时已经传过来一个上下文。绘制到这个上下文中的内容将会被绘制到图层的备份区(图层的缓冲区).但是我们也可以创建我们自己的上下文，叫做基于位图的上下文，比如 <code>CGBitmapContextCreate()</code>.这个方法返回一个我们可以传给 CGContext 方法来绘制的上下文。</p>

<p>注意 UIKit 版本的代码为何不传入一个上下文参数到方法中？这是因为当使用 UIKit 或者 AppKit 时，上下文是唯一的。UIkit 维护着一个上下文堆栈，UIKit 方法总是绘制到最顶层的上下文中。你可以使用 <code>UIGraphicsGetCurrentContext()</code> 来得到最顶层的上下文。你可以使用 <code>UIGraphicsPushContext()</code> 和 <code>UIGraphicsPopContext()</code> 在 UIKit 的堆栈中推进或取出上下文。</p>

<p>最为突出的是，UIKit 使用 <code>UIGraphicsBeginImageContextWithOptions()</code> 和 <code>UIGraphicsEndImageContext()</code> 方便的创建类似于 <code>CGBitmapContextCreate()</code> 的位图上下文。混合调用 UIKit 和 Core Graphics 非常简单：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="mi">45</span><span class="p">),</span> <span class="n">YES</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextRef</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line"><span class="n">CGContextBeginPath</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mf">16.72</span><span class="p">,</span> <span class="mf">7.22</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mf">3.29</span><span class="p">,</span> <span class="mf">20.83</span><span class="p">);</span>
</span><span class="line"><span class="p">...</span>
</span><span class="line"><span class="n">CGContextStrokePath</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class="line"><span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>或者另外一种方法:</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGContextRef</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">CGBitmapContextCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">90</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">bitmapInfo</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextScaleCTM</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span>
</span><span class="line"><span class="n">UIGraphicsPushContext</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class="line"><span class="n">UIBezierPath</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBezierPath</span> <span class="n">bezierPath</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">path</span> <span class="nl">moveToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mf">16.72</span><span class="p">,</span> <span class="mf">7.22</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">path</span> <span class="nl">addLineToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mf">3.29</span><span class="p">,</span> <span class="mf">20.83</span><span class="p">)];</span>
</span><span class="line"><span class="p">...</span>
</span><span class="line"><span class="p">[</span><span class="n">path</span> <span class="n">stroke</span><span class="p">];</span>
</span><span class="line"><span class="n">UIGraphicsPopContext</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextRelease</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>你可以使用 Core Graphics 创建大量的非常酷的东西。一个很好的理由就是，苹果的文档有很多例子。我们不能得到所有的细节，但是 Core Graphics 有一个非常接近 <a href="https://zh.wikipedia.org/wiki/Adobe_Illustrator">Adobe Illustrator</a> 和 <a href="https://zh.wikipedia.org/wiki/Adobe_Photoshop">Adobe Photoshop</a> 如何工作的绘图模型，并且大多数工具的理念翻译成 Core Graphics 了。终究，他是起源于 <a href="https://zh.wikipedia.org/wiki/NEXTSTEP">NeXTSTEP</a> 。(原来也是乔老爷的作品)。</p>

<h2 id="cglayer">CGLayer</h2>

<p>我们最初指出 CGLayer 可以用来提升重复绘制相同元素的速度。正如 <a href="http://iosptl.com/posts/cglayer-no-longer-recommended/">Dave Hayden指出</a>，这些<a href="http://iosptl.com/posts/cglayer-no-longer-recommended/">小道消息</a>不再可靠。</p>

<h2>像素</h2>

<p>屏幕上的像素是由红，绿，蓝三种颜色组件构成的。因此，位图数据有时也被叫做 RGB 数据。你可能会对数据如何组织在内存中感到好奇。而事实是，有很多种不同的方式在内存中展现RGB位图数据。</p>

<p>稍后我们将会谈到压缩数据，这又是一个完全不同的概念。现在，我们先看一下RGB位图数据，我们可以从颜色组件:红，绿，蓝中得到一个值。而大多数情况下，我们有第四个组件:透明度。最终我们从每个像素中得到四个单独的值。</p>

<h2>默认的像素布局</h2>

<p>在 iOS 和 OS X 上最常见的格式就是大家所熟知的 32bits-per-pixel(bpp), 8bits-per-componet(bpc),透明度会首先被乘以到像素值上(就像上文中提到的那个公式一样),在内存中，像下面这样:</p>

<pre><code>  A   R   G   B   A   R   G   B   A   R   G   B  
| pixel 0       | pixel 1       | pixel 2   
  0   1   2   3   4   5   6   7   8   9   10  11 ...
</code></pre>

<p>这个格式经常被叫做 ARGB。每个像素占用 4 字节(32bpp),每一个颜色组件是1字节(8bpc).每个像素有一个 alpha 值，这个值总是最先得到的(在RGB值之前)，最终红、绿、蓝的值都会被预先乘以 alpha 的值。预乘的意思就是 alpha 值被烘烤到红、绿、蓝的组件中。如果我们有一个橙色，他们各自的 8bpc 就像这样: 240,99,24.一个完全不透明的橙色像素拥有的 ARGB 值为: 255，240，99，24，它在内存中的布局就像上面图示那样。如果我们有一个相同颜色的像素，但是 alpha 值为 33%，那么他的像素值便是:84，80，33，8.</p>

<p>另一个常见的格式便是 32bpp，8bpc，跳过第一个 alpha 值，看起来像下面这样：</p>

<pre><code>  x   R   G   B   x   R   G   B   x   R   G   B  
| pixel 0       | pixel 1       | pixel 2   
  0   1   2   3   4   5   6   7   8   9   10  11 ...
</code></pre>

<p>这常被叫做 xRGB。像素并没有任何 alpha 值(他们都被假定为100%不透明)，但是内存布局是一样的。你应该想知道为什么这种格式很流行，当我们每一个像素中都有一个不用字节时，我们将会省下 25% 的空间。事实证明，这种格式更容易被现代的 CPU 和绘图算法消化，因为每一个独立的像素都对齐到 32-bit 的边界。现代的 CPU 不喜欢装载(读取)不对齐的数据，特别是当将这种数据和上面没有 alpha 值格式的数据混合时，算法需要做很多挪动和蒙板操作。</p>

<p>当处理 RGB 数据时，Core Graphics 也需要支持把alpha 值放到最后(另外还要支持跳过)。有时候也分别称为 RGBA 和 RGBx，假定是 8bpc，并且预乘了 alpha 值。</p>

<h2>深奥的布局</h2>

<p>大多数时候，当处理位图数据时，我们也需要处理 Core Graphics/Quartz 2D。有一个非常详细的列表列出了他支持的混合组合。但是让我们首先看一下剩下的 RGB 格式：</p>

<p>另一个选择是 16bpp，5bpc，不包含 alpha 值。这个格式相比之前一个仅占用 50% 的存储大小(每个像素2字节)，但将使你存储它的 RGB 数据到内存或磁盘中变得困难。既然这种格式中，每个颜色组件只有 5bits(原文中写的是每个像素是5bits，但根据上下文可知应该是每个组件)，这样图形(特别是平滑渐变的)会造成重叠在一起的假象。</p>

<p>还有一个是 64bpp，16bpc，最终为 128bpp，32bpc，浮点数组件(有或没有 alpha 值)。它们分别使用 8 字节和 16 字节，并且允许更高的精度。当然，这会造成更多的内存使用和昂贵的计算。</p>

<p>整件事件中，Core Graphics 也支持一些像灰度模式和 <a href="https://zh.wikipedia.org/wiki/%E5%8D%B0%E5%88%B7%E5%9B%9B%E5%88%86%E8%89%B2%E6%A8%A1%E5%BC%8F">CMYK</a> 格式，这些格式类似于仅有 alpha 值的格式(蒙板)。</p>

<h2>二维数据</h2>

<p>当颜色组件(红、绿、蓝、alpha)混杂在一起的时候，大多数框架(包括 Core Graphics )使用像素数据。正是这种情况下我们称之为二维数据，或者二维组件。这个意思是：每一个颜色组件都在它自己的内存区域，也就是说它是二维的。比如 RGB 数据，我们有三个独立的内存区域，一个大的区域包含了所有像素的红颜色的值，一个包含了所有绿颜色的值，一个包含了所有蓝颜色的值。</p>

<p>在某些情况下，一些视频框架便会使用二维数据。</p>

<h2 id="ycbcr">YCbCr</h2>

<p>当我们处理视频数据时，<a href="https://zh.wikipedia.org/wiki/YCbCr">YCbCr</a> 是一种常见的格式。它也是包含了三种(Y,Cb和Cr)代表颜色数据的组件。但是简单的讲，它更类似于通过人眼看到的颜色。人眼对 Cb 和 Cr 这两种组件的色彩度不太能精确的辨认出来，但是能很准确的识别出 Y 的亮度。当数据使用 YCbCr 格式时，在同等的条件下，Cb 和 Cr 组件比 Y 组件压缩的更紧密。</p>

<p>出于同样的原因，JPEG 图像有时会将像素数据从 RGB 转换到 YCbCr。JPEG 单独的压缩每一个二维颜色。当压缩基于 YCbCr 的平面时，Cb 和 Cr 能比 Y 压缩得更完全。</p>

<h2>图片格式</h2>

<p>当你在 iOS 或者 OS X 上处理图片时，他们大多数为 JPEG 和 PNG。让我们更进一步观察。</p>

<h2 id="jpeg">JPEG</h2>

<p>每个人都知道 JPEG。他是相机的产物。它代表这照片如何存储在电脑上。甚至你嘛嘛都听说过 JPEG。</p>

<p>一个很好的理由，很多人都认为 JPEG 文件仅是另一种像素数据的格式，就像我们刚刚谈到的 RGB 像素布局那样。这样理解离真像真是差十万八千里了。</p>

<p>将 JPEG 数据转换成像素数据是一个非常复杂的过程，你通过一个周末的计划都不能完成，甚至是一个非常漫长的周末(原文的意思好像就是为了表达这个过程非常复杂，不过老外的比喻总让人拎不清)。对于每一个二维颜色，JPEG 使用一种基于<a href="https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2">离散余弦变换</a>(简称 DCT 变换)的算法，将空间信息转变到频域.这个信息然后被量子化，排好序，并且用一种<a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">哈夫曼编码</a>的变种来压缩。很多时候，首先数据会被从 RGB 转换到二维 YCbCr，当解码 JPEG 的时候，这一切都将变得可逆。</p>

<p>这也是为什么当你通过 JPEG 文件创建一个 UIImage 并且绘制到屏幕上时，将会有一个延时，因为 CPU 这时候忙于解压这个 JPEG。如果你需要为每一个 tableviewcell 解压 JPEG，那么你的滚动当然不会平滑(原来 tableviewcell 里面最要不要用 JPEG 的图片)。</p>

<p>那究竟为什么我们还要用 JPEG 呢？答案就是 JPEG 可以非常非常好的压缩图片。一个通过 iPhone5 拍摄的，未经压缩的图片占用接近 24M。但是通过默认压缩设置，你的照片通常只会在 2-3M 左右。JPEG 压缩这么好是因为它是失真的，它去除了人眼很难察觉的信息，并且这样做可以超出像 gzip 这样压缩算法的限制。但这仅仅在图片上有效的，因为 JPEG 依赖于图片上有很多人类不能察觉出的数据。如果你从一个基本显示文本的网页上截取一张图，JPEG 将不会这么高效。压缩效率将会变得低下，你甚至能看出来图片已经压缩变形了。</p>

<h2 id="png">PNG</h2>

<p><a href="https://zh.wikipedia.org/wiki/PNG">PNG</a>读作”ping”。和 JPEG 相反，它的压缩对格式是无损的。当你将一张图片保存为 PNG，并且打开它(或解压)，所有的像素数据会和最初一模一样，因为这个限制，PNG 不能像 JPEG 一样压缩图片，但是对于像程序中的原图(如buttons，icons)，它工作的非常好。更重要的是，解码 PNG 数据比解码 JPEG 简单的多。</p>

<p>在现实世界中，事情从来没有那么简单，目前存在了大量不同的 PNG 格式。可以通过维基百科查看详情。但是简言之，PNG 支持压缩带或不带 alpha 通道的颜色像素(RGB)，这也是为什么它在程序原图中表现良好的另一个原因。</p>

<h2>挑选一个格式</h2>

<p>当你在你的程序中使用图片时，你需要坚持这两种格式: JPEG 或者 PNG。读写这种格式文件的压缩和解压文件能表现出很高的性能，另外，还支持并行操作。同时 Apple 正在改进解压缩并可能出现在将来的新操作系统中，届时你将会得到持续的性能提升。如果尝试使用另一种格式，你需要注意到，这可能对你程序的性能会产生影响，同时可能会打开安全漏洞，经常，图像解压缩算法是黑客最喜欢的攻击目标。</p>

<p>已经写了很多关于优化 PNGs，如果你想要了解更多，请到互联网上查询。非常重要的一点，注意 Xcode 优化 PNG 选项和优化其他引擎有很大的不同。</p>

<p>当 Xcode 优化一个 PNG 文件的时候，它将 PNG 文件变成一个从技术上讲不再是<a href="https://developer.apple.com/library/ios/qa/qa1681/_index.html">有效的PNG文件</a>。但是 iOS 可以读取这种文件，并且这比解压缩正常的 PNG 文件更快。Xcode 改变他们，让 iOS 通过一种对正常 PNG 不起作用的算法来对他们解压缩。值得注意的重点是，这改变了像素的布局。正如我们所提到的一样，在像素之下有很多种方式来描绘 RGB 数据，如果这不是 iOS 绘制系统所需要的格式，它需要将每一个像素的数据替换，而不需要加速来做这件事。</p>

<p>让我们再强调一遍，如果你可以，你需要为原图设置 resizable images。你的文件将变得更小，因此你只需要从文件系统装载更少的数据。</p>

<h2 id="uikitpixels">UIKit 和 Pixels</h2>

<p>每一个在 UIKit 中的 view 都有它自己的 CALayer。依次，这些图层都有一个叫像素位图的后备存储，有点像一个图像。这个后备存储正是被渲染到显示器上的。</p>

<h2 id="withdrawrect">With –drawRect:</h2>

<p>如果你的视图类实现了 <code>-drawRect:</code>，他们将像这样工作:</p>

<p>当你调用 <code>-setNeedsDisplay</code>，UIKit 将会在这个视图的图层上调用 <code>-setNeedsDisplay</code>。这为图层设置了一个标识，标记为 dirty(直译是脏的意思，想不出用什么词比较贴切,污染？)，但还显示原来的内容。它实际上没做任何工作，所以在一个row 中可以多次调用 <code>-setNeedsDisplay</code>。</p>

<p>下面，当渲染系统准备好，它会调用视图图层的-display方法.此时，图层会装配它的后备存储。然后建立一个 Core Graphics 上下文(CGContextRef)，将后备存储对应内存中的数据恢复出来，绘图会进入对应的内存区域，并使用 CGContextRef 绘制。</p>

<p>当你使用 UIKit 的绘制方法，例如: <code>UIRectFill()</code> 或者 <code>-[UIBezierPath fill]</code> 代替你的 <code>-drawRect:</code> 方法，他们将会使用这个上下文。使用方法是，UIKit 将后备存储的 CGContextRef 推进他的 graphics context stack，也就是说，它会将那个上下文设置为当前的。因此 <code>UIGraphicsGetCurrent()</code> 将会返回那个对应的上下文。既然 UIKit 使用 <code>UIGraphicsGetCurrent()</code> 绘制方法，绘图将会进入到图层的后备存储。如果你想直接使用 Core Graphics 方法，你可以自己调用 <code>UIGraphicsGetCurrent()</code> 得到相同的上下文，并且将这个上下文传给 Core Graphics 方法。</p>

<p>从现在开始，图层的后备存储将会被不断的渲染到屏幕上。直到下次再次调用视图的 <code>-setNeedsDisplay</code> ，将会依次将图层的后备存储更新到视图上。</p>

<h2 id="drawrect">不使用 -drawRect:</h2>

<p>当你用一个 UIImageView 时，事情略有不同，这个视图仍然有一个 CALayer，但是图层却没有申请一个后备存储。取而代之的是使用一个 CGImageRef 作为他的内容，并且渲染服务将会把图片的数据绘制到帧的缓冲区，比如，绘制到显示屏。</p>

<p>在这种情况下，将不会继续重新绘制。我们只是简单的将位图数据以图片的形式传给了 UIImageView，然后 UIImageView 传给了 Core Animation，然后轮流传给渲染服务。</p>

<h2 id="drawrectdrawrect">实现-drawRect: 还是不实现 -drawRect:</h2>

<p>这听起来貌似有点低俗，但是最快的绘制就是你不要做任何绘制。</p>

<p>大多数时间，你可以不要合成你在其他视图(图层)上定制的视图(图层)，这正是我们推荐的，因为 UIKit 的视图类是非常优化的 (就是让我们不要闲着没事做,自己去合并视图或图层) 。</p>

<p>当你需要自定义绘图代码时，Apple 在<a href="https://developer.apple.com/videos/wwdc/2012/?id=506">WWDC 2012’s session 506</a>:Optimizing 2D Graphics and Animation Performance 中展示了一个很好的例子:”finger painting”。</p>

<p>另一个地方需要自定义绘图的就是 iOS 的股票软件。股票是直接用 Core Graphics 在设备上绘制的，注意，这仅仅是你需要自定义绘图，你并不需要实现 <code>-drawRect:</code> 方法。有时，通过 <code>UIGraphicsBeginImageContextWithOptions()</code> 或者 <code>CGBitmapContextCeate()</code> 创建位图会显得更有意义，从位图上面抓取图像，并设置为 <code>CALayer</code> 的内容。下面我们将给出一个例子来测试，检验。</p>

<h2>单一颜色</h2>

<p>如果我们看这个例子：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="c1">// Don&#39;t do this</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawRect:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">rect</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">]</span> <span class="n">setFill</span><span class="p">];</span>
</span><span class="line">    <span class="n">UIRectFill</span><span class="p">([</span><span class="n">self</span> <span class="n">bounds</span><span class="p">]);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在我们知道这为什么不好:我们促使 Core Animation 来为我们创建一个后备存储，并让它使用单一颜色填充后备存储，然后上传给 GPU。</p>

<p>我们跟本不需要实现 <code>-drawRect:</code>，并节省这些代码工作量，只需简单的设置这个视图图层的背景颜色。如果这个视图有一个 CAGradientLayer 作为图层，那么这个技术也同样适用于此（渐变图层）。</p>

<h2>可变尺寸的图像</h2>

<p>类似的，你可以使用可变尺寸的图像来降低绘图系统的压力。让我们假设你需要一个 300×500 点的按钮插图，这将是 600×100=60k 像素或者 60kx4=240kB 内存大小需要上传到 GPU，并且占用 VRAM。如果我们使用所谓的可变尺寸的图像，我们只需要一个 54×12 点的图像，这将占用低于 2.6k 的像素或者 10kB 的内存，这样就变得更快了。</p>

<p>Core Animation 可以通过 CALayer 的 <a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CALayer_class/Introduction/Introduction.html#//apple_ref/occ/instp/CALayer/contentsCenter"><code>contentsCenter</code></a> 属性来改变图像，大多数情况下，你可能更倾向于使用，<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImage_Class/Reference/Reference.html#//apple_ref/occ/instm/UIImage/resizableImageWithCapInsets:resizingMode:"><code>-[UIImage resizableImageWithCapInsets:resizingMode:]</code></a>。</p>

<p>同时注意，在第一次渲染这个按钮之前，我们并不需要从文件系统读取一个 60k 像素的 PNG 并解码，解码一个小的 PNG 将会更快。通过这种方式，你的程序在每一步的调用中都将做更少的工作，并且你的视图将会加载的更快。</p>

<h2>并发绘图</h2>

<p>上一次 <a href="http://objccn.io/issue-2/">objc.io</a> 的话题是关于并发的讨论。正如你所知道的一样，UIKit 的线程模型是非常简单的：你仅可以从主队列(比如主线程)中调用 UIKit 类(比如视图),那么并发绘图又是什么呢？</p>

<p>如果你必须实现 <code>-drawRect:</code>，并且你必须绘制大量的东西，这将占用时间。由于你希望动画变得更平滑，除了在主队列中，你还希望在其他队列中做一些工作。同时发生的绘图是复杂的，但是除了几个警告，同时发生的绘图还是比较容易实现的。</p>

<p>我们除了在主队列中可以向 CALayer 的后备存储中绘制一些东西，其他方法都将不可行。可怕的事情将会发生。我们能做的就是向一个完全断开链接的位图上下文中进行绘制。</p>

<p>正如我们上面所提到的一样，在 Core Graphics 下，所有 Core Graphics 绘制方法都需要一个上下文参数来指定绘制到那个上下文中。UIKit 有一个当前上下文的概念(也就是绘制到哪儿去)。这个当前的上下文就是 per-thread.</p>

<p>为了同时绘制，我们需要做下面的操作。我们需要在另一个队列创建一个图像，一旦我们拥有了图像，我们可以切换回主队列，并且设置这个图像为 UIImageView 的图像。这个技术在 <a href="https://developer.apple.com/videos/wwdc/2012/?id=211">WWDC 2012 session 211</a> 中讨论过。(异步下载图片经常用到这个)</p>

<p>增加一个你可以在其中绘制的新方法：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nf">renderInImageOfSize:</span><span class="p">(</span><span class="n">CGSize</span><span class="p">)</span><span class="nv">size</span><span class="p">;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// do drawing here</span>
</span><span class="line">
</span><span class="line">    <span class="n">UIImage</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class="line">    <span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span><span class="line">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这个方法通过 <code>UIGraphicsBeginImageContextWithOptions()</code> 方法，并根据给定的大小创建一个新的 CGContextRef 位图。这个方法也会将这个上下文设置为<em>当前UIKit</em>的上下文。现在你可以在这里做你想在 <code>-drawRect:</code> 中做的事了。然后我们可以通过 <code>UIGraphicsGetImageFromCurrentImageContext()</code>,将获得的这个上下文位图数据作为一个 UIImage，最终移除这个上下文。</p>

<p>很重要的一点就是，你在这个方法中所做的所有绘图的代码都是线程安全的，也就是说，当你访问属性等等，他们需要线程安全。因为你是在另一个队列中调用这个方法的。如果这个方法在你的视图类中，那就需要注意一点了。另一个选择就是创建一个单独的渲染类，并设置所有需要的属性，然后通过触发来渲染图片。如果这样，你可以通过使用简单的 UIImageView 或者 UITableViewCell。</p>

<p>要知道，所有 UIKit 的绘制 API 在使用另一个队列时，都是安全的。只需要确定是在同一个操作中调用他们的，这个操作需要以 <code>UIGraphicsBeginImageContextWithOptions()</code> 开始，以 <code>UIGraphicsEndIamgeContext()</code> 结束。</p>

<p>你需要像下面这样触发渲染代码：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">UIImageView</span> <span class="o">*</span><span class="n">view</span><span class="p">;</span> <span class="c1">// assume we have this</span>
</span><span class="line"><span class="n">NSOperationQueue</span> <span class="o">*</span><span class="n">renderQueue</span><span class="p">;</span> <span class="c1">// assume we have this</span>
</span><span class="line"><span class="n">CGSize</span> <span class="n">size</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
</span><span class="line"><span class="p">[</span><span class="n">renderQueue</span> <span class="nl">addOperationWithBlock:</span><span class="o">^</span><span class="p">(){</span>
</span><span class="line">        <span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">renderer</span> <span class="nl">renderInImageOfSize:</span><span class="n">size</span><span class="p">];</span>
</span><span class="line">        <span class="p">[[</span><span class="n">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">]</span> <span class="nl">addOperationWithBlock:</span><span class="o">^</span><span class="p">(){</span>
</span><span class="line">            <span class="n">view</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
</span><span class="line">        <span class="p">}];</span>
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>要注意，我们是在主队列中调用 view.image = image.这是一个非常重要的细节。你不可以在任何其他队列中调用这个代码。</p>

<p>像往常一样，同时绘制会伴随很多问题，你现在需要取消后台渲染。并且在渲染队列中设置合理的同时绘制的最大限度。</p>

<p>为了支持这一切，最简单的就是在一个 NSOperation 子类内部实现 <code>-renderInImageOfSize:</code>。</p>

<p>最终，需要指出，设置 UITableViewCell 内容为异步是非常困难的。单元格很有可能在完成异步渲染前已经被复用了。尽管单元格已经被其他地方复用，但你只需要设置内容就行了。</p>

<h2 id="calayer">CALayer</h2>

<p>到现在为止，你需要知道在 GPU 内，一个 CALayer 在某种方式上和一个纹理类似。图层有一个后备存储，这便是被用来绘制到屏幕上的位图。</p>

<p>通常，当你使用 CALayer 时，你会设置它的内容为一个图片。这到底做了什么？这样做会告诉 Core Animation 使用图片的位图数据作为纹理。如果这个图片(JPEG或PNG)被压缩了，Core Animation 将会这个图片解压缩，然后上传像素数据到 GPU。</p>

<p>尽管还有很多其他中图层，如果你是用一个简单的没有设置上下文的 CALayer，并为这个 CALayer 设置一个背景颜色，Core Animation 并不会上传任何数据到 GPU，但却能够不用任何像素数据而在 GPU 上完成所有的工作，类似的，对于渐变的图层，GPU 是能创建渐变的，而且不需要 CPU 做任何工作，并且不需要上传任何数据到 GPU。</p>

<h2>自定义绘制的图层</h2>

<p>如果一个 CALayer 的子类实现了 <code>-drawInContext:</code> 或者它的代理，类似于 <code>-drawLayer:inContest:</code>, Core Animation 将会为这个图层申请一个后备存储，用来保存那些方法绘制进来的位图。那些方法内的代码将会运行在 CPU 上，结果将会被上传到 GPU。</p>

<h2>形状和文本图层</h2>

<p>形状和文本图层还是有些不同的。开始时，Core Animation 为这些图层申请一个后备存储来保存那些需要为上下文生成的位图数据。然后 Core Animation 会讲这些图形或文本绘制到后备存储上。这在概念上非常类似于，当你实现 <code>-drawInContext:</code> 方法，然后在方法内绘制形状或文本，他们的性能也很接近。</p>

<p>在某种程度上，当你需要改变形状或者文本图层时，这需要更新它的后备存储，Core Animation 将会重新渲染后备存储。例如，当动态改变形状图层的大小时，Core Animation 需要为动画中的每一帧重新绘制形状。</p>

<h2>异步绘图</h2>

<p>CALayer 有一个叫做 drawsAsynchronously 的属性，这似乎是一个解决所有问题的高招。注意，尽管这可能提升性能，但也可能让事情变慢。</p>

<p>当你设置 drawsAsynchronously 为 YES 时，发生了什么？你的 <code>-drawRect:/-drawInContext:</code> 方法仍然会被在主线程上调用。但是所有调用 Core Graphics 的操作都不会被执行。取而代之的是，绘制命令被推迟，并且在后台线程中异步执行。</p>

<p>这种方式就是先记录绘图命令，然后在后台线程中重现。为了这个过程的顺利进行，更多的工作需要被做，更多的内存需要被申请。但是主队列中的一些工作便被移出来了(大概意思就是让我们把一些能在后台实现的工作放到后台实现，让主线程更顺畅)。</p>

<p>对于昂贵的绘图方法，这是最有可能提升性能的，但对于那些绘图方法来说，也不会节省太多资源。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-08T09:46:25+08:00" data-updated="true" itemprop="datePublished">Apr 8<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/08/iCould-%E5%92%8C-Core-Data/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/08/iCould-%E5%92%8C-Core-Data/" itemprop="url">iCould 和 Core Data</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<div><p>当乔布斯第一次在苹果全球开发大会上介绍 <a href="http://en.wikipedia.org/wiki/ICloud">iCloud</a> 的时候，他将无缝同步的功能描述的太过完美，以至于让人怀疑其是否真的能实现。但当你在 <a href="http://adcdownload.apple.com//videos/wwdc_2011__hd/session_303__whats_new_in_core_data_on_ios.m4v">iOS 5</a> 和 <a href="http://adcdownload.apple.com//videos/wwdc_2012__hd/session_227__using_icloud_with_core_data.mov">iOS 6</a> 系统中尝试使用 iCloud <a href="http://www.objc.io/issue-4/core-data-overview.html">Core Data</a> 同步的时候你会对其真实情况了如指掌。</p>
<p><a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/MOSXAppProgrammingGuide/CoreAppDesign/CoreAppDesign.html#//apple_ref/doc/uid/TP40010543-CH3-SW3">库风格应用</a>(译者注:&#8221;盒子类型&#8221;，比如 iPhoto )的同步中的问题导致<a href="http://www.macworld.com/article/1167742/developers_dish_on_iclouds_challenges.html">很多</a><a href="http://blog.caffeine.lu/problems-with-core-data-icloud-storage.html">开发者</a><a href="http://www.jumsoft.com/2013/01/response-to-sync-issues/">放弃</a>支持 iCloud，而选择一些其他的方案比如 <a href="http://simperium.com">Simperium</a>，<a href="https://github.com/nothirst/TICoreDataSync">TICoreDataSync</a> 和 <a href="http://www.wasabisync.com">WasabiSync</a>。</p>

<p>2013年初，在苹果公司不透明及充满 bug 的 iCloud Core Data 同步实现中挣扎多年后，开发者终于公开批判了这项服务的重大缺陷并将这个话题推上了<a href="http://arstechnica.com/apple/2013/03/frustrated-with-icloud-apples-developer-community-speaks-up-en-masse/">风口浪尖</a>。 最终被 Ellis Hamburger 在一篇<a href="http://www.theverge.com/2013/3/26/4148628/why-doesnt-icloud-just-work">尖锐文章</a>提出。</p>

<h2 id="wwdc">WWDC</h2>

<p>苹果也注意到了，很明显这些事情必须改变。在 WWDC 2013，<a href="http://about.me/nickgillett">Nick Gillett</a> 宣布 Core Data 团队花了一年时间专注于在 iOS 7 中解决一些 iCloud 最令人挫败的漏洞，承诺大幅改善问题并且让开发者更简单的使用。“我们明显减少了开发者所需要编写的复杂代码的数量。” Nick Gillett在 [“What’s New in Core Data and iCloud”] 舞台上讲到。 在 iOS 7 中，Apple 专注于 iCloud 的速度，可靠性，和性能，事实上这卓有成效。</p>

<p>让我们看看具体有哪些改变，以及如何在 iOS 7 应用程序实现 Core Data。</p>

<h2>设置</h2>

<p>要设置一个 iCloud Core Data 应用，你首先需要在你的应用中请求 iCloud 的<a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/iCloudDesignGuide/Chapters/iCloudFundametals.html">访问权限</a>，让你的应用程序可以读写一个或多个开放性容器 (ubiquity containers)，在 Xcode 5中你可以在你应用 target 的 <a href="https://developer.apple.com/xcode/">“Capabilities”</a> 选项卡中轻易完成着这一切。</p>

<p>在开放性容器内部，Core Data Framework 将会存储所有的事务日志 &#8211; 记录你的所有持久化的存储 &#8211; 为了跨设备同步数据做准备。 Core Data 使用了一个被称为<a href="http://en.wikipedia.org/wiki/Multi-master_replication">多源复制</a>(multi-master replication)的技术来同步 iOS 和 Macs 之间的数据。可持久化存储的数据存在了每个设备的 <code>CoreDataUbiquitySupport</code> 文件夹里，你可以在应用沙盒中找到他。当用户修改了 iCloud accounts，Core Data framework 会管理多个账户，而并不需要你自己去监听<a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/nsfilemanager_class/Reference/Reference.html#//apple_ref/doc/uid/20000305-SW81"><code>NSUbiquityIdentityDidChangeNotification</code></a>。</p>

<p>每一个事务日志都是一个<code>plist</code>文件，负责实体的跟踪插入，删除以及更新。这些日志会自动被系统按照一定<a href="http://mentalfaculty.tumblr.com/post/23788055417/under-the-sheets-with-icloud-and-core-data-seeding">基准</a>合并。</p>
<div>
<p>在你设置iCloud的持久化存储的时候，调用</p><code>addPersistentStoreWithType:configuration:URL:options:error:</code><p>或者</p> <code>migratePersistentStore:toURL:options:withType:error:</code>的时候注意需要设置一些选项:
</div>
<ul>
<li><p><code>NSPersistentStoreUbiquitousContentNameKey</code> (<code>NSString</code>) <br />
给 iCloud 存储空间指定一个名字（例如 @“MyAppStore”）</p></li>
<li><p><code>NSPersistentStoreUbiquitousContentURLKey</code> (<code>NSString</code>, iOS 7 中可选)
给事务日志指定一个二级目录(例如 @&#8221;Logs&#8221;)</p></li>
<li><p><code>NSPersistentStoreUbiquitousPeerTokenOption</code> (<code>NSString</code>, 可选) <br />
为每个程序设置一个盐，为了让不同应用可以在同一个集成 iCloud 的设备中分享 Core Data 数据 (比如<code>@"d70548e8a24c11e3bbec425861b86ab6"</code>)</p></li>
<li><p><code>NSPersistentStoreRemoveUbiquitousMetadataOption</code> (<code>NSNumber</code> (Boolean), 可选)
指定程序是否需要备份或迁移 iCloud 的元数据(例如 <code>@YES</code>)</p></li>
<li><p><code>NSPersistentStoreUbiquitousContainerIdentifierKey</code> (<code>NSString</code>) <br />
指定一个容器，如果你的应用有多个容器定义在 entitlements 中(例如 <code>@"com.company.MyApp.anothercontainer"</code>)</p></li>
<li><p><code>NSPersistentStoreRebuildFromUbiquitousContentOption</code> (<code>NSNumber</code> (Boolean), 可选) 
告诉 Core Data 抹除本地存储数据并且用 iCoud 重建数据(例如 <code>@YES</code>)</p></li>
</ul>

<p>只支持 iOS 7 的应用的唯一必填选项是 ContentNameKey，它是为了让 Core Data 知道把日志和元数据放在哪里。在 iOS 7 中，你传入 NSPersistentStoreUbiquitousContentNameKey 的字符串值不应该包含&#8217;.&#8217;。 如果你的应用已经使用 Core Data 去存储持久化数据，但是没有实现 iCloud 同步，你只需要简单加入 content name key 就能将存储转为可以使用 iCloud 的状态，而无需关注有没有活跃的 iCloud 账户。</p>

<p>为你的应用设置一个管理对象上下文简单到只需要实例化一个 <code>NSManagedObjectContext</code> 并连同一个合并策略一并告诉你的持久化存储。苹果建议使用 <code>NSMergeByPropertyObjectTrumpMergePolicy</code> 作为合并策略，它会合并冲突，并给予内存中的变化的数据相较于磁盘数据更高的优先级。</p>

<p>虽然 Apple 还没有发布官方的 iOS7 中 iCloud Core Data 的示例代码，但是 Apple 的 Core Data 团队中的一个工程师在<a href="https://devforums.apple.com/message/828503#828503">开发者论坛</a>上提供了这个模板。我们稍微修改让它更清晰:</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#pragma mark - Notification Observers</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">registerForiCloudNotifications</span> <span class="p">{</span>
</span><span class="line">    <span class="n">NSNotificationCenter</span> <span class="o">*</span><span class="n">notificationCenter</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">notificationCenter</span> <span class="nl">addObserver:</span><span class="n">self</span>
</span><span class="line">                           <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">storesWillChange:</span><span class="p">)</span>
</span><span class="line">                               <span class="nl">name:</span><span class="n">NSPersistentStoreCoordinatorStoresWillChangeNotification</span>
</span><span class="line">                             <span class="nl">object:</span><span class="n">self</span><span class="p">.</span><span class="n">persistentStoreCoordinator</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">notificationCenter</span> <span class="nl">addObserver:</span><span class="n">self</span>
</span><span class="line">                           <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">storesDidChange:</span><span class="p">)</span>
</span><span class="line">                               <span class="nl">name:</span><span class="n">NSPersistentStoreCoordinatorStoresDidChangeNotification</span>
</span><span class="line">                             <span class="nl">object:</span><span class="n">self</span><span class="p">.</span><span class="n">persistentStoreCoordinator</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">notificationCenter</span> <span class="nl">addObserver:</span><span class="n">self</span>
</span><span class="line">                           <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">persistentStoreDidImportUbiquitousContentChanges:</span><span class="p">)</span>
</span><span class="line">                               <span class="nl">name:</span><span class="n">NSPersistentStoreDidImportUbiquitousContentChangesNotification</span>
</span><span class="line">                             <span class="nl">object:</span><span class="n">self</span><span class="p">.</span><span class="n">persistentStoreCoordinator</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="cp"># pragma mark - iCloud Support</span>
</span><span class="line">
</span><span class="line"><span class="c1">/// 在 -addPersistentStore: 使用这些配置</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nf">iCloudPersistentStoreOptions</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="err">@</span><span class="p">{</span><span class="nl">NSPersistentStoreUbiquitousContentNameKey:</span> <span class="s">@&quot;MyAppStore&quot;</span><span class="p">};</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">persistentStoreDidImportUbiquitousContentChanges:</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span><span class="p">)</span><span class="nv">notification</span> <span class="p">{</span>
</span><span class="line">    <span class="n">NSManagedObjectContext</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">managedObjectContext</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">context</span> <span class="nl">performBlock:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">context</span> <span class="nl">mergeChangesFromContextDidSaveNotification:</span><span class="n">changeNotification</span><span class="p">];</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">storesWillChange:</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span><span class="p">)</span><span class="nv">notification</span> <span class="p">{</span>
</span><span class="line">    <span class="n">NSManagedObjectContext</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">managedObjectContext</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">context</span> <span class="nl">performBlockAndWait:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">        <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="k">if</span> <span class="p">([</span><span class="n">context</span> <span class="n">hasChanges</span><span class="p">])</span> <span class="p">{</span>
</span><span class="line">            <span class="kt">BOOL</span> <span class="n">success</span> <span class="o">=</span> <span class="p">[</span><span class="n">context</span> <span class="nl">save:</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">error</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="c1">// 执行错误处理</span>
</span><span class="line">                <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,[</span><span class="n">error</span> <span class="n">localizedDescription</span><span class="p">]);</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="p">[</span><span class="n">context</span> <span class="n">reset</span><span class="p">];</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 刷新界面</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">storesDidChange:</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span><span class="p">)</span><span class="nv">notification</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// 刷新界面</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3>异步持久化设置</h3>

<p>在 iOS 7 中，使用 iCloud 选项来调用 </p><code>addPersistentStoreWithType:configuration:URL:options:error:</code> 几乎可以瞬间返回存储对象。 能做到这样是因为它首先设置了一个内部‘回滚’存储，利用本地存储作为一个占位符，同时由事务日志和元数据来异步地构建 iCloud 存储。当回滚存储有变化时，这些变化将在 iCloud 存储被添加到 coordinator 时合并至其中。在完成回滚存储的设置后，控制台将会打印<code>Using local storage: 1</code> ，当 iCloud 完全设置完后，你会看到 <code>Using local storage: 0</code>。 这句话的意思是 iCloud 存储已经启用，此后你可以通过监听<code>NSPersistentStoreDidImportUbiquitousContentChangesNotification</code>看到来自 iCloud 的内容。

<p>如果你的应用关注在不同存储间的迁移，那么你需要监听</p><p><code>NSPersistentStoreCoordinatorStoresWillChangeNotification</code></p> 或<code>NSPersistentStoreCoordinatorStoresDidChangeNotification</code>(将这些通知关联到你的 coordinator，这样就可以过滤其他和你无关的通知) 并且在 <code>userInfo</code> 中检查 <code>NSPersistentStoreUbiquitousTransitionTypeKey</code> <p>的值， 这个数值是一个对应</p> <a href="https://developer.apple.com/library/ios/documentation/cocoa/Reference/CoreDataFramework/Classes/NSPersistentStoreCoordinator_Class/NSPersistentStoreCoordinator.html#//apple_ref/c/tdef/NSPersistentStoreUbiquitousTransitionType"><code>NSPersistentStoreUbiquitousTransitionType</code></a> <p>枚举类型的 NSNumber，在迁移已经发生时，这个值是<code>NSPersistentStoreUbiquitousTransitionTypeInitialImportCompleted</code>。</p>

<h2>边缘情况</h2>

<h3 id="churn">混淆 (Churn)</h3>

<p>在 iOS 5 和 iOS 6 中测试 iCloud 时最严重的一个问题是重度用户的账号会遇到一种“混淆”的状态，导致无法使用。同步将完全停止，甚至删除开放性数据也无法使其正常工作。在 <a href="http://lickability.com">Lickability</a>，我们亲切地称为这种状态“fucking bucket。”</p>

<p>在 iOS 7 中，系统提供了一个方法来真正移除全部的开放性存储内容:</p> <code>+removeUbiquitousContentAndPersistentStoreAtURL:options:error:</code>，这个方法对测试很有帮助，甚至在你应用中，当你用户进入了一个不正常的状态时，他们可以通过这个方法删除所有数据，并重新来过。不过，需要指出的是：首先，这种方法是同步的。甚至在做网络操作的时候它也是同步的，因此它会花很长时间，并且在完成前也不会返回。第二，绝对不能在有持久性存储 coordinators 活跃时执行此操作。这样会造成很严重的问题，你的应用程序可能进入一个不可恢复的状态，而且官方指导指出所有活跃的持久性存储 coordinators 都应在使用这个方法前完全销毁收回。

<h3>账户修改</h3>

<p>iOS 5 系统中，用户在切换 iCloud 账户或者禁用账户时，<code>NSPersistentStoreCoordinator</code> 中的数据会在应用无法知晓的情况下完全消失。事实上检查一个账号是否变更了的唯一的方法是调用 <code>NSFileManager</code> 中的 <code>URLForUbiquityContainerIdentifier</code>，这个方法可以创建一个开放性容器文件夹，而且需要数秒返回。在 iOS 6，这种情况随着引进 <code>ubiquityIdentityToken</code> 和相应的<code>NSUbiquityIdentityDidChangeNotification</code> 之后得到改善。因为在 ubiquity id 变化的时候会发送通知，这就可以对应用账户的变更进行有效的确认并及时的发出提示。</p>

<p>然而，iOS 7 中这种转换的情况就变得更加简单，账户的切换是由 Core Data 框架来处理的，因此只要你的程序能够正常响应 <code>NSPersistentStoreCoordinatorStoresWillChangeNotification</code> 和 <code>NSPersistentStoreCoordinatorStoresDidChangeNotification</code> 便可以在切换账户的时候流畅的更换信息。检查 <code>userInfo</code> 的字典中 <code>NSPersistentStoreUbiquitousTransitionType</code> 键将提供更多关于迁移的类型的细节。</p>

<p>在应用沙箱中框架会为每个账户管理各自独立的持久化存储，所以这就意味着如果用户回到之前的账户，其数据会和之前离开时一样，仍然可用。Core Data 现在也会在磁盘空间不足时管理对这些文件进行的清理工作。</p>

<h3 id="icloud">iCloud 的启用与停用</h3>

<p>在 iOS 7 中应用实现用一个开关用来切换启用关闭 iCloud 变的非常容易，虽然对大部分应用来说这个功能不是很需要，因为在创建 <code>NSPersistentStore</code> 时候如果加入 iCloud 选项，那么 API 现在将自动建立一个独立的文件结构，这意味着本地存储和 iCloud 存储共用相同的存储 URL 和其他很多设置。这个选项将把 ubiquitous 元数据和存储本身进行分离，并专门为迁移或者复制的场景进行了特殊设计。下面是一个示例:</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">migrateiCloudStoreToLocalStore</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// 假设你只有一个存储</span>
</span><span class="line">    <span class="n">NSPersistentStore</span> <span class="o">*</span><span class="n">store</span> <span class="o">=</span> <span class="p">[[</span><span class="n">_coordinator</span> <span class="n">persistentStores</span><span class="p">]</span> <span class="n">firstObject</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">localStoreOptions</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self</span> <span class="n">storeOptions</span><span class="p">]</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">localStoreOptions</span> <span class="nl">setObject:</span><span class="err">@</span><span class="n">YES</span> <span class="nl">forKey:</span><span class="n">NSPersistentStoreRemoveUbiquitousMetadataOption</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSPersistentStore</span> <span class="o">*</span><span class="n">newStore</span> <span class="o">=</span>  <span class="p">[</span><span class="n">_coordinator</span> <span class="nl">migratePersistentStore:</span><span class="n">store</span>
</span><span class="line">                                                                  <span class="nl">toURL:</span><span class="p">[</span><span class="n">self</span> <span class="n">storeURL</span><span class="p">]</span>
</span><span class="line">                                                                <span class="nl">options:</span><span class="n">localStoreOptions</span>
</span><span class="line">                                                               <span class="nl">withType:</span><span class="n">NSSQLiteStoreType</span> <span class="nl">error:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">reloadStore:</span><span class="n">newStore</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">reloadStore:</span><span class="p">(</span><span class="n">NSPersistentStore</span> <span class="o">*</span><span class="p">)</span><span class="nv">store</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">store</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">_coordinator</span> <span class="nl">removePersistentStore:</span><span class="n">store</span> <span class="nl">error:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">_coordinator</span> <span class="nl">addPersistentStoreWithType:</span><span class="n">NSSQLiteStoreType</span>
</span><span class="line">                               <span class="nl">configuration:</span><span class="nb">nil</span>
</span><span class="line">                                         <span class="nl">URL:</span><span class="p">[</span><span class="n">self</span> <span class="n">storeURL</span><span class="p">]</span>
</span><span class="line">                                     <span class="nl">options:</span><span class="p">[</span><span class="n">self</span> <span class="n">storeOptions</span><span class="p">]</span>
</span><span class="line">                                       <span class="nl">error:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>切换一个本地存储到　iCloud 存储是一个非常容易的事情，简单到只需启用 iCloud 选项，并且把拥有相同选项的可持久存储加入到 coordinator 中。</p>

<h3>外部文件的引用</h3>

<p>外部文件的应用是一个在 iOS 5　中加入的 Core Data 新特性，允许大尺寸的二进制自动存储在 SQLite 数据库之外的文件系统中。 在我们测试中，当发生改变时，iCloud 并不知道如何解决依赖关系并会抛出异常。如果你计划使用 iCloud 同步 ,可以考虑在 iCloud entities 中取消这个选择:</p>

<p><img src="http://cloud.mttb.me/UBrx/image.png" alt="Core Data Modeler Checkbox" /></p>

<h3 id="model">Model 版本</h3>

<p>如果你计划使用 iCloud，存储的内容只能在未来兼容自动<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/CoreDataVersioning/Articles/vmLightweightMigration.html">轻量级迁移</a>，
这意味着 Core Data 需要能推断出映射，你也不能提供自己的映射模型。在未来只有对 Model 的简单改变，比如添加和重命名属性，才能被支持。在考虑是否使用 Core Data 同步时，一定要考虑到你的 app 的 Model 在未来版本中改变的情况。</p>

<h3>合并冲突</h3>

<p>在任何同步系统中，服务器和客户端之前的文件冲突是不可避免的。不同于 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/iCloudDesignGuide/Chapters/DesigningForDocumentsIniCloud.html#//apple_ref/doc/uid/TP40012094-CH2-SW1">iCloud Data 文档同步</a>的 APIs, iCloud 的 Core Data 整合并没有明确允许处理本地存储和事务日志之间的冲突。这其实是因为 Core Data 已经支持通过实现 <code>NSMergePolicy</code> 的子类来自定义策合并策略。 如果你要处理冲突，创建 <code>NSMergePolicy</code> 的子类并且覆盖 <code>resolveConflicts:error:</code> 来决定在冲突发生的时候做什么。然后在你的 <code>NSManagedObjectContext</code> 子类中，让<code>mergePolicy</code> 方法返回一个你自定义的策略的实例。</p>

<h3>界面更新</h3>

<p>很多库风格应用同时显示集合对象和一个对象的详细信息。 视图是由 <code>NSFetchedResultsController</code> 实例自动从网络更新 Core Data 的数据然后刷新。然而，您应该确保每一个详细视图正确监听变化对象并使自己保持最新。如果你不这样做, 将有显示陈旧的数据的风险，或者更糟，你将覆盖其他设备修改的数据。</p>

<h2>测试</h2>

<h3>本地网络和因特网同步</h3>

<p>iCloud 守护进程将使用本地网络或使用因特网这两种方式中的其中一种，来进行跨设备的数据同步。守护进程检测到两个设备时，也被称为对等网络，在同一个局域网，将在内网快速传输。然而，如果在不同的网络，该系统将传输回滚事务日志。这很重要，你必须在开发中对两种情况进行大量的测试，以确保您的应用程序正常运作。在这两种场景中，从备份存储同步更改或过渡到 iCloud 有时需要比预期更长的时间，所以如果有什么不工作，尝试给它点时间。</p>

<h3 id="icloud">模拟器中使用 iCloud</h3>

<p>在 iOS 7 中最有用的更新就是 iCloud 终于可以在<a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/iCloudDesignGuide/Chapters/TestingandDebuggingforiCloud.html">模拟器</a>中使用。在以往的版本中，你只能在设备中测试，这个限制使监听开发的同步进程有点困难。现在你甚至可以在你的 Mac 和模拟器中进行数据同步。</p>

<p>在 Xcode 5 新增的 iCloud 调试仪表中，你可以看到在你的应用程序的开放性存储中的文件，以及检查它们的文件传输状态，比如 &#8220;Current&#8221;， &#8220;Excluded&#8221;， 和 &#8220;Stored in Cloud&#8221; 等。 对于更底层的调试，可以把 <code>-com.apple.coredata.ubiquity.logLevel 3</code> 加入到启动参数或者设置成用户默认，以启用详细日志。还可以考虑在 iOS 中安装 <a href="http://developer.apple.com/downloads">iCloud 存储调试日志配置文件</a> 以及新的 <a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/Manpages/man1/ubcontrol.1.html"><code>ubcontrol</code></a> 命令行工具提供高质量错误报告到Apple 。你可以在你的设备连入 iTunes 并同步后在 <code>~/Library/Logs/CrashReporter/MobileDevice/device-name/DiagnosticLogs</code>
 中获取这些工具生成的日志。</p>

<p>然而，iCloud Core Data 并不完全支持模拟器。在用实际设备和模拟器测试传输时，似乎模拟器的 iCloud Core Data 只上传更改，却从不把它们抓取下来。虽然比起分别使用多个不同测试设备来说，确实进步和方便了很多，但是 iOS 模拟器上的 iCloud Core Data 支持绝对还没有完全成熟。</p>

<h2>继续改进</h2>

<p>因为 iOS 7 中 APIs 和功能得到了极大的改善，那些在 iOS 5 和 iOS 6 上分发的带有 iCloud Core Data 的应用的命运就显得扑朔迷离了。 由于从 API 的角度来看它们完全不同（当然我们从功能角度也验证了这一点)，Apple 的建议对于那些需要传统同步的应用来说并不那么友好。Apple <strong>清楚地</strong> 在<a href="https://devforums.apple.com/thread/199983?start=0&amp;tstart=0*">开发者论坛</a> 上建议，绝对不要在 iOS 7 和之前的设备同步之间同步数据。</p>

<p>事实上，“任何时候你都不应该在 iOS 7 与 iOS 6 同步。iOS 6 将持续造成那些已经在 iOS 7 上修正了的 bug，这样做将会会污染 iCloud 账户。” 保证这种分离的最简单的方法是简单地改变你存储中的 <code>NSPersistentStoreUbiquitousContentNameKey</code>，遵循规范进行命名。这样保证从旧版本数据同步的方法是孤立的，并允许开发人员从老旧的实现中完全脱身。</p>

<h2>发布</h2>

<p>发布一个 iCloud Core Data 应用仍旧有很大的风险，你需要对所有的环节进行测试：账户转换，iCloud 存储空间耗尽，多种设备，Model 的升级，以及设备恢复等。尽管 iCloud 调试仪表和 <a href="http://developer.icloud.com">developer.icloud.com</a> 对这些有所帮助，但依靠一个你完全无法控制的服务来发布一个应用仍然需要那种纵身一跃入深渊的信念。</p>

<p>正如 Brent Simmon <a href="http://inessential.com/2013/03/27/why_developers_shouldnt_use_icloud_sy">提到</a>的，发布任意一种 iCloud Syncing 应用都会有限制，所以需要事先了解一下成本。像 <a href="http://dayoneapp.com">Day One</a> 和 <a href="https://agilebits.com/onepassword">1Password</a> 这样的程序，会让使用者选择用 iCloud 还是 Dropbox 来同步他们的数据。对于很多使用者来说，没什么可以比一个独立的账户更加简易，但是一部分动手能力强的人喜欢更好的更全面的控制他们的数据。对于开发者而言，维持这种完全不同的<a href="https://www.dropbox.com/developers/datastore">数据库同步系统</a>在开发和测试的过程当中是十分繁琐和超负荷的。</p>

<h2 id="bugs">Bugs</h2>

<p>一旦你测试并且发布了你的 iCloud Core Data 应用，你很可能会遇到很多框架里的 bug，最好的办法是反馈这些 bug 的详细信息到  <a href="http://bugreport.apple.com">Apple</a>，其中需要包含以下信息：</p>

<ol>
<li>完整的重现步骤  </li>
<li>安装了 iCloud 调试配置并将 iCloud 调试日志输出级别调为 3 的终端输出  </li>
<li>打包为 zip 的完整的开放性存储内容</li>
</ol>

<h2>结论</h2>

<p>在 iOS 5 和 6 中 iCloud Core Data 根本就没法用这件事已经是不是一个秘密， Apple 的程序员自己都承认“在 iOS 5 和 6 中使用 Core Data + iCloud 时，存在重大的稳定性和长期可靠性的问题，要使用它的话请一定一定一定把应用设为 iOS 7 only“。一些高端的开发者，比如 <a href="http://agiletortoise.com">Agile Tortoise</a> 以及 <a href="http://realmacsoftware.com">Realmac Software</a>，现在已经信任 iCloud Core Data，并把它集成到了他们的应用中。因为有着充分的<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/iCloudDesignGuide/Chapters/Introduction.html">考量</a>和测试，你也应该这么做了。</p>

<p><em>特别感谢 Andrew Harrison, Greg Pierce, and Paul Bruneau 对这篇文章的帮助</em></p>

<p>[^1]: 在之前的 OS 版本中，这个方法直到 iCloud 数据下载并合并到持久化存储中前是不会返回的。这将造成大幅延迟，并意味着任何对这个方法的调用需要被派发到一个后台的队列中去。值得庆幸的是现在已经不再需要这么做了。</p>

<hr /><p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
</div>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-02T10:34:35+08:00" data-updated="true" itemprop="datePublished">Apr 2<span>nd</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/shao-nian/'>少年</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/02/%5B%3F%5D-ge-shao-nian/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/02/%5B%3F%5D-ge-shao-nian/" itemprop="url">一个少年</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><img src="http://ww3.sinaimg.cn/large/626e5d69gw1ef12djbjbkj20s00j342z.jpg" alt="" /></p>
<p>我要是没有生在这个世界就好了 受伤的心灵如此诉说</p>
<p>要是这么想的话就中了那个混蛋的当了 不要认输呀少年</p>
<p>「让内心休息一下」这种事 看来是不会被允许的呢</p>
<p>略微玩耍一下 把该做的事都置于身后吧 选择自己喜欢的事情吧</p>
<p>在这双手伸出之前 还有着无尽的喜悦</p>
<p>那无穷无尽而来的悲伤 如果无法背负的话就不背好了</p>
<p>为何要去勉强自己去感受痛苦呢? 本来谁都可以自由自在</p>
<p>像那振翅翱翔的鸟儿一般 像那海面中跳跃的飞鱼一般</p>
<p>在这欢乐的地方 比谁都能 自由微笑的少年吧</p>
<p>如果穿上流行的服饰的话 明天也会变得落伍吧</p>
<p>要不要去赶潮流 选择自己喜欢的方法就好了</p>
<p>在这双脚踏出路程之前 还有着无限的幸福存在</p>
<p>如果有着无尽的烦恼的话 那就让他烦恼下去好了</p>
<p>欲速则不达 不要不懂装懂 每个人都有缺陷</p>
<p>自己诞生而来的意义 即使最后再想也是绝妙的</p>
<p>微风轻轻拂过 将身心委任给涓涓小溪 成为一个学习的少年吧</p>
<p>成为在这个世界上 比谁都能 自由恋爱的少年吧</p>
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-03-31T11:13:25+08:00" data-updated="true" itemprop="datePublished">Mar 31<span>st</span>, 2014</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/Blog/blog/2014/03/31/%E7%B2%BE%E7%AE%80%E5%BC%80%E5%8F%91iOS/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/03/31/%E7%B2%BE%E7%AE%80%E5%BC%80%E5%8F%91iOS/" itemprop="url">精简开发iOS</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>View controllers 通常是 iOS 项目中最大的文件，并且它们包含了许多不必要的代码。所以 View controllers 中的代码几乎总是复用率最低的。我们将会看到给 view controllers 瘦身的技术，让代码变得可以复用，以及把代码移动到更合适的地方。</p>
<h2>把 Data Source 和其他 Protocols 分离出来</h2>
<p>把 <code>UITableViewDataSource</code> 的代码提取出来放到一个单独的类中，是为 view controller 瘦身的强大技术之一。当你多做几次，你就能总结出一些模式，并且创建出可复用的类。</p>
<p>举个例，在示例项目中，有个 <code>PhotosViewController</code> 类，它有以下几个方法：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp"># pragma mark Pragma</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">Photo</span><span class="o">*</span><span class="p">)</span><span class="nf">photoAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span><span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">photos</span><span class="p">[(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="n">UITableView</span><span class="o">*</span><span class="p">)</span><span class="nv">tableView</span>
</span><span class="line"> <span class="nf">numberOfRowsInSection:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">section</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">photos</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">UITableViewCell</span><span class="o">*</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="n">UITableView</span><span class="o">*</span><span class="p">)</span><span class="nv">tableView</span>
</span><span class="line">        <span class="nf">cellForRowAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span><span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span> <span class="p">{</span>
</span><span class="line">    <span class="n">PhotoCell</span><span class="o">*</span> <span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">tableView</span> <span class="nl">dequeueReusableCellWithIdentifier:</span><span class="n">PhotoCellIdentifier</span>
</span><span class="line">                                                      <span class="nl">forIndexPath:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class="line">    <span class="n">Photo</span><span class="o">*</span> <span class="n">photo</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">photoAtIndexPath:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class="line">    <span class="n">cell</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">photo</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">cell</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这些代码基本都是围绕数组做一些事情，更针对地说，是围绕 view controller 所管理的 photos 数组做一些事情。我们可以尝试把数组相关的代码移到<code>单独的类</code>中。我们使用一个 block 来设置 cell，也可以用 delegate 来做这件事，这取决于你的习惯。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">ArrayDataSource</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">itemAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span><span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">items</span><span class="p">[(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="n">UITableView</span><span class="o">*</span><span class="p">)</span><span class="nv">tableView</span>
</span><span class="line"> <span class="nf">numberOfRowsInSection:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">section</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">UITableViewCell</span><span class="o">*</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="n">UITableView</span><span class="o">*</span><span class="p">)</span><span class="nv">tableView</span>
</span><span class="line">        <span class="nf">cellForRowAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span><span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">id</span> <span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">tableView</span> <span class="nl">dequeueReusableCellWithIdentifier:</span><span class="n">cellIdentifier</span>
</span><span class="line">                                              <span class="nl">forIndexPath:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class="line">    <span class="kt">id</span> <span class="n">item</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">itemAtIndexPath:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class="line">    <span class="n">configureCellBlock</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span><span class="n">item</span><span class="p">);</span>
</span><span class="line">    <span class="k">return</span> <span class="n">cell</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在，你可以把 view controller 中的这 3 个方法去掉了，取而代之，你可以创建一个 <code>ArrayDataSource</code> 类的实例作为 table view 的 data source。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">configureCell</span><span class="p">)(</span><span class="n">PhotoCell</span><span class="o">*</span><span class="p">,</span> <span class="n">Photo</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">PhotoCell</span><span class="o">*</span> <span class="n">cell</span><span class="p">,</span> <span class="n">Photo</span><span class="o">*</span> <span class="n">photo</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">   <span class="n">cell</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">photo</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="n">photosArrayDataSource</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ArrayDataSource</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItems:</span><span class="n">photos</span>
</span><span class="line">                                                <span class="nl">cellIdentifier:</span><span class="n">PhotoCellIdentifier</span>
</span><span class="line">                                            <span class="nl">configureCellBlock:</span><span class="n">configureCell</span><span class="p">];</span>
</span><span class="line"><span class="n">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="n">photosArrayDataSource</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在你不用担心把一个 index path 映射到数组中的位置了，每次你想把这个数组显示到一个 table view 中时，你都可以复用这些代码。你也可以实现一些额外的方法，比如 <code>tableView:commitEditingStyle:forRowAtIndexPath:</code>，在 table view controllers 之间共享。</p>
<p>这样的好处在于，你可以<code>单独测试这个类</code>，再也不用写第二遍。该原则同样适用于数组之外的其他对象。</p>
<p>在今年我们做的一个应用里面，我们大量使用了<code> Core Data</code>。我们创建了相似的类，但和之前使用的数组不一样，它用一个 fetched results controller 来获取数据。它实现了所有动画更新、处理 section headers、删除操作等逻辑。你可以创建这个类的实例，然后赋予一个 fetch request 和用来设置 cell 的 block，剩下的它都会处理，不用你操心了。</p>
<p>此外，这种方法也可以扩展到其他 protocols 上面。最明显的一个就是<code> UICollectionViewDataSource</code>。这给了你极大的灵活性；如果，在开发的某个时候，你想用 <code>UICollectionView </code>代替 <code>UITableView</code>，你几乎不需要对 view controller 作任何修改。你甚至可以让你的 data source 同时支持这两个协议。</p>
<h2>将业务逻辑移到 Model 中</h2>
<p>下面是 view controller（来自其他项目）中的示例代码，用来查找一个用户的目前的优先事项的列表：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">loadPriorities</span> <span class="p">{</span>
</span><span class="line">    <span class="n">NSDate</span><span class="o">*</span> <span class="n">now</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDate</span> <span class="n">date</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSString</span><span class="o">*</span> <span class="n">formatString</span> <span class="o">=</span> <span class="s">@&quot;startDate = %@&quot;</span><span class="p">;</span>
</span><span class="line">    <span class="n">NSPredicate</span><span class="o">*</span> <span class="n">predicate</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSPredicate</span> <span class="nl">predicateWithFormat:</span><span class="n">formatString</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">now</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSSet</span><span class="o">*</span> <span class="n">priorities</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">user</span><span class="p">.</span><span class="n">priorities</span> <span class="nl">filteredSetUsingPredicate:</span><span class="n">predicate</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">priorities</span> <span class="o">=</span> <span class="p">[</span><span class="n">priorities</span> <span class="n">allObjects</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>把这些代码移动到<code> User </code>类的 category 中会变得更加清晰，处理之后，在<code> View Controller.m</code> 中看起来就是这样：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">loadPriorities</span> <span class="p">{</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">priorities</span> <span class="o">=</span> <span class="p">[</span><span class="n">user</span> <span class="n">currentPriorities</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>在<code> User+Extensions.m </code>中：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span><span class="o">*</span><span class="p">)</span><span class="nf">currentPriorities</span> <span class="p">{</span>
</span><span class="line">    <span class="n">NSDate</span><span class="o">*</span> <span class="n">now</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDate</span> <span class="n">date</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSString</span><span class="o">*</span> <span class="n">formatString</span> <span class="o">=</span> <span class="s">@&quot;startDate = %@&quot;</span><span class="p">;</span>
</span><span class="line">    <span class="n">NSPredicate</span><span class="o">*</span> <span class="n">predicate</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSPredicate</span> <span class="nl">predicateWithFormat:</span><span class="n">formatString</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">now</span><span class="p">];</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[[</span><span class="n">self</span><span class="p">.</span><span class="n">priorities</span> <span class="nl">filteredSetUsingPredicate:</span><span class="n">predicate</span><span class="p">]</span> <span class="n">allObjects</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>有些代码不能被轻松地移动到 model 对象中，但明显和 model 代码紧密联系，对于这种情况，我们可以使用一个 <code>Store</code>：</p>
<h2>创建 Store 类</h2>
<p>在我们第一版的示例程序的中，有些代码去加载文件并解析它。下面就是 view controller 中的代码</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">readArchive</span> <span class="p">{</span>
</span><span class="line">    <span class="n">NSBundle</span><span class="o">*</span> <span class="n">bundle</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSBundle</span> <span class="nl">bundleForClass:</span><span class="p">[</span><span class="n">self</span> <span class="n">class</span><span class="p">]];</span>
</span><span class="line">    <span class="n">NSURL</span> <span class="o">*</span><span class="n">archiveURL</span> <span class="o">=</span> <span class="p">[</span><span class="n">bundle</span> <span class="nl">URLForResource:</span><span class="s">@&quot;photodata&quot;</span>
</span><span class="line">                                 <span class="nl">withExtension:</span><span class="s">@&quot;bin&quot;</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSAssert</span><span class="p">(</span><span class="n">archiveURL</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">,</span> <span class="s">@&quot;Unable to find archive in bundle.&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="n">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSData</span> <span class="nl">dataWithContentsOfURL:</span><span class="n">archiveURL</span>
</span><span class="line">                                         <span class="nl">options:</span><span class="mi">0</span>
</span><span class="line">                                           <span class="nl">error:</span><span class="nb">NULL</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSKeyedUnarchiver</span> <span class="o">*</span><span class="n">unarchiver</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSKeyedUnarchiver</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initForReadingWithData:</span><span class="n">data</span><span class="p">];</span>
</span><span class="line">    <span class="n">_users</span> <span class="o">=</span> <span class="p">[</span><span class="n">unarchiver</span> <span class="nl">decodeObjectOfClass:</span><span class="p">[</span><span class="n">NSArray</span> <span class="n">class</span><span class="p">]</span> <span class="nl">forKey:</span><span class="s">@&quot;users&quot;</span><span class="p">];</span>
</span><span class="line">    <span class="n">_photos</span> <span class="o">=</span> <span class="p">[</span><span class="n">unarchiver</span> <span class="nl">decodeObjectOfClass:</span><span class="p">[</span><span class="n">NSArray</span> <span class="n">class</span><span class="p">]</span> <span class="nl">forKey:</span><span class="s">@&quot;photos&quot;</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">unarchiver</span> <span class="n">finishDecoding</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>但是 view controller 没必要知道这些，所以我们创建了一个 Store 对象来做这些事。通过分离，我们就可以复用这些代码，单独测试他们，并且让 view controller 保持小巧。Store 对象会关心数据加载、缓存和设置数据栈。它也经常被称为服务层或者仓库。</p>
<h2>把网络请求逻辑移到 Model 层</h2>
<p>和上面的主题相似：不要在 view controller 中做网络请求的逻辑。取而代之，你应该将它们封装到另一个类中。这样，你的 view controller 就可以在之后通过使用带有回调（比如一个 completion 的 block）来请求网络了。这样的好处是，缓存和错误控制也可以在这个类里面完成。</p>
<h2>把 View 代码移到 View 层</h2>
<p>不应该在 view controller 中构建复杂的 view 层次结构。你可以使用 Interface Builder 或者把 views 封装到一个<code> UIView </code>子类当中。例如，如果你要创建一个选择日期的控件，把它放到一个名为 <code>DatePickerView</code> 的类中会比把所有的事情都在 view controller 中做好好得多。再一次，这样增加了可复用性并保持了简单。</p>
<p>如果你喜欢 Interface Builder，你也可以在 Interface Builder 中做。有些人认为 IB 只能和 view controllers 一起使用，但事实上你也可以加载单独的 nib 文件到自定义的 view 中。在示例程序中，我们创建了一个<code> PhotoCell.xib</code>，包含了 photo cell 的布局：</p>
<p><img src="http://ww1.sinaimg.cn/large/626e5d69tw1eeys0sfm2tj20wg0naq7c.jpg" alt="" /></p>
<p>就像你看到的那样，我们在 view（我们没有在这个 nib 上使用 File&#8217;s Owner 对象）上面创建了 properties，然后连接到指定的 subviews。这种技术同样适用于其他自定义的 views。</p>
<h2>通讯</h2>
<p>其他在 view controllers 中经常发生的事是与其他 view controllers，model，和 views 之间进行通讯。这当然是 controller 应该做的，但我们还是希望以尽可能少的代码来完成它。</p>

<p>关于 view controllers 和 model 对象之间的消息传递，已经有很多阐述得很好的技术（比如 KVO 和 fetched results controllers）。但是 view controllers 之间的消息传递稍微就不是那么清晰了。</p>

<p>当一个 view controller 想把某个状态传递给多个其他 view controllers 时，就会出现这样的问题。较好的做法是把状态放到一个单独的对象里，然后把这个对象传递给其它 view controllers，它们观察和修改这个状态。这样的好处是消息传递都在一个地方（被观察的对象）进行，而且我们也不用纠结嵌套的 delegate 回调。这其实是一个复杂的主题，我们可能在未来用一个完整的话题来讨论这个主题。</p>
<h2>总结</h2>
<p>我们已经看到一些用来创建更小巧的 view controllers 的技术。我们并不是想把这些技术应用到每一个可能的角落，只是我们有一个目标：写可维护的代码。知道这些模式后，我们就更有可能把那些笨重的 view controllers 变得更整洁。</p>
<h3>扩展阅读</h3>

<ul>
<li><a href="http://developer.apple.com/library/ios/#featuredarticles/ViewControllerPGforiPhoneOS/BasicViewControllers/BasicViewControllers.html">View Controller Programming Guide for iOS</a></li>
<li><a href="http://developer.apple.com/library/mac/#documentation/General/Conceptual/DevPedia-CocoaCore/ControllerObject.html">Cocoa Core Competencies: Controller Object</a></li>
<li><a href="http://subjective-objective-c.blogspot.de/2011/08/writing-high-quality-view-controller.html">Writing high quality view controllers</a></li>
<li><a href="http://programmers.stackexchange.com/questions/184396/mvcs-model-view-controller-store">Stack Overflow: Model View Controller Store</a></li>
<li><a href="https://speakerdeck.com/trianglecocoa/unburdened-viewcontrollers-by-jay-thrash">Unburdened View Controllers</a></li>
<li><a href="http://programmers.stackexchange.com/questions/177668/how-to-avoid-big-and-clumsy-uitableviewcontroller-on-ios">Stack Overflow: How to avoid big and clumsy <code>UITableViewControllers</code> on iOS</a></li>
</ul>
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-03-24T15:54:02+08:00" data-updated="true" itemprop="datePublished">Mar 24<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/Blog/blog/2014/03/24/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82GCD%E5%90%97%3F/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/03/24/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82GCD%E5%90%97%3F/" itemprop="url">你真的懂GCD吗?</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>GCD是什么，你知道吗？你知道了GCD，你确定你会使用吗？</p>
<p> 这一篇文章是站在初学者角度去分析GCD，原因是这个很多iOS开发者根本就没用过，即使用过，不知道其中的原理。讲解之前认识一下什么是线程，为什么要介绍线程。是因为GCD是Grand Central Dispatch的缩写，是一系列的BSD层面的接口，在Mac 10.6 和iOS4.0以后才引入的，且现在NSOperation和NSOperationQueue的多线程的实现就是基于GCD的。目前这个特性也被移植到 FreeBSD上了，可以查看libdispatch这个开源项目。</p>
<blockquote>
	iPhone中的线程应用并不是无节制的，官方给出的资料显示iPhone  OS下的主线程的堆栈大小是1M，第二个线程开始都是512KB。并且该值不能通过编译器开关或线程API函数来更改。只有主线程有直接修改UI的能力。
</blockquote>
<h2>
	一、线程的概述
</h2>
<p><br /></p>
<p>有些程序是一条直线，起点到终点；有些程序是一个圆，不断循环，直到将它切断。直线的如简单的Hello World，运行打印完,它的生命周期便结束了，像昙花一现那样；圆如操作系统，一直运行直到你关机。 </p>
<p>一个运行着的程序就是一个进程或者叫做一个任务，一个进程至少包含一个线程，线程就是程序的执行流。Mac和iOS中的程序启动，创建好一个进程的同时， 一个线程便开始运行，这个线程叫主线程。主线程在程序中的地位和其他线程不同，它是其他线程最终的父线程，且所有界面的显示操作即AppKit或 UIKit的操作必须在主线程进行。 </p>
<p>系统中的每一个进程都有自己独立的虚拟内存空间，而同一个进程中的多个线程则共用进程的内存空间。每创建一个新的线程，都需要一些内存(如每个线程有自己的Stack空间)和消耗一定的CPU时间。另外当多个线程对同一个资源出现争夺的时候需要注意线程安全问题。</p>
<h2>二、创建线程</h2>
<p>创建一个新的线程就是给进程增加了一个执行流，执行流总得有要执行的代码吧，所以新建一个线程需要提供一个函数或者方法作为线程的入口。</p>
<h3>1.使用NSThread</h3>
<p>NSThread提供了创建线程的途径，还可以提供了检测当前线程是否是主线程的方法。 使用NSThread创建一个新的线程有两种方式：</p>
<ul>
<li>1.创建一个NSThread的对象，调用其start方法。对于这种方式的NSThread对象的创建，可以使用一个目标对象的方法初始化一个NSThread对象，或者创建一个继承NSThread类的子类，实现其main方法，然后在直接创建这个子类的对象。</li>
<li>2.使用 detachNewThreadSelector:toTarget:withObject:这个类方法创建一个线程，这个比较直接了，直接使用目标对象的方法作为线程启动入口。</li>
</ul>
<h3>2.使用NSObject</h3>
<p>其实NSObject直接就加入了多线程的支持，允许对象的某个方法在后台运行。如:</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">myObj</span> <span class="nl">performSelectorInBackground:</span><span class="k">@selector</span><span class="p">(</span><span class="n">doSomething</span><span class="p">)</span> <span class="nl">withObject:</span><span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<h3>3.POSIX Thread</h3>
<p>由于Mac和iOS都是基于Darwin系统，Darwin系统的XUN内核，是基于Mach和BSD的，继承了BSD的POSIX接口，所以可以直接使用POSIX线程的相关接口来使用线程。</p>
<p>创建线程的接口为 <code>pthread_create</code>，当然在创建之前可以通过相关函数设置好线程的属性。以下为POSIX线程使用简单的例子。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="c1">//</span>
</span><span class="line"><span class="c1">//  main.c</span>
</span><span class="line"><span class="c1">//  pthread</span>
</span><span class="line"><span class="c1">//</span>
</span><span class="line"><span class="c1">//  Created by Rick on 3/23/14.</span>
</span><span class="line"><span class="c1">//  Copyright (c) 2014 ISoftstone. All rights reserved.</span>
</span><span class="line"><span class="c1">//</span>
</span><span class="line">
</span><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="o">*</span><span class="nf">pthreadRoutine</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">pthread_attr_t</span>  <span class="n">attr</span><span class="p">;</span>
</span><span class="line">    <span class="n">pthread_t</span>       <span class="n">pthreadID</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span>             <span class="n">returnVal</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">returnVal</span> <span class="o">=</span> <span class="n">pthread_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
</span><span class="line">    <span class="n">returnVal</span> <span class="o">=</span> <span class="n">pthread_attr_setdetachstate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD_CREATE_DETACHED</span><span class="p">);</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">threadError</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pthreadID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pthreadRoutine</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">returnVal</span> <span class="o">=</span> <span class="n">pthread_attr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">threadError</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="c1">// Report an error.</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="o">*</span><span class="nf">pthreadRoutine</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;count = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">count</span><span class="o">++</span><span class="p">);</span>
</span><span class="line">        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><br /></p>
<h2>三、多线程进阶</h2>
<p><code>NSOperation</code>&amp;<code>NSOperationQueue</code></p>
<p>很多时候我们使用多线程，需要控制线程的并发数，毕竟线程也是消耗系统资源的，当程序中同时运行的线程过多时，系统必然变慢。
所以很多时候我们会控制同时运行线程的数目。</p>
<p>NSOperation可以封装我们的操作，然后将创建好的NSOperation对象放到NSOperationQueue中，OperationQueue便开始启动新的线程去执行队列中的操作，OperationQueue的并发度是可以通过如下方式进行设置:</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setMaxConcurrentOperationCount:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">count</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<h3>GCD</h3>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">dispatch_queue_t</span> <span class="n">imageDownloadQueue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="n">dispatch_async</span><span class="p">(</span><span class="n">imageDownloadQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">        <span class="n">NSURL</span> <span class="o">*</span><span class="n">imageURL</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nl">URLWithString:</span><span class="s">@&quot;http://test.com/test.png&quot;</span><span class="p">];</span>
</span><span class="line">       <span class="n">NSData</span> <span class="o">*</span><span class="n">imageData</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSData</span> <span class="nl">dataWithContentsOfURL:</span><span class="n">imageURL</span><span class="p">];</span>
</span><span class="line">        <span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageWithData:</span><span class="n">imageData</span><span class="p">];</span>
</span><span class="line">       <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">            <span class="p">[</span><span class="n">imageView</span> <span class="nl">setImage:</span><span class="n">image</span><span class="p">];</span><span class="c1">//UIKit必须在主线程执行</span>
</span><span class="line">        <span class="p">});</span>
</span><span class="line">    <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>当然，GCD除了处理多线程外还有很多非常好的功能，其建立在强大的kqueue之上，效率也能够得到保障。</p>
<p><br /></p>
<h2>四.线程间通信</h2>
<p>线程间通信和进程间通信从本质上讲是相似的。线程间通信就是在进程内的两个执行流之间进行数据的传递，就像两条并行的河流之间挖出了一道单向流动长沟，使得一条河流中的水可以流入另一条河流，物质得到了传递。</p>
<h3>1.performSelect On The Thread</h3>
<p>框架为我们提供了强制在某个线程中执行方法的途径,如果两个非主线程的线程需要相互间通信，可以先将自己的当前线程对象注册到某个全局的对象中去，这样相互之间就可以获取对方的线程对象，然后就可以使用下面的方法进行线程间的通信了，由于主线程比较特殊，所以框架直接提供了在出线程执行的方法。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">NSObject</span> <span class="nl">(NSThreadPerformAdditions)</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelectorOnMainThread:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">arg</span> <span class="nf">waitUntilDone:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">wait</span> <span class="nf">modes:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">array</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelectorOnMainThread:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">arg</span> <span class="nf">waitUntilDone:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">wait</span><span class="p">;</span>
</span><span class="line"><span class="c1">// equivalent to the first method with kCFRunLoopCommonModes</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">onThread:</span><span class="p">(</span><span class="n">NSThread</span> <span class="o">*</span><span class="p">)</span><span class="nv">thr</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">arg</span> <span class="nf">waitUntilDone:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">wait</span> <span class="nf">modes:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">array</span> <span class="n">NS_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_5</span><span class="p">,</span> <span class="mi">2</span><span class="n">_0</span><span class="p">);</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">onThread:</span><span class="p">(</span><span class="n">NSThread</span> <span class="o">*</span><span class="p">)</span><span class="nv">thr</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">arg</span> <span class="nf">waitUntilDone:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">wait</span> <span class="n">NS_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_5</span><span class="p">,</span> <span class="mi">2</span><span class="n">_0</span><span class="p">);</span>
</span><span class="line"><span class="c1">// equivalent to the first method with kCFRunLoopCommonModes</span>
</span><span class="line">    <span class="p">...</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<h3>2.Mach Port</h3>
<p>在苹果的Thread Programming Guide的Run Pool一节的Configuring a Port-Based Input Source
这一段中就有使用Mach Port进行线程间通信的例子。
其实质就是父线程创建一个NSMachPort对象，在创建子线程的时候以参数的方式将其传递给子线程，这样子线程中就可以向这个传过来的NSMachPort对象发送消息，如果想让父线程也可以向子线程发消息的话，那么子线程可以先向父线程发个特殊的消息，传过来的是自己创建的另一个NSMachPort对象，这样父线程便持有了子线程创建的port对象了，可以向这个子线程的port对象发送消息了。</p>
<p>当然各自的port对象需要设置delegate以及schdule到自己所在线程的RunLoop中，这样来了消息之后，处理port消息的delegate方法会被调用，你就可以自己处理消息了。</p>
<p><br /></p>
<h2>五.RunLoop</h2>
<p>RunLoop从字面上看是运行循环的意思，这一点也不错，它确实就是一个循环的概念，或者准确的说是线程中的循环。
本文一开始就提到有些程序是一个圈，这个圈本质上就是这里的所谓的RunLoop，就是一个循环，只是这个循环里加入很多特性。 <br />
首先循环体的开始需要检测是否有需要处理的事件，如果有则去处理，如果没有则进入睡眠以节省CPU时间。
所以重点便是这个需要处理的事件，在RunLoop中，需要处理的事件分两类，一种是输入源，一种是定时器，定时器好理解就是那些需要定时执行的操作，输入源分三类：performSelector源，基于端口（Mach port）的源，以及自定义的源。编程的时候可以添加自己的源。RunLoop还有一个观察者Observer的概念，可以往RunLoop中加入自己的观察者以便监控着RunLoop的运行过程，CFRunLoop.h中定义了所有观察者的类型:</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">enum</span> <span class="n">CFRunLoopActivity</span> <span class="p">{</span>
</span><span class="line">   <span class="n">kCFRunLoopEntry</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
</span><span class="line">   <span class="n">kCFRunLoopBeforeTimers</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
</span><span class="line">   <span class="n">kCFRunLoopBeforeSources</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
</span><span class="line">   <span class="n">kCFRunLoopBeforeWaiting</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>
</span><span class="line">   <span class="n">kCFRunLoopAfterWaiting</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>
</span><span class="line">   <span class="n">kCFRunLoopExit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>
</span><span class="line">   <span class="n">kCFRunLoopAllActivities</span> <span class="o">=</span> <span class="mh">0x0FFFFFFF</span><span class="n">U</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="k">typedef</span> <span class="k">enum</span> <span class="n">CFRunLoopActivity</span> <span class="n">CFRunLoopActivity</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>如果你使用过select系统调用写过程序你便可以快速的理解runloop事件源的概念，本质上讲事件源的机制和select一样是一种多路复用IO的实现，在一个线程中我们需要做的事情并不单一，如需要处理定时钟事件，需要处理用户的触控事件，需要接受网络远端发过来的数据，将这些需要做的事情统统注册到事件源中，每一次循环的开始便去检查这些事件源是否有需要处理的数据，有的话则去处理。
拿具体的应用举个例子，NSURLConnection网络数据请求，默认是异步的方式，其实现原理就是创建之后将其作为事件源加入到当前的RunLoop，而等待网络响应以及网络数据接受的过程则在一个新创建的独立的线程中完成，当这个线程处理到某个阶段的时候比如得到对方的响应或者接受完了网络数据之后便通知之前的线程去执行其相关的delegate方法。所以在Cocoa中经常看到<code>scheduleInRunLoop:forMode:</code>这样的方法，这个便是将其加入到事件源中，当检测到某个事件发生的时候，相关的delegate方法便被调用。对于CoreFoundation这一层而言，通常的模式是创建输入源，然后将输入源通过<code>CFRunLoopAddSource</code>函数加入到RunLoop中，相关事件发生后，相关的回调函数会被调用。如CFSocket的使用。
另外RunLoop中还有一个运行模式的概念，每一个运行循环必然运行在某个模式下，而模式的存在是为了过滤事件源和观察者的，只有那些和当前RunLoop运行模式一致的事件源和观察者才会被激活。</p>

<p>每一个线程都有其对应的RunLoop，但是默认非主线程的RunLoop是没有运行的，需要为RunLoop添加至少一个事件源，然后去run它。一般情况下我们是没有必要去启用线程的RunLoop的，除非你在一个单独的线程中需要长久的检测某个事件。</p>
<h2>GCD使用攻略</h2>
<p><strong>什么是GCD?</strong></p>
<p>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。该方法在Mac OS X 10.6雪豹中首次推出，并随后被引入到了iOS4.0中。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术，它看起来象就其它语言的闭包(Closure)一样，但苹果把它叫做<code>blocks</code>。</p>
<p>当我们不使用GCD时，想要多线程处理。需要放在后台，避免阻塞主线程。</p>
<p><strong>GCD的定义</strong></p>
<p>简单GCD的定义有点象函数指针，差别是用 ^ 替代了函数指针的 * 号，如下所示：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="c1">// 申明变量 </span>
</span><span class="line"> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">(</span><span class="o">^</span><span class="n">loggerBlock</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class="line"> <span class="c1">// 定义 </span>
</span><span class="line"> <span class="n">loggerBlock</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Hello world&quot;</span><span class="p">);</span>
</span><span class="line"> <span class="p">};</span>
</span><span class="line"> <span class="c1">// 调用 </span>
</span><span class="line"> <span class="n">loggerBlock</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>但是大多数时候，我们通常使用内联的方式来定义它，即将它的程序块写在调用的函数里面，例如这样：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">     <span class="c1">// something </span>
</span><span class="line"><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>从上面大家可以看出，block有如下特点：</p>
<ul>
	<li>程序块可以在代码中以内联的方式来定义。</li>
	<li>程序块可以访问在创建它的范围内的可用的变量。</li>
</ul>
<p><strong>系统提供的dispatch方法</strong></p>
<p>为了方便地使用GCD，苹果提供了一些方法方便我们将block放在主线程 或 后台线程执行，或者延后执行。使用的例子如下：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="c1">//  后台执行： </span>
</span><span class="line"> <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">      <span class="c1">// something </span>
</span><span class="line"> <span class="p">});</span>
</span><span class="line"> <span class="c1">// 主线程执行： </span>
</span><span class="line"> <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">      <span class="c1">// something </span>
</span><span class="line"> <span class="p">});</span>
</span><span class="line"> <span class="c1">// 一次性执行： </span>
</span><span class="line"> <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class="line"> <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">     <span class="c1">// code to be executed once </span>
</span><span class="line"> <span class="p">});</span>
</span><span class="line"> <span class="c1">// 延迟2秒执行： </span>
</span><span class="line"> <span class="kt">double</span> <span class="n">delayInSeconds</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
</span><span class="line"> <span class="n">dispatch_time_t</span> <span class="n">popTime</span> <span class="o">=</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="n">delayInSeconds</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">);</span>
</span><span class="line"> <span class="n">dispatch_after</span><span class="p">(</span><span class="n">popTime</span><span class="p">,</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span><span class="line">     <span class="c1">// code to be executed on the main queue after delay </span>
</span><span class="line"> <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>dispatch_queue_t 也可以自己定义，如要要自定义queue，可以用dispatch_queue_create方法，示例如下：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">dispatch_queue_t</span> <span class="n">urls_queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;blog.devtang.com&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line"><span class="n">dispatch_async</span><span class="p">(</span><span class="n">urls_queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">     <span class="c1">// your code </span>
</span><span class="line"><span class="p">});</span>
</span><span class="line"><span class="n">dispatch_release</span><span class="p">(</span><span class="n">urls_queue</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>另外，GCD还有一些高级用法，例如让后台2个线程并行执行，然后等2个线程都结束后，再汇总执行结果。这个可以用dispatch_group, dispatch_group_async 和 dispatch_group_notify来实现，示例如下：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class="line"><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">      <span class="c1">// 并行执行的线程一 </span>
</span><span class="line"> <span class="p">});</span>
</span><span class="line"> <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">      <span class="c1">// 并行执行的线程二 </span>
</span><span class="line"> <span class="p">});</span>
</span><span class="line"> <span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">      <span class="c1">// 汇总结果 </span>
</span><span class="line"> <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><strong>修改block之外的变量</strong></p>
<p>默认情况下，在程序块中访问的外部变量是复制过去的，即写操作不对原变量生效。但是你可以加上 __block来让其写操作生效，示例代码如下：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">__block</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="kt">void</span>  <span class="p">(</span><span class="o">^</span><span class="n">foo</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">     <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="n">foo</span><span class="p">();</span>
</span><span class="line"><span class="c1">// 这里，a的值被修改为1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><strong>后台运行</strong></p>
<p>GCD的另一个用处是可以让程序在后台较长久的运行。在没有使用GCD时，当app被按home键退出后，app仅有最多5秒钟的时候做一些保存或清理资源的工作。但是在使用GCD后，app最多有10分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存，发送统计数据等工作。</p>
<p>让程序在后台长久运行的示例代码如下：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="c1">// AppDelegate.h文件 </span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">assign</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">UIBackgroundTaskIdentifier</span> <span class="n">backgroundUpdateTask</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">// AppDelegate.m文件 </span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">applicationDidEnterBackground:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="n">beingBackgroundUpdateTask</span><span class="p">];</span>
</span><span class="line">    <span class="c1">// 在这里加上你需要长久运行的代码 </span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="n">endBackgroundUpdateTask</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">beingBackgroundUpdateTask</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">backgroundUpdateTask</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">beginBackgroundTaskWithExpirationHandler:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">self</span> <span class="n">endBackgroundUpdateTask</span><span class="p">];</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">endBackgroundUpdateTask</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">endBackgroundTask:</span> <span class="n">self</span><span class="p">.</span><span class="n">backgroundUpdateTask</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">backgroundUpdateTask</span> <span class="o">=</span> <span class="n">UIBackgroundTaskInvalid</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<h2>总结</h2>
<p>总体来说，GCD能够极大地方便开发者进行多线程编程。如果你的app不需要支持iOS4.0以下的系统，那么就应该尽量使用GCD来处理后台线程和UI线程的交互。</p>
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-03-21T18:05:55+08:00" data-updated="true" itemprop="datePublished">Mar 21<span>st</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/03/21/iOS%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/03/21/iOS%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" itemprop="url">iOS设备信息收集</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>收集iOS设备的信息，包含设备系统版本，设备型号，手机型号，屏幕分辨率，当地所在时区，CPU 型号，系统语言，网络环境，应用名称以及应用版本，还有判断设备是否，应用是否被破解</p>
<p>需要的头文件</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &quot;ISSMobileClick.h&quot;</span>
</span><span class="line"><span class="cp">#import &quot;AppInfoModel.h&quot;</span>
</span><span class="line"><span class="cp">#import &lt;CoreLocation/CoreLocation.h&gt;</span>
</span><span class="line"><span class="cp">#import &lt;CoreTelephony/CTCarrier.h&gt;</span>
</span><span class="line"><span class="cp">#import &lt;CoreTelephony/CTTelephonyNetworkInfo.h&gt;</span>
</span><span class="line"><span class="cp">#import &lt;objc/runtime.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;sys/types.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;sys/sysctl.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;mach/machine.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;sys/types.h&gt;</span>
</span><span class="line"><span class="cp">#import &quot;ITTNetworkTrafficManager.h&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>实现方法，我使用类方法方便调用，无需实例化，直接类调用</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
<span class="line-number">91</span>
<span class="line-number">92</span>
<span class="line-number">93</span>
<span class="line-number">94</span>
<span class="line-number">95</span>
<span class="line-number">96</span>
<span class="line-number">97</span>
<span class="line-number">98</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">collectAppInfo</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">//获取设备信息，如当前系统版本、设备型号，</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSString</span> <span class="o">*</span><span class="n">content</span><span class="o">=</span><span class="p">[[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span>
</span><span class="line">                       <span class="nl">initWithFormat:</span>
</span><span class="line">                       <span class="s">@&quot;unique id: %@ </span><span class="se">\n</span><span class="s">localized model: %@ </span><span class="se">\n</span><span class="s">system version: %@ </span><span class="se">\n</span><span class="s">system name: %@ </span><span class="se">\n</span><span class="s">model: %@&quot;</span><span class="p">,</span>
</span><span class="line">                       <span class="p">[[</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">identifierForVendor</span><span class="p">],</span>
</span><span class="line">                       <span class="p">[[</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">localizedModel</span><span class="p">],</span>
</span><span class="line">                       <span class="p">[[</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">systemVersion</span><span class="p">],</span>
</span><span class="line">                       <span class="p">[[</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">systemName</span><span class="p">],</span>
</span><span class="line">                       <span class="p">[[</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">model</span><span class="p">]];</span>
</span><span class="line">    <span class="c1">//platform手机型号</span>
</span><span class="line">    <span class="c1">//</span>
</span><span class="line">    <span class="n">size_t</span> <span class="n">size</span><span class="p">;</span>
</span><span class="line">    <span class="n">sysctlbyname</span><span class="p">(</span><span class="s">&quot;hw.machine&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">    <span class="kt">char</span> <span class="o">*</span><span class="n">machine</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class="line">    <span class="n">sysctlbyname</span><span class="p">(</span><span class="s">&quot;hw.machine&quot;</span><span class="p">,</span> <span class="n">machine</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">    <span class="n">NSString</span> <span class="o">*</span><span class="n">platform</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithCString:</span><span class="n">machine</span> <span class="nl">encoding:</span><span class="n">NSUTF8StringEncoding</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;手机型号 :%@&quot;</span><span class="p">,</span><span class="n">platform</span><span class="p">);</span>
</span><span class="line">    <span class="c1">//date</span>
</span><span class="line">    <span class="n">NSString</span> <span class="o">*</span><span class="n">date</span> <span class="o">=</span><span class="p">[[</span><span class="n">NSDate</span> <span class="n">date</span><span class="p">]</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;yyyy-MM-dd&quot;</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSString</span> <span class="o">*</span><span class="n">time</span> <span class="o">=</span><span class="p">[[</span><span class="n">NSDate</span> <span class="n">date</span><span class="p">]</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;HH:MM:SS&quot;</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@</span><span class="se">\n</span><span class="s">app version %@</span><span class="se">\n</span><span class="s">date :%@</span><span class="se">\n</span><span class="s">time:%@&quot;</span><span class="p">,</span><span class="n">content</span><span class="p">,</span><span class="n">XcodeAppVersion</span><span class="p">,</span><span class="n">date</span><span class="p">,</span><span class="n">time</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">CTTelephonyNetworkInfo</span> <span class="o">*</span><span class="n">netInfo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CTTelephonyNetworkInfo</span> <span class="n">alloc</span><span class="p">]</span><span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="n">CTCarrier</span><span class="o">*</span><span class="n">carrier</span> <span class="o">=</span> <span class="p">[</span><span class="n">netInfo</span> <span class="n">subscriberCellularProvider</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Carriername:%@</span><span class="se">\n</span><span class="s">ISO Country Code:%@&quot;</span><span class="p">,[</span><span class="n">carrier</span> <span class="n">carrierName</span><span class="p">],[</span><span class="n">carrier</span> <span class="n">isoCountryCode</span><span class="p">]);</span><span class="c1">//手机运营商以及运营国家标号</span>
</span><span class="line">
</span><span class="line">    <span class="n">UIScreen</span> <span class="o">*</span><span class="n">MainScreen</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIScreen</span> <span class="n">mainScreen</span><span class="p">];</span>
</span><span class="line">    <span class="n">CGSize</span> <span class="n">Size</span> <span class="o">=</span> <span class="p">[</span><span class="n">MainScreen</span> <span class="n">bounds</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
</span><span class="line">    <span class="n">CGFloat</span> <span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="n">MainScreen</span> <span class="n">scale</span><span class="p">];</span>
</span><span class="line">    <span class="n">CGFloat</span> <span class="n">screenWidth</span> <span class="o">=</span> <span class="n">Size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>
</span><span class="line">    <span class="n">CGFloat</span> <span class="n">screenHeight</span> <span class="o">=</span> <span class="n">Size</span><span class="p">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">scale</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;屏幕分辨率为 :%.0f %.0f&quot;</span><span class="p">,</span><span class="n">screenWidth</span><span class="p">,</span> <span class="n">screenHeight</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;当地所在时区 :%@&quot;</span><span class="p">,[[</span><span class="n">NSTimeZone</span> <span class="n">localTimeZone</span><span class="p">]</span> <span class="n">description</span><span class="p">]);</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSMutableString</span> <span class="o">*</span><span class="n">cpu</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableString</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">cpu_type_t</span> <span class="n">type</span><span class="p">;</span>
</span><span class="line">    <span class="n">cpu_subtype_t</span> <span class="n">subtype</span><span class="p">;</span>
</span><span class="line">    <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
</span><span class="line">    <span class="n">sysctlbyname</span><span class="p">(</span><span class="s">&quot;hw.cputype&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">subtype</span><span class="p">);</span>
</span><span class="line">    <span class="n">sysctlbyname</span><span class="p">(</span><span class="s">&quot;hw.cpusubtype&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subtype</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// values for cputype and cpusubtype defined in mach/machine.h</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CPU_TYPE_X86</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">cpu</span> <span class="nl">appendString:</span><span class="s">@&quot;x86 &quot;</span><span class="p">];</span>
</span><span class="line">        <span class="c1">// check for subtype ...</span>
</span><span class="line">
</span><span class="line">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">CPU_TYPE_ARM</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">cpu</span> <span class="nl">appendString:</span><span class="s">@&quot;ARM&quot;</span><span class="p">];</span>
</span><span class="line">        <span class="k">switch</span><span class="p">(</span><span class="n">subtype</span><span class="p">)</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="k">case</span> <span class="nl">CPU_SUBTYPE_ARM_V7:</span>
</span><span class="line">                <span class="p">[</span><span class="n">cpu</span> <span class="nl">appendString:</span><span class="s">@&quot;V7&quot;</span><span class="p">];</span>
</span><span class="line">                <span class="k">break</span><span class="p">;</span>
</span><span class="line">            <span class="k">case</span> <span class="nl">CPU_SUBTYPE_ARM_V7S:</span>
</span><span class="line">                <span class="p">[</span><span class="n">cpu</span> <span class="nl">appendString:</span><span class="s">@&quot;V7s&quot;</span><span class="p">];</span>
</span><span class="line">                <span class="k">break</span><span class="p">;</span>
</span><span class="line">                <span class="c1">// ...</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;cpu 型号 :%@&quot;</span><span class="p">,</span><span class="n">cpu</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSArray</span> <span class="o">*</span><span class="n">arLanguages</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">]</span> <span class="nl">objectForKey:</span><span class="s">@&quot;AppleLanguages&quot;</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSString</span> <span class="o">*</span><span class="n">strLang</span> <span class="o">=</span> <span class="p">[</span><span class="n">arLanguages</span> <span class="nl">objectAtIndex:</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;LANG:%@&quot;</span><span class="p">,</span><span class="n">strLang</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;网络环境:%@&quot;</span><span class="p">,[</span><span class="n">ITTNetworkTrafficManager</span> <span class="n">sharedManager</span><span class="p">].</span><span class="n">networkType</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">    <span class="n">AppInfoModel</span> <span class="o">*</span><span class="n">appInfo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AppInfoModel</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="n">appInfo</span><span class="p">.</span><span class="n">uniqIdentifier</span> <span class="o">=</span> <span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)[[</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">identifierForVendor</span><span class="p">];</span>
</span><span class="line">    <span class="n">appInfo</span><span class="p">.</span><span class="n">deviceModel</span> <span class="o">=</span> <span class="n">platform</span><span class="p">;</span>
</span><span class="line">    <span class="n">appInfo</span><span class="p">.</span><span class="n">systemVersion</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">systemVersion</span><span class="p">];</span>
</span><span class="line">    <span class="n">appInfo</span><span class="p">.</span><span class="n">systemName</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">systemName</span><span class="p">];</span>
</span><span class="line">    <span class="n">appInfo</span><span class="p">.</span><span class="n">systemModel</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">model</span><span class="p">];</span>
</span><span class="line">    <span class="n">appInfo</span><span class="p">.</span><span class="n">currentDate</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDate</span> <span class="n">date</span><span class="p">];</span>
</span><span class="line">    <span class="n">appInfo</span><span class="p">.</span><span class="n">carrierName</span> <span class="o">=</span> <span class="p">[</span><span class="n">carrier</span> <span class="n">carrierName</span><span class="p">];</span>
</span><span class="line">    <span class="n">appInfo</span><span class="p">.</span><span class="n">carrierCountryCode</span> <span class="o">=</span> <span class="p">[</span><span class="n">carrier</span> <span class="n">isoCountryCode</span><span class="p">];</span>
</span><span class="line">    <span class="n">appInfo</span><span class="p">.</span><span class="n">screen</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%.0fx%.0f&quot;</span><span class="p">,</span><span class="n">screenWidth</span><span class="p">,</span> <span class="n">screenHeight</span><span class="p">];</span>
</span><span class="line">    <span class="n">appInfo</span><span class="p">.</span><span class="n">timeZone</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSTimeZone</span> <span class="n">localTimeZone</span><span class="p">]</span> <span class="n">abbreviation</span><span class="p">];</span>
</span><span class="line">    <span class="n">appInfo</span><span class="p">.</span><span class="n">sdkType</span> <span class="o">=</span> <span class="s">@&quot;iOS&quot;</span><span class="p">;</span>
</span><span class="line">    <span class="n">appInfo</span><span class="p">.</span><span class="n">packageName</span> <span class="o">=</span> <span class="n">PACKAGE_NAME</span><span class="p">;</span>
</span><span class="line">    <span class="n">appInfo</span><span class="p">.</span><span class="n">appName</span> <span class="o">=</span> <span class="n">XcodeAppName</span><span class="p">;</span>
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;应用名称 ：%@</span><span class="se">\n</span><span class="s">gmt %@&quot;</span><span class="p">,</span><span class="n">appInfo</span><span class="p">.</span><span class="n">appName</span> <span class="p">,[[</span><span class="n">NSTimeZone</span> <span class="n">localTimeZone</span><span class="p">]</span> <span class="n">abbreviation</span><span class="p">]);</span>
</span><span class="line">
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>真机运行之后，log信息如下</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="mi">2014</span><span class="o">-</span><span class="mo">03</span><span class="o">-</span><span class="mi">21</span> <span class="mi">17</span><span class="o">:</span><span class="mi">40</span><span class="o">:</span><span class="mf">13.224</span> <span class="n">AppCountDemo</span><span class="p">[</span><span class="mi">2004</span><span class="o">:</span><span class="mi">60</span><span class="n">b</span><span class="p">]</span> <span class="err">手机型号</span> <span class="o">:</span><span class="n">iPhone5</span><span class="p">,</span><span class="mi">4</span>
</span><span class="line"><span class="mi">2014</span><span class="o">-</span><span class="mo">03</span><span class="o">-</span><span class="mi">21</span> <span class="mi">17</span><span class="o">:</span><span class="mi">40</span><span class="o">:</span><span class="mf">13.230</span> <span class="n">AppCountDemo</span><span class="p">[</span><span class="mi">2004</span><span class="o">:</span><span class="mi">60</span><span class="n">b</span><span class="p">]</span> <span class="n">unique</span> <span class="n">id</span><span class="o">:</span> <span class="o">&lt;</span><span class="n">__NSConcreteUUID</span> <span class="mh">0x17d827f0</span><span class="o">&gt;</span> <span class="mf">0E21</span><span class="n">F593</span><span class="o">-</span><span class="mo">06</span><span class="n">EB</span><span class="o">-</span><span class="mi">4</span><span class="n">D3B</span><span class="o">-</span><span class="mi">8</span><span class="n">DE4</span><span class="o">-</span><span class="mi">8</span><span class="n">CAF31AB413A</span>
</span><span class="line"><span class="n">localized</span> <span class="n">model</span><span class="o">:</span> <span class="n">iPhone</span>
</span><span class="line"><span class="n">system</span> <span class="n">version</span><span class="o">:</span> <span class="mf">7.1</span>
</span><span class="line"><span class="n">system</span> <span class="n">name</span><span class="o">:</span> <span class="n">iPhone</span> <span class="n">OS</span>
</span><span class="line"><span class="nl">model:</span> <span class="n">iPhone</span>
</span><span class="line"><span class="n">app</span> <span class="n">version</span> <span class="mf">1.0</span>
</span><span class="line"><span class="n">date</span> <span class="o">:</span><span class="mi">2014</span><span class="o">-</span><span class="mo">03</span><span class="o">-</span><span class="mi">21</span>
</span><span class="line"><span class="nl">time:</span><span class="mi">17</span><span class="o">:</span><span class="mo">03</span><span class="o">:</span><span class="mi">22</span>
</span><span class="line"><span class="mi">2014</span><span class="o">-</span><span class="mo">03</span><span class="o">-</span><span class="mi">21</span> <span class="mi">17</span><span class="o">:</span><span class="mi">40</span><span class="o">:</span><span class="mf">13.240</span> <span class="n">AppCountDemo</span><span class="p">[</span><span class="mi">2004</span><span class="o">:</span><span class="mi">60</span><span class="n">b</span><span class="p">]</span> <span class="n">Carriername</span><span class="o">:</span><span class="err">中国联通</span>
</span><span class="line"><span class="n">ISO</span> <span class="n">Country</span> <span class="n">Code</span><span class="o">:</span><span class="n">cn</span>
</span><span class="line"><span class="mi">2014</span><span class="o">-</span><span class="mo">03</span><span class="o">-</span><span class="mi">21</span> <span class="mi">17</span><span class="o">:</span><span class="mi">40</span><span class="o">:</span><span class="mf">13.242</span> <span class="n">AppCountDemo</span><span class="p">[</span><span class="mi">2004</span><span class="o">:</span><span class="mi">60</span><span class="n">b</span><span class="p">]</span> <span class="err">屏幕分辨率为</span> <span class="o">:</span><span class="mi">640</span> <span class="mi">1136</span>
</span><span class="line"><span class="mi">2014</span><span class="o">-</span><span class="mo">03</span><span class="o">-</span><span class="mi">21</span> <span class="mi">17</span><span class="o">:</span><span class="mi">40</span><span class="o">:</span><span class="mf">13.244</span> <span class="n">AppCountDemo</span><span class="p">[</span><span class="mi">2004</span><span class="o">:</span><span class="mi">60</span><span class="n">b</span><span class="p">]</span> <span class="err">当地所在时区</span> <span class="o">:</span><span class="n">Local</span> <span class="n">Time</span> <span class="n">Zone</span> <span class="p">(</span><span class="n">Asia</span><span class="o">/</span><span class="n">Shanghai</span> <span class="p">(</span><span class="n">GMT</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span> <span class="n">offset</span> <span class="mi">28800</span><span class="p">)</span>
</span><span class="line"><span class="mi">2014</span><span class="o">-</span><span class="mo">03</span><span class="o">-</span><span class="mi">21</span> <span class="mi">17</span><span class="o">:</span><span class="mi">40</span><span class="o">:</span><span class="mf">13.246</span> <span class="n">AppCountDemo</span><span class="p">[</span><span class="mi">2004</span><span class="o">:</span><span class="mi">60</span><span class="n">b</span><span class="p">]</span> <span class="n">cpu</span> <span class="err">型号</span> <span class="o">:</span><span class="n">ARMV7s</span>
</span><span class="line"><span class="mi">2014</span><span class="o">-</span><span class="mo">03</span><span class="o">-</span><span class="mi">21</span> <span class="mi">17</span><span class="o">:</span><span class="mi">40</span><span class="o">:</span><span class="mf">13.247</span> <span class="n">AppCountDemo</span><span class="p">[</span><span class="mi">2004</span><span class="o">:</span><span class="mi">60</span><span class="n">b</span><span class="p">]</span> <span class="n">LANG</span><span class="o">:</span><span class="n">zh</span><span class="o">-</span><span class="n">Hans</span>
</span><span class="line"><span class="mi">2014</span><span class="o">-</span><span class="mo">03</span><span class="o">-</span><span class="mi">21</span> <span class="mi">17</span><span class="o">:</span><span class="mi">40</span><span class="o">:</span><span class="mf">13.260</span> <span class="n">AppCountDemo</span><span class="p">[</span><span class="mi">2004</span><span class="o">:</span><span class="mi">60</span><span class="n">b</span><span class="p">]</span> <span class="n">Reachability</span> <span class="n">Flag</span> <span class="n">Status</span><span class="o">:</span> <span class="o">-</span><span class="n">R</span> <span class="o">-----</span><span class="n">l</span><span class="o">-</span> <span class="n">networkStatusForFlags</span>
</span><span class="line"><span class="mi">2014</span><span class="o">-</span><span class="mo">03</span><span class="o">-</span><span class="mi">21</span> <span class="mi">17</span><span class="o">:</span><span class="mi">40</span><span class="o">:</span><span class="mf">13.261</span> <span class="n">AppCountDemo</span><span class="p">[</span><span class="mi">2004</span><span class="o">:</span><span class="mi">60</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span><span class="p">[</span><span class="n">ITTNetworkTrafficManager</span> <span class="n">updateNetwordStatus</span><span class="o">:</span><span class="p">](</span><span class="mi">120</span><span class="p">)</span><span class="o">:</span> <span class="n">network</span> <span class="n">status</span> <span class="n">wifi</span>
</span><span class="line"><span class="mi">2014</span><span class="o">-</span><span class="mo">03</span><span class="o">-</span><span class="mi">21</span> <span class="mi">17</span><span class="o">:</span><span class="mi">40</span><span class="o">:</span><span class="mf">13.304</span> <span class="n">AppCountDemo</span><span class="p">[</span><span class="mi">2004</span><span class="o">:</span><span class="mi">60</span><span class="n">b</span><span class="p">]</span> <span class="err">网络环境</span><span class="o">:</span><span class="n">wifi</span>
</span><span class="line"><span class="mi">2014</span><span class="o">-</span><span class="mo">03</span><span class="o">-</span><span class="mi">21</span> <span class="mi">17</span><span class="o">:</span><span class="mi">40</span><span class="o">:</span><span class="mf">13.306</span> <span class="n">AppCountDemo</span><span class="p">[</span><span class="mi">2004</span><span class="o">:</span><span class="mi">60</span><span class="n">b</span><span class="p">]</span> <span class="err">应用名称</span> <span class="err">：统计</span><span class="n">SDKDemo</span>
</span><span class="line"><span class="n">gmt</span> <span class="n">GMT</span><span class="o">+</span><span class="mi">8</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后聊一下，目前遇到的问题</p>
<li>生成静态库，另一个工程载入静态库时候出现一个问题，Catagory使用出现错误，调用方法会报错，运行时exception “selector not recognized”。</li>
<p>这是由于 UNIX的静态库实现、linker和Objective-C的动态结构三者之间的问题引起的。通过修改工程配置文件，只要在build静态库时，加上linker flag “-ObjC”即可（在64位osx上和iOS程序上，这样做还不够），这个flag告诉linker将每个定义了class或者category的对象文件都载入静态库。</p>
<p>但是最终程序还是会抛这个异常，这是因为linker的bug，对于64位osx程序和iOS程序，这个bug导致只包含category而不包含class的文件没法从静态库中加载。</p>

<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-03-17T17:26:25+08:00" data-updated="true" itemprop="datePublished">Mar 17<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/markdown/'>Markdown</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/03/17/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/03/17/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/" itemprop="url">Markdown 入门新手指南</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<div class="show-content">
          <p>作为一款「写作软件」在诞生之初就支持了 Markdown，Markdown 是一种「电子邮件」风格的「标记语言」，我强烈推荐所有写作者学习和掌握该语言。</p>
<p>在此，总结 Markdown 的优点如下：</p>
<ul>
<li>纯文本，所以兼容性极强，可以用所有文本编辑器打开。</li>
<li>让你专注于文字而不是排版。</li>
<li>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。</li>
<li>Markdown 的标记语法有极好的可读性。</li>
</ul>
<p>当然，既然如此推崇 Markdown ，也必定会教会你使用 Markdown ，这也是本文的目的所在。不过，虽然 <a href="http://wowubuntu.com/markdown/">Markdown 的语法</a>已经足够简单，但是现有的 Markdown 语法说明更多的是写给 web 从业者看的，对于很多写作者来说，学习起来效率很低，现在，特地为写作者量身定做本指南，从写作者的实际需求出发，介绍写作者真正实用的常用格式，深入浅出、图文并茂地让您迅速掌握 Markdown 语法。</p>
<p>为了使您更好地学习，我们建议您登录，将您的编辑器切换至 Markdown 编辑器，新建一篇空白笔记，然后点击右上角的预览模式，此时，您的界面应当如下图所示，左侧为编辑区域，右侧为预览区域，您在左侧输入 Markdown 语法的文本，右侧会立即帮您呈现最终结果，好了，让我们开始学习吧~</p>
<p><em> Markdown：</em><br /><img src="http://ww2.sinaimg.cn/large/687afc7fjw1dzs642j2qoj.jpg" alt="" /></p>
<h2>标题</h2>
<p>这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。</p>
<p>而在 Markdown 中，你只需要在文本前面加上 <code>#</code> 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加  <code>#</code> 即可，标题字号相应降低。例如：</p>
<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题</code></pre>
<p><em>注：<code>#</code> 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。</em></p>
<p><em>你可以你的编辑器中尝试输入这六级标题，可以参考下方的截图：</em><br /><img src="http://ww4.sinaimg.cn/large/687afc7fjw1dzs5crii94j.jpg" alt="一级标题至六级标题" />  </p>
<h2>列表</h2>
<p>列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 <code>-</code> 就可以了，例如：</p>
<pre><code>- 文本1
- 文本2
- 文本3</code></pre>
<p>如果你希望有序列表，也可以在文字前面加上 <code>1.</code> <code>2.</code> <code>3.</code> 就可以了，例如：</p>
<pre><code>1. 文本1
2. 文本2
3. 文本3</code></pre>
<p><em>注：<code>-</code>、<code>1.</code>和文本之间要保留一个字符的空格。</em></p>
<p><em>列表案例截图如下：</em><br /><img src="http://ww1.sinaimg.cn/large/687afc7fjw1dzs56gavuzj.jpg" alt="" /></p>
<p><h2 id="picture"> 链接和图片</h2>

</p>
<p>在 Markdown 中，插入链接不需要其他按钮，你只需要使用 <code>[显示文本](链接地址)</code> 这样的语法即可，例如：</p>
<pre><code>[ITMonkeyLife](http://itmonkeylife.github.io/Blog/)</code></pre>
<p>在 Markdown 中，插入图片不需要其他按钮，你只需要使用 <code>![](图片链接地址)</code> 这样的语法即可，例如：</p>
<pre><code>![](http://ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg)</code></pre>
<p><em>注：插入图片的语法和链接的语法很像，只是前面多了一个 <code>！</code>。</em></p>
<p><em>插入链接和图片的案例截图：</em><br /><img src="http://ww3.sinaimg.cn/large/687afc7fjw1dzs5i4iw3uj.jpg" alt="" /></p>
<h2>引用</h2>
<p>在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 <code>&gt;</code> 就好了，例如：</p>
<pre><code>&gt; 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</code></pre>
<p><em>注：<code>&gt;</code> 和文本之间要保留一个字符的空格。</em></p>
<p>最终显示的就是：</p>
<blockquote>
<p>一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</p>
</blockquote>
<p><em>引用的案例截图：</em><br /><img src="http://ww3.sinaimg.cn/large/687afc7fjw1dzs5oehlj5j.jpg" alt="" /></p>
<h2>粗体和斜体</h2>
<p>Markdown 的粗体和斜体也非常简单，用两个 <code>*</code> 包含一段文本就是粗体的语法，用一个 <code>*</code> 包含一段文本就是斜体的语法。例如：</p>
<pre><code> *一盏灯*， 一片昏黄；**一简书**， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</code></pre>
<p>最终显示的就是下文，其中「一盏灯」是斜体，「一简书」是粗体：</p>
<p> <em>一盏灯</em>， 一片昏黄；<strong>一简书</strong>， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</p>
<p><em>粗体和斜体的案例截图：</em><br /><img src="http://ww4.sinaimg.cn/large/687afc7fjw1dzs5qrr3jcj.jpg" alt="" /></p>
<h2>结语</h2>
<p>以上几种格式是比较常用的格式，所以我们针对这些语法做了比较详细的说明。除这些之外，Markdown 还有其他语法，如想了解和学习更多，可以参考这篇<a href="http://wowubuntu.com/markdown/">『Markdown 语法说明』</a>。</p>
<p>强烈建议您现在就立马用 Markdown 写一篇文章吧，体会一下 Markdown 的优雅之处！</p>
<p>最后，希望我们的指南可以帮助到您，也希望能够成为您书写 Markdown 的最佳选择。</p>
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
</div>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-03-13T14:05:56+08:00" data-updated="true" itemprop="datePublished">Mar 13<span>th</span>, 2014</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/Blog/blog/2014/03/13/%E6%95%99%E7%A8%8B%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%9C%A8github%E4%B8%8A%E5%BB%BA%E7%AB%8Boctopress%E5%8D%9A%E5%AE%A2/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/03/13/%E6%95%99%E7%A8%8B%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%9C%A8github%E4%B8%8A%E5%BB%BA%E7%AB%8Boctopress%E5%8D%9A%E5%AE%A2/" itemprop="url">教程:一步步在github上建立octopress博客</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>目标</h2>
<p>创建网址为<a href="http://itmonkeylife.github.io/Blog">http://itmonkeylife.github.io/Blog</a>的博客.博客使用octopress程序,搭建在github的服务器上.网页与本地机器的<code>Blog</code>文件夹同步.</p>
<h2>步骤</h2>
<h3>0) 配置环境</h3>
<p>octopress需要ruby和git支持. 因此我们需要先安装这两个程序.
这儿分windows和Mac分别讲下.</p>
<p><strong>Windows(简略说下,详细教程请搜索):</strong></p>
<p>下载并安装git:</p>
<blockquote>
    
<p><a href="http://git-scm.com/download">http://git-scm.com/download</a></p>
</blockquote>
<p>下载并安装Ruby和开发组件(DEVELOPMENT KIT),共两个文件,Ruby推荐1.9.3版,对octopuses支持很好:</p>
<blockquote>
<p><a href="http://rubyinstaller.org/downloads/">http://rubyinstaller.org/downloads/</a></p>
</blockquote>
<p><strong>Mac:</strong></p>
<p>Mac本身自带了git,因此不需要单独安装.</p>
<p>Octopress需要带openssl组件的ruby支持.</p>
<p>但新版本的ruby似乎编译对参数<code>--with-openssl-dir=my/openssl/dir</code>支持有问题, 因此推荐使用rvm安装管理多版本的Ruby, rvm默认安装Ruby 2.0版本, 这儿为了不发生兼容性问题, 除了默认的2.0, 再安装个带openssl的1.9.3版.</p>
<ul>
<li><p>确认<a href="https://developer.apple.com/xcode/">Xcode</a>和其自带的<code>命令行工具</code>已经安装.</p>
<p>  如没有,Xcode可在App Store免费下载.<code>命令行工具</code>可以在<code>Xcode- Preferences - Download</code> 中    点击安装 <code>Command Line Tools</code>.</p>
</li>
<li><p>安装rvm, rvm是个软件管理工具,和Linux上的apt-get,yum之类类似.</p>
</li>
</ul>
<pre><code class="lang-bash">sudo curl -L https://get.rvm.io | bash -s stable</code></pre>
<p>在~/.bash_profile文件末尾添加:</p>
<pre><code class="lang-bash">echo &#39;[[ -s &quot;$HOME/.rvm/scripts/rvm&quot; ]] &amp;&amp; . &quot;$HOME/.rvm/scripts/rvm&quot;</code></pre>
<p>加载下配置文件:</p>
<pre><code class="lang-bash">source ~/.bash_profile</code></pre>
<ul>
<li>安装1.93版支持openssl的Ruby.</li>
</ul>
<pre><code class="lang-bash">rvm install 1.9.3 --with-gcc=clang ----with-openssl-dir=$HOME/.rvm/usr
rvm use 1.9.3 --default</code></pre>
<h3>1) 下载octopress至本地Blog文件夹</h3>
<p>octopress的源代码同样在github上管理,因此我们使用git克隆一份到本地的<code>Blog</code>文件夹,并进入此文件夹.
如你没有域名,可以使用github提供的默认域名:<code>yourname.github.com</code>,yourname是你github的用户名.</p>
<pre><code class="lang-bash">git clone git@github.com:ITMonkeyLife/Blog.git ITMonkeyLife/Blog
cd ITMonkeyLife/Blog</code></pre>
<h3>2) 安装相关组件</h3>
<pre><code class="lang-bash">gem install bundler
bundle install</code></pre>
<h3>3) 安装主题</h3>
<pre><code class="lang-bash">rake install</code></pre>
<p>上条命令安装默认主题,在<a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes">https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes</a>可以找到许多第三方主题,这儿我们选择<a href="http://zespia.tw/Octopress-Theme-Slash/">slash</a>主题,如询问是否覆盖,选择是:</p>
<pre><code class="lang-bash">git clone git://github.com/tommy351/Octopress-Theme-Slash.git .themes/slash
rake install[&#39;slash&#39;]</code></pre>
<h3>4) 在github上创建repository</h3>
<p>去<a href="http://github.com">Github</a>上注册个账户,选择免费套餐.</p>
<p>新建一个repository.</p>
<p><strong>注意:repository的名字一定要<code>yourname.github.com</code>这样的格式.</strong>
<code>yourname</code>是你注册时的用户名.</p>
<p>这儿我创建名为<code>itmonkeylife.github.com</code>的repository,创建好后拷贝ssh地址.</p>
<p><code>https://github.com/itmonkeylife/Blog.github.com.git</code></p>
<h3>5) 建立本地与github的联系</h3>
<pre><code class="lang-bash">rake setup_github_pages</code></pre>
<p>输入上述ssh地址,注意区分大小写.
如遇验证问题,提示类似</p>
<pre><code class="lang-bash">rake aborted!
undefined method
[]&#39; for nil:NilClass

Tasks: TOP =&gt; setup_github_pages
(See full trace by running task with --trace)</code></pre>
<p>的信息,请看此文:<a href="http://never.doubting.me/2013/04/18/2013-04-18-github-set-up-ssh-keys/">github设置ssh验证</a></p>
<h3>6) 绑定域名</h3>
<p>首先把你的域名指向<code>207.97.227.245</code>,如不知怎么操作,请咨询域名注册商.
在source文件夹下建立CNAME文件:</p>
<pre><code class="lang-bash">echo &#39;never.doubting.me&#39; &gt;&gt; source/CNAME</code></pre>
<h3>7) 生成网页并推送到github</h3>
<pre><code class="lang-bash">rake generate
rake deploy</code></pre>
<p>稍等几分钟,你就可通过域名访问博客了.并且收到一封博客建立的信件.</p>
<h3>8) 自定义博客</h3>
<p>博客的基本信息在<code>_config.yml</code>文件中修改.
自定义css等在<code>source</code>文件夹中.
修改后别忘了:</p>
<pre><code class="lang-bash">rake generate
rake deploy</code></pre>
<h3>9) 发表文章</h3>
<pre><code>rake new_post[&quot;教程:一步步在github上建立octopress博客&quot;]</code></pre>
<p>这儿我新建了一篇名为<code>教程:一步步在github上建立octopress博客</code>的文章.
之后去<code>source/_post/</code>文件夹找到对应<code>.markdown</code>文件修改.</p>
<p>打开文件后可以看到文件头包含一些文章的信息,这儿我修改为:</p>
<pre><code class="lang-html">---
layout: post    
title: &quot;教程:一步步在github上建立octopress博客&quot;    
date: 2014-03-13 11:13    
author: znithy    
comments: true    
categories:     
- 教程    
- github    
- octopress    
published: false
---</code></pre>
<p>第一张指明此篇是<code>post</code>,后面是标题,时间和作者,我加了<code>教程</code> <code>github</code> <code>octopuses</code> 三个标签,并且允许评论,<code>published: false</code>表示不要发表,如想要发表改成<code>published: true</code>或者直接删掉这行.</p>
<p>文章直接写在这部分内容下面.</p>
<h3>10) 发表外链文章</h3>
<p>点击标题转向其他网页.创建方法同上,只是需要添加<code>external-url</code>这个条目.
下面是一个例子:</p>
<pre><code class="lang-html">---        
layout: post    
title: &quot;非常不错的科学博客&quot;    
date: 2014-03-13 14:13         
comments: true        
external-url: http://www.baidu.com/        
---</code></pre>
<h3>11) 发表页面</h3>
<p>创建网址为<code>http://itmonkeylife.github.io/Blog//about/i.html</code>的网页:</p>
<pre><code class="lang-bash">rake new_page[about/i.html]</code></pre>
<p>与<code>post</code>不同的是,此时没有<code>categories</code>这个条目,但多了<code>sharing</code>和<code>footer</code>,具体有什么作用,不妨自己试下.</p>
<pre><code class="lang-html">---    
layout: page        
title: &quot;Super Awesome&quot;    
date: 2011-07-03 5:59    
comments: true    
sharing: true    
footer: true        
---</code></pre>
<h3>12) 管理文章</h3>
<p>直接增加或删除.markdown文件即可.
每次更新文件后别忘了:</p>
<pre><code class="lang-bash">rake generate
rake deploy</code></pre>
<h2>其他</h2>
<h3>git设置用户名</h3>
<p>默认情况下直接使用系统的用户名,也可通过下面的命令自定义:</p>
<pre><code class="lang-bash">git config --global user.name author #将用户名设为author    
git config --global user.email author@mail.com #将用户邮箱设为author@mail.com</code></pre>
<h3>关于怎样使用git,这份教程很不错,推荐.</h3>
<blockquote>
<p><a href="http://znithy.com/download/看日记学git.pdf">看日记学git.pdf</a></p>
</blockquote>
<h3>第三方插件地址:</h3>
<blockquote>
<p><a href="https://github.com/imathis/octopress/wiki/3rd-party-plugins">https://github.com/imathis/octopress/wiki/3rd-party-plugins</a></p>
</blockquote>
<h3>中文问题:</h3>
<p>如遇到此类提示(可能因设置了中文的catagory):</p>
<pre><code class="lang-bash">...
Liquid Exception: invalid byte sequence in UTF-8 in atom.xml
/Documents/never.doubting.me/plugins/octopress_filters.rb:75:in `gsub;
/Documents/never.doubting.me/plugins/octopress_filters.rb:75:in `cdata_escape;
...</code></pre>
<p>最方便的方法是换用kramdown.首先安装kramdown:</p>
<pre><code class="lang-bash">gem install kramdown</code></pre>
<p>之后修改<code>_config.yml</code>文件:</p>
<pre><code class="lang-html">markdown: kramdown</code></pre>
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
    <div class="center"><a href="/Blog/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    Rick


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
</body>
</html>
