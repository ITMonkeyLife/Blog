
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>IT Monkey Life</title>
	<meta name="author" content="Rick">

	
	<meta name="description" content="Apr 21st, 2014 iOS Comments 深入理解CocoaPods CocoaPods 是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具。利用 CocoaPods，可以定义自己的依赖关系 (称作 pods)，并且随着时间的变化， &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/Blog/atom.xml" rel="alternate" title="IT Monkey Life" type="application/atom+xml">
	
	<link rel="canonical" href="http://ITMonkeyLife.github.io/Blog/">
	<link href="/Blog/favicon.png" rel="shortcut icon">
	<link href="/Blog/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/Blog/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/Blog/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("382542165@qq.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>

<nav id="main-nav">
<section class="aboutme">
  <p class = "subtitle">
    心无所恃，随遇而安
  </p>
</section>

<ul class="main">
    <li><a href="/Blog/">我的Blog</a></li>
    <li><a href="/Blog/about/">关于我</a></li>
    <li><a href="/Blog/blog/archives">全部文章</a></li>
</ul></nav>
<nav id="sub-nav">
	<div class="social">
    	
			<a class="sina" href="http://weibo.com/1651400041" title="Sina">Sina</a>
		
		
			<a class="email" href="mailto:382542165@qq.com" title="Email">Email</a>
		
		
		
		
		
		
		
		
		
		
		
		
			<a class="douban" href="https://www.douban.com/people/47445127" title="Douban">Douban</a>
		
		
		
    	
    	
			<a class="rss" href="/Blog/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-21T18:06:50+08:00" data-updated="true" itemprop="datePublished">Apr 21<span>st</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/21/shen-ru-li-jie-cocoapods/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/21/shen-ru-li-jie-cocoapods/" itemprop="url">深入理解CocoaPods</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>CocoaPods 是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具。利用 CocoaPods，可以定义自己的依赖关系 (称作 <code>pods</code>)，并且随着时间的变化，以及在整个开发环境中对第三方库的版本管理非常方便。</p>

<p>CocoaPods 背后的理念主要体现在两个方面。首先，在工程中引入第三方代码会涉及到许多内容。针对 Objective-C 初级开发者来说，工程文件的配置会让人很沮丧。在配置 build phases 和 linker flags 过程中，会引起许多人为因素的错误。CocoaPods 简化了这一切，它能够自动配置编译选项。</p>

<p>其次，通过 CocoaPods，可以很方便的查找到新的第三方库。当然，这并不是说你可以简单的将别人提供的库拿来拼凑成一个应用程序。它的真正作用是让你能够找到真正好用的库，以此来缩短我们的开发周期和提升软件的质量。</p>

<p>本文中，我们将通过分析 <code>pod 安装 (</code>pod install<code>)</code> 的过程，一步一步揭示 CocoaPods 背后的技术。</p>

<h2>核心组件</h2>

<p>CocoaPods是用 Ruby 写的，并由若干个 Ruby 包 (gems) 构成的。在解析整合过程中，最重要的几个 gems 分别是： <a href="https://github.com/CocoaPods/CocoaPods/">CocoaPods/CocoaPods</a>, <a href="https://github.com/CocoaPods/Core">CocoaPods/Core</a>, 和 <a href="https://github.com/CocoaPods/Xcodeproj">CocoaPods/Xcodeproj</a> (是的，CocoaPods 是一个依赖管理工具 &#8211; 利用依赖管理进行构建的！)。</p>

<blockquote>
  <p><p><span class="secondary radius label">编者注</span> CocoaPods 是一个 objc 的依赖管理工具，而其本身是利用 ruby 的依赖管理 gem 进行构建的</p>


<h3 id="cocoapodscocoapod">CocoaPods/CocoaPod</h3>

<p>这是是一个面向用户的组件，每当执行一个 <code>pod</code> 命令时，这个组件都将被激活。该组件包括了所有使用 CocoaPods 涉及到的功能，并且还能通过调用所有其它的 gems 来执行任务。</p>

<h3 id="cocoapodscore">CocoaPods/Core</h3>

<p>Core 组件提供支持与 CocoaPods 相关文件的处理，文件主要是 Podfile 和 podspecs。</p>

<h5 id="podfile">Podfile</h5>

<p>Podfile 是一个文件，用于定义项目锁需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 <a href="http://guides.cocoapods.org/syntax/podfile.html">Podfile 指南</a>。</p>

<h4 id="podspec">Podspec</h4>

<p><code>.podspec</code> 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。</p>

<h3 id="cocoapodsxcodeproj">CocoaPods/Xcodeproj</h3>

<p>这个 gem 组件负责所有工程文件的整合。它能够对创建并修改 <code>.xcodeproj</code> 和 <code>.xcworkspace</code> 文件。它也可以作为单独的一个 gem 包使用。如果你想要写一个脚本来方便的修改工程文件，那么可以使用这个 gem。</p>

<h2 id="podinstall">运行 <code>pod install</code> 命令</h2>

<p>当运行 <code>pod install</code> 命令时会引发许多操作。要想深入了解这个命令执行的详细内容，可以在这个命令后面加上 <code>--verbose</code>。现在运行这个命令 <code>pod install --verbose</code>，可以看到类似如下的内容：</p>

<pre><code>$ pod install --verbose

Analyzing dependencies

Updating spec repositories
Updating spec repo `master`
  $ /usr/bin/git pull
  Already up-to-date.


Finding Podfile changes
  - AFNetworking
  - HockeySDK

Resolving dependencies of `Podfile`
Resolving dependencies for target `Pods' (iOS 6.0)
  - AFNetworking (= 1.2.1)
  - SDWebImage (= 3.2)
    - SDWebImage/Core

Comparing resolved specification to the sandbox manifest
  - AFNetworking
  - HockeySDK

Downloading dependencies

-&gt; Using AFNetworking (1.2.1)

-&gt; Using HockeySDK (3.0.0)
  - Running pre install hooks
    - HockeySDK

Generating Pods project
  - Creating Pods project
  - Adding source files to Pods project
  - Adding frameworks to Pods project
  - Adding libraries to Pods project
  - Adding resources to Pods project
  - Linking headers
  - Installing libraries
    - Installing target `Pods-AFNetworking` iOS 6.0
      - Adding Build files
      - Adding resource bundles to Pods project
      - Generating public xcconfig file at `Pods/Pods-AFNetworking.xcconfig`
      - Generating private xcconfig file at `Pods/Pods-AFNetworking-Private.xcconfig`
      - Generating prefix header at `Pods/Pods-AFNetworking-prefix.pch`
      - Generating dummy source file at `Pods/Pods-AFNetworking-dummy.m`
    - Installing target `Pods-HockeySDK` iOS 6.0
      - Adding Build files
      - Adding resource bundles to Pods project
      - Generating public xcconfig file at `Pods/Pods-HockeySDK.xcconfig`
      - Generating private xcconfig file at `Pods/Pods-HockeySDK-Private.xcconfig`
      - Generating prefix header at `Pods/Pods-HockeySDK-prefix.pch`
      - Generating dummy source file at `Pods/Pods-HockeySDK-dummy.m`
    - Installing target `Pods` iOS 6.0
      - Generating xcconfig file at `Pods/Pods.xcconfig`
      - Generating target environment header at `Pods/Pods-environment.h`
      - Generating copy resources script at `Pods/Pods-resources.sh`
      - Generating acknowledgements at `Pods/Pods-acknowledgements.plist`
      - Generating acknowledgements at `Pods/Pods-acknowledgements.markdown`
      - Generating dummy source file at `Pods/Pods-dummy.m`
  - Running post install hooks
  - Writing Xcode project file to `Pods/Pods.xcodeproj`
  - Writing Lockfile in `Podfile.lock`
  - Writing Manifest in `Pods/Manifest.lock`

Integrating client project
</code></pre>

<p>可以上到，整个过程执行了很多操作，不过把它们分解之后，再看看，会发现它们都很简单。让我们逐步来分析一下。</p>

<h3 id="podfile">读取 Podfile 文件</h3>

<p>你是否对 Podfile 的语法格式感到奇怪过，那是因为这是用 Ruby 语言写的。相较而言，这要比现有的其他格式更加简单好用一些。</p>

<p>在安装期间，第一步是要弄清楚显示或隐式的声明了哪些第三方库。在加载 podspecs 过程中，CocoaPods 就建立了包括版本信息在内的所有的第三方库的列表。Podspecs 被存储在本地路径 <code>~/.cocoapods</code> 中。</p>

<h4>版本控制和冲突</h4>

<p>CocoaPods 使用<a href="http://semver.org/">语义版本控制 - Semantic Versioning</a> 命名约定来解决对版本的依赖。由于冲突解决系统建立在非重大变更的补丁版本之间，这使得解决依赖关系变得容易很多。例如，两个不同的 pods 依赖于 CocoaLumberjack 的两个版本，假设一个依赖于 <code>2.3.1</code>，另一个依赖于 <code>2.3.3</code>，此时冲突解决系统可以使用最新的版本 <code>2.3.3</code>，因为这个可以向后与 <code>2.3.1</code> 兼容。</p>

<p>但这并不总是有效。有许多第三方库并不使用这样的约定，这让解决方案变得非常复杂。</p>

<p>当然，总会有一些冲突需要手动解决。如果一个库依赖于 CocoaLumberjack 的 <code>1.2.5</code>，另外一个库则依赖于 <code>2.3.1</code>，那么只有最终用户通过明确指定使用某个版本来解决冲突。</p>

<h3>加载源文件</h3>

<p>CocoaPods 执行的下一步是加载源码。每个 <code>.podspec</code> 文件都包含一个源代码的索引，这些索引一般包裹一个 git 地址和 git tag。它们以 commit SHAs 的方式存储在 <code>~/Library/Caches/CocoaPods</code> 中。这个路径中文件的创建是由 Core gem 负责的。</p>

<p>CocoaPods 将依照 <code>Podfile</code>、<code>.podspec</code> 和缓存文件的信息将源文件下载到 <code>Pods</code> 目录中。</p>

<h3 id="podsxcodeproj">生成 Pods.xcodeproj</h3>

<p>每次 <code>pod install</code> 执行，如果检测到改动时，CocoaPods 会利用 Xcodeproj gem 组件对 <code>Pods.xcodeproj</code> 进行更新。如果该文件不存在，则用默认配置生成。否则，会将已有的配置项加载至内存中。</p>

<h3>安装第三方库</h3>

<p>当 CocoaPods 往工程中添加一个第三方库时，不仅仅是添加代码这么简单，还会添加很多内容。由于每个第三方库有不同的 target，因此对于每个库，都会有几个文件需要添加，每个 target 都需要：</p>

<ul>
<li>一个包含编译选项的 <code>.xcconfig</code> 文件</li>
<li>一个同时包含编译设置和 CocoaPods 默认配置的私有 <code>.xcconfig</code> 文件</li>
<li>一个编译所必须的 <code>prefix.pch</code> 文件</li>
<li>另一个编译必须的文件 <code>dummy.m</code></li>
</ul>

<p>一旦每个 pod 的 target 完成了上面的内容，整个 <code>Pods</code> target 就会被创建。这增加了相同文件的同时，还增加了另外几个文件。如果源码中包含有资源 bundle，将这个 bundle 添加至程序 target 的指令将被添加到 <code>Pods-Resources.sh</code> 文件中。还有一个名为 <code>Pods-environment.h</code> 的文件，文件中包含了一些宏，这些宏可以用来检查某个组件是否来自 pod。最后，将生成两个认可文件，一个是 <code>plist</code>，另一个是 <code>markdown</code>，这两个文件用于给最终用户查阅相关许可信息。</p>

<h3>写入至磁盘</h3>

<p>直到现在，许多工作都是在内存中进行的。为了让这些成果能被重复利用，我们需要将所有的结果保存到一个文件中。所以 <code>Pods.xcodeproj</code> 文件被写入磁盘，另外两个非常重要的文件：<code>Podfile.lock</code> 和 <code>Manifest.lock</code> 都将被写入磁盘。</p>

<h4 id="podfilelock">Podfile.lock</h4>

<p>这是 CocoaPods 创建的最重要的文件之一。它记录了需要被安装的 pod 的每个已安装的版本。如果你想知道已安装的 pod 是哪个版本，可以查看这个文件。推荐将 Podfile.lock 文件加入到版本控制中，这有助于整个团队的一致性。</p>

<h4 id="manifestlock">Manifest.lock</h4>

<p>这是每次运行 <code>pod install</code> 命令时创建的 <code>Podfile.lock</code> 文件的副本。如果你遇见过这样的错误 <code>沙盒文件与 Podfile.lock 文件不同步 (The sandbox is not in sync with the Podfile.lock)</code>，这是因为 Manifest.lock 文件和 <code>Podfile.lock</code> 文件不一致所引起。由于 <code>Pods</code> 所在的目录并不总在版本控制之下，这样可以保证开发者运行 app 之前都能更新他们的 pods，否则 app 可能会 crash，或者在一些不太明显的地方编译失败。</p>

<h3 id="xcproj">xcproj</h3>

<p>如果你已经依照我们的建议在系统上安装了 <a href="https://github.com/0xced/xcproj">xcproj</a>，它会对 <code>Pods.xcodeproj</code> 文件执行一下 <code>touch</code> 以将其转换成为旧的 ASCII plist 格式的文件。为什么要这么做呢？虽然在很久以前就不被其它软件支持了，但是 Xcode 仍然依赖于这种格式。如果没有 xcproj，你的 <code>Pods.xcodeproj</code> 文件将会以 XML 格式的 plist 文件存储，当你用 Xcode 打开它时，它会被改写，并造成大量的文件改动。</p>

<h2>结果</h2>

<p>运行 <code>pod install</code> 命令的最终结果是许多文件被添加到你的工程和系统中。这个过程通常只需要几秒钟。当然没有 Cocoapods 这些事也都可以完成。只不过所花的时间就不仅仅是几秒而已了。</p>

<h2>补充：持续集成</h2>

<p>CocoaPods 和持续集成在一起非常融洽。虽然持续集成很大程度上取决于你的项目配置，但 Cocoapods 依然能很容易地对项目进行编译。</p>

<h3 id="pods">Pods 文件夹的版本控制</h3>

<p>如果 Pods 文件夹和里面的所有内容都在版本控制之中，那么你不需要做什么特别的工作，就能够持续集成。我们只需要给 <code>.xcworkspace</code> 选择一个正确的 scheme 即可。</p>

<h3 id="pods">不受版本控制的 Pods 文件夹</h3>

<p>如果你的 <code>Pods</code> 文件夹不受版本控制，那么你需要做一些额外的步骤来保证持续集成的顺利进行。最起码，<code>Podfile</code> 文件要放入版本控制之中。另外强烈建议将生成的 <code>.xcworkspace</code> 和 <code>Podfile.lock</code> 文件纳入版本控制，这样不仅简单方便，也能保证所使用 Pod 的版本是正确的。</p>

<p>一旦配置完毕，在持续集成中运行 CocoaPods 的关键就是确保每次编译之前都执行了 <code>pod install</code> 命令。在大多数系统中，例如 Jenkins 或 Travis，只需要定义一个编译步骤即可 (实际上，Travis 会自动执行 <code>pod install</code> 命令)。对于 <a href="https://groups.google.com/d/msg/cocoapods/eYL8QB3XjyQ/10nmCRN8YxoJ">Xcode Bots，在书写这篇文章时我们还没能找到非常流畅的方式</a>，不过我们正朝着解决方案努力，一旦成功，我们将会立即分享。</p>

<h2>结束语</h2>

<p>CocoaPods 简化了 Objective-C 的开发流程，我们的目标是让第三方库更容易被发现和添加。了解 CocoaPods 的原理能让你做出更好的应用程序。我们沿着 CocoaPods 的整个执行过程，从载入 specs 文件和源代码、创建 <code>.xcodeproj</code> 文件和所有组件，到将所有文件写入磁盘。所以接下来，我们运行 <code>pod install --verbose</code>，静静观察 CocoaPods 的魔力如何显现。</p>

<hr /><p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
</p></blockquote>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-21T17:51:10+08:00" data-updated="true" itemprop="datePublished">Apr 21<span>st</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/21/macke-zhi-xing-wen-jian/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/21/macke-zhi-xing-wen-jian/" itemprop="url">Mac可执行文件</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>我们用 Xcode 构建一个程序的过程中，会把源文件 (<code>.m</code> 和 <code>.h</code>) 文件转换为一个可执行文件。这个可执行文件中包含的字节码会将被 CPU (iOS 设备中的 ARM 处理器或 Mac 上的 Intel 处理器) 执行。</p>

<p>本文将介绍一下上面的过程中编译器都做了些什么，同时深入看看可执行文件内部是怎样的。实际上里面的东西要比我们第一眼看到的多得多。</p>

<p>这里我们把 Xcode 放一边，将使用命令行工具 (command-line tools)。当我们用 Xcode 构建一个程序时，Xcode 只是简单的调用了一系列的工具而已。Florian 对工具调用是如何工作的做了更详细的讨论。本文我们就直接调用这些工具，并看看它们都做了些什么。</p>

<p>真心希望本文能帮助你更好的理解 iOS 或 OS X 中的一个可执行文件 (也叫做 <em>Mach-O executable</em>) 是如何执行，以及怎样组装起来的。</p>

<h2 id="xcrun">xcrun</h2>

<p>先来看一些基础性的东西：这里会大量使用一个名为 <code>xcrun</code> 的命令行工具。看起来可能会有点奇怪，不过它非常的出色。这个小工具用来调用别的一些工具。原先，我们在终端执行如下命令：</p>

<pre><code>% clang -v
</code></pre>

<p>现在我们用下面的命令代替：</p>

<pre><code>% xcrun clang -v
</code></pre>

<p>在这里 <code>xcrun</code> 做的是定位到 <code>clang</code>，并执行它，附带输入 <code>clang</code> 后面的参数。</p>

<p>我们为什么要这样做呢？看起来没有什么意义。不过 <code>xcode</code> 允许我们: (1) 使用多个版本的 Xcode，以及使用某个特定 Xcode 版本中的工具。(2) 针对某个特定的 SDK (software development kit) 使用不同的工具。如果你有 Xcode 4.5 和 Xcode 5，通过 <code>xcode-select</code> 和 <code>xcrun</code> 可以选择使用 Xcode 5 中 iOS SDK 的工具，或者 Xcode 4.5 中的 OS X 工具。在许多其它平台中，这是不可能做到的。查阅 <code>xcrun</code> 和 <code>xcode-select</code> 的主页内容可以了解到详细内容。不用安装 <em>Command Line Tools</em>，就能使用命令行中的开发者工具。</p>

<h2 id="idehelloworld">不使用 IDE 的 Hello World</h2>

<p>回到终端 (Terminal)，创建一个包含一个 C 文件的文件夹：</p>

<pre><code>% mkdir ~/Desktop/objcio-command-line
% cd !$
% touch helloworld.c
</code></pre>

<p>接着使用你喜欢的文本编辑器来编辑这个文件 &#8211; 例如 TextEdit.app：</p>

<pre><code>% open -e helloworld.c
</code></pre>

<p>输入如下代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>保存并返回到终端，然后运行如下命令：</p>

<pre><code>% xcrun clang helloworld.c
% ./a.out
</code></pre>

<p>现在你能够在终端上看到熟悉的 <code>Hello World!</code>。这里我们编译并运行 C 程序，全程没有使用 IDE。深呼吸一下，高兴高兴。</p>

<p>上面我们到底做了些什么呢？我们将 <code>helloworld.c</code> 编译为一个名为 <code>a.out</code> 的 Mach-O 二进制文件。注意，如果我们没有指定名字，那么编译器会默认的将其指定为 a.out。</p>

<p>这个二进制文件是如何生成的呢？实际上有许多内容需要观察和理解。我们先看看编译器吧。</p>

<h3 id="helloworld">Hello World 和编译器</h3>

<p>时下 Xcode 中编译器默认选择使用 <code>clang</code>(读作 /klæŋ/)。<a href="http://objccn.io/issue-6-2/">关于编译器</a>，Chris 写了更详细的文章。</p>

<p>简单的说，编译器处理过程中，将 <code>helloworld.c</code> 当做输入文件，并生成一个可执行文件 <code>a.out</code>。这个过程有多个步骤/阶段。我们需要做的就是正确的执行它们。</p>

<h5>预处理</h5>

<ul>
<li>符号化 (Tokenization)</li>
<li>宏定义的展开</li>
<li><code>#include</code> 的展开</li>
</ul>

<h5>语法和语义分析</h5>

<ul>
<li>将符号化后的内容转化为一棵解析树 (parse tree)</li>
<li>解析树做语义分析</li>
<li>输出一棵<em>抽象语法树</em>（Abstract Syntax Tree* (AST)）</li>
</ul>

<h5>生成代码和优化</h5>

<ul>
<li>将 AST 转换为更低级的中间码 (LLVM IR)</li>
<li>对生成的中间码做优化</li>
<li>生成特定目标代码</li>
<li>输出汇编代码</li>
</ul>

<h5>汇编器</h5>

<ul>
<li>将汇编代码转换为目标对象文件。</li>
</ul>

<h5>链接器</h5>

<ul>
<li>将多个目标对象文件合并为一个可执行文件 (或者一个动态库)</li>
</ul>

<p>我们来看一个关于这些步骤的简单的例子。</p>

<h4>预处理</h4>

<p>编译过程中，编译器首先要做的事情就是对文件做处理。预处理结束之后，如果我们停止编译过程，那么我们可以让编译器显示出预处理的一些内容：</p>

<pre><code>% xcrun clang -E helloworld.c
</code></pre>

<p>喔喔。 上面的命令输出的内容有 413 行。我们用编辑器打开这些内容，看看到底发生了什么：</p>

<pre><code>% xcrun clang -E helloworld.c | open -f
</code></pre>

<p>在顶部可以看到的许多行语句都是以 <code>#</code> 开头 (读作 <code>hash</code>)。这些被称为 <em>行标记</em> 的语句告诉我们后面跟着的内容来自哪里。如果再回头看看 <code>helloworld.c</code> 文件，会发现第一行是：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们都用过 <code>#include</code> 和 <code>import</code>。它们所做的事情是告诉预处理器将文件 <code>stdio.h</code> 中的内容插入到 <code>#include</code> 语句所在的位置。这是一个递归的过程：<code>stdio.h</code> 可能会包含其它的文件。</p>

<p>由于这样的递归插入过程很多，所以我们需要确保记住相关行号信息。为了确保无误，预处理器在发生变更的地方插入以 <code>#</code> 开头的 <code>行标记</code>。跟在 <code>#</code> 后面的数字是在源文件中的行号，而最后的数字是在新文件中的行号。回到刚才打开的文件，紧跟着的是系统头文件，或者是被看做为封装了 <code>extern "C"</code> 代码块的文件。</p>

<p>如果滚动到文件末尾，可以看到我们的 <code>helloworld.c</code> 代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp"># 2 &quot;helloworld.c&quot; 2</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line"> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在 Xcode 中，可以通过这样的方式查看任意文件的预处理结果：<strong>Product</strong> -&gt; <strong>Perform Action</strong> -&gt; <strong>Preprocess</strong>。注意，编辑器加载预处理后的文件需要花费一些时间 &#8211; 接近 100,000 行代码。</p>

<h4>编译</h4>

<p>下一步：分析和代码生成。我们可以用下面的命令让 <code>clang</code> 输出汇编代码：</p>

<pre><code>% xcrun clang -S -o - helloworld.c | open -f
</code></pre>

<p>我们来看看输出的结果。首先会看到有一些以点 <code>.</code> 开头的行。这些就是汇编指令。其它的则是实际的 x86_64 汇编代码。最后是一些标记 (label)，与 C 语言中的类似。</p>

<p>我们先看看前三行：</p>

<pre><code>    .section    __TEXT,__text,regular,pure_instructions
    .globl  _main
    .align  4, 0x90
</code></pre>

<p>这三行是汇编指令，不是汇编代码。<code>.section</code> 指令指定接下来会执行哪一个段。</p>

<p>第二行的 <code>.globl</code> 指令说明 <code>_main</code> 是一个外部符号。这就是我们的 <code>main()</code> 函数。这个函数对于二进制文件外部来说是可见的，因为系统要调用它来运行可执行文件。</p>

<p><code>.align</code> 指令指出了后面代码的对齐方式。在我们的代码中，后面的代码会按照 16(2^4) 字节对齐，如果需要的话，用 <code>0x90</code> 补齐。</p>

<p>接下来是 main 函数的头部：</p>

<pre><code>_main:                                  ## @main
    .cfi_startproc
## BB#0:
    pushq   %rbp
Ltmp2:
    .cfi_def_cfa_offset 16
Ltmp3:
    .cfi_offset %rbp, -16
    movq    %rsp, %rbp
Ltmp4:
    .cfi_def_cfa_register %rbp
    subq    $32, %rsp
</code></pre>

<p>上面的代码中有一些与 C 标记工作机制一样的一些标记。它们是某些特定部分的汇编代码的符号链接。首先是 <code>_main</code> 函数真正开始的地址。这个符号会被 export。二进制文件会有这个位置的一个引用。</p>

<p><code>.cfi_startproc</code> 指令通常用于函数的开始处。CFI 是调用帧信息 (Call Frame Information) 的缩写。这个调用 <code>帧</code> 以松散的方式对应着一个函数。当开发者使用 debugger 和 <em>step in</em> 或 <em>step out</em> 时，实际上是 stepping in/out 一个调用帧。在 C 代码中，函数有自己的调用帧，当然，别的一些东西也会有类似的调用帧。<code>.cfi_startproc</code> 指令给了函数一个 <code>.eh_frame</code> 入口，这个入口包含了一些调用栈的信息（抛出异常时也是用其来展开调用帧堆栈的）。这个指令也会发送一些和具体平台相关的指令给 CFI。它与后面的 <code>.cfi_endproc</code> 相匹配，以此标记出 <code>main()</code> 函数结束的地方。</p>

<p>接着是另外一个 label <code>## BB#0:</code>。然后，终于，看到第一句汇编代码：<code>pushq %rbp</code>。从这里开始事情开始变得有趣。在 OS X上，我们会有 X86_64 的代码，对于这种架构，有一个东西叫做 <em>ABI</em> ( 应用二进制接口 application binary interface)，ABI 指定了函数调用是如何在汇编代码层面上工作的。在函数调用期间，ABI 会让 <code>rbp</code> 寄存器 (基础指针寄存器 base pointer register) 被保护起来。当函数调用返回时，确保 <code>rbp</code> 寄存器的值跟之前一样，这是属于 main 函数的职责。<code>pushq %rbp</code> 将 <code>rbp</code> 的值 push 到栈中，以便我们以后将其 pop 出来。</p>

<p>接下来是两个 CFI 指令：<code>.cfi_def_cfa_offset 16</code> 和 <code>.cfi_offset %rbp, -16</code>。这将会输出一些关于生成调用堆栈展开和调试的信息。我们改变了堆栈和基础指针，而这两个指令可以告诉编译器它们都在哪儿，或者更确切的，它们可以确保之后调试器要使用这些信息时，能找到对应的东西。</p>

<p>接下来，<code>movq %rsp, %rbp</code> 将把局部变量放置到栈上。<code>subq $32, %rsp</code> 将栈指针移动 32 个字节，也就是函数会调用的位置。我们先将老的栈指针存储到 <code>rbp</code> 中，然后将此作为我们局部变量的基址，接着我们更新堆栈指针到我们将会使用的位置。</p>

<p>之后，我们调用了 <code>printf()</code>：</p>

<pre><code>leaq    L_.str(%rip), %rax
movl    $0, -4(%rbp)
movl    %edi, -8(%rbp)
movq    %rsi, -16(%rbp)
movq    %rax, %rdi
movb    $0, %al
callq   _printf
</code></pre>

<p>首先，<code>leaq</code> 会将 <code>L_.str</code> 的指针加载到 <code>rax</code> 寄存器中。留意 <code>L_.str</code> 标记在后面的汇编代码中是如何定义的。它就是 C 字符串<code>"Hello World!\n"</code>。 <code>edi</code> 和 <code>rsi</code> 寄存器保存了函数的第一个和第二个参数。由于我们会调用别的函数，所以首先需要将它们的当前值保存起来。这就是为什么我们使用刚刚存储的 <code>rbp</code> 偏移32个字节的原因。第一个 32 字节的值是 0，之后的 32 字节的值是 <code>edi</code> 寄存器的值 (存储了 <code>argc</code>)。然后是 64 字节 的值：<code>rsi</code> 寄存器的值 (存储了 <code>argv</code>)。我们在后面并没有使用这些值，但是编译器在没有经过优化处理的时候，它们还是会被存下来。</p>

<p>现在我们把第一个函数 <code>printf()</code> 的参数 <code>rax</code> 设置给第一个函数参数寄存器 <code>edi</code> 中。<code>printf()</code> 是一个可变参数的函数。ABI 调用约定指定，将会把使用来存储参数的寄存器数量存储在寄存器 <code>al</code> 中。在这里是 0。最后 <code>callq</code> 调用了 <code>printf()</code> 函数。</p>

<pre><code>    movl    $0, %ecx
    movl    %eax, -20(%rbp)         ## 4-byte Spill
    movl    %ecx, %eax
</code></pre>

<p>上面的代码将 <code>ecx</code> 寄存器设置为 0，并把 <code>eax</code> 寄存器的值保存至栈中，然后将 <code>ect</code> 中的 0 拷贝至 <code>eax</code> 中。ABI 规定 <code>eax</code> 将用来保存一个函数的返回值，或者此处 <code>main()</code> 函数的返回值 0：</p>

<pre><code>    addq    $32, %rsp
    popq    %rbp
    ret
    .cfi_endproc
</code></pre>

<p>函数执行完成后，将恢复堆栈指针 —— 利用上面的指令 <code>subq $32, %rsp</code> 把堆栈指针 <code>rsp</code> 上移 32 字节。最后，把之前存储至 <code>rbp</code> 中的值从栈中弹出来，然后调用 <code>ret</code> 返回调用者， <code>ret</code> 会读取出栈的返回地址。 <code>.cfi_endproc</code> 平衡了 <code>.cfi_startproc</code> 指令。</p>

<p>接下来是输出字符串 <code>"Hello World!\n"</code>:</p>

<pre><code>    .section    __TEXT,__cstring,cstring_literals
L_.str:                                 ## @.str
    .asciz   "Hello World!\n"
</code></pre>

<p>同样，<code>.section</code> 指令指出下面将要进入的段。<code>L_.str</code> 标记运行在实际的代码中获取到字符串的一个指针。<code>.asciz</code> 指令告诉编译器输出一个以 ‘\0’ (null) 结尾的字符串。</p>

<p><code>__TEXT __cstring</code> 开启了一个新的段。这个段中包含了 C 字符串：</p>

<pre><code>L_.str:                                 ## @.str
    .asciz     "Hello World!\n"
</code></pre>

<p>上面两行代码创建了一个 null 结尾的字符串。注意 <code>L_.str</code> 是如何命名，之后会通过它来访问字符串。</p>

<p>最后的 <code>.subsections_via_symbols</code> 指令是静态链接编辑器使用的。</p>

<p>更过关于汇编指令的资料可以在 苹果的 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/Assembler/">OS X Assembler Reference</a> 中看到。AMD 64 网站有关于 <a href="http://www.x86-64.org/documentation/abi.pdf">ABI for x86 的文档</a>。另外还有 <a href="http://www.x86-64.org/documentation/assembly.html">Gentle Introduction to x86-64 Assembly</a>。</p>

<p>重申一下，通过下面的选择操作，我们可以用 Xcode 查看任意文件的汇编输出结果：<strong>Product</strong> -&gt; <strong>Perform Action</strong> -&gt; <strong>Assemble</strong>.</p>

<h4>汇编器</h4>

<p>汇编器将可读的汇编代码转换为机器代码。它会创建一个目标对象文件，一般简称为 <em>对象文件</em>。这些文件以 <code>.o</code> 结尾。如果用 Xcode 构建应用程序，可以在工程的 <em>derived data</em> 目录中，<code>Objects-normal</code> 文件夹下找到这些文件。</p>

<h4>链接器</h4>

<p>稍后我们会对链接器做更详细的介绍。这里简单介绍一下：链接器解决了目标文件和库之间的链接。什么意思呢？还记得下面的语句吗：</p>

<pre><code>callq   _printf
</code></pre>

<p><code>printf()</code> 是 <em>libc</em> 库中的一个函数。无论怎样，最后的可执行文件需要能需要知道 <code>printf()</code> 在内存中的具体位置：例如，<code>_printf</code> 的地址符号是什么。链接器会读取所有的目标文件 (此处只有一个) 和库 (此处是 <em>libc</em>)，并解决所有未知符号 (此处是 <code>_printf</code>) 的问题。然后将它们编码进最后的可执行文件中  （可以在 <em>libc</em> 中找到符号 <code>_printf</code>），接着链接器会输出可以运行的执行文件：<code>a.out</code>。</p>

<h2 id="section">Section</h2>

<p>就像我们上面提到的一样，这里有些东西叫做 section。一个可执行文件包含多个段，也就是多个 section。可执行文件不同的部分将加载进不同的 section，并且每个 section 会转换进某个 segment 里。这个概念对于所有的可执行文件都是成立的。</p>

<p>我们来看看 <code>a.out</code> 二进制中的 section。我们可以使用 <code>size</code> 工具来观察：</p>

<pre><code>% xcrun size -x -l -m a.out 
Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)
Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0)
    Section __text: 0x37 (addr 0x100000f30 offset 3888)
    Section __stubs: 0x6 (addr 0x100000f68 offset 3944)
    Section __stub_helper: 0x1a (addr 0x100000f70 offset 3952)
    Section __cstring: 0xe (addr 0x100000f8a offset 3978)
    Section __unwind_info: 0x48 (addr 0x100000f98 offset 3992)
    Section __eh_frame: 0x18 (addr 0x100000fe0 offset 4064)
    total 0xc5
Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096)
    Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096)
    Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112)
    total 0x18
Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)
total 0x100003000
</code></pre>

<p>如上代码所示，我们的 <code>a.out</code> 文件有 4 个 segment。有些 segment 中有多个 section。</p>

<p>当运行一个可执行文件时，虚拟内存 (VM - virtual memory) 系统将 segment 映射到进程的地址空间上。映射完全不同于我们一般的认识，如果你对虚拟内存系统不熟悉，可以简单的想象虚拟内存系统将整个可执行文件加载进内存 &#8211; 虽然在实际上不是这样的。VM 使用了一些技巧来避免全部加载。</p>

<p>当虚拟内存系统进行映射时，segment 和 section 会以不同的参数和权限被映射。</p>

<p>上面的代码中，<code>__TEXT</code> segment 包含了被执行的代码。它被以只读和可执行的方式映射。进程被允许执行这些代码，但是不能修改。这些代码也不能对自己做出修改，因此这些被映射的页从来不会被改变。</p>

<p><code>__DATA</code> segment 以可读写和不可执行的方式映射。它包含了将会被更改的数据。</p>

<p>第一个 segment 是 <code>__PAGEZERO</code>。它的大小为 4GB。这 4GB 并不是文件的真实大小，但是规定了进程地址空间的前 4GB 被映射为 不可执行、不可写和不可读。这就是为什么当读写一个 <code>NULL</code> 指针或更小的值时会得到一个 <code>EXC_BAD_ACCESS</code> 错误。这是操作系统在尝试防止<a href="http://www.xkcd.com/371/">引起系统崩溃</a>。</p>

<p>在 segment中，一般都会有多个 section。它们包含了可执行文件的不同部分。在 <code>__TEXT</code> segment 中，<code>__text</code> section 包含了编译所得到的机器码。<code>__stubs</code> 和 <code>__stub_helper</code> 是给动态链接器 (<code>dyld</code>) 使用的。通过这两个 section，在动态链接代码中，可以允许延迟链接。<code>__const</code> (在我们的代码中没有) 是常量，不可变的，就像 <code>__cstring</code> (包含了可执行文件中的字符串常量 &#8211; 在源码中被双引号包含的字符串) 常量一样。</p>

<p><code>__DATA</code> segment 中包含了可读写数据。在我们的程序中只有 <code>__nl_symbol_ptr</code> 和 <code>__la_symbol_ptr</code>，它们分别是 <em>non-lazy</em> 和 <em>lazy</em> 符号指针。延迟符号指针用于可执行文件中调用未定义的函数，例如不包含在可执行文件中的函数，它们将会延迟加载。而针对非延迟符号指针，当可执行文件被加载同时，也会被加载。</p>

<p>在 <code>_DATA</code> segment 中的其它常见 section 包括 <code>__const</code>，在这里面会包含一些需要重定向的常量数据。例如 <code>char * const p = "foo";</code> &#8211; <code>p</code> 指针指向的数据是可变的。<code>__bss</code> section 没有被初始化的静态变量，例如 <code>static int a;</code> &#8211; ANSI C 标准规定静态变量必须设置为 0。并且在运行时静态变量的值是可以修改的。<code>__common</code> section 包含未初始化的外部全局变量，跟 <code>static</code> 变量类似。例如在函数外面定义的 <code>int a;</code>。最后，<code>__dyld</code> 是一个 section 占位符，被用于动态链接器。</p>

<p>苹果的 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/Assembler/">OS X Assembler Reference</a> 文档有更多关于 section 类型的介绍。</p>

<h3 id="section">Section 中的内容</h3>

<p>下面，我们用 <code>otool(1)</code> 来观察一个 section 中的内容：</p>

<pre><code>% xcrun otool -s __TEXT __text a.out 
a.out:
(__TEXT,__text) section
0000000100000f30 55 48 89 e5 48 83 ec 20 48 8d 05 4b 00 00 00 c7 
0000000100000f40 45 fc 00 00 00 00 89 7d f8 48 89 75 f0 48 89 c7 
0000000100000f50 b0 00 e8 11 00 00 00 b9 00 00 00 00 89 45 ec 89 
0000000100000f60 c8 48 83 c4 20 5d c3 
</code></pre>

<p>上面是我们 app 中的代码。由于 <code>-s __TEXT __text</code> 很常见，<code>otool</code> 对其设置了一个缩写 <code>-t</code> 。我们还可以通过添加 <code>-v</code> 来查看反汇编代码：</p>

<pre><code>% xcrun otool -v -t a.out
a.out:
(__TEXT,__text) section
_main:
0000000100000f30    pushq   %rbp
0000000100000f31    movq    %rsp, %rbp
0000000100000f34    subq    $0x20, %rsp
0000000100000f38    leaq    0x4b(%rip), %rax
0000000100000f3f    movl    $0x0, 0xfffffffffffffffc(%rbp)
0000000100000f46    movl    %edi, 0xfffffffffffffff8(%rbp)
0000000100000f49    movq    %rsi, 0xfffffffffffffff0(%rbp)
0000000100000f4d    movq    %rax, %rdi
0000000100000f50    movb    $0x0, %al
0000000100000f52    callq   0x100000f68
0000000100000f57    movl    $0x0, %ecx
0000000100000f5c    movl    %eax, 0xffffffffffffffec(%rbp)
0000000100000f5f    movl    %ecx, %eax
0000000100000f61    addq    $0x20, %rsp
0000000100000f65    popq    %rbp
0000000100000f66    ret
</code></pre>

<p>上面的内容是一样的，只不过以反汇编形式显示出来。你应该感觉很熟悉，这就是我们在前面编译时候的代码。唯一的不同就是，在这里我们没有任何的汇编指令在里面。这是纯粹的二进制执行文件。</p>

<p>同样的方法，我们可以查看别的 section：</p>

<pre><code>% xcrun otool -v -s __TEXT __cstring a.out
a.out:
Contents of (__TEXT,__cstring) section
0x0000000100000f8a  Hello World!\n
</code></pre>

<p>或:</p>

<pre><code>% xcrun otool -v -s __TEXT __eh_frame a.out 
a.out:
Contents of (__TEXT,__eh_frame) section
0000000100000fe0    14 00 00 00 00 00 00 00 01 7a 52 00 01 78 10 01 
0000000100000ff0    10 0c 07 08 90 01 00 00 
</code></pre>

<h4>性能上需要注意的事项</h4>

<p>从侧面来讲，<code>__DATA</code> 和 <code>__TEXT</code> segment对性能会有所影响。如果你有一个很大的二进制文件，你可能得去看看苹果的文档：<a href="https://developer.apple.com/library/mac/documentation/Performance/Conceptual/CodeFootprint/Articles/MachOOverview.html">关于代码大小性能指南</a>。将数据移至 <code>__TEXT</code> 是个不错的选择，因为这些页从来不会被改变。</p>

<h4>任意的片段</h4>

<p>使用链接符号 <code>-sectcreate</code> 我们可以给可执行文件以 section 的方式添加任意的数据。这就是如何将一个 Info.plist 文件添加到一个独立的可执行文件中的方法。Info.plist 文件中的数据需要放入到 <code>__TEXT</code> segment 里面的一个 <code>__info_plist</code> section 中。可以将 <code>-sectcreate segname sectname file</code> 传递给链接器（通过将下面的内容传递给 clang）：</p>

<pre><code>-Wl,-sectcreate,__TEXT,__info_plist,path/to/Info.plist
</code></pre>

<p>同样，<code>-sectalign</code> 规定了对其方式。如果你添加的是一个全新的 segment，那么需要通过 <code>-segprot</code> 来规定 segment 的保护方式 (读/写/可执行)。这些所有内容在链接器的帮助文档中都有，例如 <code>ld(1)</code>。</p>

<p>我们可以利用定义在 <code>/usr/include/mach-o/getsect.h</code> 中的函数 <code>getsectdata()</code> 得到 section，例如 <code>getsectdata()</code> 可以得到指向 section 数据的一个指针，并返回相关 section 的长度。</p>

<h3 id="macho">Mach-O</h3>

<p>在 OS X 和 iOS 中可执行文件的格式为 <a href="https://en.wikipedia.org/wiki/Mach-o">Mach-O</a>：</p>

<pre><code>% file a.out 
a.out: Mach-O 64-bit executable x86_64
</code></pre>

<p>对于 GUI 程序也是一样的：</p>

<pre><code>% file /Applications/Preview.app/Contents/MacOS/Preview 
/Applications/Preview.app/Contents/MacOS/Preview: Mach-O 64-bit executable x86_64
</code></pre>

<p>关于 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachORuntime/index.html">Mach-O 文件格式</a> 苹果有详细的介绍。</p>

<p>我们可以使用 <code>otool(1)</code> 来观察可执行文件的头部 &#8211; 规定了这个文件是什么，以及文件是如何被加载的。通过 <code>-h</code> 可以打印出头信息：</p>

<pre><code>% otool -v -h a.out           a.out:
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64  X86_64        ALL LIB64     EXECUTE    16       1296   NOUNDEFS DYLDLINK TWOLEVEL PIE
</code></pre>

<p><code>cputype</code> 和 <code>cpusubtype</code> 规定了这个可执行文件能够运行在哪些目标架构上。<code>ncmds</code> 和 <code>sizeofcmds</code> 是加载命令，可以通过 <code>-l</code> 来查看这两个加载命令：</p>

<pre><code>% otool -v -l a.out | open -f
a.out:
Load command 0
      cmd LC_SEGMENT_64
  cmdsize 72
  segname __PAGEZERO
   vmaddr 0x0000000000000000
   vmsize 0x0000000100000000
...
</code></pre>

<p>加载命令规定了文件的逻辑结构和文件在虚拟内存中的布局。<code>otool</code> 打印出的大多数信息都是源自这里的加载命令。看一下 <code>Load command 1</code> 部分，可以找到 <code>initprot r-x</code>，它规定了之前提到的保护方式：只读和可执行。</p>

<p>对于每一个 segment，以及segment 中的每个 section，加载命令规定了它们在内存中结束的位置，以及保护模式等。例如，下面是 <code>__TEXT __text</code> section 的输出内容：</p>

<pre><code>Section
  sectname __text
   segname __TEXT
      addr 0x0000000100000f30
      size 0x0000000000000037
    offset 3888
     align 2^4 (16)
    reloff 0
    nreloc 0
      type S_REGULAR
attributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS
 reserved1 0
 reserved2 0
</code></pre>

<p>上面的代码将在 0x100000f30 处结束。它在文件中的偏移量为 3888。如果看一下之前 <code>xcrun otool -v -t a.out</code> 输出的反汇编代码，可以发现代码实际位置在 0x100000f30。</p>

<p>我们同样看看在可执行文件中，动态链接库是如何使用的：</p>

<pre><code>% otool -v -L a.out
a.out:
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 169.3.0)
    time stamp 2 Thu Jan  1 01:00:02 1970
</code></pre>

<p>上面就是我们可执行文件将要找到 <code>_printf</code> 符号的地方。</p>

<h2>一个更复杂的例子</h2>

<p>我们来看看有三个文件的复杂例子：</p>

<p><code>Foo.h</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="k">@interface</span> <span class="nc">Foo</span> : <span class="nc">NSObject</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">run</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>Foo.m</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &quot;Foo.h&quot;</span>
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">Foo</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">run</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">NSFullUserName</span><span class="p">());</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>helloworld.m</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &quot;Foo.h&quot;</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="err">@</span><span class="n">autoreleasepool</span> <span class="p">{</span>
</span><span class="line">        <span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Foo</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">        <span class="p">[</span><span class="n">foo</span> <span class="n">run</span><span class="p">];</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3>编译多个文件</h3>

<p>在上面的示例中，有多个源文件。所以我们需要让 clang 对输入每个文件生成对应的目标文件：</p>

<pre><code>% xcrun clang -c Foo.m
% xcrun clang -c helloworld.m
</code></pre>

<p>我们从来不编译头文件。头文件的作用就是在被编译的实现文件中对代码做简单的共享。<code>Foo.m</code> 和 <code>helloworld.m</code> 都是通过 <code>#import</code> 语句将 <code>Foo.h</code> 文件中的内容添加到实现文件中的。</p>

<p>最终得到了两个目标文件：</p>

<pre><code>% file helloworld.o Foo.o
helloworld.o: Mach-O 64-bit object x86_64
Foo.o:        Mach-O 64-bit object x86_64
</code></pre>

<p>为了生成一个可执行文件，我们需要将这两个目标文件和 Foundation framework 链接起来：</p>

<pre><code>xcrun clang helloworld.o Foo.o -Wl,`xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation
</code></pre>

<p>现在可以运行我们的程序了:</p>

<pre><code>% ./a.out 
2013-11-03 18:03:03.386 a.out[8302:303] Daniel Eggert
</code></pre>

<h3>符号表和链接</h3>

<p>我们这个简单的程序是将两个目标文件合并到一起的。<code>Foo.o</code> 目标文件包含了 <code>Foo</code> 类的实现，而 <code>helloworld.o</code> 目标文件包含了 <code>main()</code> 函数，以及调用/使用 <code>Foo</code> 类。</p>

<p>另外，这两个目标对象都使用了 Foundation framework。<code>helloworld.o</code> 目标文件使用了它的 autorelease pool，并间接的使用了  <code>libobjc.dylib</code> 中的 Objective-C 运行时。它需要运行时函数来进行消息的调用。<code>Foo.o</code> 目标文件也有类似的原理。</p>

<p>所有的这些东西都被形象的称之为符号。我们可以把符号看成是一些在运行时将会变成指针的东西。虽然实际上并不是这样的。</p>

<p>每个函数、全局变量和类等都是通过符号的形式来定义和使用的。当我们将目标文件链接为一个可执行文件时，链接器 (<code>ld(1)</code>) 在目标文件盒动态库之间对符号做了解析处理。</p>

<p>可执行文件和目标文件有一个符号表，这个符号表规定了它们的符号。如果我们用 <code>nm(1)</code> 工具观察一下 <code>helloworld.0</code> 目标文件，可以看到如下内容：</p>

<pre><code>% xcrun nm -nm helloworld.o
                 (undefined) external _OBJC_CLASS_$_Foo
0000000000000000 (__TEXT,__text) external _main
                 (undefined) external _objc_autoreleasePoolPop
                 (undefined) external _objc_autoreleasePoolPush
                 (undefined) external _objc_msgSend
                 (undefined) external _objc_msgSend_fixup
0000000000000088 (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_
000000000000008e (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_1
0000000000000093 (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_2
00000000000000a0 (__DATA,__objc_msgrefs) weak private external l_objc_msgSend_fixup_alloc
00000000000000e8 (__TEXT,__eh_frame) non-external EH_frame0
0000000000000100 (__TEXT,__eh_frame) external _main.eh
</code></pre>

<p>上面就是那个目标文件的所有符号。<code>_OBJC_CLASS_$_Foo</code> 是 <code>Foo</code> Objective-C 类的符号。该符号是 <em>undefined, external</em> 。<em>External</em> 的意思是指对于这个目标文件该类并不是私有的，相反，<code>non-external</code> 的符号则表示对于目标文件是私有的。我们的 <code>helloworld.o</code> 目标文件引用了类 <code>Foo</code>，不过这并没有实现它。因此符号表中将其标示为 undefined。</p>

<p>接下来是 <code>_main</code> 符号，它是表示 <code>main()</code> 函数，同样为 <em>external</em>，这是因为该函数需要被调用，所以应该为可见的。由于在 <code>helloworld.o</code> 文件中实现了 这个 main 函数。这个函数地址位于 0处，并且需要转入到  <code>__TEXT,__text</code> section。接着是 4 个 Objective-C 运行时函数。它们同样是 undefined的，需要链接器进行符号解析。</p>

<p>如果我们转而观察 <code>Foo.o</code> 目标文件，可以看到如下输出：</p>

<pre><code>% xcrun nm -nm Foo.o
0000000000000000 (__TEXT,__text) non-external -[Foo run]
                 (undefined) external _NSFullUserName
                 (undefined) external _NSLog
                 (undefined) external _OBJC_CLASS_$_NSObject
                 (undefined) external _OBJC_METACLASS_$_NSObject
                 (undefined) external ___CFConstantStringClassReference
                 (undefined) external __objc_empty_cache
                 (undefined) external __objc_empty_vtable
000000000000002f (__TEXT,__cstring) non-external l_.str
0000000000000060 (__TEXT,__objc_classname) non-external L_OBJC_CLASS_NAME_
0000000000000068 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_$_Foo
00000000000000b0 (__DATA,__objc_const) non-external l_OBJC_$_INSTANCE_METHODS_Foo
00000000000000d0 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_$_Foo
0000000000000118 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo
0000000000000140 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo
0000000000000168 (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_
000000000000016c (__TEXT,__objc_methtype) non-external L_OBJC_METH_VAR_TYPE_
00000000000001a8 (__TEXT,__eh_frame) non-external EH_frame0
00000000000001c0 (__TEXT,__eh_frame) non-external -[Foo run].eh
</code></pre>

<p>第五行至最后一行显示了 <code>_OBJC_CLASS_$_Foo</code> 已经定义了，并且对于 <code>Foo.o</code> 是一个外部符号 &#8211; ·Foo.o· 包含了这个类的实现。</p>

<p><code>Foo.o</code> 同样有 undefined 的符号。首先是使用了符号 <code>NSFullUserName()</code>，<code>NSLog()</code>和 <code>NSObject</code>。</p>

<p>当我们将这两个目标文件和 Foundation framework (是一个动态库) 进行链接处理时，链接器会尝试解析所有的 undefined 符号。它可以解析  <code>_OBJC_CLASS_$_Foo</code>。另外，它将使用 Foundation framework。</p>

<p>当链接器通过动态库 (此处是 Foundation framework) 解析成功一个符号时，它会在最终的链接图中记录这个符号是通过动态库进行解析的。链接器会记录输出文件是依赖于哪个动态链接库，并连同其路径一起进行记录。在我们的例子中，<code>_NSFullUserName</code>，<code>_NSLog</code>，<code>_OBJC_CLASS_$_NSObject</code>，<code>_objc_autoreleasePoolPop</code> 等符号都是遵循这个过程。</p>

<p>我们可以看一下最终可执行文件 <code>a.out</code> 的符号表，并注意观察链接器是如何解析所有符号的：</p>

<pre><code>% xcrun nm -nm a.out 
                 (undefined) external _NSFullUserName (from Foundation)
                 (undefined) external _NSLog (from Foundation)
                 (undefined) external _OBJC_CLASS_$_NSObject (from CoreFoundation)
                 (undefined) external _OBJC_METACLASS_$_NSObject (from CoreFoundation)
                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)
                 (undefined) external __objc_empty_cache (from libobjc)
                 (undefined) external __objc_empty_vtable (from libobjc)
                 (undefined) external _objc_autoreleasePoolPop (from libobjc)
                 (undefined) external _objc_autoreleasePoolPush (from libobjc)
                 (undefined) external _objc_msgSend (from libobjc)
                 (undefined) external _objc_msgSend_fixup (from libobjc)
                 (undefined) external dyld_stub_binder (from libSystem)
0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header
0000000100000e50 (__TEXT,__text) external _main
0000000100000ed0 (__TEXT,__text) non-external -[Foo run]
0000000100001128 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo
0000000100001150 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo
</code></pre>

<p>可以看到所有的 Foundation 和 Objective-C 运行时符号依旧是 undefined，不过现在的符号表中已经多了如何解析它们的信息，例如在哪个动态库中可以找到对应的符号。</p>

<p>可执行文件同样知道去哪里找到所需库：</p>

<pre><code>% xcrun otool -L a.out
a.out:
    /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1056.0.0)
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1197.1.1)
    /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 855.11.0)
    /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)
</code></pre>

<p>在运行时，动态链接器  <code>dyld(1)</code> 可以解析这些 undefined 符号，<code>dyld</code> 将会确定好 <code>_NSFullUserName</code> 等符号，并指向它们在 Foundation 中的实现等。</p>

<p>我们可以针对 Foundation 运行 <code>nm(1)</code>，并检查这些符号的定义情况： </p>

<pre><code>% xcrun nm -nm `xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation | grep NSFullUserName
0000000000007f3e (__TEXT,__text) external _NSFullUserName 
</code></pre>

<h3>动态链接编辑器</h3>

<p>有一些环境变量对于 <code>dyld</code> 的输出信息非常有用。首先，如果设置了 <code>DYLD_PRINT_LIBRARIES</code>，那么 <code>dyld</code> 将会打印出什么库被加载了：</p>

<pre><code>% (export DYLD_PRINT_LIBRARIES=; ./a.out )
dyld: loaded: /Users/deggert/Desktop/command_line/./a.out
dyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation
dyld: loaded: /usr/lib/libSystem.B.dylib
dyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation
dyld: loaded: /usr/lib/libobjc.A.dylib
dyld: loaded: /usr/lib/libauto.dylib
[...]
</code></pre>

<p>上面将会显示出在加载 Foundation 时，同时会加载的 70 个动态库。这是由于 Foundation 依赖于另外一些动态库。运行下面的命令：</p>

<pre><code>% xcrun otool -L `xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation
</code></pre>

<p>可以看到 Foundation 使用了 15 个动态库。</p>

<h3 id="dyld">dyld 的共享缓存</h3>

<p>当你构建一个真正的程序时，将会链接各种各样的库。它们又会依赖其他一些 framework 和 动态库。需要加载的动态库会非常多。而对于相互依赖的符号就更多了。可能将会有上千个符号需要解析处理，这将花费很长的时间：一般是好几秒钟。</p>

<p>为了缩短这个处理过程所花费时间，在 OS X 和 iOS 上的动态链接器使用了共享缓存，共享缓存存于 <code>/var/db/dyld/</code>。对于每一种架构，操作系统都有一个单独的文件，文件中包含了绝大多数的动态库，这些库都已经链接为一个文件，并且已经处理好了它们之间的符号关系。当加载一个 Mach-O 文件 (一个可执行文件或者一个库) 时，动态链接器首先会检查 <em>共享缓存</em> 看看是否存在其中，如果存在，那么就直接从共享缓存中拿出来使用。每一个进程都把这个共享缓存映射到了自己的地址空间中。这个方法大大优化了 OS X 和 iOS 上程序的启动时间。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-21T10:25:35+08:00" data-updated="true" itemprop="datePublished">Apr 21<span>st</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/http/'>Http</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/21/http/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/21/http/" itemprop="url">Http,Tcp,IP协议</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>当 app 和服务器进行通信的时候，大多数情况下，都是采用 HTTP 协议。HTTP 最初是为 web 浏览器而定制的，如果在浏览器里输入 <a href="http://www.objc.io">http://www.objc.io</a> ，浏览器会通过 HTTP 协议和 www.objc.io 所对应的服务器进行通信。</p>

<p>HTTP是运行在应用层上的应用协议，而不同的层级上都有相应的协议在运行。层级的堆栈关系一般可以这么描述：</p>

<pre><code>Application Layer -- e.g. HTTP
----
Transport Layer -- e.g. TCP
----
Internet Layer -- e.g. IP
----
Link Layer -- e.g. IEEE 802.2
</code></pre>

<p>所谓的 <a href="https://en.wikipedia.org/wiki/OSI_model">OSI（Open Systems Interconnection，开放式系统互联）</a>模型定义了七层结构。本文会关注应用层 (application layer)、传输层 (transport layer) 和网络层 (internet layer)，它们分别代表了典型的 HTTP 的应用的 HTTP，TCP 以及 IP。在 IP 之下的是数据连接和物理层级，比如像 Ethernet 的实现之类的东西（Ethernet 拥有一个数据连接部分以及一个物理部分）。</p>

<p>如上文所述，我们只关注应用层，传输层和互联网层的部分，更确切的说，着重探讨一种特殊的混合模式：基于 IP 的 TCP，以及基于 TCP 实现的 HTTP。这就是我们每天使用的 app 的基本网络配置。</p>

<p>通过本文，希望大家能够对HTTP工作原理有一个细致的了解，知道一些常见的 HTTP 问题的产生原因，从而能在实践中尽量避免这些问题的发生。</p>

<p>其实在互联网上传递数据的方式并不只 HTTP 一种。HTTP 之所以被广泛使用的原因是其非常稳定、易用，即便是防火墙一般也是允许 HTTP 协议穿透的。</p>

<p>接下来我们从最低的一层谈起，说说 IP 网络协议。</p>

<h2 id="ipipinternetproctocol">IP网络协议 (IP-Internet Proctocol)</h2>

<p>TCP/IP 中的 IP 是<a href="https://en.wikipedia.org/wiki/Internet_Protocol">网络协议 (Internet Protocol)</a> 的缩写。从字面意思便知，它是互联网众多协议的基础。</p>

<p>IP 实现了<a href="https://en.wikipedia.org/wiki/Packet_switching">分组交换网络</a>。在协议下，机器被叫做 <em>主机 (host)</em>，IP 协议明确了 host 之间的资料包（数据包）的传输方式。</p>

<p>所谓数据包是指一段二进制数据，其中包含了发送源主机和目标主机的信息。IP 网络负责源主机与目标主机之间的数据包传输。IP 协议的特点是 <em>best effort</em>（尽力服务，其目标是提供有效服务并尽力传输）。这意味着，在传输过程中，数据包可能会丢失，也有可能被重复传送导致目标主机收到多个同样的数据包。</p>

<p>IP 网络中的主机都配有自己的地址，被称为 <em>IP 地址</em>。每个数据包中都包含了源主机和目标主机的 IP 地址。IP 协议负责路径计算，即 IP 数据包在网络中的传输传输时，数据包所经过的每一个主机节点都会读取数据包中的目标主机地址信息，以便选择朝什么地方传送数据包。</p>

<p>今天，绝大多数的数据包仍旧是 IPv4（Internet Protocol version 4 网际协议版本 4）的，每一个 IPv4 地址是长度为 32 位。常见采用 <a href="https://en.wikipedia.org/wiki/Dotted_decimal">dotted-decimal</a>（点分十进制）表示法，具体形式如：198.51.100.42。</p>

<p>新的 IPv6 标准也正在逐渐推广中。它有更大的地址空间：长度为 128 位，这使得数据包在网络中传输时的寻址更容易一些。另外，由于有更多的地址可以分配，诸如<a href="https://en.wikipedia.org/wiki/Network_address_translation">网络地址转换</a>等问题也迎刃而解。IPv6 的表示形式为：八组十六进制数以冒号分割，比如：2001:0db8:85a3:0042:1000:8a2e:0370:7334。</p>

<h2 id="iphearder">IP Hearder</h2>

<p>一个 IP 数据包通常包含 header (报头信息) 和 payload (有效载荷)。</p>

<p>payload 中的内容即是要传输的真正信息，而 header 承载的是与传输数据有关的元数据 (metadata)。</p>

<h3 id="ipv4header">IPv4 Header</h3>

<p>IPv4的 header 信息内容如下：</p>

<pre><code>IPv4 Header Format
Offsets  Octet    0                       1                       2                       3
Octet    Bit      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31|
 0         0     |Version    |IHL        |DSCP            |ECN  |Total Length                                   |
 4        32     |Identification                                |Flags   |Fragment Offset                       |
 8        64     |Time To Live           |Protocol              |Header Checksum                                |
12        96     |Source IP Address                                                                             |
16       128     |Destination IP Address                                                                        |
20       160     |Options (if IHL &gt; 5)                                                                          |
</code></pre>

<p>header 长度为 20 字节（不包含极少用到的可选项信息）。</p>

<p>header 信息中最关键的是源和目标 IP 地址。除此之外，版本信息是 4，代表 IPv4。<em>protocol</em>（协议区）代表 payload 采用的传输协议。TCP 的协议号是 6。Total Length（总长度区）标明了 header 加 payload 整个数据包的大小。</p>

<p>详情参看维基百科中关于 <a href="https://en.wikipedia.org/wiki/IPv4_header">IPv4 的条目</a>，里面有关于 header 各个区域信息的详细介绍。</p>

<h3 id="ipv6header">IPv6 Header</h3>

<p>IPv6 的地址长度为 128 位。IPv6 的 header 信息内容如下：</p>

<pre><code>Offsets  Octet    0                       1                       2                       3
Octet    Bit      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31|
 0         0     |Version    |Traffic Class         |Flow Label                                                 |
 4        32     |Payload Length                                |Next Header            |Hop Limit              |
 8        64     |Source Address                                                                                |
12        96     |                                                                                              |
16       128     |                                                                                              |
20       160     |                                                                                              |
24       192     |Destination Address                                                                           |
28       224     |                                                                                              |
32       256     |                                                                                              |
36       288     |                                                                                              |
</code></pre>

<p>IPv6 header 采用固定长度 40 字节。经过多年来对 IPv4 使用的总结，如今 IPv6 的 header 信息简化了许多。</p>

<p>除了源和目标地址这种必备信息外，IPv6 提供专门的 <em>next header</em> 区域来指明紧接 header 的数据是什么。也就是说，IPv6 允许在数据包中将 header 链接起来。每一个被链接的 IPv6 header 都会有一个 <em>next header</em> 字段，直到到达实际的 payload 数据。比如说，当 <em>next header</em> 的值为 6 (TCP 的协议号) 时，数据包的其他信息就是 TCP 协议要传输的数据。</p>

<p>同样的，更多信息请参考维基百科上关于 <a href="https://en.wikipedia.org/wiki/IPv6_packet">IPv6 数据包的条目</a>。</p>

<h2 id="fragmentation">Fragmentation (数据分片)</h2>

<p>由于底部链路层对所传输的数据帧有最大长度限制（最大传输单元，MTU），所以有时候 IPv4 需要对所传数据包进行<a href="https://en.wikipedia.org/wiki/IP_fragmentation">分片</a>。具体表现为，如果数据包尺寸超过了所要经过的数据链路的最大传输限制，路由就会对数据包进行分片。当分片数据包到达目标主机后，可以根据分片信息进行数据重组。当然，数据发送源有权决定路由是否启用对传输数据包进行分片，假如所传输的数据超过了输送限制，又禁止了路由分片，发送源会收到 <a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a>(Internet Control Message Protocol，Internet报文控制协议) 的<em>数据帧超长</em>报告信息。</p>

<p>在IPv6中，如果数据包超限制，路由会直接丢弃数据包并且向发送源回传 <a href="https://en.wikipedia.org/wiki/ICMPv6">ICMP6</a> 的<em>数据帧超长</em>报告信息。源和目标两端会基于这个特性来进行<a href="https://en.wikipedia.org/wiki/Path_MTU">路径 MTU 发现</a>，以此寻找两端之间<em>最大传输单元</em>（maximum transfer unit）所在的路由。找到 MTU 路由后，仅当上层数据包的最小 payload 确实超过了 MTU，IPv6 才会进行<a href="https://en.wikipedia.org/wiki/IPv6_packet#Fragmentation">分片</a>传输。对于 IPv6 下的 TCP 来说，这不会造成什么问题。</p>

<h2 id="tcptrasnmissioncontrolprotocol">TCP - 传输控制协议 (Trasnmission Control Protocol)</h2>

<p>TCP 层位于 IP 层之上，是最受欢迎的因特网通讯协议之一，人们通常用 TCP/IP 来泛指整个因特网协议族。</p>

<p>刚刚提到，IP 协议允许两个主机之间传送单一数据包。为了保证对所传送数据包达到<em>尽力服务</em>的目的，最终的传输的结果可能是数据包乱序、重复甚至丢包。</p>

<p>TCP 是基于 IP 层的协议。但是 TCP 是可靠的、有序的、有错误检查机制的基于字节流传输的协议。这样当两个设备上的应用通过 TCP 来传递数据的时候，总能够保证目标接收方收到的数据的顺序和内容与发送方所发出的是一致的。TCP 做的这些事看起来稀松平常，但是比起 IP 层的粗旷处理方式已经是有显著的进步了。</p>

<p>应用程序之间可以通过 TCP 建立链接。TCP 建立的是双向连接，通信双方可以同时进行数据的传输。连接的双方都不需要操心数据是否分块，或者是否采用了<em>尽力服务</em>等。TCP 会确保所传输的数据的正确性，即接受方收到的数据与发出方的数据一致。</p>

<p>HTTP 是典型的 TCP 应用。用户浏览器（应用 1）与 web 服务器（应用 2）建立连接后，浏览器可以通过连接发送服务请求，web 服务器可以通过同样的连接对请求做出响应。</p>

<p>同一个 host 主机上可以有多个应用同时使用 TCP 协议。TCP 用不同的<em>端口</em>来区分应用。作为连接的两端，发送源和接收目标分别拥有自己的 IP 地址和端口号。凭借这样一对 IP 地址和端口号，就可以唯一标识一个连接。</p>

<p>使用 HTTPS 的 web 服务器会<em>监听</em> 443 端口。浏览器作为发送源会启用一个临时端口结合自己的 IP 地址与目标服务器对应的端口和 IP 地址建立 TCP 连接。</p>

<p>TCP 在 IPv4 和 IPv6 上是无差别运行的。所以，如果 IPv4 的 <em>Protocol</em> 或 IPv6 的 <em>Next Hearder</em>的协议号被设置成 6，表示执行 TCP 协议。</p>

<h3 id="tcpsegmentstcp">TCP Segments (TCP 报文段)</h3>

<p>主机之间传输的数据流一般先会被分块，再转化成 TCP 的报文段，最终会生成 IP 数据包中的 payload 载荷数据。</p>

<p>每个 TCP 报文段都有 header 信息和对应的载荷 payload。payload 信息就是待传输的数据块。TCP 报文段的 header 信息中主要包含的是源和目标端口号，至于说源和目标的 IP 地址信息则已经包含在 IP header 信息中了。</p>

<p>TCP 的报文段 header 信息中还有报文序列号、确认号等其他一些用于管理连接的信息。</p>

<p>所谓序列号信息，其实就是为每个报文段分配的唯一编号。第一个报文段的序列号是随机的，比如：1721092979，其后的每一个报文段的序列号都以此号为基础依次加 1，1721092980，1721092981 等等。至于确认号，是目标端反馈给源的确认信息，通知源目前已经接到哪些报文段了。由于 TCP 是双向的，所以数据和确认信息发送也都是双向的。</p>

<h3 id="tcp">TCP 连接</h3>

<p>连接管理是 TCP 的核心功能之一，而且协议需要解决由于IP层采用不可靠传输引发的一系列复杂问题。下面会分别介绍TCP的连接建立、数据传输以及连接终止的详细过程。</p>

<p>TCP 连接全过程的状态变化是很复杂的（参考 <a href="https://upload.wikimedia.org/wikipedia/commons/f/f6/Tcp_state_diagram_fixed_new.svg">TCP 状态图</a>）。但是大多数情况下还是比较简单的。</p>

<h4>连接建立</h4>

<p>TCP 连接都是建立在两个主机之间的。所以，每个连接建立过程中都存在两个角色：一端（例如 web 服务器）监听连接，另一端（例如应用）主动连接正在监听的一端（web 服务器）。服务器端的这种监听行为被称为 <em>passive open</em>（被动打开）。客户端主动连接服务器的行为被称为 <em>active open</em>（主动打开）。</p>

<p>TCP 会通过三次握手来完成连接建立，具体过程是这样的：</p>

<ol>
<li>客户端首先向服务端发送一个 <strong>SYN</strong> 包和一个随机序列号 A  </li>
<li>服务端收到后会回复客户端一个 <strong>SYN-ACK</strong> 包以及一个确认号（用于确认收到 SYN）A+1，同时再发送一个随机序列号 B  </li>
<li>客户端收到后会发送一个 <strong>ACK</strong> 包以及确认号（用于确认收到 SYN-ACK）B+1 和序列号 A+1 给服务端</li>
</ol>

<p><strong>SYN</strong> 是 <em>synchronize sequence numbers</em> (同步序列号) 的缩写。两端在传递数据时，所传递的每个 TCP 报文段都有一个序列号。就是利用这种机制，TCP 可以确保分块传输的数据包最终都以正确的个数和顺序抵达目标端。在正式传输开始之前，源和目标端需要同步确认第一个报文的序列号。</p>

<p><strong>ACK</strong> 是 <em>acknowledgment</em> (确认)的缩写。当某一端接到了报文包后，通过回传已报文序列号来确认接收到报文这件事。</p>

<p>运行如下语句：</p>

<pre><code>curl -4 http://www.apple.com/contact/
</code></pre>

<p>这是通过 <code>curl</code> 命令与 www.apple.com 的 80 端口创建一个 TCP 连接。</p>

<p>www.apple.com 所在服务器 23.63.125.15（注意，整个 IP 不是固定的）会监听 80 端口。我们自己的 IP 地址是 <code>10.0.1.6</code>，启用的<em>临时端口</em> <code>52181</code>（这个端口是从可用端口中随机选择的）。利用 <code>tcpdump(1)</code> 输出的三次握手过程是这样的：</p>

<pre><code>% sudo tcpdump -c 3 -i en3 -nS host 23.63.125.15
18:31:29.140787 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [S], seq 1721092979, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 743929763 ecr 0,sackOK,eol], length 0
18:31:29.150866 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [S.], seq 673593777, ack 1721092980, win 14480, options [mss 1460,sackOK,TS val 1433256622 ecr 743929763,nop,wscale 1], length 0
18:31:29.150908 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673593778, win 8235, options [nop,nop,TS val 743929773 ecr 1433256622], length 0
</code></pre>

<p>这里信息量很大。下面要逐个分析一下。</p>

<p>最左边是系统时间。当时执行命令的时间是晚上18:31。后面的 <code>IP</code> 代表的是这些都是 IP 协议数据包。</p>

<p>接下来看这段 <code>10.0.1.6.52181 &gt; 23.63.125.15.80</code>，这一对是源和目标端的 IP 地址＋端口。第一行和第三行是客户端发向服务端的信息，第二行是服务端发向客户端的。<code>tcpdump</code> 会自动把端口号加到 IP 地址后头，比如 <code>10.0.1.6.52181</code> 表示 IP 地址为 10.0.1.6，端口号为 52181。</p>

<p><code>Flags</code> 表示 TCP 报文段 header 信息中的一些缩写标识：<code>S</code> 代表 <strong>SYN</strong>，<code>.</code> 代表<strong>ACK</strong>，<code>P</code> 代表<strong>PUSH</strong>，<code>F</code> 是 <strong>FIN</strong>。还有一些其他的标识，这边就不罗列了。注意上面三行 Flags 中先是携带 <strong>SYN</strong> ，接着是 <strong>SYN-ACK</strong>，最后是 <strong>ACK</strong>，这就是三次握手确认的全过程。</p>

<p>另外，第一行中客户端发送了一个随机序列号 1721092979 (就是上文所说的A)给服务器。第二行展示的是服务器回传给客户端的确认号 1721092980 (A+1) 和一个随机序列号 673593777 (B)。 最后在第三行，客户端将自己的确认号 673593778 (B+1) 发还给服务端。</p>

<h4>其他选项</h4>

<p>当然，在连接建立过程中还会配置一些其他的信息。比如第一行中客户端发送的内容：</p>

<pre><code>[mss 1460,nop,wscale 4,nop,nop,TS val 743929763 ecr 0,sackOK,eol]
</code></pre>

<p>还有第二行服务端发送的：</p>

<pre><code>[mss 1460,sackOK,TS val 1433256622 ecr 743929763,nop,wscale 1]
</code></pre>

<p>其中 <code>TS val</code> / <code>ecr</code> 是 TCP 用来创建 RTT 往返时间 (round-trip time) 的。<code>TS val</code> 是发送方的 <em>时间戳</em> (time stamp)，<code>ecr</code> 是<em>相应应答 (echo reply)</em> 时间戳，通常情况下就是发送方收到的最后时间戳。TCP 以 RTT 作为其拥塞控制算法 (congestion-control algorithms) 的依据。</p>

<p>连接的两端都发送 <code>sackOK</code>。这样会启用<em>选择性确认 (Selective Acknowledgement)</em> 机制，使连接双方能够确认收到的字节范围。一般情况下，确认机制只是确认接受方已收到的数据的字节总数。<a href="http://tools.ietf.org/html/rfc2018#section-3">RFC  2018 第 3 部分</a>有对 SACK 的详细阐述。</p>

<p><code>mss</code> 选项声明了<em>最大报文长度 (Maximum Segment Size)</em>，表示接收端希望接收的单个报文的最大长度（以字节为单位）。<code>wscale</code> 是 <em>窗口放大因子 (window scale factor)</em>，稍后会详细说明。</p>

<h4>数据传输</h4>

<p>一旦建立了连接，双方就可以互发数据了。发送端所发出的每个报文段都有一个序列号，这个序列号与当下已传送的字节总数有关。接收端会针对已接收的数据包向源端发送确认报文，确认信息同样是由报文 header 所携带的 <strong>ACK</strong>。</p>

<p>假设现在传送的信息是除最后一个报文 5 字节外，其他都是 10 字节。具体是这样的：</p>

<pre><code>host A sends segment with seq 10
host A sends segment with seq 20
host A sends segment with seq 30    host B sends segment with ack 10
host A sends segment with seq 35    host B sends segment with ack 20
                                    host B sends segment with ack 30
                                    host B sends segment with ack 35
</code></pre>

<p>整个机制是双向运转的。A 主机会持续的发送数据包。B 收到数据包后会向 A 发送确认信息。A 发送数据包的过程不需要等待 B 的确认。</p>

<p>TCP 将流量控制和其他一系列复杂机制结合起来进行拥塞控制。需要处理以下问题：针对丢失的报文采用重发机制，同时还需要动态的调整发送报文的频率。</p>

<p>流量控制的原则是发送方发送数据的速度不能比接收方处理数据的速度快。接收方，也就是所谓的 <em>接收窗口 (receive window)</em> 会告知发送方自身接收窗口数据缓冲区的大小。从上面 <code>tcpdump</code> 的输出来看，窗口大小是 <code>win 65535</code>，<code>wscale</code>（窗口放大因子）是 4。这些数字的意思是说，<code>10.0.1.6</code> 主机的接收窗口大小是 4＊64 kB = 256 kB，<code>23.63.125.15</code> 主机的 <code>win</code> 是 14480，wscale 是 1，接收窗口约为 14KB。总之，不管哪一方作为数据接收方，都会向对方通报自己的接收窗口大小。</p>

<p>拥塞控制要更复杂一些。所有拥塞控制的目标都是要计算出当前网络中数据传输的最佳速率。所谓最佳速率就是要达到一种微妙的平衡。一方面，是希望速度越快越好，另一方面，速度快意味着数据传输多，这样处理性能会大打折扣甚至导致崩溃。而这种<a href="https://en.wikipedia.org/wiki/Congestive_collapse#Congestive_collapse">超负荷崩溃</a>是分组交换网络的固有特点。当负载过大，数据包之间会产生拥塞，直接导致丢包率急速上升。</p>

<p>拥塞控制还需要充分考虑对流量的影响。<a href="https://www.rfc-editor.org/rfc/rfc5681.txt">RFC 5681</a> 中对 TCP 拥塞控制有 6,000 字左右的阐述。发送方要时刻关注来自接收方的确认信息。要做到这点并不简单，有的时候还需要一定的妥协。要知道底部 IP 协议数据包是无序传输的，数据包会丢失也会重复。发送方需要评估 RTT 往返时间，然后基于 RTT 去确定是否收到了接收方的确认信息。重发数据包也有很大代价，除了连接延迟问题，网络的负载也会发生明显的波动。导致 TCP 需要不停的去适应当前网络情况。</p>

<p>更重要的是，TCP 连接本身是易变的。除了数据传输，连接的两端还会不时的发送一些提醒和确认信息以便可以适当的调整状态来维持连接。</p>

<p>基于这种一直在相互协调中的连接关系，TCP 连接往往会是短暂而低效的。在建立连接的初期，TCP 协议算法还不能完全了解当前网络状况。而在连接将要结束的时候，反馈给发送方的信息又可能不充分，这样就很难对连接状况做出实时的合理的评估。</p>

<p>之前展示了客户端和服务端之间交换的三段报文。再看看关于连接的其他信息：</p>

<pre><code>18:31:29.150955 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [P.], seq 1721092980:1721093065, ack 673593778, win 8235, options [nop,nop,TS val 743929773 ecr 1433256622], length 85
18:31:29.161213 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], ack 1721093065, win 7240, options [nop,nop,TS val 1433256633 ecr 743929773], length 0
</code></pre>

<p>客户端 <code>10.0.1.6</code> 发送的第一段报文长度是 85 bytes (HTTP 请求)。由于在上一个报文发送后没有收到来自服务端的信息，所以 ACK 确认号的值不变。</p>

<p>服务端 <code>23.63.125.15</code> 只是对接收客户端的数据进行确认回复，没有向客户端发送数据，所以 <code>length</code> 为 0。由于当前连接是采用<em>选择性确认 (Selective acknowledgments)</em>，所以序列号和确认号是之间的字节长度是从 1721092980 到 1721093065，也就是 85 bytes。接收方发送的 ACK 确认号是 1721093065，这代表目前已接收的数据确认累计到 1721093065 字节了。至于说为什么数字会如此之大，这要说到初次握手时发出的随机数，数字的范围和那个初始数字是相关的。</p>

<p>这种模式会一直持续到全部数据传送完成：</p>

<pre><code>18:31:29.189335 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673593778:673595226, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190280 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673595226:673596674, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190350 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673596674, win 8101, options [nop,nop,TS val 743929811 ecr 1433256660], length 0
18:31:29.190597 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673596674:673598122, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190601 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673598122:673599570, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190614 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673599570:673601018, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190616 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673601018:673602466, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190617 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673602466:673603914, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190619 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673603914:673605362, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190621 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673605362:673606810, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190679 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673599570, win 8011, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
18:31:29.190683 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673602466, win 7830, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
18:31:29.190688 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673605362, win 7830, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
18:31:29.190703 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673605362, win 8192, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
18:31:29.190743 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673606810, win 8192, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
18:31:29.190870 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673606810:673608258, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.198582 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [P.], seq 673608258:673608401, ack 1721093065, win 7240, options [nop,nop,TS val 1433256670 ecr 743929811], length 143
18:31:29.198672 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673608401, win 8183, options [nop,nop,TS val 743929819 ecr 1433256660], length 
</code></pre>

<h4>终止连接</h4>

<p>最终连接会终止（或结束）。连接的每一端都会发送 <strong>FIN</strong> 标识给另一端来声明结束传输，接着另一端会对收到 <strong>FIN</strong> 进行确认。当连接两端均发送完各自 <strong>FIN</strong> 和做出相应的确认后，连接将会彻底关闭：</p>

<pre><code>18:31:29.199029 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [F.], seq 1721093065, ack 673608401, win 8192, options [nop,nop,TS val 743929819 ecr 1433256660], length 0
18:31:29.208416 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [F.], seq 673608401, ack 1721093066, win 7240, options [nop,nop,TS val 1433256680 ecr 743929819], length 0
18:31:29.208493 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673608402, win 8192, options [nop,nop,TS val 743929828 ecr 1433256680], length 0
</code></pre>

<p>这里值得注意的是第二行，<code>23.63.125.15</code> 发送了 <strong>FIN</strong>，同时在这个报文信息中还对第一行中另一端发送的 <strong>FIN</strong> 予以 <strong>ACK</strong>（以.代表）确认。</p>

<h2 id="httphypertexttransferprotocol">HTTP — 超文本传输协议 (Hypertext Transfer Protocol)</h2>

<p>1989 年，Tim Berners Lee 在 <a href="https://en.wikipedia.org/wiki/CERN">CERN</a>(European Organization for Nuclear Research 欧洲原子核研究委员会) 担任软件咨询师的时候，开发了一套程序，奠定了<a href="https://en.wikipedia.org/wiki/World_Wide_Web">万维网</a>的基础。<em>HyperText Transfer Protocol</em>（超文本转移协议，即HTTP）是用于从 WWW 服务器传输超文本到本地浏览器的传送协议。<a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 定义了今天普遍使用的一个版本：HTTP 1.1。</p>

<h3>请求与响应</h3>

<p>HTTP 采用简单的请求和响应机制。在 Safari 输入 <a href="http://www.apple.com">http://www.apple.com</a> 时，会向 <code>www.appple.com</code> 所在的服务器发送一个 HTTP 请求。服务器会对请求做出一个响应，将请求结果信息返回给 Safari。</p>

<p>每一个请求都有一个对应的响应信息。请求和响应遵从同样的格式。第一行是请求行或者响应状态行。接下来是 header 信息，header 信息之后会有一个空行。空行之后是 body 请求信息体。</p>

<h3>一个简单请求</h3>

<p>当 <a href="https://en.wikipedia.org/wiki/Safari_%28web_browser%29">Safari</a> 加载 HTML 页面 <a href="http://www.objc.io/about.html">http://www.objc.io/about.html</a> 的时候，先是发送 HTTP 请求到 <code>www.objc.io</code>，请求的内容是：</p>

<pre><code>GET /about.html HTTP/1.1
Host: www.objc.io
Accept-Encoding: gzip, deflate
Connection: keep-alive
If-None-Match: "a54907f38b306fe3ae4f32c003ddd507"
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
If-Modified-Since: Mon, 10 Feb 2014 18:08:48 GMT
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.74.9 (KHTML, like Gecko) Version/7.0.2 Safari/537.74.9
Referer: http://www.objc.io/
DNT: 1
Accept-Language: en-us
</code></pre>

<p>第一行是<strong>请求行</strong>。它包含三部分信息：动作，资源信息，还有 HTTP 的版本。</p>

<p>本例中，动作是 GET。所谓动作也就是常说的 HTTP <a href="https://en.wikipedia.org/wiki/HTTP_method#Request_methods">请求方法</a>。资源信息表明所请求的资源。例子中的资源信息是 <code>/about.html</code>，这表示我们想 get 服务器的在 <code>/about.html</code> 位置中的文档。当前 HTTP 版本是 <code>HTTP/1.1</code>。</p>

<p>接下来 10 行是 HTTP header 信息。跟着是一行空行。例子中的请求没有 body 信息。</p>

<p>header 的作用是向服务器传递一些额外的辅助信息，它的内容比较宽泛。维基百科中有<a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">常用 HTTP header 关键字</a>信息的清单。例子中的 header 信息 <code>Host: www.objc.io</code> 表示告诉服务器，本次请求的服务器名称是什么。这样可以让同一个服务器处理针对多个<a href="https://en.wikipedia.org/wiki/Domain_names">域名</a>的请求。</p>

<p>下面是一些常见的header信息:</p>

<pre><code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us
</code></pre>

<p>服务器可能具备返回多种媒体类型的能力，Accept 表示 Safari 希望接收的媒体格式类型。<code>text/html</code> 是<a href="https://en.wikipedia.org/wiki/Mime_type">互联网媒体类型</a>(Internet media types)，也被称为 MIME 类型或者是内容类型 (Content-types)。<code>q=0.9</code> 表示 Safari 对给定媒体类型的优先级要求。<code>Accept-Language</code> 代表 Safari 希望接收的自然语言清单。这会要求服务器尽可能的根据清单要求去匹配相应的语言。</p>

<pre><code>Accept-Encoding: gzip, deflate
</code></pre>

<p>通过这个header，Safari 告诉服务器可以对响应 body 做压缩处理。如果 header 信息中没有设置压缩标识，那么服务器就必须返回没有压缩过的信息。压缩可以大大减少数据的传输量，在文本信息 (比如 HTML) 中尤为明显。</p>

<pre><code>If-Modified-Since: Mon, 10 Feb 2014 18:08:48 GMT
If-None-Match: "a54907f38b306fe3ae4f32c003ddd507"
</code></pre>

<p>这两行信息表明 Safari 已经对请求结果做过缓存。如果服务器上的待请求内容在 2 月 10 号以后发生过变化或者是 ETag 与 <code>a54907f38b306fe3ae4f32c003ddd507</code> 不匹配，这就表示请求结果与当前缓存信息不一致，需要服务器返回最新的请求结果。</p>

<p><code>User-Agent</code> 是告知服务器当前发送请求的客户端类型。</p>

<h3>一个简单响应</h3>

<p>作为上面请求的响应，服务器的返回是：</p>

<pre><code>HTTP/1.1 304 Not Modified
Connection: keep-alive
Date: Mon, 03 Mar 2014 21:09:45 GMT
Cache-Control: max-age=3600
ETag: "a54907f38b306fe3ae4f32c003ddd507"
Last-Modified: Mon, 10 Feb 2014 18:08:48 GMT
Age: 6
X-Cache: Hit from cloudfront
Via: 1.1 eb67cb25620df959ba21a943fbc49ef6.cloudfront.net (CloudFront)
X-Amz-Cf-Id: dDSBgR86EKBemW6el-pBI9kAnuYJEaPQYEqGmBnilD12CbixCuZYVQ==
</code></pre>

<p>第一行是<em>状态行</em>。它包括 HTTP 版本，<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">状态码</a> (304) 和状态信息。</p>

<p>HTTP 定义了<a href="https://en.wikipedia.org/wiki/Http_status_codes">一系列状态码</a>，它们各有用途。本例中的 <strong>304</strong> 表示所请求的信息自上次访问以来没有变化。</p>

<p>响应中没有包含 body 信息。也就是说服务器通知客户端：你的版本已经是最新了，可以直接使用当前缓存信息。</p>

<h3>关闭缓存</h3>

<p>用 <code>curl</code> 发送一个请求：</p>

<pre><code>% curl http://www.apple.com/hotnews/ &gt; /dev/null
</code></pre>

<p><code>curl</code> 没有使用本地缓存。整个请求会是这样的：</p>

<pre><code>GET /hotnews/ HTTP/1.1
User-Agent: curl/7.30.0
Host: www.apple.com
Accept: */*
</code></pre>

<p>这个请求与之前 Safari 发的请求很类似。但是 <code>curl</code> 请求的 header 信息中没有 <code>If-None-Match</code>，所以服务器必须将请求结果返回。</p>

<p>此处 <code>curl</code> 头信息中声明的 <code>Accept: */*</code> 表示可以接收任何媒体类型。</p>

<p>来自 www.apple.com 的响应：</p>

<pre><code>HTTP/1.1 200 OK
Server: Apache
Content-Type: text/html; charset=UTF-8
Cache-Control: max-age=424
Expires: Mon, 03 Mar 2014 21:57:55 GMT
Date: Mon, 03 Mar 2014 21:50:51 GMT
Content-Length: 12342
Connection: keep-alive

&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US"&gt;
&lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
</code></pre>

<p>后面还会有一些，现在收到的响应里 body 中包含了 HTML 文档信息。</p>

<p>Apple 服务器响应的<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">状态码</a>是 <em>200</em>，这是标准的表示 HTTP 请求成功的状态码。</p>

<p>服务器同时还告知响应媒体类型是 <code>text/html</code>；字符集 <code>charset=UTF-8</code>；内容长度 <code>Content-Length：12342</code>，代表了 body 信息的大小。</p>

<h2 id="httpshttp">HTTPS - 安全的 HTTP</h2>

<p><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer Security</a> (安全传输层协议，TLS) 是一种基于 TCP 的加密协议。它支持两件事：传输的两端可以互相验证对方的身份，以及加密所传输的数据。基于 TLS 的 HTTP 请求就是 HTTPS。</p>

<p>用 HTTPS 去替代 HTTP，在安全方面会有显著的提升。也许你还会采用一些其他的安全措施，总之这都会为安全通信提供保障。</p>

<h3 id="tls12">TLS 1.2</h3>

<p>如果服务器支持的话，你应该将 <code>TLSMinimumSupportedProtocol</code> 设置为 <code>kTLSProtocol12</code>，以要求使用 <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_1.2">TLS 1.2</a> 版本。这能有效的防御<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">中间人攻击</a>。</p>

<h3 id="certificatepinning">证书锁定 (Certificate Pinning)</h3>

<p>如果不确定数据接收方的身份，那么即便对所传输数据进行加密也没什么意义。服务器的证书可以表明服务器的身份，只允许和持有某个特定证书的一方建立连接，就就是<a href="https://en.wikipedia.org/wiki/Certificate_pinning#Certificate_pinning">证书锁定</a>。</p>

<p>如果一个客户端通过 TLS 和服务器建立连接，操作系统会验证服务器证书的有效性。当然，有很多手段可以绕开这个校验，最直接的是在 iOS 设备上安装证书并且将其设置为可信的。这种情况下，实施<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">中间人攻击</a>也不是什么难事。</p>

<p>可以使用证书锁定来规避这种风险（或者说是将风险降到最低）。当建立 TLS 连接后，应立即检查服务器的证书，不仅要验证证书的有效性，还需要确定证书和其持有者是否匹配。考虑到应用和服务器需要同时升级证书的要求，这种方式比较适合应用在访问自家服务器的情况下。</p>

<p>为了实现证书锁定，在建立连接的过程中需要对服务器进行信任检查 (<em>server trust</em>)。每当通过 <code>NSURLSession</code> 创建了连接，<code>NSURLSession</code> 的代理就会收到一个 <code>-URLSession:didReceiveChallenge:completionHandler:</code> 的调用。传递的参数 <code>NSURLAuthenticationChallenge</code> 有一个属性 <code>protectionSpace</code>，它是 <code>NSURLProtectionSpace</code> 的实例，它有一个 <code>serverTrust</code> 属性。</p>

<p><code>serverTrust</code> 是一个 <code>SecTrustRef</code> 对象。<code>Security</code> 框架提供了很多方法用于验证 <code>SecTrustRef</code>。AFNetworking 项目中的 <a href="https://github.com/AFNetworking/AFNetworking/blob/7f2c395ba185b586468557b22977ccd2b79fae66/AFNetworking/AFSecurityPolicy.m"><code>AFSecurityPolicy</code></a> 就是一个不错的使用。一如既往的提醒大家，如果要自己构建安全验证相关的代码，请一定要认真做好代码审查，千万不要再出现诸如 <a href="https://www.imperialviolet.org/2014/02/22/applebug.html"><code>goto fail;</code></a> 这类 bug。</p>

<h2>综合讨论</h2>

<p>现在大家对 IP，TCP 和 HTTP 的工作原理有了一定的了解了。下面说说还可以做些什么以及一些相关注意事项。</p>

<h3>有效地使用连接</h3>

<p>TCP 连接容易在两个时点出现问题：初始设置，以及通过连接传输的最后一部分报文。</p>

<h4>建立连接</h4>

<p>连接设置可能会非常耗时。正如前文所说，TCP 建立连接的过程中需要进行三次握手。这个过程中本身没有太多的数据需要传递。但是，对于移动网络来说，从手机端向服务器端发送一个数据包普遍需要 250ms，也就是四分之一秒。推及到三次握手，也就是说在还没有传送任何数据之前，光建立连接就要花费 750ms。</p>

<p>HTTPS 的情况更夸张，由于 HTTPS 是基于 TLS 的 HTTP，而 HTTP 又基于 TCP。TCP 连接就要执行三次握手，然后到了 TLS 层还会再握手三次。估算一下，建立一个 HTTPS 连接的耗时至少是创建一个 HTTP 连接的两倍。如果 RTT 时间是 500ms（假设单程 250ms），HTTPS 建立连接累计总耗时将达1.5秒。</p>

<p>不管建立连接后是要传递多少数据，建立连接本身都太过耗时了。</p>

<p>另一个影响 TCP 连接的因素是传送大规模数据。如果要在网络情况未知的条件下传送报文，TCP 需要侦测当前网络的能力。换句话说，TCP 得花费一定的时间去计算此网络的最佳传输速率。上文提到过，TCP 需要逐步调整以便找到最佳速度。这种算法被称为 <a href="https://en.wikipedia.org/wiki/Slow-start">慢启动 (slow-start)</a>。还有一点值得注意，慢启动策略在那些数据链路层传输质量较差的网络环境中的表现更差，无线网络就是典型的例子。</p>

<h4>结束连接</h4>

<p>另一个问题主要存在于数据传输的最后阶段。每当客户端发起 HTTP 请求某些资源的时候，服务器会持续的向客户端主机发送 TCP 报文数据，客户端收到数据后会给服务器反馈 <strong>ACK</strong> 确认信息。假如某个报文在传输过程中发生丢包，那么服务器也就不会收到该包的确认 ACK。一旦服务器发现有数据包没有 ACK 反馈，就会触发<a href="https://en.wikipedia.org/wiki/Fast_retransmit">快速重传 (fast retransmit)</a>。</p>

<p>每当某个数据包丢失，数据接收方在收到下个数据包后发出的确认 <strong>ACK</strong> 与所接收的前一个数据包的确认 <strong>ACK</strong> 相同。那么数据发送方自然就会收到重复的 ACK。除了报文丢失，还有很多种网络状况会导致重复 ACK 的问题。一般情况下，如果数据发送方连续收到 3 个重复的 ACK 就会立即进行快速重发。</p>

<p>这所导致的问题将发生在数据传输的收尾阶段。如果发送方完成数据发送，接受方自然会停止发送 ACK 确认。在最后四个报文传输的过程中，快速重发算法是没有办法处理这四个报文的数据包的丢失问题的（因为不会收到三个相同的确认 ACK，所以不能界定传输丢包）。在常规网络环境下，四个数据包相当于 5.7kB 的数据规模。总之，在这最后 5.7kB 的传输的过程中，快速重发机制是无效的。针对这种情况，TCP 会启用其他机制来侦测丢包问题。对于这种情况，重传操作可能要消耗几秒钟去执行，这并不奇怪。</p>

<h4>长连接和管线化</h4>

<p>HTTP 有两种策略来解决这些问题。最简单的是 <a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection">HTTP 持久连接 (persistent connection)</a>，也被称为<em>长连接</em> (keep-alive)。具体就是，每当 HTTP 完成一组请求－响应处理后，还会继续复用相同的 TCP 连接。而 HTTPS 会复用同样的 TLS 连接：</p>

<pre><code>open connection
client sends HTTP request 1 -&gt;
                            &lt;- server sends HTTP response 1
client sends HTTP request 2 -&gt;
                            &lt;- server sends HTTP response 2
client sends HTTP request 3 -&gt;
                            &lt;- server sends HTTP response 3
close connection
</code></pre>

<p>第二步就利用了 <a href="https://en.wikipedia.org/wiki/Http_pipelining">HTTP 管线 (pipelining)</a> 处理，即允许客户端利用同样的连接并行发送多个请求，也就是说无需等待上一个请求的响应完成可以发下一个请求。这表示能同时处理请求和响应，请求处理的顺序采用<a href="https://en.wikipedia.org/wiki/FIFO">先进先出</a>原则，响应结果会按照请求发出的顺序依次返还给客户端。</p>

<p>稍微简化一下，看起来会是这样：</p>

<pre><code>open connection
client sends HTTP request 1 -&gt;
client sends HTTP request 2 -&gt;
client sends HTTP request 3 -&gt;
client sends HTTP request 4 -&gt;
                            &lt;- server sends HTTP response 1
                            &lt;- server sends HTTP response 2
                            &lt;- server sends HTTP response 3
                            &lt;- server sends HTTP response 4
close connection
</code></pre>

<p>注意，服务器发出的响应是实时的，不会等到接收完全部请求才处理。</p>

<p>可以利用这个特点来提升 TCP 的效率。只需要在建立连接初始阶段执行握手，而后一直复用同样的连接，这样 TCP 就可以最大限度的利用带宽。此种情况下，拥塞控制也会随之提升。因为快速重发机制无法处理的最末四个报文丢失情况只会发生在使用本连接的最后一个请求－响应中，而不是像之前那样每一个请求－响应都需要建立自己的连接，每个连接中都可能出现最后四个报文丢失的问题。</p>

<p>HTTP 管线化对高网络延迟连接的通讯性能提升尤为显著，在你的 iPhone 没有通过 Wi-Fi 访问网络的时候，此类网络连接就属于高延迟范畴。实际上，有<a href="http://research.microsoft.com/pubs/170059/A%20comparison%20of%20SPDY%20and%20HTTP%20performance.pdf">调查</a>显示，在移动网络环境下，<a href="https://en.wikipedia.org/wiki/SPDY">SPDY</a> 的通讯性能并不优于 HTTP 管线。</p>

<p><a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 指明，在与同一个服务器通讯的时候，如果启用了 HTTP 管线，建议启用两个连接。按照说明所述，这样能获得最优响应效率，能最大限度避免拥塞。增加更多的连接也不会再对性能有什么明显改善。</p>

<p>遗憾的是，还是有相当多的服务器不支持管线化。由于这个原因，HTTP 管线在 <code>NSURLSession</code> 中默认是关闭的。如果想要启用 HTTP 管线，需要将 <code>NSURLSessionConfiguration</code> 中的 <code>HTTPShouldUsePipelining</code> 设置为 <code>YES</code>。另外，建议服务器最好还是支持管线化。</p>

<h3>超时处理</h3>

<p>我们都有在网络不太好的情况下使用 app 的经历。很多 app 大概 15 秒左右就会结束请求并且反馈一个超时信息。这种设计其实是很不友好的。应该给用户一个他们可以理解的友好提示，诸如“你好，现在网络状况不太好，您需要多等一会儿。”。但是即便网络状况不好，只要连接还在，TCP 都会保证将请求发出去并且会一直等待响应的返回，只是时间长短的问题。</p>

<p>从另一个角度来说：在较慢的网络中，请求－响应的RTT时间可能会有 17 秒。如果 15 秒就决定中止请求，就算用户有足够的耐心，他们也没机会等到想要的操作结果。反过来，如果我们给出用户相应的提示信息，而他们又刚好愿意多等一会，用户可能会更喜欢使用这样的应用。</p>

<p>一直以来都有一种误解，用重发请求来解决上面的问题。注意，这不是问题的关键，因为 TCP 有自己的重发机制。</p>

<p>正确的处理方式应该是：每当发起一个请求的时候，同时启动一个 10 秒计时器。如果请求在 10 秒之内返回，就把计时器停掉。如果超过 10 秒，可以给用户一个提示“网络不好，请稍后。”，我建议再给用户一个取消按钮，让他们可以自行选择等待还是取消请求，当然提示信息的具体内容和是否配备取消按钮，这个可以视乎各 app 的情况去决定。总而言之，开发者最好不要直接替用户做决定，比如直接中止他们的请求。</p>

<p>只要连接双方的 IP 地址是不变的、可用的，连接就一定会是“活跃”的。如果把 iPhone 从 Wi-Fi 连接切换到 3G 网络，这样连接就会变得不可用，因为手机的 IP 地址发生了变化，基于原 IP 地址创建的路由自然是失效的。</p>

<h3>缓存</h3>

<p>看看第一个例子中发送的这段 header 信息：</p>

<pre><code>If-None-Match: "a54907f38b306fe3ae4f32c003ddd507"
</code></pre>

<p>这表示客户端本地已经针对所请求的资源做过缓存了，如果服务器上的资源有过更新，需要将最新的资源返回给客户端，否则不需要返回。如果自己构建客户端和服务器的数据通信，建议充分利用这个机制。这种机制叫做 <a href="https://en.wikipedia.org/wiki/HTTP_ETag">HTTP ETag</a>，如果使用得当，会对通讯的速度有明显的优化。</p>

<p>记住“最快的请求是不发请求”。举个极端的例子，拿一个请求来说，哪怕你有最好的网络，请求的数据量极小，有超快的服务器，你也不大可能在 50ms 内拿到请求的响应。这还只是一个请求。想想吧，如果有可能在本地创建相同的数据，而且耗时小于 50ms，那就不要发这样的请求。</p>

<p>针对已请求的资源，只要服务器上对应的资源具备在一定时间内不发生变化特性，建议在本地缓存起来。注意检查 header 中缓存过期的相关属性，也可以直接利用 <code>NSURLSession</code> 中的 <code>NSURLRequestUseProtocolCachePolicy</code> 策略。</p>

<h2>总结</h2>

<p>利用 <code>NSURLSession</code> 发 HTTP 请求是非常简单便捷的。但是请求背后有很多技术点做支撑。只有知晓和理解其中的细节和内涵才能更好的去优化 HTTP 请求。用户期望的是我们的 app 时时刻刻都是好用的。只有深刻理解 IP，TCP 和 HTTP 的工作原理才能更好的去满足用户的期望。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-15T17:55:48+08:00" data-updated="true" itemprop="datePublished">Apr 15<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/15/foundationji-chu-ji-he-lei/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/15/foundationji-chu-ji-he-lei/" itemprop="url">Foundation基础集合类</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2 id="nsarraynssetnsorderedsetnsdictionary">NSArray, NSSet, NSOrderedSet 和 NSDictionary</h2>

<p>基础集合类是每一个 Mac/iOS 应用的基本组成部分。在本文中，我们将对”老类” (<code>NSArray</code>, <code>NSSet</code>)和”新类” (<code>NSMapTable</code>, <code>NSHashTable</code>, <code>NSPointerArray</code>) 进行一个深入的研究，探索每一个的效率细节，并讨论其使用场景。</p>

<p>作者提示：本文包含一些参照结果，但它们并不意味着绝对精确，也没有进行均差分析及多次的测试。这些结果的目的是给出运行时统计，来帮助我们认识到通常来说用什么会更快。所有的测试基于 iPhone 5s，使用 Xcode 5.1b1 和 iOS 7.1b1 的 64 位程序。编译选项设置为 -Ofast 的发布构建。Vectorize loops 和 unroll loops (默认设置) 均设置为关闭。</p>

<h2 id="o">大 O 符号，算法复杂度计量</h2>

<p>首先，我们需要一些理论知识。效率通常用<a href="https://en.wikipedia.org/wiki/Big_O_notation">大 O 符号</a>描述。它定义了一个函数的<em>极限特征</em>，通常被用于描绘其算法效率。O 定义了函数增长率的上限。不同量级的差异非常巨大，可以看看通常使用的 O 符号的量级以及它们所对应需要的操作数的关系。</p>

<p><img src="http://img.objccn.io/issue-7/big-o-notation.png" alt="" /></p>

<p>例如，如果用算法复杂度为 O(n^2)的算法对一个有 50 个元素的数组排序，需要 2,500 步的操作。而且，还有内部的系统开销和方法调用 — 所以是 250 0个操作的时间常量。 O(1)是理想的复杂度，代表着恒定的时间。<a href="http://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms">好的排序算法通常需要 O(n*log n) 的时间</a>。</p>

<h3>可变性</h3>

<p>大多数的集合类存在两个版本:可变和不可变(默认)。这和其他大多数的框架有非常大的不同，一开始会让人觉得有一点奇怪。然而其他的框架现在也应用了这一特性：就在几个月前，<a href="http://blogs.msdn.com/b/dotnet/archive/2013/09/25/immutable-collections-ready-for-prime-time.aspx">.NET公布了作为官方扩展的不可变集合</a>。</p>

<p>最大的好处是什么？<strong>线程安全</strong>。不可变的集合完全是线程安全的，可以同时在多个线程中迭代，避免各种转变时出现异常的风险。你的 API <em>绝不</em>应该暴露一个可变的集合。</p>

<p>当然从不可变到可变然后再回来是会有一定代价的 — 对象必须被拷贝两次，所有集合内的对象将被 retain/release。有时在内部使用一个可变的集合，而在访问时返回一个不可变的对象副本会更高效。</p>

<p>与其他框架不同的是，苹果没有提供一个线程安全的可变集合，<code>NSCache</code> 是例外，但它真的算不上是集合类，因为它不是一个通用的容器。大多数时候，你不会需要在集合层级的同步特性。想象一段代码，作用是检查字典中一个 key 是否存在，并根据检查结果决定设置一个新的 key 或者返回某些值 — 你通常需要把多个操作归类，这时线程安全的可变集合并不能对你有所帮助。</p>

<p>其实也有<em>一些</em>同步的，线程安全的可以使用的可变集合案例，它们往往只需要用几行代码，通过子类和组合的方法建立，比如这个 <a href="https://gist.github.com/steipete/7746843"><code>NSDictionary</code></a> 或这个 <a href="https://github.com/Cue/TheKitchenSync/blob/master/Classes/Collections/CueSyncArray.mm"><code>NSArray</code></a>。</p>

<p>需要注意的是，一些较新的集合类，如 <code>NSHashTable</code>，<code>NSMapTable</code> 和 <code>NSPointerArray</code> 默认就是可变的，它们并没有对应的不可变的类。它们用于类的内部使用，你基本应该不会能找到需要它们的不可变版本的应用场景。</p>

<h2 id="nsarray">NSArray</h2>

<p><code>NSArray</code> 作为一个存储对象的有序集合，可能是被使用最多的集合类。这也是为什么它有自己的比原来的 <code>[NSArray arrayWithObjects:..., nil]</code> 简短得多的快速语法糖符号 <code>@[...]</code>。
<code>NSArray</code> 实现了 <code>objectAtIndexedSubscript:</code>，因为我们可以使用类 C 的语法 <code>array[0]</code> 来代替原来的 <code>[array objectAtIndex:0]</code>。</p>

<h3>性能特征</h3>

<p>关于 <code>NSArray</code> 的内容比你想象的要多的多。基于存储对象的多少，它使用各种内部的变体。最有趣的部分是苹果对于个别的对象访问并不保证 O(1) 的访问时间 — 正如你在 <a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFArray.h">CFArray.h CoreFoundation 头文件</a>中的关于算法复杂度的注解中可以读到的:</p>

<blockquote>
  <p>对于 array 中值的访问时间，不管是在现在还是将来，我们保证在任何一种实现下最坏情况是 O(lg N)。但是通常来说它会是 O(1) (常数时间)。线性搜索操作很可能在最坏情况下的复杂度为 O(N*lg N)，但通常来说上限会更小一些。插入和删除操作耗时通常和数组中的值的数量成线性关系。但在某些实现的最坏情况下会是 O(N*lg N) 。在数组中，没有对于性能上特别有优势的数据位置，也就是说，为了更快地访问到元素而将其设为在较低的 index 上，或者在较高的 index 上进行插入和删除，或者类似的一些做法，是没有必要的。</p>
</blockquote>

<p>在测量的时候，<code>NSArray</code> 产生了一些<a href="http://ridiculousfish.com/blog/posts/array.html">有趣的额外的性能特征</a>。在数组的开头和结尾插入/删除元素通常是一个 O(1)操作，而随机的插入/删除通常是 O(N) 的。</p>

<h3>有用的方法</h3>

<p><code>NSArray</code> 的大多数方法使用 <code>isEqual:</code> 来检查对象间的关系(例如 <code>containsObject:</code> 中)。有一个特别的方法 <code>indexOfObjectIdenticalTo:</code> 用来检查指针相等，如果你确保在同一个集合中搜索，那么这个方法可以很大的提升搜索速度。
在 iOS 7 中，我们最终得到了与 <code>lastObject</code> 对应的公开的 <code>firstObject</code> 方法，对于空数组，这两个方法都会返回 <code>nil</code> — 而常规的访问方法会抛出一个 <code>NSRangeException</code> 异常。</p>

<p>关于构造（可变）数组有一个漂亮的细节可以节省代码量。如果你通过一个可能为 nil 的数组创建一个可变数组，通常会这么写:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableObjects</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutableObjects</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">mutableObjects</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>或者通过更简洁的<a href="http://en.wikipedia.org/wiki/%3F:">三元运算符</a>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableObjects</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="n">mutableCopy</span><span class="p">]</span> <span class="o">?:</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>更好的解决方案是使用<code>arrayWithArray:</code>，即使原数组为nil，该方法也会返回一个数组对象:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableObjects</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="nl">arrayWithArray:</span><span class="n">array</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这两个操作在效率上几乎相等。使用 <code>copy</code> 会快一点点，不过话说回来，这不太可能是你应用的瓶颈所在。提醒：不要使用 <code>[@[] mutableCopy]</code>。经典的<code>[NSMutableArray array]</code>可读性更好。</p>

<p>逆序一个数组非常简单：<code>array.reverseObjectEnumerator.allObjects</code>。我们使用系统提供的 <code>reverseObjectEnumerator</code>，每一个 <code>NSEnumerator</code> 都实现了 <code>allObjects</code>，该方法返回一个新数组。虽然没有原生的 <code>randomObjectEnumerator</code> 方法，你可以写一个自定义的打乱数组顺序的枚举器或者使用一些<a href="https://github.com/mattt/TTTRandomizedEnumerator/blob/master/TTTRandomizedEnumerator/TTTRandomizedEnumerator.m">出色的开源代码</a>。</p>

<h3>数组排序</h3>

<p>有很多各种各样的方法来对一个数组排序。如果数组存储的是字符串对象，<code>sortedArrayUsingSelector:</code>是第一选择:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="s">@&quot;John Appleseed&quot;</span><span class="p">,</span> <span class="s">@&quot;Tim Cook&quot;</span><span class="p">,</span> <span class="s">@&quot;Hair Force One&quot;</span><span class="p">,</span> <span class="s">@&quot;Michael Jurewitz&quot;</span><span class="p">];</span>
</span><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">sortedArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">sortedArrayUsingSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">localizedCaseInsensitiveCompare:</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>下面的代码对存储数字的内容同样很好，因为 <code>NSNumber</code> 实现了 <code>compare:</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">numbers</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="err">@</span><span class="mi">9</span><span class="p">,</span> <span class="err">@</span><span class="mi">5</span><span class="p">,</span> <span class="err">@</span><span class="mi">11</span><span class="p">,</span> <span class="err">@</span><span class="mi">3</span><span class="p">,</span> <span class="err">@</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">sortedNumbers</span> <span class="o">=</span> <span class="p">[</span><span class="n">numbers</span> <span class="nl">sortedArrayUsingSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">compare:</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果想更可控，可以使用基于函数指针的排序方法:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nf">sortedArrayHint</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">sortedArrayUsingFunction:</span><span class="p">(</span><span class="n">NSInteger</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">))</span><span class="nv">comparator</span>
</span><span class="line">                          <span class="nf">context:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">sortedArrayUsingFunction:</span><span class="p">(</span><span class="n">NSInteger</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">))</span><span class="nv">comparator</span>
</span><span class="line">                          <span class="nf">context:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span> <span class="nf">hint:</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nv">hint</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>苹果增加了一个方法来加速使用 <code>sortedArrayHint</code> 的排序。</p>

<blockquote>
  <p>hinted sort 方式在你有一个已排序的大数组 (N 个元素) 并且只改变其中一小部分（P 个添加和删除，这里 P远小于 N）时，会非常有效。你可以重用原来的排序结果，然后在 N 个老项目和 P 个新项目进行一个概念上的归并排序。为了得到合适的 hint，你应该在原来的数组排序后使用 sortedArrayHint 来在你需要的时候(比如在数组改变后想重新排序时)保证持有它。</p>
</blockquote>

<p>因为block的引入，也出现了一些基于block的排序方法:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">sortedArrayUsingComparator:</span><span class="p">(</span><span class="n">NSComparator</span><span class="p">)</span><span class="nv">cmptr</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">sortedArrayWithOptions:</span><span class="p">(</span><span class="n">NSSortOptions</span><span class="p">)</span><span class="nv">opts</span>
</span><span class="line">                <span class="nf">usingComparator:</span><span class="p">(</span><span class="n">NSComparator</span><span class="p">)</span><span class="nv">cmptr</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>性能上来说，不同的方法间并没有太多的不同。有趣的是，基于 selector 的方式是最快的。<a href="https://github.com/steipete/PSTFoundationBenchmark">你可以在 GitHub 上找到测试用的源代码</a>:</p>

<blockquote>
  <p>Sorting 1000000 elements. selector: 4947.90[ms] function: 5618.93[ms] block: 5082.98[ms].</p>
</blockquote>

<h3>二分查找</h3>

<p><code>NSArray</code> 从 iOS 4 / Snow Leopard 开始内置了<a href="http://en.wikipedia.org/wiki/Binary_search_algorithm">二分查找</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">typedef</span> <span class="nf">NS_OPTIONS</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">,</span> <span class="n">NSBinarySearchingOptions</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">NSBinarySearchingFirstEqual</span>     <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">UL</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
</span><span class="line">    <span class="n">NSBinarySearchingLastEqual</span>      <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">UL</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>
</span><span class="line">    <span class="n">NSBinarySearchingInsertionIndex</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">UL</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">indexOfObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">obj</span>
</span><span class="line">          <span class="nf">inSortedRange:</span><span class="p">(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">r</span>
</span><span class="line">                <span class="nf">options:</span><span class="p">(</span><span class="n">NSBinarySearchingOptions</span><span class="p">)</span><span class="nv">opts</span>
</span><span class="line">        <span class="nf">usingComparator:</span><span class="p">(</span><span class="n">NSComparator</span><span class="p">)</span><span class="nv">cmp</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>为什么要使用这个方法？类似 <code>containsObject:</code> 和 <code>indexOfObject:</code> 这样的方法从 0 索引开始搜索每个对象直到找到目标 — 这样不需要数组被排序，但是却是 O(n)的效率特性。如果使用二分查找的话，需要数组事先被排序，但在查找时只需要 O(log n) 的时间。因此，对于 一百万条记录，二分查找法最多只需要 21 次比较，而传统的线性查找则平均需要 500,000 次的比较。</p>

<p>这是个简单的衡量二分查找有多快的数据:</p>

<pre><code>Time to search for 1000 entries within 1000000 objects. Linear: 54130.38[ms]. Binary: 7.62[ms]
</code></pre>

<p>作为比较，查找 <code>NSOrderedSet</code> 中的指定索引花费 0.23 毫秒 — 就算和二分查找相比也又快了 30 多倍。</p>

<p>记住排序的开销也是昂贵的。苹果使用复杂度为 O(n*log n) 的归并排序，所以如果你执行一次 <code>indexOfObject:</code> 的话，就没有必要使用二分查找了。</p>

<p>通过指定 <code>NSBinarySearchingInsertionIndex</code>，你可以获得正确的插入索引，以确保在插入元素后仍然可以保证数组的顺序。</p>

<h3>枚举和总览</h3>

<p>作为测试，我们来看一个普通的使用场景。从一个数组中过滤出一些元素组成另一个数组。这些测试都包括了枚举的方法以及使用 API 进行过滤的方式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="c1">// 第一种方式，使用 `indexesOfObjectsWithOptions:passingTest:`.</span>
</span><span class="line"><span class="n">NSIndexSet</span> <span class="o">*</span><span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomArray</span> <span class="nl">indexesOfObjectsWithOptions:</span><span class="n">NSEnumerationConcurrent</span>
</span><span class="line">                                               <span class="nl">passingTest:</span><span class="o">^</span><span class="kt">BOOL</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class="line"><span class="p">}];</span>
</span><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">filteredArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomArray</span> <span class="nl">objectsAtIndexes:</span><span class="n">indexes</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="c1">// 使用 predicate 过滤，包括 block 的方式和文本 predicate 的方式</span>
</span><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">filteredArray2</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomArray</span> <span class="nl">filteredArrayUsingPredicate:</span><span class="p">[</span><span class="n">NSPredicate</span> <span class="nl">predicateWithBlock:</span><span class="o">^</span><span class="kt">BOOL</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">bindings</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class="line"><span class="p">}]];</span>
</span><span class="line">
</span><span class="line"><span class="c1">// 基于 block 的枚举</span>
</span><span class="line"><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">randomArray</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">mutableArray</span> <span class="nl">addObject:</span><span class="n">obj</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}];</span>
</span><span class="line">
</span><span class="line"><span class="c1">// 传统的枚举</span>
</span><span class="line"><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="kt">id</span> <span class="n">obj</span> <span class="k">in</span> <span class="n">randomArray</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">mutableArray</span> <span class="nl">addObject:</span><span class="n">obj</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">// 使用 NSEnumerator，传统学院派</span>
</span><span class="line"><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class="line"><span class="n">NSEnumerator</span> <span class="o">*</span><span class="n">enumerator</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomArray</span> <span class="n">objectEnumerator</span><span class="p">];</span>
</span><span class="line"><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line"><span class="k">while</span> <span class="p">((</span><span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">enumerator</span> <span class="n">nextObject</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">mutableArray</span> <span class="nl">addObject:</span><span class="n">obj</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">// 通过下标使用 objectAtIndex：</span>
</span><span class="line"><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="n">NSUInteger</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">randomArray</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">randomArray</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">mutableArray</span> <span class="nl">addObject:</span><span class="n">obj</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<table><thead><tr><th style="text-align: left;padding-right:1em;">枚举方法 / 时间 [ms]</th><th style="text-align:right;padding-right:1em;">10.000.000 elements</th><th style="text-align:right;padding-right:1em;">10.000 elements</th></tr></thead><tbody><tr><td style="text-align: left;"><code>indexesOfObjects:</code>, concurrent</td><td style="text-align: right;padding-right:1em;">1844.73</td><td style="text-align: right;padding-right:1em;">2.25</td>  
</tr><tr><td style="text-align: left;padding-right:1em;"><code>NSFastEnumeration</code> (<code>for in</code>)</td><td style="text-align: right;padding-right:1em;">3223.45</td><td style="text-align: right;padding-right:1em;">3.21</td>  
</tr><tr><td style="text-align: left;padding-right:1em;"><code>indexesOfObjects:</code></td><td style="text-align: right;padding-right:1em;">4221.23</td><td style="text-align: right;padding-right:1em;">3.36</td>  
</tr><tr><td style="text-align: left;padding-right:1em;"><code>enumerateObjectsUsingBlock:</code></td><td style="text-align: right;padding-right:1em;">5459.43</td><td style="text-align: right;padding-right:1em;">5.43</td>  
</tr><tr><td style="text-align: left;padding-right:1em;"><code>objectAtIndex:</code></td><td style="text-align: right;padding-right:1em;">5282.67</td><td style="text-align: right;padding-right:1em;">5.53</td>  
</tr><tr><td style="text-align: left;padding-right:1em;"><code>NSEnumerator</code></td><td style="text-align: right;padding-right:1em;">5566.92</td><td style="text-align: right;padding-right:1em;">5.75</td>  
</tr><tr><td style="text-align: left;padding-right:1em;"><code>filteredArrayUsingPredicate:</code></td><td style="text-align: right;padding-right:1em;">6466.95</td><td style="text-align: right;padding-right:1em;">6.31</td>  
</tr></tbody></table>

<p>为了更好的理解这里的效率测量，我们首先看一下数组是如何迭代的。</p>

<p><code>indexesOfObjectsWithOptions:passingTest:</code> 必须每次都执行一次 block 因此比传统的使用 <code>NSFastEnumeration</code> 技术的基于 for 循环的枚举要稍微低效一些。但是如果开启了并发枚举，那么前者的速度则会大大的超过后者几乎 2 倍。iPhone 5s 是双核的，所以这说得通。这里并没有体现出来的是 <code>NSEnumerationConcurrent</code> 只对大量的对象有意义，如果你的集合中的对象数量很少，用哪个方法就真的无关紧要。甚至 <code>NSEnumerationConcurrent</code> 上额外的线程管理实际上会使结果变得更慢。</p>

<p>最大的输家是 <code>filteredArrayUsingPredicate:</code>。<code>NSPredicate</code> 需要在这里提及是因为，人们可以写出<a href="http://nshipster.com/nspredicate/">非常复杂的表达式</a>，尤其是用不基于 block 的变体。使用 Core Data 的用户应该会很熟悉。</p>

<p>为了比较的完整，我们也加入了 <code>NSEnumerator</code> 作为比较 — 虽然没有任何理由再使用它了。然而它竟出人意料的快(至少还是比基于 <code>NSPredicate</code> 的过滤要快)，它的运行时消耗无疑比快速枚举更多 — 现在它只用于向后兼容。甚至没有优化过的 <code>objectAtIndex:</code> 都要更快些。</p>

<h3 id="nsfastenumeration">NSFastEnumeration</h3>

<p>在OSX 10.5和iOS的最初版本中，苹果增加了 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSFastEnumeration_protocol/Reference/NSFastEnumeration.html"><code>NSFastEnumeration</code></a>。在此之前，只有每次返回一个元素的 <code>NSEnumeration</code> ，每次迭代都有运行时开销。而快速枚举，苹果通过 <code>countByEnumeratingWithState:objects:count:</code> 返回一个数据块。该数据块被解析成 <code>id</code> 类型的 C 数组。这就是更快的速度的原因；迭代一个 C 数组要快得多，而且可以被编译器更深一步的优化。手动的实现快速枚举是十分难办的，所以苹果的 <a href="https://developer.apple.com/library/ios/samplecode/FastEnumerationSample/Introduction/Intro.html">FastEnumerationSample</a> 是一个不错的开始，还有一篇 <a href="http://www.mikeash.com/pyblog/friday-qa-2010-04-16-implementing-fast-enumeration.html">Mike Ash 的文章</a>也很不错。</p>

<h3 id="arraywithcapacity">应该用arrayWithCapacity:吗?</h3>

<p>初始化<code>NSArray</code>的时候，可以选择指定数组的预期大小。在检测的时候，结果是在效率上没有差别 — 至少在统计误差范围内的测量的时间几乎相等。有消息透漏说实际上苹果根本没有使用这个参数。然而使用 <code>arrayWithCapacity:</code> 仍然好处，它可以作为一种隐性的文档来帮助你理解代码:</p>

<blockquote>
  <p>Adding 10.000.000 elements to NSArray. no count 1067.35[ms] with count: 1083.13[ms].</p>
</blockquote>

<h3>子类化注意事项</h3>

<p>很少有理由去子类化基础集合类。大多数时候，使用 CoreFoundation 级别的类并且自定义回调函数定制自定义行为是更好的解决方案。
创建一个大小写不敏感的字典，一种方法是子类化 <code>NSDictionary</code> 并且自定义访问方法，使其将字符串始终变为小写(或大写)，并对排序也做类似的修改。更快更好的解决方案是提供一组不同的 <code>CFDictionaryKeyCallBacks</code> 集，你可以提供自定义的 <code>hash</code> 和 <code>isEqual:</code> 回调。你可以在<a href="https://gist.github.com/steipete/7739473">这里</a>找到一个例子。这种方法的优美之处应该归功于 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html">toll-free 桥接</a>)，它仍然是一个简单的字典，因此可以被任何使用 <code>NSDictionary</code> 作为参数的API接受。</p>

<p>子类作用的一个例子是有序字典的用例。.NET 提供了一个 <code>SortedDictionary</code>，Java 有 <code>TreeMap</code>，C++ 有 <code>std::map</code>。虽然你<em>可以</em>使用 C++ 的 STL 容器，但却无法使它自动的 <code>retain/release</code> ，这会让使用起来笨拙得多。因为 <code>NSDictionary</code> 是一个<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html">类簇</a>，所以子类化跟人们想象的相比非常不同。这已经超过了本文的讨论范畴，<a href="https://github.com/nicklockwood/OrderedDictionary/blob/master/OrderedDictionary/OrderedDictionary.m">这里</a>有一个真实的有序字典的例子。</p>

<h2 id="nsdictionary">NSDictionary</h2>

<p>一个字典存储任意的对象键值对。 由于历史原因，初始化方法 <code>[NSDictionary dictionaryWithObjectsAndKeys:object, key, nil]</code> 使用了相反的值到键的顺序，而新的快捷语法则从 key 开始，<code>@{key : value, ...}</code>。</p>

<p><code>NSDictionary</code> 中的键是被拷贝的并且需要是不变的。如果在一个键在被用于在字典中放入一个值后被改变的话，那么这个值就会变得无法获取了。一个有趣的细节是，在 <code>NSDictionary</code> 中键是被 copy 的，但是在使用一个 toll-free 桥接的 <code>CFDictionary</code> 时却只会被 retain。CoreFoundation 类没有通用的拷贝对象的方法，因此这时拷贝是不可能的(*)。这只适用于你使用 <code>CFDictionarySetValue()</code> 的时候。如果你是通过 <code>setObject:forKey</code> 来使用一个 toll-free 桥接的 <code>CFDictionary</code> 的话，苹果会为其增加额外处理逻辑，使得键被拷贝。但是反过来这个结论则不成立 — 使用已经转换为 <code>CFDictionary</code> 的 <code>NSDictionary</code> 对象，并用对其使用 <code>CFDictionarySetValue()</code> 方法，还是会导致调用回 <code>setObject:forKey</code> 并对键进行拷贝。</p>

<blockquote>
  <p>(*)其实有一个现成的键的回调函数 <code>kCFCopyStringDictionaryKeyCallBacks</code> 可以拷贝字符串，因为对于 ObjC对象来说， <code>CFStringCreateCopy()</code> 会调用 <code>[NSObject copy]</code>，我们可以巧妙使用这个回调来创建一个能进行键拷贝的 <code>CFDictionary</code>。</p>
</blockquote>

<h3>性能特征</h3>

<p>苹果在定义字典的计算复杂度时显得相当低调。唯一的信息可以在 <a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFDictionary.h"><code>CFDictionary</code> 的头文件</a>中找到:</p>

<blockquote>
  <p>对于字典中值的访问时间，不管是在现在还是将来，我们保证在任何一种实现下最坏情况是 O(N)。但通常来说它会是 O(1) (常数时间)。插入和删除操作一般来说也会是常数时间，但是在某些实现中最坏情况将为 O(N*N)。通过键来访问值将比直接访问值要快（如果你有这样的操作要做的话）。对于同样数目的值，字典需要花费比数组多得多的内存空间。</p>
</blockquote>

<p>跟数组相似的，字典根据尺寸的不同使用不同的实现，并在其中无缝切换。</p>

<h3>枚举和总览</h3>

<p>过滤字典有几个不同的方法:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="c1">// 使用 keysOfEntriesWithOptions:passingTest:，可并行</span>
</span><span class="line"><span class="n">NSSet</span> <span class="o">*</span><span class="n">matchingKeys</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomDict</span> <span class="nl">keysOfEntriesWithOptions:</span><span class="n">NSEnumerationConcurrent</span>
</span><span class="line">                                               <span class="nl">passingTest:</span><span class="o">^</span><span class="kt">BOOL</span><span class="p">(</span><span class="kt">id</span> <span class="n">key</span><span class="p">,</span> <span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class="line"><span class="p">}];</span>
</span><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">keys</span> <span class="o">=</span> <span class="n">matchingKeys</span><span class="p">.</span><span class="n">allObjects</span><span class="p">;</span>
</span><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomDict</span> <span class="nl">objectsForKeys:</span><span class="n">keys</span> <span class="nl">notFoundMarker:</span><span class="n">NSNull</span><span class="p">.</span><span class="n">null</span><span class="p">];</span>
</span><span class="line"><span class="n">__unused</span> <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">filteredDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDictionary</span> <span class="nl">dictionaryWithObjects:</span><span class="n">values</span>
</span><span class="line">                                                                        <span class="nl">forKeys:</span><span class="n">keys</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="c1">// 基于 block 的枚举</span>
</span><span class="line"><span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">mutableDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableDictionary</span> <span class="n">dictionary</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">randomDict</span> <span class="nl">enumerateKeysAndObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">key</span><span class="p">,</span> <span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">        <span class="n">mutableDictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}];</span>
</span><span class="line">
</span><span class="line"><span class="c1">// NSFastEnumeration</span>
</span><span class="line"><span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">mutableDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableDictionary</span> <span class="n">dictionary</span><span class="p">];</span>
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="kt">id</span> <span class="n">key</span> <span class="k">in</span> <span class="n">randomDict</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">randomDict</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">        <span class="n">mutableDictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"> <span class="c1">// NSEnumeration</span>
</span><span class="line"> <span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">mutableDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableDictionary</span> <span class="n">dictionary</span><span class="p">];</span>
</span><span class="line"> <span class="n">NSEnumerator</span> <span class="o">*</span><span class="n">enumerator</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomDict</span> <span class="n">keyEnumerator</span><span class="p">];</span>
</span><span class="line"> <span class="kt">id</span> <span class="n">key</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line"> <span class="k">while</span> <span class="p">((</span><span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">enumerator</span> <span class="n">nextObject</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">       <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">randomDict</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
</span><span class="line">       <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">           <span class="n">mutableDictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span><span class="line">       <span class="p">}</span>
</span><span class="line"> <span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">// 基于 C 数组，通过 getObjects:andKeys: 枚举</span>
</span><span class="line"><span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">mutableDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableDictionary</span> <span class="n">dictionary</span><span class="p">];</span>
</span><span class="line"><span class="kt">id</span> <span class="n">__unsafe_unretained</span> <span class="n">objects</span><span class="p">[</span><span class="n">numberOfEntries</span><span class="p">];</span>
</span><span class="line"><span class="kt">id</span> <span class="n">__unsafe_unretained</span> <span class="n">keys</span><span class="p">[</span><span class="n">numberOfEntries</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">randomDict</span> <span class="nl">getObjects:</span><span class="n">objects</span> <span class="nl">andKeys:</span><span class="n">keys</span><span class="p">];</span>
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">numberOfEntries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">    <span class="kt">id</span> <span class="n">key</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">       <span class="n">mutableDictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<table><thead><tr><th style="text-align: left;min-width:22em;">过滤/枚举方法</th><th style="text-align: right;">Time [ms], 50.000 elements</th><th style="text-align: right;">1.000.000 elements</th></tr></thead><tbody><tr><td style="text-align: left;"><code>keysOfEntriesWithOptions:</code>, concurrent</td><td style="text-align: right;">16.65</td><td style="text-align: right;">425.24</td>  
</tr><tr><td style="text-align: left;"><code>getObjects:andKeys:</code></td><td style="text-align: right;">30.33</td><td style="text-align: right;">798.49*</td>  
</tr><tr><td style="text-align: left;"><code>keysOfEntriesWithOptions:</code></td><td style="text-align: right;">30.59</td><td style="text-align: right;">856.93</td>  
</tr><tr><td style="text-align: left;"><code>enumerateKeysAndObjectsUsingBlock:</code></td><td style="text-align: right;">36.33</td><td style="text-align: right;">882.93</td>  
</tr><tr><td style="text-align: left;"><code>NSFastEnumeration</code></td><td style="text-align: right;">41.20</td><td style="text-align: right;">1043.42</td>  
</tr><tr><td style="text-align: left;"><code>NSEnumeration</code></td><td style="text-align: right;">42.21</td><td style="text-align: right;">1113.08</td>  
</tr></tbody></table>

<p>(*)使用 <code>getObjects:andKeys:</code> 时需要注意。在上面的代码例子中，我们使用了<a href="http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html">可变长度数组</a>这一 C99 特性(通常，数组的数量需要是一个固定值)。这将在栈上分配内存，虽然更方便一点，但却有其限制。上面的代码在元素数量很多的时候会崩溃掉，所以我们使用基于 <code>malloc/calloc</code> 的分配 (和 <code>free</code>) 以确保安全。</p>

<p>为什么这次 <code>NSFastEnumeration</code> 这么慢？迭代字典通常需要键和值两者，快速枚举只能枚举键，我们必须每次都自己获取值。使用基于 block 的 <code>enumerateKeysAndObjectsUsingBlock:</code> 更高效，因为两者都可以更高效的被提前获取。</p>

<p>这次测试的胜利者又是通过 <code>keysOfEntriesWithOptions:passingTest:</code> 和 <code>objectsForKeys:notFoundMarker:</code> 的并发迭代。代码稍微多了一点，但是可以用 category 进行漂亮的封装。</p>

<h3 id="dictionarywithcapacity">应该用 dictionaryWithCapacity: 吗?</h3>

<p>到现在你应该已经知道该如何测试了，简单的回答是不，<code>count</code> 参数没有改变任何事情:</p>

<blockquote>
  <p>Adding 10000000 elements to NSDictionary. no count 10786.60[ms] with count: 10798.40[ms].</p>
</blockquote>

<h3>排序</h3>

<p>关于字典排序没有太多可说的。你只能将键数组排序为一个新对象，因此你可以使用任何正规的 <code>NSArray</code> 的排序方法:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">keysSortedByValueUsingSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">comparator</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">keysSortedByValueUsingComparator:</span><span class="p">(</span><span class="n">NSComparator</span><span class="p">)</span><span class="nv">cmptr</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">keysSortedByValueWithOptions:</span><span class="p">(</span><span class="n">NSSortOptions</span><span class="p">)</span><span class="nv">opts</span>
</span><span class="line">                      <span class="nf">usingComparator:</span><span class="p">(</span><span class="n">NSComparator</span><span class="p">)</span><span class="nv">cmptr</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3>共享键</h3>

<p>从 iOS 6 和 OS X 10.8 开始，新建的字典可以使用一个预先生成好的键集，使用 <code>sharedKeySetForKeys:</code> 从一个数组中创建键集，然后用 <code>dictionaryWithSharedKeySet:</code> 创建字典。共享键集会复用对象，以节省内存。根据 <a href="https://developer.apple.com/library/mac/releasenotes/Foundation/RN-FoundationOlderNotes/">Foundation Release Notes</a>，<code>sharedKeySetForKeys:</code> 中会计算一个最小完美哈希，这个哈希值可以取代字典查找过程中探索循环的需要，因此使键的访问更快。</p>

<p>虽然在我们有限的测试中没有法线苹果在 <code>NSJSONSerialization</code> 中使用这个特性，但毫无疑问，在处理 JSON 的解析工作时这个特性可以发挥得淋漓尽致。(使用共享键集创建的字典是 <code>NSSharedKeyDictionary</code> 的子类；通常的字典是 <code>__NSDictionaryI</code> / <code>__NSDictionaryM</code>，I / M 表明可变性；可变和不可变的的字典在 toll-free 桥接后对应的都是 <code>_NSCFDictionary</code> 类。)</p>

<p><strong>有趣的细节：</strong>共享键字典<strong>始终是可变的</strong>，即使对它们执行了”copy”命令后也是。这个行为文档中并没有说明，但很容易被测试:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">id</span> <span class="n">sharedKeySet</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDictionary</span> <span class="nl">sharedKeySetForKeys:</span><span class="err">@</span><span class="p">[</span><span class="err">@</span><span class="mi">1</span><span class="p">,</span> <span class="err">@</span><span class="mi">2</span><span class="p">,</span> <span class="err">@</span><span class="mi">3</span><span class="p">]];</span>
</span><span class="line"><span class="c1">// 返回 NSSharedKeySet</span>
</span><span class="line"><span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">test</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableDictionary</span> <span class="nl">dictionaryWithSharedKeySet:</span><span class="n">sharedKeySet</span><span class="p">];</span>
</span><span class="line"><span class="n">test</span><span class="p">[</span><span class="err">@</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="s">@&quot;First element (not in the shared key set, but will work as well)&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">immutable</span> <span class="o">=</span> <span class="p">[</span><span class="n">test</span> <span class="n">copy</span><span class="p">];</span>
</span><span class="line"><span class="n">NSParameterAssert</span><span class="p">(</span><span class="n">immutable</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line"><span class="p">((</span><span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="p">)</span><span class="n">immutable</span><span class="p">)[</span><span class="err">@</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s">@&quot;Adding objects to an immutable collection should throw an exception.&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">NSParameterAssert</span><span class="p">(</span><span class="n">immutable</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="nsset">NSSet</h2>

<p><code>NSSet</code> 和它的可变变体 <code>NSMutableSet</code> 是无序对象集合。检查一个对象是否存在通常是一个 O(1) 的操作，使得比 <code>NSArray</code> 快很多。<code>NSSet</code> 只在被使用的哈希方法平衡的情况下能高效的工作；如果所有的对象都在同一个哈希筐内，<code>NSSet</code> 在查找对象是否存在时并不比 <code>NSArray</code> 快多少。</p>

<p><code>NSSet</code> 还有变体 <code>NSCountedSet</code>，以及非 toll-free 计数变体 <code>CFBag</code> / <code>CFMutableBag</code>。</p>

<p><code>NSSet</code> 会 retain 它其中的对象，但是根据 set 的规定，对象应该是不可变的。添加一个对象到 set 中随后改变它会导致一些奇怪的问题并破坏 set 的状态。</p>

<p><code>NSSet</code> 的方法比 <code>NSArray</code> 少的多。没有排序方法，但有一些方便的枚举方法。重要的方法有 <code>allObjects</code>，将对象转化为 <code>NSArray</code>，<code>anyObject</code> 则返回任意的对象，如果 set 为空，则返回 nil。</p>

<h3 id="set">Set 操作</h3>

<p><code>NSMutableSet</code> 有几个很强大的方法，例如 <code>intersectSet:</code>，<code>minusSet:</code> 和 <code>unionSet:</code>。</p>

<p><img src="http://img.objccn.io/issue-7/set.png" alt="img" /></p>

<h3 id="setwithcapacity">应该用setWithCapacity:吗?</h3>

<p>我们再一次测试当创建 set 时给定容量大小是否会有显著的速度差异:</p>

<blockquote>
  <p>Adding 1.000.000 elements to NSSet. no count 2928.49[ms] with count: 2947.52[ms].</p>
</blockquote>

<p>在统计误差范围内，结果没有显著差异。有一份证据表明<a href="http://www.cocoawithlove.com/2008/08/nsarray-or-nsset-nsdictionary-or.html">至少在上一个 runtime 版本中，有很多的性能上的影响</a>。</p>

<h3 id="nsset">NSSet 性能特征</h3>

<p>苹果在 <a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFSet.h">CFSet 头文件</a>中没有提供任何关于算法复杂度的注释。</p>

<table><thead><tr><th style="text-align: left;">类 / 时间 [ms]</th><th style="text-align: right;">1.000.000 elements</th></tr></thead><tbody><tr><td style="text-align: left;"><code>NSMutableSet</code>, adding</td><td style="text-align: right;">2504.38</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableArray</code>, adding</td><td style="text-align: right;">1413.38</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableSet</code>, random access</td><td style="text-align: right;">4.40</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableArray</code>, random access</td><td style="text-align: right;">7.95</td>  
</tr></tbody></table>

<p>这个检测非常符合我们的预期：<code>NSSet</code> 在每一个被添加的对象上执行 <code>hash</code> 和 <code>isEqual:</code> 方法并管理一系列哈希值，所以在添加元素时耗费了更多的时间。set的随机访问比较难以测试，因为这里执行的都是 <code>anyObject</code>。</p>

<p>这里没有必要包含 <code>containsObject:</code> 的测试，set 要快几个数量级，毕竟这是它的特点。</p>

<h3 id="nsorderedset">NSOrderedSet</h3>

<p><code>NSOrderedSet</code> 在 iOS 5 和 Mac OS X 10.7 中第一次被引入，除了 Core Data，几乎没有直接使用它的 API。看上去它综合了 <code>NSArray</code> 和 <code>NSSet</code> 两者的好处，对象查找，对象唯一性，和快速随机访问。</p>

<p><code>NSOrderedSet</code> 有着优秀的 API 方法，使得它可以很便利的与其他 set 或者有序 set 对象合作。合并，交集，差集，就像 <code>NSSet</code> 支持的那样。它有 <code>NSArray</code> 中除了比较陈旧的基于函数的排序方法和二分查找以外的大多数排序方法。毕竟 <code>containsObject:</code> 非常快，所以没有必要再用二分查找了。</p>

<p><code>NSOrderedSet</code> 的 <code>array</code> 和 <code>set</code> 方法分别返回一个 <code>NSArray</code> 和 <code>NSSet</code>，这些对象表面上是不可变的对象，但实际上在 NSOrderedSet 更新的时候，它们也会更新自己。如果你在不同线程上使用这些对象并发生了诡异异常的时候，知道这一点是非常有好处的。本质上，这些类使用的是 <code>__NSOrderedSetSetProxy</code> 和 <code>__NSOrderedSetArrayProxy</code>。</p>

<p>附注：如果你想知道为什么 <code>NSOrderedSet</code> 不是 <code>NSSet</code> 的子类，<a href="http://nshipster.com/nsorderedset/">NSHipster 上有一篇非常好的文章解释了可变/不可变类簇的缺点</a>。</p>

<h3 id="nsorderedset">NSOrderedSet 性能特征</h3>

<p>如果你看到这份测试，你就会知道 <code>NSOrderedSet</code> 代价高昂了，毕竟天下没有免费的午餐:</p>

<table><thead><tr><th style="text-align: left;">类 / 时间 [ms]</th><th style="text-align: right;">1.000.000 elements</th></tr></thead><tbody><tr><td style="text-align: left;"><code>NSMutableOrderedSet</code>, adding</td><td style="text-align: right;"><strong>3190.52</strong></td>  
</tr><tr><td style="text-align: left;"><code>NSMutableSet</code>, adding</td><td style="text-align: right;">2511.96</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableArray</code>, adding</td><td style="text-align: right;">1423.26</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableOrderedSet</code>, random access</td><td style="text-align: right;"><strong>10.74</strong></td>  
</tr><tr><td style="text-align: left;"><code>NSMutableSet</code>, random access</td><td style="text-align: right;">4.47</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableArray</code>, random access</td><td style="text-align: right;">8.08</td>  
</tr></tbody></table>

<p>这个测试在每一个集合类中添加自定义字符串，随后随机访问它们。</p>

<p><code>NSOrderedSet</code> 比 <code>NSSet</code> 和 <code>NSArray</code> 占用更多的内存，因为它需要同时维护哈希值和索引。</p>

<h3 id="nshashtable">NSHashTable</h3>

<p><code>NSHashTable</code> 效仿了 <code>NSSet</code>，但在对象/内存处理时更加的灵活。可以通过自定义 <code>CFSet</code> 的回调获得 <code>NSHashTable</code> 的一些特性，哈希表可以保持对对象的弱引用并在对象被销毁之后正确的将其移除，有时候如果手动在 NSSet 中添加的话，想做到这个是挺恶心的一件事。它是默认可变的 — 并且这个类没有相应的不可变版本。</p>

<p><code>NSHashTable</code> 有 ObjC 和原始的 C API，C API 可以用来存储任意对象。苹果在 10.5 Leopard 系统中引入了这个类，但是 iOS 的话直到最近的 iOS 6 中才被加入。足够有趣的是它们只移植了 ObjC API；更多强大的 C API 没有包括在 iOS 中。</p>

<p><code>NSHashTable</code> 可以通过 <code>initWithPointerFunctions:capacity:</code> 进行大量的设置 — 我们只选取使用预先定义的 <code>hashTableWithOptions:</code> 这一最普遍的使用场景。其中最有用的选项有利用 <code>weakObjectsHashTable</code> 来使用其自身的构造函数。</p>

<h3 id="nspointerfunctions">NSPointerFunctions</h3>

<p>这些指针函数可以被用在 <code>NSHashTable</code>，<code>NSMapTable</code>和 <code>NSPointerArray</code> 中，定义了对存储在这个集合中的对象的获取和保留行为。这里只介绍最有用的选项。完整列表参见 <code>NSPointerFunctions.h</code>。</p>

<p>有两组选项。内存选项决定了内存管理，个性化定义了哈希和相等。</p>

<p><code>NSPointerFunctionsStrongMemory</code> 创建了一个r etain/release 对象的集合，非常像常规的 <code>NSSet</code> 或 <code>NSArray</code>。</p>

<p><code>NSPointerFunctionsWeakMemory</code> 使用和 <code>__weak</code> 等价的方式来存储对象并自动移除被销毁的对象。</p>

<p><code>NSPointerFunctionsCopyIn</code> 在对象被加入到集合前拷贝它们。</p>

<p><code>NSPointerFunctionsObjectPersonality</code> 使用对象的 <code>hash</code> 和 <code>isEqual:</code> (默认)。</p>

<p><code>NSPointerFunctionsObjectPointerPersonality</code> 对于 <code>isEqual:</code> 和 <code>hash</code> 使用直接的指针比较。</p>

<h3 id="nshashtable">NSHashTable 性能特征</h3>

<table><thead><tr><th style="text-align: left;">类 / 时间 [ms]</th><th style="text-align: right;">1.000.000 elements</th></tr></thead><tbody><tr><td style="text-align: left;"><code>NSHashTable</code>, adding</td><td style="text-align: right;">2511.96</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableSet</code>, adding</td><td style="text-align: right;">1423.26</td>  
</tr><tr><td style="text-align: left;"><code>NSHashTable</code>, random access</td><td style="text-align: right;">3.13</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableSet</code>, random access</td><td style="text-align: right;">4.39</td>  
</tr><tr><td style="text-align: left;"><code>NSHashTable</code>, containsObject</td><td style="text-align: right;">6.56</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableSet</code>, containsObject</td><td style="text-align: right;">6.77</td>  
</tr><tr><td style="text-align: left;"><code>NSHashTable</code>, NSFastEnumeration</td><td style="text-align: right;">39.03</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableSet</code>, NSFastEnumeration</td><td style="text-align: right;">30.43</td>  
</tr></tbody></table>

<p>如果你只是需要 <code>NSSet</code> 的特性，请坚持使用 <code>NSSet</code>。<code>NSHashTable</code> 在添加对象时花费了将近2倍的时间，但是其他方面的效率却非常相近。</p>

<h3 id="nsmaptable">NSMapTable</h3>

<p><code>NSMapTable</code> 和 <code>NSHashTable</code> 相似，但是效仿的是 <code>NSDictionary</code>。因此，我们可以通过 <code>mapTableWithKeyOptions:valueOptions:</code> 分别控制键和值的对象获取/保留行为。存储弱引用是 <code>NSMapTable</code> 最有用的特性，这里有4个方便的构造函数:</p>

<ul>
<li><code>strongToStrongObjectsMapTable</code></li>
<li><code>weakToStrongObjectsMapTable</code></li>
<li><code>strongToWeakObjectsMapTable</code></li>
<li><code>weakToWeakObjectsMapTable</code></li>
</ul>

<p>注意，除了使用 <code>NSPointerFunctionsCopyIn</code>，任何的默认行为都会 retain (或弱引用)键对象而不会拷贝它，这与 <code>CFDictionary</code> 的行为相同而与 <code>NSDictionary</code> 不同。当你需要一个字典，它的键没有实现 <code>NSCopying</code> 协议的时候（比如像 <code>UIView</code>），这会非常有用。</p>

<p>如果你好奇为什么苹果”忘记”为 <code>NSMapTable</code> 增加下标，你现在知道了。下标访问需要一个 <code>id&lt;NSCopying&gt;</code> 作为 key，对 <code>NSMapTable</code> 来说这不是强制的。如果不通过一个非法的 API 协议或者移除 <code>NSCopying</code> 协议来削弱全局下标，是没有办法给它增加下标的。</p>

<p>你可以通过 <code>dictionaryRepresentation</code> 把内容转换为普通的 <code>NSDictionary</code>。不像 <code>NSOrderedSet</code>，这个方法返回的是一个常规的字典而不是一个代理。</p>

<h3 id="nsmaptable">NSMapTable 性能特征</h3>

<table><thead><tr><th style="text-align: left;">类 / 时间 [ms]</th><th style="text-align: right;">1.000.000 elements</th></tr></thead><tbody><tr><td style="text-align: left;"><code>NSMapTable</code>, adding</td><td style="text-align: right;">2958.48</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableDictionary</code>, adding</td><td style="text-align: right;">2522.47</td>  
</tr><tr><td style="text-align: left;"><code>NSMapTable</code>, random access</td><td style="text-align: right;">13.25</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableDictionary</code>, random access</td><td style="text-align: right;">9.18</td>  
</tr></tbody></table>

<p><code>NSMapTable</code> 只比 <code>NSDictionary</code> 略微慢一点。如果你需要一个不 retain 键的字典，放弃 <code>CFDictionary</code> 而使用它吧。</p>

<h3 id="nspointerarray">NSPointerArray</h3>

<p><code>NSPointerArray</code>类是一个稀疏数组，工作起来与 <code>NSMutableArray</code> 相似，但可以存储 <code>NULL</code> 值，并且 <code>count</code> 方法会反应这些空点。可以用 <code>NSPointerFunctions</code> 对其进行各种设置，也有应对常见的使用场景的快捷构造函数 <code>strongObjectsPointerArray</code> 和 <code>weakObjectsPointerArray</code>。</p>

<p>在能使用 <code>insertPointer:atIndex:</code> 之前，我们需要通过直接设置 <code>count</code> 属性来申请空间，否则会产生一个异常。另一种选择是使用 <code>addPointer:</code>，这个方法可以自动根据需要增加数组的大小。</p>

<p>你可以通过 <code>allObjects</code> 将一个 <code>NSPointerArray</code> 转换成常规的 <code>NSArray</code>。这时所有的 <code>NULL</code> 值会被去掉，只有真正存在的对象被加入到数组 — 因此数组的对象索引很有可能会跟指针数组的不同。注意：如果向指针数组中存入任何非对象的东西，试图执行 <code>allObjects</code> 都会造成 <code>EXC_BAD_ACCESS</code> 崩溃，因为它会一个一个地去 retain ”对象”。</p>

<p>从调试的角度讲，<code>NSPointerArray</code>没有受到太多欢迎。<code>description</code>方法只是简单的返回了<code>&lt;NSConcretePointerArray: 0x17015ac50&gt;</code>。为了得到所有的对象需要执行<code>[pointerArray allObjects]</code>，当然，如果存在<code>NULL</code>的话会改变索引。</p>

<h2 id="nspointerarray">NSPointerArray 性能特征</h2>

<p>在性能方面，    <code>NSPointerArray</code> 真的非常非常慢，所以当你打算在一个很大的数据集合上使用它的时候一定要三思。在本测试中我们比较了使用 <code>NSNull</code> 作为空标记的 <code>NSMutableArray</code> ，而对 <code>NSPointerArray</code> 我们用 <code>NSPointerFunctionsStrongMemory</code> 来进行设置 (这样对象会被适当的 retain)。在一个有 10,000 个元素的数组中，我们每隔十个插入一个字符串 ”Entry %d”。此测试包括了用 <code>NSNull.null</code> 填充 <code>NSMutableArray</code> 的总时间。对于 <code>NSPointerArray</code>，我们使用 <code>setCount:</code> 来代替:</p>

<table><thead><tr><th style="text-align: left;">类 / 时间 [ms]</th><th style="text-align: right;">10.000 elements</th></tr></thead><tbody><tr><td style="text-align: left;"><code>NSMutableArray</code>, adding</td><td style="text-align: right;">15.28</td>  
</tr><tr><td style="text-align: left;"><code>NSPointerArray</code>, adding</td><td style="text-align: right;"><strong>3851.51</strong></td>  
</tr><tr><td style="text-align: left;"><code>NSMutableArray</code>, random access</td><td style="text-align: right;">0.23</td>  
</tr><tr><td style="text-align: left;"><code>NSPointerArray</code>, random access</td><td style="text-align: right;">0.34</td>  
</tr></tbody></table>

<p>注意 <code>NSPointerArray</code> 需要的时间比 <code>NSMutableArray</code> 多了超过<em>* 250 倍(!)</em>* 。这非常奇怪和意外。跟踪内存是比较困难的，所以按理说 <code>NSPointerArray</code> 会更高效才对。不过由于我们使用的是同一个 <code>NSNull</code> 来标记空对象，所以除了指针也没有什么更多的消耗。</p>

<h2 id="nscache">NSCache</h2>

<p><code>NSCache</code> 是一个非常奇怪的集合。在 iOS 4 / Snow Leopard 中加入，默认为可变并且线程安全的。这使它很适合缓存那些创建起来代价高昂的对象。它自动对内存警告做出反应并基于可设置的”成本”清理自己。与 <code>NSDictionary</code> 相比，键是被 retain 而不是被 copy 的。</p>

<p><code>NSCache</code> 的回收方法是不确定的，在文档中也没有说明。向里面放一些类似图片那样超大的对象并不是一个好主意，有可能它在能回收之前就更快地把你的 cache 给填满了。(这是在 <a href="http://pspdfkit.com/">PSPDFKit</a> 中很多跟内存有关的 crash 的原因，在使用自定义的基于 LRU 的链表缓存的代码之前，我们起初使用了 <code>NSCache</code> 存储事先渲染的图片。)</p>

<p>可以对 <code>NSCache</code> 进行设置，这样它就能自动回收那些实现了 <code>NSDiscardableContent</code> 协议的对象。实现了该属性的一个比较常用的类是同时间加入的 <code>NSPurgeableData</code>，但是<a href="https://developer.apple.com/library/mac/releasenotes/Foundation/RN-Foundation/index.html#//apple_ref/doc/uid/TP30000742">在 OS X 10.9 之前，它是非完全线程安全的 (也没有信息表明这个变化也影响到了 iOS，或者说在 iOS 7 中被修复了)</a>。</p>

<h3 id="nscache">NSCache 性能</h3>

<p>那么相比起 <code>NSMutableDictionary</code> 来说，<code>NSCache</code> 表现如何呢？加入的线程安全必然会带来一些消耗。处于好奇，我也加入了一个自定义的线程安全的字典的子类 (<a href="https://gist.github.com/steipete/5928916">PSPDFThreadSafeMutableDictionary</a>)，它通过 <code>OSSpinLock</code> 实现同步的访问。</p>

<table><thead><tr><th style="text-align: left;min-width:28em;">类 / 时间 [ms]</th><th style="text-align: right;">1.000.000 elements</th><th style="text-align: right;">iOS 7x64 Simulator</th><th style="text-align: right;">iPad Mini iOS 6</th></tr></thead><tbody><tr><td style="text-align: left;"><code>NSMutableDictionary</code>, adding</td><td style="text-align: right;">195.35</td><td style="text-align: right;">51.90</td><td style="text-align: right;">921.02</td>  
</tr><tr><td style="text-align: left;"><code>PSPDFThreadSafeMutableDictionary</code>, adding</td><td style="text-align: right;">248.95</td><td style="text-align: right;">57.03</td><td style="text-align: right;">1043.79</td>  
</tr><tr><td style="text-align: left;"><code>NSCache</code>, adding</td><td style="text-align: right;">557.68</td><td style="text-align: right;">395.92</td><td style="text-align: right;">1754.59</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableDictionary</code>, random access</td><td style="text-align: right;">6.82</td><td style="text-align: right;">2.31</td><td style="text-align: right;">23.70</td>  
</tr><tr><td style="text-align: left;"><code>PSPDFThreadSafeMutableDictionary</code>, random access</td><td style="text-align: right;">9.09</td><td style="text-align: right;">2.80</td><td style="text-align: right;">32.33</td>  
</tr><tr><td style="text-align: left;"><code>NSCache</code>, random access</td><td style="text-align: right;">9.01</td><td style="text-align: right;"><strong>29.06</strong></td><td style="text-align: right;">53.25</td>  
</tr></tbody></table>

<p><code>NSCache</code> 表现的相当好，随机访问跟我们自定义的线程安全字典一样快。如我们预料的，添加更慢一些，因为 <code>NSCache</code> 要多维护一个决定何时回收对象的成本系数。就这一点来看这不是一个非常公平的比较。有趣的是，在模拟器上运行效率要慢了几乎 10 倍。无论对 32 或 64 位的系统都是这样。而且看起来这个类已经在 iOS 7 中优化过，或者是受益于 64 位 runtime 环境。当在老的设备上测试时，使用 <code>NSCache</code> 的性能消耗就明显得多。</p>

<p>iOS 6(32 bit) 和 iOS 7(64 bit) 的区别也很明显，因为 64 位运行时使用<a href="http://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html">标签指针 (tagged pointer)</a>，因此我们的 <code>@(idx)</code> boxing 要更为高效。</p>

<h2 id="nsindexset">NSIndexSet</h2>

<p>有些使用场景下 <code>NSIndexSet</code> (和它的可变变体，<code>NSMutableIndexSet</code>) 真的非常出色，对它的使用贯穿在 Foundation 中。它可以用一种非常高效的方法存储一组无符号整数的集合，尤其是如果只是一个或少量范围的时候。正如 set 这个名字已经暗示的那样，每一个 <code>NSUInteger</code> 要么在索引 set 中，要么不在。如果你需要存储任意非唯一的数的时候，最好使用 <code>NSArray</code>。</p>

<p>下面是如何把一个整数数组转换为 <code>NSIndexSet</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSIndexSet</span> <span class="o">*</span><span class="nf">PSPDFIndexSetFromArray</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">array</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">NSMutableIndexSet</span> <span class="o">*</span><span class="n">indexSet</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableIndexSet</span> <span class="n">indexSet</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">NSNumber</span> <span class="o">*</span><span class="n">number</span> <span class="k">in</span> <span class="n">array</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">indexSet</span> <span class="nl">addIndex:</span><span class="p">[</span><span class="n">number</span> <span class="n">unsignedIntegerValue</span><span class="p">]];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">indexSet</span> <span class="n">copy</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果不使用block，从索引set中拿到所有的索引有点麻烦，<code>getIndexes:maxCount:inIndexRange:</code> 是最快的方法，其次是使用 <code>firstIndex</code> 并迭代直到 <code>indexGreaterThanIndex:</code> 返回 <code>NSNotFound</code>。随着 block 的到来，使用 <code>NSIndexSet</code> 工作变得方便的多:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="nf">PSPDFArrayFromIndexSet</span><span class="p">(</span><span class="n">NSIndexSet</span> <span class="o">*</span><span class="n">indexSet</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">indexesArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="nl">arrayWithCapacity:</span><span class="n">indexSet</span><span class="p">.</span><span class="n">count</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">indexSet</span> <span class="nl">enumerateIndexesUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">       <span class="p">[</span><span class="n">indexesArray</span> <span class="nl">addObject:</span><span class="err">@</span><span class="p">(</span><span class="n">idx</span><span class="p">)];</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">indexesArray</span> <span class="n">copy</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="nsindexset">NSIndexSet性能</h3>

<p>Core Foundation 中没有和 <code>NSIndexSet</code> 相当的类，苹果也没有对性能做出任何承诺。<code>NSIndexSet</code> 和 <code>NSSet</code> 之间的比较也相对的不公平，因为常规的 set 需要对数字进行包装。为了缓解这个影响，这里的测试准备了实现包装好的 <code>NSUintegers</code> ，并且在两个循环中都会执行 <code>unsignedIntegerValue</code>:</p>

<table><thead><tr><th style="text-align: left;min-width:28em;">类 / 时间 [ms]</th><th style="text-align: right;">1.000.000 elements</th><th style="text-align: right;">iOS 7x64 Simulator</th><th style="text-align: right;">iPad Mini iOS 6</th></tr></thead><tbody><tr><td style="text-align: left;"><code>NSMutableDictionary</code>, adding</td><td style="text-align: right;">195.35</td><td style="text-align: right;">51.90</td><td style="text-align: right;">921.02</td>  
</tr><tr><td style="text-align: left;"><code>PSPDFThreadSafeMutableDictionary</code>, adding</td><td style="text-align: right;">248.95</td><td style="text-align: right;">57.03</td><td style="text-align: right;">1043.79</td>  
</tr><tr><td style="text-align: left;"><code>NSCache</code>, adding</td><td style="text-align: right;">557.68</td><td style="text-align: right;">395.92</td><td style="text-align: right;">1754.59</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableDictionary</code>, random access</td><td style="text-align: right;">6.82</td><td style="text-align: right;">2.31</td><td style="text-align: right;">23.70</td>  
</tr><tr><td style="text-align: left;"><code>PSPDFThreadSafeMutableDictionary</code>, random access</td><td style="text-align: right;">9.09</td><td style="text-align: right;">2.80</td><td style="text-align: right;">32.33</td>  
</tr><tr><td style="text-align: left;"><code>NSCache</code>, random access</td><td style="text-align: right;">9.01</td><td style="text-align: right;"><strong>29.06</strong></td><td style="text-align: right;">53.25</td>  
</tr></tbody></table>

<p>我们看到在一百万左右对象的时候，<code>NSIndexSet</code> 开始变得比 <code>NSSet</code> 慢，但只是因为新的运行时和标签指针。在 iOS 6 上运行相同的测试表明，甚至在更高数量级实体的条件下，<code>NSIndexSet</code> 更快。实际上，在大多数应用中，你不会添加太多的整数到索引 set 中。还有一点这里没有测试，就是 <code>NSIndexSet</code> 跟 <code>NSSet</code> 比无疑有更好的内存优化。</p>

<h2>结论</h2>

<p>本文提供了一些真实的测试，使你在使用基础集合类的时候做出有根据的选择。除了上面讨论的类，还有一些不常用但确实有用的类，尤其是 <code>NSCountedSet</code>，<a href="http://nshipster.com/cfbag/"><code>CFBag</code></a>，<a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFTreeRef/Reference/reference.html"><code>CFTree</code></a>，<a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFBitVectorRef/Reference/reference.html"><code>CFBitVector</code></a>和<a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFBinaryHeapRef/Reference/reference.html"><code>CFBinaryHeap</code></a>。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-15T08:45:11+08:00" data-updated="true" itemprop="datePublished">Apr 15<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/shi-ge/'>诗歌</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/15/wo-bu-hui-xie-shi/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/15/wo-bu-hui-xie-shi/" itemprop="url">我不会写诗</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>
好想在此写诗一回，<br />
但我始终不敢下笔，<br />
或许是诗不若景美，<br />
或许是诗不及影魅，<br />
抑或是我的诗，<br />
比此刻风景甚悲，<br />
忘记了天空的深邃，<br />
忘记了风的轻微，<br />
愿一只纸鸳的甜蜜，<br />
放飞漫天的心醉。<br />
好想在此放声歌唱，<br />
歌唱那满地的青黄，<br />
那白衣的姑娘，<br />
那微微的碎影，<br />
折射出太阳的方向，<br />
也许那甜蜜的不是淡淡阳光，<br />
而是那挂着笑容的脸庞，<br />
和那美好的希望。</p>
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-14T13:56:37+08:00" data-updated="true" itemprop="datePublished">Apr 14<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/android/'>Android</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/14/ioskai-fa-zhe-de-an-zhuo-chu-bu-kui-tan/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/14/ioskai-fa-zhe-de-an-zhuo-chu-bu-kui-tan/" itemprop="url">iOS开发者的安卓初步窥探</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>随着移动软件工业的发展，一个移动产品只局限于 iOS 系统变得越来越不切实际。 Android 目前占有近 80% 的智能手机份额[^1]，它能给一个产品带来的潜在用户量实在不能再被忽略了。</p>

<p>在本文中，我会在 iOS 的开发范围内介绍 Android 开发的核心内容。 Android 和 iOS 处理类似的问题集，但在大部分问题上，它们都有不同的解决方式。通过本文，我会使用一个配套项目（在 <a href="https://github.com/objcio/issue-11-android-101">GitHub</a> 上）来说明如何在两个平台上开发以完成相同的任务。</p>

<p>除了 iOS 开发的相关知识，我假设你在 Java 上也有一定经验，能够安装和使用<a href="http://developer.android.com/tools/index.html">ADT（Android Development Tools）</a>。此外，如果你最近才开始 Android 开发，读一遍 Google 编写的关于<a href="http://developer.android.com/training/basics/firstapp/index.html">创建你的第一个应用</a>的教程会很有帮助。</p>

<h3 id="ui">UI设计概要</h3>

<p>本文不会深入到介绍 iOS 和 Android 在用户体验和设计模式上的不同。然而，了解一些当今 Android 上使用的关键 UI 范式，比如 Action Bar、Overflow Menu、Back Button、Share Action 等，还是会很有好处的。如果你正在认真考虑 Android 开发，我推荐你从 Google Play Store 买个 <a href="https://play.google.com/store/devices/details?id=nexus_5_white_16gb">Nexus 5</a>，将它作为你的主要设备，用满一周，强迫自己最大程度的去体验这个操作系统。一个开发者若不清楚要为之开发的操作系的关键使用模式，就那是对产品的不负责任。</p>

<h2>语言应用结构</h2>

<h3 id="java">Java</h3>

<p>Objective-C 和 Java 之间有很多不同，虽然若能将 Objective-C 的方式带入 Java 可能会很有诱惑力，但这样做很可能导致代码库与驱动它的主要框架产生冲突。总之，有一些需要提防地陷阱：</p>

<ul>
<li>类前缀就留在 Objective-C 里不要带过来了。Java 有实在的命名空间和包管理，所以不再需要类前缀。</li>
<li>实例变量的前缀是 <code>m</code>，不是 <code>_</code>。尽可能多的在代码里使用JavaDoc来写方法和类描述，它能让你和其他人更舒服些。</li>
<li>Null 检查！Objective-C能妥善处理向nil发送消息，但Java不行。</li>
<li>向属性说再见。如果你想要 setter 和 getter，你只能实际地创建一个 getVariableName()方法，并显式的调用它。使用 <code>this.object</code> <strong>不会</strong>调用你自定义地getter，你必须使用 <code>this.getObjct</code>。</li>
<li>同样的，给方法名加上 <code>get</code> 和 <code>set</code> 前缀来更好的识别 getter 和 setter 。Java 方法通常写为动作和查询，例如 <code>getCell()</code>，而不是 <code>cellForRowAtIndexPath:</code>。</li>
</ul>

<h3>项目结构</h3>

<p>Android 应用主要分为两个部分，第一部分是 Java 源代码。源代码通过 Java 包的方式进行组织，所以可按照你的喜好来决定。然而一个常见的实践是为 Activity、Fragment、View、Adapter 和 Data（模型和管理器）使用顶层的类别（top-level categories）。</p>

<p>第二个主要部分是 <code>res</code> 文件夹，也就是资源文件夹。<code>res</code> 文件夹包含有图像、 XML 布局文件，以及 XML 值文件，它们构成了大部分非代码资源。在 iOS 上，图像可有 <code>@2x</code> 版本，但在 Android 上有好几种不同的屏幕密度文件夹要考虑[^2]。Android 使用文件夹来组织文件、字符串以及其他与屏幕密度相关的值。<code>res</code> 文件夹还包含有 XML 布局文件，就像 <code>xib</code> 文件一样。最后，还有其他 XML 文件存储了字符串、整数和样式资源。</p>

<p>最后一个与项目结构相关的是 <code>AndroidManifest.xml</code> 文件。这个文件等同于 iOS 上的 <code>Project-Info.plist</code> 文件，它存储着 Activity 信息、应用名字，并设置应用能处理的 Intent [^3]（系统级事件）。关于 Intent 的更多信息，继续阅读本文，或者阅读 <a href="http://objccn.io/issue-11-2">Intents</a> 这篇文章。</p>

<h2 id="activity">Activity</h2>

<p>Activity 是 Android 应用的基本显示单元，就像 <code>UIViewController</code> 是iOS的基本显示组件一样。作为 <code>UINavigationController</code> 的替代，Android 由系统来维护一个 Activity 栈。当应用完成加载，系统将应用的主 Activity（main activity）压到栈上。注意你也可以加载其他应用的 Activity 并将它们放在栈里。默认，Android 上的返回（back）按钮将从系统的 Activity 栈中弹出 Activity，所以当用户不停地按下返回时，他可以见到多个曾经加载过的应用。</p>

<p>通过使用包含有额外的数据 Intent，Activity 同样可以初始化其他 Activity 。通过 Intent 启动 Activity 类似于通过自定义的 <code>init</code> 方法创建一个 <code>UIViewController</code>。因为最常见的加载新 Activity 的方法是创建一个有数据的 Intent，在 Android 上暴露自定义初始化方法的一个非常棒的方式是创建一个静态 Intent getter 方法。Activity 同样能在完成时返回结果（再见，modal 代理），当其完成时在 Intent 上放置额外数据即可。</p>

<p>Android 和 iOS 的一大差别是任何 Activity 都可以作为你应用的入口，只要它们在 <code>AndroidManifest</code>文件里正确注册即可。在 AndroidManifest.xml 文件中，为一个 Activity 设置一个 <code>media intent</code> 的 Intent 过滤器的话，就能让系统知道这个 Activity 可以作为包含有媒体数据的 Intent 的入口。一个不错的例子是相片编辑  Activity ，它打开一个相片，修改它，并在 Activity 完成时返回修改后的图片。</p>

<p>作为一个旁注，如果你想在 Activity 和 Fragment 之间发送模型对象的话，它们必须实现 <code>Parcelable</code> 接口。实现 <code>Parcelable</code> 接口很类似于 iOS 上实现 <code>&lt;NSCopying&gt;</code> 协议。同样值得一提的是，<code>Parcelable</code> 对象可以存储在 activity 或者 fragment 的 savedInstanceState 里，这是为了能更容易地在它们被销毁后恢复它们的状态。</p>

<p>接下来就看看一个 Activity 启动另一个 Activity，同时能在第二个 Activity 完成时做出响应。</p>

<h3 id="activity">加载另一个Activity并得到结果</h3>

<pre><code>// request code 是为返回 activities 所设置的特定值
private static final int REQUEST_CODE_NEXT_ACTIVITY = 1234;

protected void startNextActivity() {
    // Intents 需要一个 context, 所以将当前的 activity 作为 context 给入
    Intent nextActivityIntent = new Intent(this, NextActivity.class);
       startActivityForResult(nextActivityResult, REQUEST_CODE_NEXT_ACTIVITY);
}

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    switch (requestCode) {
    case REQUEST_CODE_NEXT_ACTIVITY:
        if (resultCode == RESULT_OK) {
            // 这表示我们的 activity 成功返回了。现在显示一段提示文字
            // 这里在屏幕上创建了一个简单的 pop-up 消息框
                Toast.makeText(this, "Result OK!", Toast.LENGTH_SHORT).show();
            }
            return;
        }    
        super.onActivityResult(requestCode, resultCode, data);
}
</code></pre>

<h3 id="activityfinish">在 Activity finish() 上返回结果</h3>

<pre><code>public static final String activityResultString = "activityResultString";

/*
 * 结束时调用, 在 intent 上设置 object ID 并调用成功结束
 * @param returnObject 是要处理的对象
 */
private void onActivityResult(Object returnObject) {
        Intent data = new Intent();
        if (returnObject != null) {
            data.putExtra(activityResultString, returnObject.uniqueId);
        }

        setResult(RESULT_OK, data);
        finish();        
}
</code></pre>

<h2 id="fragments">Fragments</h2>

<p><a href="http://developer.android.com/guide/components/fragments.html">Fragment</a> 的概念是 Android 独有的，它最近才随着 Android 3.0 的问世而出现。Fragment 是一种迷你控制器，能够被实例化来填充 Activity。它们可以存储状态信息，还有可能包含视图逻辑，但区别 Activity 和 Fragment 的最大不同在于。同一时间里屏幕上可能有多个 Fragment。同时注意 Fragment 自身没有上下文，它们严重依赖 Activity 来将它们和应用的状态联系起来。</p>

<p>平板是使用 Fragment 的绝好场景：你可以在左边放一个列表 Fragment，右边放一个详细信息 Fragment。[^4]Fragment 能让你将 UI 和控制器逻辑分割到更小、可重用的层面上。但要当心，Fragment 的生命周期有不少细微差别，我们会在后面详细谈到。</p>

<p><img src="http://img.objccn.io/issue-11/multipane_view_tablet.png" alt="一个含有两个 fragment 的多面板 activity" /></p>

<p>Fragment 是实现 App 的新方式，就像在 iOS 上 <code>UICollectionView</code> 是可取代 <code>UITableView</code> 的构造列表数据的新方式。[^5] 虽然在一开始避开 Fragment 而使用 Activity 会比较容易，但你之后可能会为之后悔。然而，我们也要抗拒那种想完全放弃 Activity，转而只在单个 Activity 上使用 Fragment 的冲动，因为如果那么做了，那么当你想获得 Intent 的好处且想在同一个 Activity 上使用多个 Fragment 时，你将陷入困境。</p>

<p>现在来看一个例子，<code>UITableViewController</code> 和 <code>ListFragment</code> 是如何分别显示一个地铁行程预测时刻表，数据由 <a href="http://www.mbta.com/rider_tools/developers/default.asp?id=21898">MBTA</a> 所提供。</p>

<h3 id="tableviewcontroller">Table View Controller 实现</h3>

<p>&nbsp;</p>

<p><img alt="TripDetailsTableViewController" src="http://img.objccn.io/issue-11/IMG_0095.png" width="50%" /></p>

<p>&nbsp;</p>

<pre><code>@interface MBTASubwayTripTableTableViewController ()

@property (assign, nonatomic) MBTATrip *trip;

@end

@implementation MBTASubwayTripTableTableViewController

- (instancetype)initWithTrip:(MBTATrip *)trip
{
    self = [super initWithStyle:UITableViewStylePlain];
    if (self) {
        _trip = trip;
        [self setTitle:trip.destination];
    }
    return self;
}

- (void)viewDidLoad
{
    [super viewDidLoad];

    [self.tableView registerClass:[MBTAPredictionCell class] forCellReuseIdentifier:[MBTAPredictionCell reuseId]];
    [self.tableView registerNib:[UINib nibWithNibName:NSStringFromClass([MBTATripHeaderView class]) bundle:nil] forHeaderFooterViewReuseIdentifier:[MBTATripHeaderView reuseId]];
}

#pragma mark - UITableViewDataSource

- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{
    return 1;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return [self.trip.predictions count];
}

#pragma mark - UITableViewDelegate

- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section
{
    return [MBTATripHeaderView heightWithTrip:self.trip];
}

- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section
{
    MBTATripHeaderView *headerView = [self.tableView dequeueReusableHeaderFooterViewWithIdentifier:[MBTATripHeaderView reuseId]];
    [headerView setFromTrip:self.trip];
    return headerView;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:[MBTAPredictionCell reuseId] forIndexPath:indexPath];

    MBTAPrediction *prediction = [self.trip.predictions objectAtIndex:indexPath.row];
    [(MBTAPredictionCell *)cell setFromPrediction:prediction];

    return cell;
}

- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath
{
    return NO;
}

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    [tableView deselectRowAtIndexPath:indexPath animated:YES];
}

@end
</code></pre>

<h3 id="listfragment">List Fragment 实现</h3>

<p>&nbsp;</p>

<p><img alt="TripDetailFragment" src="http://img.objccn.io/issue-11/Screenshot_2014-03-25-11-42-16.png" width="50%" /></p>

<p>&nbsp;</p>

<pre><code>public class TripDetailFragment extends ListFragment {

    /**
     * Trip Detail Fragment的配置标识.
     */
    public static final class TripDetailFragmentState {
        public static final String KEY_FRAGMENT_TRIP_DETAIL = "KEY_FRAGMENT_TRIP_DETAIL";
    }

    protected Trip mTrip;

    /**
     * 根据提供的参数使用这个工厂方法来创建 fragment 的新的实例
     *
     * @param trip trip的详细信息
     * @return fragment TripDetailFragment 的新实例.
     */
    public static TripDetailFragment newInstance(Trip trip) {
        TripDetailFragment fragment = new TripDetailFragment();
        Bundle args = new Bundle();
        args.putParcelable(TripDetailFragmentState.KEY_FRAGMENT_TRIP_DETAIL, trip);
        fragment.setArguments(args);
        return fragment;
    }

    public TripDetailFragment() { }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        Prediction[] predictions= mTrip.predictions.toArray(new Prediction[mTrip.predictions.size()]);
        PredictionArrayAdapter predictionArrayAdapter = new PredictionArrayAdapter(getActivity(), predictions);
        setListAdapter(predictionArrayAdapter);
        return super.onCreateView(inflater,container, savedInstanceState);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        TripDetailsView headerView = new TripDetailsView(getActivity());
        headerView.updateFromTripObject(mTrip);
        getListView().addHeaderView(headerView);
    }
}
</code></pre>

<p>下一节，我们将研究一些 Android 独有的组件。</p>

<h2 id="android">通用Android组件</h2>

<h3>列表视图与适配器</h3>

<p><code>ListView</code> 是 Android 上 <code>UITableView</code> 的近似物，也是最常使用的一种组件。就像 <code>UITableView</code> 有一个助手 View Controller <code>UITableViewController</code> 那样，<code>ListView</code> 也有一个助手 Activity 叫做 <code>ListActivity</code>，它还有一个助手 Fragment 叫做 <code>ListFragment</code>。同<code>UITableViewController</code>类似，这些助手为你处理布局（类似 xib）并提供管理适配器（下面将讨论）能够使用的简便方法。上面的例子使用一个 <code>ListFragment</code> 来显示来自一个 <code>Prediction</code> 模型对象列表的数据，类比一下，其实就相当于 UITableView 的 datasource 提供了一个 <code>Prediction</code> 模型对象数组，并用它来填充 <code>ListView</code>。</p>

<p>说到 datasource，在 Android 上，我们没有用于 <code>ListView</code> 的 datasource 和 delegate。作为代替，我们有适配器 (adapters)。适配器有多种形式，但它们的主要目标类似于将 datasource 和 delegate 合二为一。适配器拿到数据并通过实例化视图适配它去填充 <code>ListView</code>，这样 <code>ListView</code> 就会显示出来了。让我们来看看上面使用的数组适配器：</p>

<pre><code>public class PredictionArrayAdapter extends ArrayAdapter&lt;Prediction&gt; {

    int LAYOUT_RESOURCE_ID = R.layout.view_three_item_list_view;

    public PredictionArrayAdapter(Context context) {
        super(context, R.layout.view_three_item_list_view);
    }

    public PredictionArrayAdapter(Context context, Prediction[] objects) {
        super(context, R.layout.view_three_item_list_view, objects);
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent)
    {
        Prediction prediction = this.getItem(position);
        View inflatedView = convertView;
        if(convertView==null)
        {
            LayoutInflater inflater = (LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflatedView = inflater.inflate(LAYOUT_RESOURCE_ID, parent, false);
        }

        TextView stopNameTextView = (TextView)inflatedView.findViewById(R.id.view_three_item_list_view_left_text_view);
        TextView middleTextView = (TextView)inflatedView.findViewById(R.id.view_three_item_list_view_middle_text_view);
        TextView stopSecondsTextView = (TextView)inflatedView.findViewById(R.id.view_three_item_list_view_right_text_view);

        stopNameTextView.setText(prediction.stopName);
        middleTextView.setText("");
        stopSecondsTextView.setText(prediction.stopSeconds.toString());

        return inflatedView;
    }
}
</code></pre>

<p>你会注意到此适配器有一个叫做 <code>getView</code> 的重要方法，它非常类似于 <code>cellForRowAtIndexPath:</code> 。另一个易被发现的相似点是一个重用视图的模式，类似于 iOS 6。视图重用同在 iOS 上的情况一样重要，因为它能非常显著地提高性能！这个适配器有点儿简单，因为它使用了内建的父类 <code>ArrayAdapter&lt;T&gt;</code> ，用于数组数据，但它依然说明了如何用一个数据集来填充一个 <code>ListView</code>。</p>

<h3 id="asynctasks">AsyncTasks</h3>

<p>作为 iOS 上 GCD（Grand Central Dispatch）的替代，Android 上可以使用 <code>AsyncTasks</code>。<code>AsyncTasks</code> 是一个以更加友好的方式处理异步的工具。<code>AsyncTasks</code>有点超出本文的范围，但我强烈建议你阅读相关<a href="http://developer.android.com/reference/android/os/AsyncTask.html">文档</a>。</p>

<h2 id="activity">Activity 生命周期</h2>

<p>从 iOS 开发转过来时候，我们需要注意的首要事情之一是安卓的生命周期。让我们从查看 <a href="http://developer.android.com/training/basics/activity-lifecycle/index.html">Activity 生命周期文档</a> 开始：</p>

<p><img src="http://img.objccn.io/issue-11/Android-Activity-Lifecycle.png" alt="安卓 Activity 生命周期" /></p>

<p>从本质上看来，Activity 生命周期近似于 UIViewController 生命周期。主要的不同是 Android 系统在销毁 Activity 上比较无情，因此保证数据和 Activity 的状态的保存是非常重要的，因此只有这样它们才能在 <code>onCreate()</code> 中从被保存的状态里恢复。做到这个的最好方式是使用绑定数据（bundled data）并从 savedInstanceState 和/或 Intents 中恢复。例如，下面是来自我们示例项目中 <code>TripListActivity</code> 的部分代码，它能跟踪当前显示的地铁线路：</p>

<pre><code>public static Intent getTripListActivityIntent(Context context, TripList.LineType lineType) {
    Intent intent = new Intent(context, TripListActivity.class);
    intent.putExtra(TripListActivityState.KEY_ACTIVITY_TRIP_LIST_LINE_TYPE, lineType.getLineName());
    return intent;
}

public static final class TripListActivityState {
    public static final String KEY_ACTIVITY_TRIP_LIST_LINE_TYPE = "KEY_ACTIVITY_TRIP_LIST_LINE_TYPE";
}

TripList.LineType mLineType;    

@Override
protected void onCreate(Bundle savedInstanceState) {
   super.onCreate(savedInstanceState);
   mLineType = TripList.LineType.getLineType(getIntent().getStringExtra(TripListActivityState.KEY_ACTIVITY_TRIP_LIST_LINE_TYPE));
}    
</code></pre>

<p>注意旋转：在旋转时，生命周期会被<strong>完全</strong>重设。就是说，在旋转发生时，你的 Activity 将被摧毁并重建。如果数据被正确保存在 savedInstanceState 里，而且 Activity 能在重新创建后正确恢复的话，那么旋转看起来就会无缝平滑。许多应用开发者开发的应用因为  Activity 没有正确处理状态的改变，导致在旋转时出现稳定性问题。小心！不要通过锁定屏幕旋转来避免这种问题，这样做只会掩盖生命周期 bug，它们依然会在 Activity 被系统摧毁的时候冒出来。</p>

<h2 id="fragment">Fragment 生命周期</h2>

<p><a href="http://developer.android.com/training/basics/fragments/index.html">Fragment 生命周期</a>相似于 Activity 生命周期，但有些附加的东西：</p>

<p><img src="http://img.objccn.io/issue-11/fragment_lifecycle.png" alt="Android Fragment 生命周期" /></p>

<p>能让开发者措手不及的问题之一是 Fragment 和 Activity 之间的通信问题。注意 <code>onAttach()</code> <strong>先于</strong> <code>onActivityCreated()</code> 调用。这就意味着 Activity 不能保证在 Fragment 被创建前存在。<code>onActivityCreated()</code> 方法应该在有必要的时候用于将 interface（delegate）设置到父亲 Activity 上。</p>

<p>Fragment 同样被操作系统积极地创建和销毁，为了保存它们的状态，需要同 Activity 一样多的劳动量。下面是来自示例项目的一个例子，此处的旅程列表 Fragment 一直追踪<code>TripList</code>数据，以及地铁线路类型：</p>

<pre><code>/**
 * Trip List Fragment 的配置标识.
 */
public static final class TripListFragmentState {
    public static final String KEY_FRAGMENT_TRIP_LIST_LINE_TYPE = "KEY_FRAGMENT_TRIP_LIST_LINE_TYPE";
    public static final String KEY_FRAGMENT_TRIP_LIST_DATA = "KEY_FRAGMENT_TRIP_LIST_DATA";
}

/**
 * Use this factory method to create a new instance of
 * this fragment using the provided parameters.
 *
 * @param lineType the subway line to show trips for.
 * @return A new instance of fragment TripListFragment.
 */
public static TripListFragment newInstance(TripList.LineType lineType) {
    TripListFragment fragment = new TripListFragment();
    Bundle args = new Bundle();
    args.putString(TripListFragmentState.KEY_FRAGMENT_TRIP_LIST_LINE_TYPE, lineType.getLineName());
    fragment.setArguments(args);
    return fragment;
}

protected TripList mTripList;
protected void setTripList(TripList tripList) {
    Bundle arguments = this.getArguments();
    arguments.putParcelable(TripListFragmentState.KEY_FRAGMENT_TRIP_LIST_DATA, tripList);
    mTripList = tripList;
    if (mTripArrayAdapter != null) {
        mTripArrayAdapter.clear();
        mTripArrayAdapter.addAll(mTripList.trips);
    }
}

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    if (getArguments() != null) {
        mLineType = TripList.LineType.getLineType(getArguments().getString(TripListFragmentState.KEY_FRAGMENT_TRIP_LIST_LINE_TYPE));
        mTripList = getArguments().getParcelable(TripListFragmentState.KEY_FRAGMENT_TRIP_LIST_DATA);
    }
}    
</code></pre>

<p>注意到 Fragment 总是用 <code>onCreate</code> 里的绑定参数（bundled arguments）来恢复它的状态，用于 <code>TripList</code> 模型对象的自定义的 setter 会将对象添加到绑定参数中去。这就保证了如果 Fragment 在例如设备被旋转时被销毁并重建的话，Fragment 总是有最新的数据并从中恢复。</p>

<h2>布局</h2>

<p>类似于 Android 开发的其他部分，Android 对比 iOS，在指定布局这里同样有优点和缺点。<a href="http://developer.android.com/guide/topics/ui/declaring-layout.html">布局</a>被存储为人类可读的 XML 文件，放在 <code>res/layouts</code> 文件夹中。</p>

<h3>地铁列表视图布局</h3>

<p><img alt="Subway ListView" src="http://img.objccn.io/issue-11/Screenshot_2014-03-24-13-12-00.png" width="50%" /></p>

<pre><code>&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="com.example.androidforios.app.activities.MainActivity$PlaceholderFragment"&gt;

    &lt;ListView
        android:id="@+id/fragment_subway_list_listview"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:paddingBottom="@dimen/Button.Default.Height"/&gt;

    &lt;Button
        android:id="@+id/fragment_subway_list_Button"
        android:layout_width="match_parent"
        android:layout_height="@dimen/Button.Default.Height"
        android:minHeight="@dimen/Button.Default.Height"
        android:background="@drawable/button_red_selector"
        android:text="@string/hello_world"
        android:textColor="@color/Button.Text"
        android:layout_alignParentBottom="true"
        android:gravity="center"/&gt;

&lt;/RelativeLayout&gt;
</code></pre>

<p>下面是 iOS 上在 Interface Builder 中用<code>UITableView</code>和一个通过 Auto Layout 钉在底部的 <code>UIButton</code> 实现的同一个视图：</p>

<p><img alt="iOS Subway Lines UIViewController" src="http://img.objccn.io/issue-11/iOS_Screen1.png" width="50%" /></p>

<p><img src="http://img.objccn.io/issue-11/iOSConstraints.png" alt="Interface Builder 约束" /></p>

<p>你会注意到 Android 布局文件更易<strong>阅读</strong>和理解。Android 中的布局视图有许多不同的部分，但这里我们只会覆盖到少数几个重要的部分。</p>

<p>你需要处理的主要结构就是 <a href="http://developer.android.com/reference/android/view/ViewGroup.html">ViewGroup</a> 的子类，比如 <a href="http://developer.android.com/reference/android/widget/RelativeLayout.html">RelativeLayout</a>、<a href="http://developer.android.com/reference/android/widget/LinearLayout.html">LinearLayout</a>，以及 <a href="http://developer.android.com/reference/android/widget/FrameLayout.html">FrameLayout</a>，这些就是最常见的。这些 ViewGroup 包含其他视图并暴露属性来在屏幕上安排它们。</p>

<p>一个不错的例子是使用上面提到的 <code>RelativeLayout</code>，一个相对布局允许我们在布局中使用 <code>android:layout_alignParentBottom="true"</code> 这样的语句来将按钮钉在底部。</p>

<p>最后，要将布局连接到 Fragment 或 Activity，只需要简单地在 <code>onCreateView</code> 上使用布局的资源 ID 即可：</p>

<pre><code>@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    return inflater.inflate(R.layout.fragment_subway_listview, container, false);
}
</code></pre>

<h3>布局小贴士</h3>

<ul>
<li>总是去处理 dp（密度无关的像素）的情况，而不是直接使用像素。</li>
<li>不要在可视化编辑器里去调整的部件 - 通常来说可视化编辑器会在部件之间加间隔，而不是像你所期望的那样去调整高宽。最佳选择应该是直接在 XML 文件中进行编辑。</li>
<li>如果你曾看到 <code>fill_parent</code> 值用于布局的高或宽，这个值在好几年前的 API 8 中就被废弃并被 <code>match_parent</code> 取代了。</li>
</ul>

<p>查看看这篇<a href="http://objccn.io/issue-11-3">响应式 Android 应用</a>的文章能得到更多布局小贴士。</p>

<h2>数据</h2>

<p>Android 上可用的<a href="http://developer.android.com/guide/topics/data/data-storage.html">数据存储选项</a>同样类似于 iOS 上可用的：</p>

<ul>
<li><a href="http://developer.android.com/guide/topics/data/data-storage.html#pref">Shared Preferences</a> &lt;-&gt; NSUserDefaults</li>
<li>内存对象</li>
<li>通过<a href="http://developer.android.com/guide/topics/data/data-storage.html#filesInternal">内部</a>或<a href="http://developer.android.com/guide/topics/data/data-storage.html#filesExternal">外部</a>文件存储将数据保存到文件结构或是从文件结构获取数据 &lt;-&gt; 保存数据到 documents 目录</li>
<li><a href="http://developer.android.com/guide/topics/data/data-storage.html#db">SQLite</a> &lt;-&gt; Core Data</li>
</ul>

<p>主要的不同是缺少 Core Data，作为替代，Android 提供了直接访问 SQLite 数据库的方式，并返回一个<a href="http://developer.android.com/reference/android/database/Cursor.html">游标 (cursor)</a> 对象作为结果。请看这篇<a href="htttp://objccn.io/issue-11-5">在 Android 上使用 SQLite </a>的文章获取更多此问题的细节。</p>

<h2 id="android">Android 家庭作业</h2>

<p>我们目前为止讨论的只是一些皮毛而已。要真正从一些 Android 特有的事物里获取好处，我建议关注以下这些特性：</p>

<ul>
<li><a href="http://developer.android.com/guide/topics/ui/actionbar.html">Action Bar, Overflow Menu, 和 Menu Button</a></li>
<li><a href="https://developer.android.com/training/sharing/index.html">跨应用数据分享</a> </li>
<li><a href="http://developer.android.com/guide/components/intents-common.html">响应常见的 OS 操作</a></li>
<li>从 Java 的特性获取好处：泛型、虚方法、虚类，等等。</li>
<li><a href="http://developer.android.com/tools/support-library/index.html">Google 兼容库</a></li>
<li>Android 模拟器：安装 <a href="http://software.intel.com/en-us/android/articles/intel-hardware-accelerated-execution-manager">x86 HAXM 插件</a>让模拟器像黄油般顺滑。</li>
</ul>

<h2>最后的话</h2>

<p>本文中我们讨论的大部分都实现在 MBTA 地铁交通<a href="https://github.com/objcio/issue-11-android-101">示例项目</a>中，并放在了Github上。创建这个项目的目的是在两个平台上展示应用的结构、绑定数据、构建 UI 等相似内容的方式。</p>

<p>虽然在 Android 上一些纯粹的<strong>实现</strong>细节非常不同，但将从 iOS 学来的问题解决技能和模式用于实践依然非常容易。也许懂得一些 Android 的工作方式可能可以让你准备好面对下一版的 iOS，谁又知道会怎样呢？</p>

<p>[^1]: <a href="http://www.prnewswire.com/news-releases/strategy-analytics-android-captures-79-percent-share-of-global-smartphone-shipments-in-2013-242563381.html"> 消息来源</a></p>

<p>[^2]: <a href="http://developer.android.com/guide/practices/screens_support.html"> 在此</a>查看Google的文档支持多种屏幕尺寸。</p>

<p>[^3]: <a href="http://developer.android.com/reference/android/content/Intent.html">Intent 文档</a></p>

<p>[^4]: <a href="http://developer.android.com/design/patterns/multi-pane-layouts.html"> 查看Google的文档获得更多多窗格平板视图</a>的信息。</p>

<p>[^5]: <a href="http://nshipster.com/uicollectionview/"> 感谢，NSHipster</a></p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-10T11:21:11+08:00" data-updated="true" itemprop="datePublished">Apr 10<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/10/ti-gao-xcodebian-yi-qi-xiao-lu/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/10/ti-gao-xcodebian-yi-qi-xiao-lu/" itemprop="url">提高Xcode编译器效率</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>编译器做些什么？</h2>

<p>本文主要探讨一下编译器主要做些什么，以及如何有效的利用编译器。</p>

<p>简单的说，编译器有两个职责：把 Objective-C 代码转化成低级代码，以及对代码做分析，确保代码中没有任何明显的错误。</p>

<p>现在，Xcode 的默认编译器是 clang。本文中我们提到的编译器都表示 clang。clang 的功能是首先对 Objective-C 代码做分析检查，然后将其转换为低级的类汇编代码：LLVM Intermediate Representation(LLVM 中间表达码)。接着 LLVM 会执行相关指令将 LLVM IR 编译成目标平台上的本地字节码，这个过程的完成方式可以是即时编译 (Just-in-time)，或在编译的时候完成。</p>

<p>LLVM 指令的一个好处就是可以在支持 LLVM 的任意平台上生成和运行 LLVM 指令。例如，你写的一个 iOS app, 它可以自动的运行在两个完全不同的架构(Inter 和 ARM)上，LLVM 会根据不同的平台将 IR 码转换为对应的本地字节码。</p>

<p>LLVM 的优点主要得益于它的三层式架构 &#8211; 第一层支持多种语言作为输入(例如 C, ObjectiveC, C++ 和 Haskell)，第二层是一个共享式的优化器(对 LLVM IR 做优化处理)，第三层是许多不同的目标平台(例如 Intel, ARM 和 PowerPC)。在这三层式的架构中，如果你想要添加一门语言到 LLVM 中，那么可以把重要精力集中到第一层上，如果想要增加另外一个目标平台，那么你没必要过多的考虑输入语言。在书 <em>The Architecture of Open Source Applications</em> 中 LLVM 的创建者 (Chris Lattner) 写了一章很棒的内容：关于 <a href="http://www.aosabook.org/en/llvm.html">LLVM 架构</a>。</p>

<p>在编译一个源文件时，编译器的处理过程分为几个阶段。要想查看编译 <em>hello.m</em> 源文件需要几个不同的阶段，我们可以让通过 clang 命令观察：</p>

<pre><code>% clang -ccc-print-phases hello.m

0: input, "hello.m", objective-c
1: preprocessor, {0}, objective-c-cpp-output
2: compiler, {1}, assembler
3: assembler, {2}, object
4: linker, {3}, image
5: bind-arch, "x86_64", {4}, image
</code></pre>

<p>本文我们将重点关注第一阶段和第二阶段。在文章 <a href="http://objccn.io/issue-6-3/">Mach-O Executables</a> 中，Daniel 会对第三阶段和第四阶段进行阐述。</p>

<h3>预处理</h3>

<p>每当编源译文件的时候，编译器首先做的是一些预处理工作。比如预处理器会处理源文件中的宏定义，将代码中的宏用其对应定义的具体内容进行替换。</p>

<p>例如，如果在源文件中出现下述代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &lt;Foundation/Foundation.h&gt;;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>预处理器对这行代码的处理是用 Foundation.h 文件中的内容去替换这行代码，如果 Foundation.h 中也使用了类似的宏引入，则会按照同样的处理方式用各个宏对应的真正代码进行逐级替代。</p>

<p>这也就是为什么人们主张头文件最好尽量少的去引入其他的类或库，因为引入的东西越多，编译器需要做的处理就越多。例如，在头文件中用：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@class</span> <span class="nc">MyClass</span>;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>代替：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &quot;MyClass.h&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这么写是告诉编译器 MyClass 是一个类，并且在 .m 实现文件中可以通过 import <code>MyClass.h</code> 的方式来使用它。</p>

<p>假设我们写了一个简单的 C 程序 <code>hello.c</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hello world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后给上面的代码执行以下预处理命令，看看是什么效果：</p>

<pre><code>clang -E hello.c | less
</code></pre>

<p>接下来看看处理后的代码，一共是 401 行。如果将如下一行代码添加到上面代码的顶部：：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>再执行一下上面的预处理命令，处理后的文件代码行数暴增至 89,839 行。这个数字比某些操作系统的总代码行数还要多。</p>

<p>幸好，目前的情况已经改善许多了：引入了<a href="http://clang.llvm.org/docs/Modules.html">模块 - modules</a>功能，这使预处理变得更加的高级。</p>

<h4>自定义宏</h4>

<p>我们来看看另外一种情形定义或者使用自定义宏，比如定义了如下宏：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#define MY_CONSTANT 4</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>那么，凡是在此行宏定义作用域内，输入了 <code>MY_CONSTANT</code>，在预处理过程中 <code>MY_CONSTANT</code> 都会被替换成 <code>4</code>。我们定义的宏也是可以携带参数的， 比如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#define MY_MACRO(x) x</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>鉴于本文的内容所限，就不对强大的预处理做更多、更全面的展开讨论了。但是还是要强调一点，建议大家不要在需要预处理的代码中加入内联代码逻辑。</p>

<p>例如，下面这段代码，这样用没什么问题：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define MAX(a,b) a &gt; b ? a : b</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;largest: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAX</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>但是如果换成这么写：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define MAX(a,b) a &gt; b ? a : b</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;largest: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAX</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;i: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>用clang的max.c编译一下，结果是：</p>

<pre><code>largest: 201
i: 202
</code></pre>

<p>用 <code>clang -E max.c</code> 进行宏展开的预处理结果是如下所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;largest: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="o">?</span> <span class="n">i</span><span class="o">++</span> <span class="o">:</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;i: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>本例是典型的宏使用不当，而且通常这类问题非常隐蔽且难以 debug 。针对本例这类情况，最好使用 <code>static inline</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">MyConstant</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">   <span class="k">return</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">?</span> <span class="n">l</span> <span class="o">:</span> <span class="n">r</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">MyConstant</span><span class="p">;</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;largest: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;i: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样改过之后，就可以输出正常的结果 (<code>i:201</code>)。因为这里定义的代码是内联的 (inlined)，所以它的效率和宏变量差不多，但是可靠性比宏定义要好许多。再者，还可以设置断点、类型检查以及避免异常行为。</p>

<p>基本上，宏的最佳使用场景是日志输出，可以使用 <code>__FILE__</code> 和 <code>__LINE__</code> 和 assert 宏。</p>

<h3>词法解析标记</h3>

<p>预处理完成以后，每一个 <code>.m</code> 源文件里都有一堆的声明和定义。这些代码文本都会从 string 转化成特殊的标记流。</p>

<p>例如，下面是一段简单的 Objective-C hello word 程序：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;hello, %@&quot;</span><span class="p">,</span> <span class="s">@&quot;world&quot;</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>利用 clang 命令 <code>clang -Xclang -dump-tokens hello.m</code> 来将上面代码的标记流导出：</p>

<pre><code>int 'int'        [StartOfLine]  Loc=&lt;hello.m:4:1&gt;
identifier 'main'        [LeadingSpace] Loc=&lt;hello.m:4:5&gt;
l_paren '('             Loc=&lt;hello.m:4:9&gt;
r_paren ')'             Loc=&lt;hello.m:4:10&gt;
l_brace '{'      [LeadingSpace] Loc=&lt;hello.m:4:12&gt;
identifier 'NSLog'       [StartOfLine] [LeadingSpace]   Loc=&lt;hello.m:5:3&gt;
l_paren '('             Loc=&lt;hello.m:5:8&gt;
at '@'          Loc=&lt;hello.m:5:9&gt;
string_literal '"hello, %@"'            Loc=&lt;hello.m:5:10&gt;
comma ','               Loc=&lt;hello.m:5:21&gt;
at '@'   [LeadingSpace] Loc=&lt;hello.m:5:23&gt;
string_literal '"world"'                Loc=&lt;hello.m:5:24&gt;
r_paren ')'             Loc=&lt;hello.m:5:31&gt;
semi ';'                Loc=&lt;hello.m:5:32&gt;
return 'return'  [StartOfLine] [LeadingSpace]   Loc=&lt;hello.m:6:3&gt;
numeric_constant '0'     [LeadingSpace] Loc=&lt;hello.m:6:10&gt;
semi ';'                Loc=&lt;hello.m:6:11&gt;
r_brace '}'      [StartOfLine]  Loc=&lt;hello.m:7:1&gt;
eof ''          Loc=&lt;hello.m:7:2&gt;
</code></pre>

<p>仔细观察可以发现，每一个标记都包含了对应的源码内容和其在源码中的位置。注意这里的位置是宏展开之前的位置，这样一来，如果编译过程中遇到什么问题，clang 能够在源码中指出出错的具体位置。</p>

<h3>解析</h3>

<p>接下来要说的东西比较有意思：之前生成的标记流将会被解析成一棵抽象语法树 (abstract syntax tree &#8211; AST)。由于 Objective-C 是一门复杂的语言，因此解析的过程不简单。解析过后，源程序变成了一棵抽象语法树：一棵代表源程序的树。假设我们有一个程序 <code>hello.m</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="k">@interface</span> <span class="nc">World</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">hello</span><span class="p">;</span>
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">World</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">hello</span> <span class="p">{</span>
</span><span class="line">  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;hello, world&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">   <span class="n">World</span><span class="o">*</span> <span class="n">world</span> <span class="o">=</span> <span class="p">[</span><span class="n">World</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line">   <span class="p">[</span><span class="n">world</span> <span class="n">hello</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当我们执行 clang 命令 <code>clang -Xclang -ast-dump -fsyntax-only hello.m</code> 之后，命令行中输出的结果如下所示：：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">World</span><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">hello</span><span class="p">;</span>
</span><span class="line"><span class="k">@end</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">@implementation</span> <span class="nc">World</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">hello</span> <span class="p">(</span><span class="n">CompoundStmt</span> <span class="mh">0x10372ded0</span> <span class="o">&lt;</span><span class="n">hello</span><span class="p">.</span><span class="nl">m:</span><span class="mi">8</span><span class="o">:</span><span class="mi">15</span><span class="p">,</span> <span class="nl">line:</span><span class="mi">10</span><span class="o">:</span><span class="mi">1</span><span class="o">&gt;</span>
</span><span class="line">  <span class="p">(</span><span class="n">CallExpr</span> <span class="mh">0x10372dea0</span> <span class="o">&lt;</span><span class="nl">line:</span><span class="mi">9</span><span class="o">:</span><span class="mi">3</span><span class="p">,</span> <span class="nl">col:</span><span class="mi">24</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="kt">void</span><span class="err">&#39;</span>
</span><span class="line">    <span class="p">(</span><span class="n">ImplicitCastExpr</span> <span class="mh">0x10372de88</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">3</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">,</span> <span class="p">...)</span><span class="err">&#39;</span> <span class="o">&lt;</span><span class="n">FunctionToPointerDecay</span><span class="o">&gt;</span>
</span><span class="line">      <span class="p">(</span><span class="n">DeclRefExpr</span> <span class="mh">0x10372ddd8</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">3</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="kt">void</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">,</span> <span class="p">...)</span><span class="err">&#39;</span> <span class="n">Function</span> <span class="mh">0x1023510d0</span> <span class="err">&#39;</span><span class="n">NSLog</span><span class="sc">&#39; &#39;</span><span class="kt">void</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">,</span> <span class="p">...)</span><span class="err">&#39;</span><span class="p">))</span>
</span><span class="line">    <span class="p">(</span><span class="n">ObjCStringLiteral</span> <span class="mh">0x10372de38</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">9</span><span class="p">,</span> <span class="nl">col:</span><span class="mi">10</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="n">NSString</span> <span class="o">*</span><span class="err">&#39;</span>
</span><span class="line">      <span class="p">(</span><span class="n">StringLiteral</span> <span class="mh">0x10372de00</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">10</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="kt">char</span> <span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="err">&#39;</span> <span class="n">lvalue</span> <span class="s">&quot;hello, world&quot;</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line"><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">(</span><span class="n">CompoundStmt</span> <span class="mh">0x10372e118</span> <span class="o">&lt;</span><span class="n">hello</span><span class="p">.</span><span class="nl">m:</span><span class="mi">13</span><span class="o">:</span><span class="mi">12</span><span class="p">,</span> <span class="nl">line:</span><span class="mi">16</span><span class="o">:</span><span class="mi">1</span><span class="o">&gt;</span>
</span><span class="line">  <span class="p">(</span><span class="n">DeclStmt</span> <span class="mh">0x10372e090</span> <span class="o">&lt;</span><span class="nl">line:</span><span class="mi">14</span><span class="o">:</span><span class="mi">4</span><span class="p">,</span> <span class="nl">col:</span><span class="mi">30</span><span class="o">&gt;</span>
</span><span class="line">    <span class="mh">0x10372dfe0</span> <span class="s">&quot;World *world =</span>
</span><span class="line">      <span class="p">(</span><span class="n">ImplicitCastExpr</span> <span class="mh">0x10372e078</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">19</span><span class="p">,</span> <span class="nl">col:</span><span class="mi">29</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="n">World</span> <span class="o">*</span><span class="err">&#39;</span> <span class="o">&lt;</span><span class="n">BitCast</span><span class="o">&gt;</span>
</span><span class="line">        <span class="p">(</span><span class="n">ObjCMessageExpr</span> <span class="mh">0x10372e048</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">19</span><span class="p">,</span> <span class="nl">col:</span><span class="mi">29</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="kt">id</span><span class="sc">&#39;:&#39;</span><span class="kt">id</span><span class="err">&#39;</span> <span class="n">selector</span><span class="o">=</span><span class="n">new</span> <span class="n">class</span><span class="o">=</span><span class="err">&#39;</span><span class="n">World</span><span class="err">&#39;</span><span class="p">))</span><span class="s">&quot;)</span>
</span><span class="line">  <span class="p">(</span><span class="n">ObjCMessageExpr</span> <span class="mh">0x10372e0e8</span> <span class="o">&lt;</span><span class="nl">line:</span><span class="mi">15</span><span class="o">:</span><span class="mi">4</span><span class="p">,</span> <span class="nl">col:</span><span class="mi">16</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="kt">void</span><span class="err">&#39;</span> <span class="n">selector</span><span class="o">=</span><span class="n">hello</span>
</span><span class="line">    <span class="p">(</span><span class="n">ImplicitCastExpr</span> <span class="mh">0x10372e0d0</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">5</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="n">World</span> <span class="o">*</span><span class="err">&#39;</span> <span class="o">&lt;</span><span class="n">LValueToRValue</span><span class="o">&gt;</span>
</span><span class="line">      <span class="p">(</span><span class="n">DeclRefExpr</span> <span class="mh">0x10372e0a8</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">5</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="err">&#39;</span><span class="n">World</span> <span class="o">*</span><span class="err">&#39;</span> <span class="n">lvalue</span> <span class="n">Var</span> <span class="mh">0x10372dfe0</span> <span class="err">&#39;</span><span class="n">world</span><span class="sc">&#39; &#39;</span><span class="n">World</span> <span class="o">*</span><span class="err">&#39;</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在抽象语法树中的每个节点都标注了其对应源码中的位置，同样的，如果产生了什么问题，clang 可以定位到问题所在处的源码位置。</p>

<h5>延伸阅读</h5>

<ul>
<li><a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html">clang AST 介绍</a></li>
</ul>

<h3>静态分析</h3>

<p>一旦编译器把源码生成了抽象语法树，编译器可以对这棵树做分析处理，以找出代码中的错误，比如类型检查：即检查程序中是否有类型错误。例如：如果代码中给某个对象发送了一个消息，编译器会检查这个对象是否实现了这个消息（函数、方法）。此外，clang 对整个程序还做了其它更高级的一些分析，以确保程序没有错误。</p>

<h4>类型检查</h4>

<p>每当开发人员编写代码的时候，clang 都会帮忙检查错误。其中最常见的就是检查程序是否发送正确的消息给正确的对象，是否在正确的值上调用了正确的函数。如果你给一个单纯的 <code>NSObject*</code> 对象发送了一个 <code>hello</code> 消息，那么 clang 就会报错。同样，如果你创建了 <code>NSObject</code> 的一个子类 <code>Test</code>, 如下所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">Test</span> : <span class="nc">NSObject</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后试图给这个子类中某个属性设置一个与其自身类型不相符的对象，编译器会给出一个可能使用不正确的警告。</p>

<p>一般会把类型分为两类：动态的和静态的。动态的在运行时做检查，静态的在编译时做检查。以往，编写代码时可以向任意对象发送任何消息，在运行时，才会检查对象是否能够响应这些消息。由于只是在运行时做此类检查，所以叫做动态类型。</p>

<p>至于静态类型，是在编译时做检查。当在代码中使用 ARC 时，编译器在编译期间，会做许多的类型检查：因为编译器需要知道哪个对象该如何使用。例如，如果 myObject 没有 hello 方法，那么就不能写如下这行代码了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">myObject</span> <span class="n">hello</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4>其他分析</h4>

<p>clang 在静态分析阶段，除了类型检查外，还会做许多其它一些分析。如果你把 clang 的代码仓库 clone 到本地，然后进入目录 <code>lib/StaticAnalyzer/Checkers</code>，你会看到所有静态检查内容。比如 <code>ObjCUnusedIVarsChecker.cpp</code> 是用来检查是否有定义了，但是从未使用过的变量。而 <code>ObjCSelfInitChecker.cpp</code> 则是检查在 你的初始化方法中中调用 <code>self</code> 之前，是否已经调用 <code>[self initWith...]</code> 或 <code>[super init]</code> 了。编译器还进行了一些其它的检查，例如在 <code>lib/Sema/SemaExprObjC.cpp</code> 的 2,534 行，有这样一句：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">Diag</span><span class="p">(</span><span class="n">SelLoc</span><span class="p">,</span> <span class="n">diag</span><span class="o">::</span><span class="n">warn_arc_perform_selector_leaks</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这个会生成严重错误的警告 “performSelector may cause a leak because its selector is unknown” 。</p>

<h2>代码生成</h2>

<p>clang 完成代码的标记，解析和分析后，接着就会生成 LLVM 代码。下面继续看看<code>hello.c</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hello world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>要把这段代码编译成 LLVM 字节码（绝大多数情况下是二进制码格式），我们可以执行下面的命令：</p>

<pre><code>clang -O3 -emit-LLVM hello.c -c -o hello.bc
</code></pre>

<p>接着用另一个命令来查看刚刚生成的二进制文件：</p>

<pre><code>llvm-dis &lt; hello.bc | less
</code></pre>

<p>输出如下：</p>

<pre><code>; ModuleID = '&lt;stdin&gt;'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.8.0"

@str = private unnamed_addr constant [12 x i8] c"hello world\00"

; Function Attrs: nounwind ssp uwtable
define i32 @main() #0 {
  %puts = tail call i32 @puts(i8* getelementptr inbounds ([12 x i8]* @str, i64 0, i64 0))
  ret i32 0
}

; Function Attrs: nounwind
declare i32 @puts(i8* nocapture) #1

attributes #0 = { nounwind ssp uwtable }
attributes #1 = { nounwind }
</code></pre>

<p>在上面的代码中，可以看到 <code>main</code> 函数只有两行代码：一行输出string，另一行返回 <code>0</code>。</p>

<p>再换一个程序，拿 <code>five.m</code> 为例，对其做相同的编译，然后执行 <code>LLVM-dis &lt; five.bc | less</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">&quot;%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="err">@</span><span class="mi">5</span> <span class="n">description</span><span class="p">]);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>抛开其他的不说，单看 <code>main</code> 函数：</p>

<pre><code>define i32 @main() #0 {
  %1 = load %struct._class_t** @"\01L_OBJC_CLASSLIST_REFERENCES_$_", align 8
  %2 = load i8** @"\01L_OBJC_SELECTOR_REFERENCES_", align 8, !invariant.load !4
  %3 = bitcast %struct._class_t* %1 to i8*
  %4 = tail call %0* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to %0* (i8*, i8*, i32)*)(i8* %3, i8* %2, i32 5)
  %5 = load i8** @"\01L_OBJC_SELECTOR_REFERENCES_2", align 8, !invariant.load !4
  %6 = bitcast %0* %4 to i8*
  %7 = tail call %1* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to %1* (i8*, i8*)*)(i8* %6, i8* %5)
  tail call void (%1*, ...)* @NSLog(%1* bitcast (%struct.NSConstantString* @_unnamed_cfstring_ to %1*), %1* %7)
  ret i32 0
}
</code></pre>

<p>上面代码中最重要的是第 4 行，它创建了一个 <code>NSNumber</code> 对象。第 7 行，给这个 number 对象发送了一个  <code>description</code> 消息。第 8 行，将 <code>description</code> 消息返回的内容打印出来。</p>

<h3>优化</h3>

<p>要想了解 LLVM 的优化内容，以及 clang 能做哪些优化，我们先看一个略微复杂的 C 程序：这个函数主要是递归计算 <code>阶乘</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">   <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line">   <span class="k">else</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;factorial 10: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>先看看不做优化的编译情况，执行下面命令：</p>

<pre><code>clang -O0 -emit-llvm factorial.c  -c -o factorial.bc &amp;&amp; llvm-dis &lt; factorial.bc
</code></pre>

<p>重点看一下针对 <code>阶乘</code> 部分生成的代码：</p>

<pre><code>define i32 @factorial(i32 %x) #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  store i32 %x, i32* %2, align 4
  %3 = load i32* %2, align 4
  %4 = icmp sgt i32 %3, 1
  br i1 %4, label %5, label %11

; &lt;label&gt;:5                                       ; preds = %0
  %6 = load i32* %2, align 4
  %7 = load i32* %2, align 4
  %8 = sub nsw i32 %7, 1
  %9 = call i32 @factorial(i32 %8)
  %10 = mul nsw i32 %6, %9
  store i32 %10, i32* %1
  br label %12

; &lt;label&gt;:11                                      ; preds = %0
  store i32 1, i32* %1
  br label %12

; &lt;label&gt;:12                                      ; preds = %11, %5
  %13 = load i32* %1
  ret i32 %13
}
</code></pre>

<p>看一下 <code>%9</code> 标注的那一行，这行代码正是递归调用阶乘函数本身，实际上这样调用是非常低效的，因为每次递归调用都要重新压栈。接下来可以看一下优化后的效果，可以通过这样的方式开启优化 &#8211; 将 <code>-03</code> 标志传给 clang：</p>

<pre><code>clang -O3 -emit-llvm factorial.c  -c -o factorial.bc &amp;&amp; llvm-dis &lt; factorial.bc
</code></pre>

<p>现在 <code>阶乘</code> 计算相关代码编译后生成的代码如下：</p>

<pre><code>define i32 @factorial(i32 %x) #0 {
  %1 = icmp sgt i32 %x, 1
  br i1 %1, label %tailrecurse, label %tailrecurse._crit_edge

tailrecurse:                                      ; preds = %tailrecurse, %0
  %x.tr2 = phi i32 [ %2, %tailrecurse ], [ %x, %0 ]
  %accumulator.tr1 = phi i32 [ %3, %tailrecurse ], [ 1, %0 ]
  %2 = add nsw i32 %x.tr2, -1
  %3 = mul nsw i32 %x.tr2, %accumulator.tr1
  %4 = icmp sgt i32 %2, 1
  br i1 %4, label %tailrecurse, label %tailrecurse._crit_edge

tailrecurse._crit_edge:                           ; preds = %tailrecurse, %0
  %accumulator.tr.lcssa = phi i32 [ 1, %0 ], [ %3, %tailrecurse ]
  ret i32 %accumulator.tr.lcssa
}
</code></pre>

<p>即便我们的函数并没有按照<a href="http://en.wikipedia.org/wiki/Tail_call">尾递归</a>的方式编写，clang 仍然能对其做优化处理，让该函数编译的结果中只包含一个循环。当然 clang 能对代码进行的优化还有很多方面。可以看以下这个比较不错的 gcc 的优化例子<a href="http://ridiculousfish.com/blog/posts/will-it-optimize.html">ridiculousfish.com</a>。</p>

<p><strong>延伸阅读</strong></p>

<ul>
<li><a href="http://blog.llvm.org/search/label/optimization">LLVM blog: posts tagged &#8216;optimization&#8217;</a></li>
<li><a href="http://blog.llvm.org/2013/05/llvm-33-vectorization-improvements.html">LLVM blog: vectorization improvements</a></li>
<li><a href="http://blog.llvm.org/2011/09/greedy-register-allocation-in-llvm-30.html">LLVM blog: greedy register allocation</a></li>
<li><a href="http://polly.llvm.org/index.html">The Polly project</a></li>
</ul>

<h2>如何在实际中应用这些特性</h2>

<p>刚刚我们探讨了编译的全过程，从标记到解析，从抽象语法树到分析检查，再到汇编。读者不禁要问，为什么要关注这些？</p>

<h3 id="libclangclang">使用 libclan g或 clang 插件</h3>

<p>之所以 clang 很酷：是因为它是一个开源的项目、并且它是一个非常好的工程：几乎可以说全身是宝。使用者可以创建自己的 clang 版本，针对自己的需求对其进行改造。比如说，可以改变 clang 生成代码的方式，增加更强的类型检查，或者按照自己的定义进行代码的检查分析等等。要想达成以上的目标，有很多种方法，其中最简单的就是使用一个名为 <a href="http://clang.llvm.org/doxygen/group__CINDEX.html">libclang</a> 的C类库。libclang 提供的 API 非常简单，可以对 C 和 clang 做桥接，并可以用它对所有的源码做分析处理。不过，根据我的经验，如果使用者的需求更高，那么 libclang 就不怎么行了。针对这种情况，推荐使用 <a href="https://github.com/macmade/ClangKit">Clangkit</a>，它是基于 clang 提供的功能，用 Objective-C 进行封装的一个库。</p>

<p>最后，clang 还提供了一个直接使用 LibTooling 的 C++ 类库。这里要做的事儿比较多，而且涉及到 C++，但是它能够发挥 clang 的强大功能。用它你可以对源码做任意类型的分析，甚至重写程序。如果你想要给 clang 添加一些自定义的分析、创建自己的重构器 (refactorer)、或者需要基于现有代码做出大量修改，甚至想要基于工程生成相关图形或者文档，那么 LibTooling 是很好的选择。</p>

<h3>自定义分析器</h3>

<p>开发者可以按照 <a href="http://clang.LLVM.org/docs/LibASTMatchersTutorial.html">Tutorial for building tools using LibTooling</a> 中的说明去构造 LLVM ，clang 以及 clan g的附加工具。需要注意的是，编译代码是需要花费一些时间的，即时机器已经很快了，但是在编译期间，我还是可以吃顿饭的。</p>

<p>接下来，进入到 LLVM 目录，然后执行命令<code>cd ~/llvm/tools/clang/tools/</code>。在这个目录中，可以创建自己独立的 clang 工具。例如，我们创建一个小工具，用来检查某个库是否正确使用。首先将 <a href="https://github.com/objcio/issue6-compiler-tool">样例工程</a> 克隆到本地，然后输入 <code>make</code>。这样就会生成一个名为 <code>example</code> 的二进制文件。</p>

<p>我们的使用场景是：假如有一个 <code>Observer</code> 类, 代码如下所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">Observer</span>
</span><span class="line"><span class="k">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">observerWithTarget:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">target</span> <span class="nf">action:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">selector</span><span class="p">;</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>接下来，我们想要检查一下每当这个类被调用的时候，在 <code>target</code> 对象中是否都有对应的 <code>action</code> 方法存在。可以写个 C++ 函数来做这件事（注意，这是我第一次写 C++ 程序，可能不那么严谨）：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">virtual</span> <span class="kt">bool</span> <span class="n">VisitObjCMessageExpr</span><span class="p">(</span><span class="n">ObjCMessageExpr</span> <span class="o">*</span><span class="n">E</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">E</span><span class="o">-&gt;</span><span class="n">getReceiverKind</span><span class="p">()</span> <span class="o">==</span> <span class="n">ObjCMessageExpr</span><span class="o">::</span><span class="n">Class</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">QualType</span> <span class="n">ReceiverType</span> <span class="o">=</span> <span class="n">E</span><span class="o">-&gt;</span><span class="n">getClassReceiver</span><span class="p">();</span>
</span><span class="line">    <span class="n">Selector</span> <span class="n">Sel</span> <span class="o">=</span> <span class="n">E</span><span class="o">-&gt;</span><span class="n">getSelector</span><span class="p">();</span>
</span><span class="line">    <span class="n">string</span> <span class="n">TypeName</span> <span class="o">=</span> <span class="n">ReceiverType</span><span class="p">.</span><span class="n">getAsString</span><span class="p">();</span>
</span><span class="line">    <span class="n">string</span> <span class="n">SelName</span> <span class="o">=</span> <span class="n">Sel</span><span class="p">.</span><span class="n">getAsString</span><span class="p">();</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">TypeName</span> <span class="o">==</span> <span class="s">&quot;Observer&quot;</span> <span class="o">&amp;&amp;</span> <span class="n">SelName</span> <span class="o">==</span> <span class="s">&quot;observerWithTarget:action:&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">Expr</span> <span class="o">*</span><span class="n">Receiver</span> <span class="o">=</span> <span class="n">E</span><span class="o">-&gt;</span><span class="n">getArg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">IgnoreParenCasts</span><span class="p">();</span>
</span><span class="line">      <span class="n">ObjCSelectorExpr</span><span class="o">*</span> <span class="n">SelExpr</span> <span class="o">=</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">ObjCSelectorExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">E</span><span class="o">-&gt;</span><span class="n">getArg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">IgnoreParenCasts</span><span class="p">());</span>
</span><span class="line">      <span class="n">Selector</span> <span class="n">Sel</span> <span class="o">=</span> <span class="n">SelExpr</span><span class="o">-&gt;</span><span class="n">getSelector</span><span class="p">();</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">ObjCObjectPointerType</span> <span class="o">*</span><span class="n">OT</span> <span class="o">=</span> <span class="n">Receiver</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getAs</span><span class="o">&lt;</span><span class="n">ObjCObjectPointerType</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
</span><span class="line">        <span class="n">ObjCInterfaceDecl</span> <span class="o">*</span><span class="n">decl</span> <span class="o">=</span> <span class="n">OT</span><span class="o">-&gt;</span><span class="n">getInterfaceDecl</span><span class="p">();</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">decl</span><span class="o">-&gt;</span><span class="n">lookupInstanceMethod</span><span class="p">(</span><span class="n">Sel</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">          <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Warning: class &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">TypeName</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; does not implement selector &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Sel</span><span class="p">.</span><span class="n">getAsString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class="line">          <span class="n">SourceLocation</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">E</span><span class="o">-&gt;</span><span class="n">getExprLoc</span><span class="p">();</span>
</span><span class="line">          <span class="n">PresumedLoc</span> <span class="n">PLoc</span> <span class="o">=</span> <span class="n">astContext</span><span class="o">-&gt;</span><span class="n">getSourceManager</span><span class="p">().</span><span class="n">getPresumedLoc</span><span class="p">(</span><span class="n">Loc</span><span class="p">);</span>
</span><span class="line">          <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;in &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">PLoc</span><span class="p">.</span><span class="n">getFilename</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &lt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">PLoc</span><span class="p">.</span><span class="n">getLine</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">PLoc</span><span class="p">.</span><span class="n">getColumn</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面的这个方法首先查找消息表达式， 以 <code>Observer</code> 作为接收者， <code>observerWithTarget:action:</code> 作为 selector，然后检查 target 中是否存在相应的方法。虽然这个例子有点儿刻意，但如果你想要利用 AST 对自己的代码库做某些检查，按照上面的例子来就可以了。</p>

<h3 id="clang">clang的其他特性</h3>

<p>clang还有许多其他的用途。比如，可以写编译器插件（例如，类似上面的检查器例子）并且动态的加载到编译器中。虽然我没有亲自实验过，但是我觉得在 Xcode 中应该是可行的。再比如，也可以通过编写 clang 插件来自定义代码样式（具体可以参见 <a href="http://objccn.io/issue-6-1/">编译过程</a>）。</p>

<p>另外，如果想对现有的代码做大规模的重构， 而 Xcode 或 AppCode 本身集成的重构工具无法达你的要求，你完全可以用 clang 自己写个重构工具。听起来有点儿可怕，读读下面的文档和教程，你会发现其实没那么难。</p>

<p>最后，如果是真的有这种需求，你完全可以引导 Xcdoe 使用你自己编译的 clang 。再一次，如果你去尝试，其实这些事儿真的没想象中那么复杂，反而会发现许多个中乐趣。</p>

<h5>延伸阅读</h5>

<ul>
<li><a href="https://github.com/loarabia/Clang-tutorial">Clang Tutorial</a></li>
<li><a href="http://cocoafactory.com/blog/2012/11/23/x86-64-assembly-language-tutorial-part-1/">X86_64 Assembly Language Tutorial</a></li>
<li><a href="http://clang-analyzer.llvm.org/xcode.html">Custom clang Build with Xcode (I)</a> 和 <a href="http://stackoverflow.com/questions/3297986/using-an-external-xcode-clang-static-analyzer-binary-with-additional-checks">(II)</a></li>
<li><a href="http://kevinaboos.wordpress.com/2013/07/23/clang-tutorial-part-i-introduction/">Clang Tutorial (I)</a>, <a href="http://kevinaboos.wordpress.com/2013/07/23/clang-tutorial-part-ii-libtooling-example/">(II)</a> 和 <a href="http://kevinaboos.wordpress.com/2013/07/29/clang-tutorial-part-iii-plugin-example/">(III)</a></li>
<li><a href="http://getoffmylawnentertainment.com/blog/2011/10/01/clang-plugin-development-tutorial/">Clang Plugin Tutorial</a></li>
<li><a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">LLVM blog: What every C programmer should know (I)</a> , <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html">(II)</a> 和 <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html">(III)</a></li>
</ul>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-10T11:09:26+08:00" data-updated="true" itemprop="datePublished">Apr 10<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/10/xcodebian-yi-ni-suo-bu-zhi-dao-de-xi-jie/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/10/xcodebian-yi-ni-suo-bu-zhi-dao-de-xi-jie/" itemprop="url">Xcode编译你所不知道的细节</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>近些日子我们被宠坏了 &#8211; 我们只需要单击 Xcode 中的一个按钮（这个按钮看起来有点像是在播放一些音乐的动作），过几秒钟之后，我们的程序就会运行起来了，直到遇到一些错误，这非常的神奇。</p>

<p>在本文中，我们将从更高级别的角度来解读 Build 过程，并探索一下在 Xcode 界面中暴露出的 project setting 信息与 Build 过程有什么关系。为了更加深入的探索 Build 过程中，每一步实际执行的工作，我都会在本文中引入一些别的文章。</p>

<h2 id="build">解密 Build 日志</h2>

<p>为了了解 Xcode build 过程的内部工作原理，我们首先把突破口瞄准完整的 log 文件上。打开 Log Navigator ，从列表中选择一个 Build ，Xcode 会将 log 文件很完美的展现出来。</p>

<p><img src="http://img.objccn.io/issue-6/build-log.png" alt="Xcode build log navigator" /></p>

<p>默认情况下，上面的 Xcode 界面中隐藏了大量的信息，我们通过选择任务，然后点击右边的展开按钮，就能看到每个任务的详细信息。另外一种可选的方案就是选中列表中的一个或者多个任务，然后选择组合键 Cmd-C，这将会把所有的纯文本信息拷贝至粘贴板。最后，我们还可以选择 Editor 菜单中的 &#8220;Copy transcript for shown results&#8221;，以此将所有的 log 信息拷贝到粘贴板中。</p>

<p>本文给出的示例中，log 信息将近有 10,000 行（其实大多数的 log 信息是编译 OpenSSL 时生成的，并不是我们自己所写的代码生成的）。下面我们就开始吧！</p>

<p>注意观察输出的 log 信息，首先会发现 log 信息被分为不同的几大块，它们与我们工程中的targets相互对应着：</p>

<pre><code>Build target Pods-SSZipArchive
...
Build target Makefile-openssl
...
Build target Pods-AFNetworking
...
Build target crypto
...
Build target Pods
...
Build target ssl
...
Build target objcio
</code></pre>

<p>本文涉及到的工程有几个依赖项：其中 AFNetworking 和 SSZipArchive 包含在 Pods 中，而 OpenSSL 则以子工程的形式包含在工程中。</p>

<p>针对工程中的每个 target，Xcode 都会执行一系列的操作，将相关的源码，根据所选定的平台，转换为机器可读的二进制文件。下面我们详细的了解一下第一个 target：SSZipArchive。</p>

<p>在针对这个 target 输出的 log 信息中，我们可以看到每个任务被执行的详细情况。例如第一个任务是处理一个预编译头文件（为了增强 log 信息的可读性，我省略了许多细节）：</p>
<pre><code>(1) ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7 objective-c com.apple.compilers.llvm.clang.1_0.compiler
(2) cd /.../Dev/objcio/Pods
	setenv LANG en_US.US-ASCII
	setenv PATH "..."
(3) /.../Xcode.app/.../clang 
(4) -x objective-c-header 
(5) -arch armv7 
... configuration and warning flags ...
(6) -DDEBUG=1 -DCOCOAPODS=1 
... include paths and more ...
(7) -c 
(8) /.../Pods-SSZipArchive-prefix.pch 
(9) -o /.../Pods-SSZipArchive-prefix.pch.pch
</code></pre>

<p>在 build 处理过程中，每个任务都会出现类似上面的这些 log 信息，我们就通过上面的 log 信息进一步了解详情。</p>

<ol>
<li>类似上面的每个 log 信息块都会利用一行 log 信息来描述相关的任务作为起点。  </li>
<li>接着输出带缩进的3行 log 信息，列出了该任务执行的语句。此处，工作目录发生了改变，并对PANG和PATH环境变量进行设置。  </li>
<li>这里是发生奇迹的地方。为了处理一个<code>.pch</code>文件，调用了 clang，并附带了许多可选项。下面跟着输出的 log 信息显示了显示了完整的调用过程，以及所有的参数。我们看看其中的几个参数&#8230;  </li>
<li><code>-x</code> 标示符用来指定所使用的语言，此处是 <code>objective-c-header</code>。  </li>
<li>目标架构指定为 <code>armv7</code>。  </li>
<li>暗示 <code>#defines</code> 的内容已经被添加了。  </li>
<li><code>-c</code> 标示符用来告诉 clang 具体该如何做。<code>-c</code> 表示：运行预处理器、词法分析器、类型检查、LLVM 的生成和优化，以及 target 指定汇编代码的生成阶段，最后，运行汇编器以产出一个<code>.o</code>的目标文件。  </li>
<li>输入文件。  </li>
<li>输出文件。</li>
</ol>

<p>虽然有大量的 log 信息，不过我不会对每个任务做详细的介绍。我们的重点是让你全面的了解在整个 build 过程中，哪些工具会被调用，以及背后会使用到了哪些参数。</p>

<p>针对这个 target ，虽然只有一个 <code>.pch</code> 文件，但实际上这里对 <code>objective-c-header</code> 文件的处理有两个任务。通过观察具体输出的 log 信息，我们可以知道详情：</p>

<pre><code>ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7 objective-c ...
ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7s objective-c ...
</code></pre>

<p>从上面的 log 信息中，可以明显的看出 target 针对两种架构做了 build &#8211; armv7 和 armv7s &#8211; 因此 clang 对文件做了两次处理，每次针对一种架构。</p>

<p>在处理预编译头文件之后，可以看到针对 SSZipArchive target 有另外的几个任务类型。</p>

<pre><code>CompileC ...
Libtool ...
CreateUniversalBinary ...
</code></pre>

<p>顾名思义：<code>CompileC</code> 用来编译 <code>.m</code> 和 <code>.c</code> 文件，<code>Libtool</code> 用来从目标文件中构建 library，而 <code>CreateUniversalBinary</code> 则将上一阶段产生的两个 <code>.a</code> 文件（每个文件对应一种架构）合并为一个通用的二进制文件，这样就能同时在 armv7 和 armv7s 上面运行。</p>

<p>接着，在工程中其它一些依赖项也会发生于此类似的步骤。AFNetworking 被编译之后，会与 SSZipArchive 进行链接，以当做 pod library。OpenSSL 编译之后，会接着处理 crypto 和 ssl target。</p>

<p>当所有的依赖项都 build 完成之后，就轮到我们程序的 target 了。Build 该 target 时，输出的 log 信息会包含一些非常有价值，并且之前没有出现过的内容：</p>

<pre><code>PhaseScriptExecution ...
DataModelVersionCompile ...
Ld ...
GenerateDSYMFile ...
CopyStringsFile ...
CpResource ...
CopyPNGFile ...
CompileAssetCatalog ...
ProcessInfoPlistFile ...
ProcessProductPackaging /.../some-hash.mobileprovision ...
ProcessProductPackaging objcio/objcio.entitlements ...
CodeSign ...
</code></pre>

<p>在上面的任务列表中，根据名称不能区分的唯一任务可能就是 <code>Ld</code>，<code>Ld</code> 是一个 linker 工具的名称，与 <code>libtool</code> 非常相似。实际上，<code>libtool</code>也是简单的调用 <code>ld</code> 和 <code>lipo</code>。&#8217;ld&#8217;被用来构建可执行文件，而<code>libtool</code>则用来构建 library 文件。阅读<a href="http://www.objccn.io/issue-6-3">Daniel</a> 和 <a href="http://www.objccn.io/issue-6-2">Chris</a>两篇文章，可以了解到更多关于编译和链接的工作原理。</p>

<p>上面每一个步骤，实际上都会调用相关的命令行工具来做实际的工作，这跟之前我们看到的的 <code>ProcessPCH</code> 类似。至此，我将不会继续介绍这些 log 信息了，我将带领大家从另外一个不同的角度来继续探索这些任务：Xcode 是如何知道哪些任务需要被执行？</p>

<h2 id="build">Build过程的控制</h2>

<p>当你选择 Xcode 5 中的一个工程时，会在 project editor 顶部显示出 6 个 tabs：General, Capabilities, Info, Build Settings, Build Phases 以及 Build Rules。</p>

<p><img src="http://img.objccn.io/issue-6/project-editor-tabs.png" alt="Xcode project editor tabs" /></p>

<p>对于我们理解 build 过程来说，其中最后 3 项与 build 过程紧密相连。</p>

<h3 id="buildphases">Build Phases</h3>

<p>Build Phases 代表着将代码转变为可执行文件的最高级别规则。里面描述了 build 过程中必须执行的不同类型规则。</p>

<p><img src="http://img.objccn.io/issue-6/build-phases.png" alt="Xcode build phases" /></p>

<p>首先是 target 依赖项的构建。这里会告诉 build 系统，build 当前的 target 之前，必须先对这里的依赖性进行 build。实际上这并不属于真正的 build phase，在这里，Xcode 只不过将其与 build phase 显示到一块罢了。</p>

<p>接着在 build phase中是一个 CocoaPods 相关的脚本 <em>script execution</em> &#8211; 更多 CocoaPods 相关信息和 它的 build 过程可以查看<a href="http://www.objc.io/issue-6-4">Michele的文章</a> &#8211; 接着在 <code>Compile Sources</code> section 中规定了所有必须参与编译的文件。需要留意的是，这里并没有指明这些文件是<em>如何</em>被编译处理的。关于处理这些文件的更多内容，我们将在研究 build rules 和 build settings 时学习到。此处列出的所有文件将根据相关的 rules 和 settings 被处理。</p>

<p>当编译结束之后，接下来就是将编译所生成的目标文件链接到一块。注意观察，Xcode 中的 build phase 之后是：&#8221;Link Binary with Libraries.&#8221; 这里面列出了所有的静态库和动态库，这些库会参与上面编译阶段生成的目标文件进行链接。静态库和动态库的处理过程有非常大的区别，相关内容请参考 Daniel的文章 <a href="http://www.objccn.io/issue-6-3">Mach-O 可执行文件</a>。</p>

<p>当链接完成之后，build phase 中最后需要处理的就是将静态资源（例如图片和字体）拷贝到 app bundle 中。需要注意的是，如果图片资源是PNG格式，那么不仅仅对其进行拷贝，还会做一些优化（如果 build settings 中的 PNG 优化是打开的话）。</p>

<p>虽然静态资源的拷贝是 build phase 中的最后一步，但 build 还没有完成。例如，还没有进行 code signing （这并不是 build phase 考虑的范畴），code signing 属于 build 步骤中的最后一步 &#8220;Packaging&#8221;。</p>

<h3 id="buildphases">定制Build Phases</h3>

<p>至此，如果不考虑默认设置的话，你已经可以完全掌握了上面介绍的 build phases。例如，你可以在 build phases 中添加运行自定义脚本，就像<a href="http://www.objccn.io/issue-6-4/">CocoaPods</a>使用的一样，来做额外的工作。当然也可以添加一些资源的拷贝任务，当你需要将某些确定的资源拷贝到指定的 target 目录中，这非常有用。</p>

<p>另外定制 build phases 有一个非常好用的功能：添加带有水印（包括版本号和 commit hash）的 app icon &#8211; 只需要在 build phase 中添加一个 &#8220;Run Script&#8221;，并用下面的命令来获取版本号和 commit hash：</p>

<pre><code>version=`/usr/libexec/PlistBuddy -c "Print CFBundleVersion" "${INFOPLIST_FILE}"`
commit=`git rev-parse --short HEAD`
</code></pre>

<p>然后使用 ImageMagick 来修改 app icon。这里有一个<a href="https://github.com/krzysztofzablocki/IconOverlaying">完整的示例</a>，可以参考。</p>

<p>如果你希望自己或者别人编写的代码看起来比较简洁点，可以添加一个 &#8220;Run Script&#8221;：如果一个源文件超过指定行数，就发出警告。如下代码所示，设置的行数为 200。</p>

<pre><code>find "${SRCROOT}" \( -name "*.h" -or -name "*.m" \) -print0 | xargs -0 wc -l | awk '$1 &gt; 200 &amp;&amp; $2 != "total" { print $2 ":1: warning: file more than 200 lines" }'
</code></pre>

<h3 id="buildrules">Build Rules</h3>

<p>Build rules 指定了不同的文件类型该如何编译。一般来说，开发者并不需要修改这里面的内容。如果你需要对特定类型的文件添加处理方法，那么可以在此处添加一条新的规则。</p>

<p>一条 build rule 指定了其应用于哪种类型文件，该类型文件是如何被处理的，以及输出的内容该如何处置。比方说，我们创建了一条预处理规则，该规则将 Objective-C 的实现文件当做输入，解析文件中的注释内容，最后再输出一个 <code>.m</code> 文件，文件中包含了生成的代码。由于我们不能将 <code>.m</code> 文件既当做输入又当做输出，所以我使用了 <code>.mal</code> 后缀，定制的 build rule 如下所示：</p>

<p><img src="http://img.objccn.io/issue-6/custom-build-rule.png" alt="Custom build rule" /></p>

<p>上面的规则应用于所有后缀为 <code>*.mal</code> 的文件，这些文件会被自定义的脚本处理（调用我们的预处理器，并附带上输入和输出参数）。最后，该规则告诉 build system 在哪里可以找到此规则的输出文件。</p>

<p>在脚本中，我使用了少量的变量来指定正确的路径和文件名。在苹果的 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html#//apple_ref/doc/uid/TP40003931-CH3-SW105">Build Setting Reference</a> 文档中可以找到所有可用的变量。build 过程中，要想观察所有已存在的环境变量，你可以在 build phase 中添加一个 &#8220;Run Script&#8221;，并勾选上 &#8220;Show environment variables in build log&#8221;。</p>

<h3 id="buildsettings">Build Settings</h3>

<p>至此，我们已经了解到在 build phases 中是如何定义 build 处理的过程，以及 build rules 是如何指定哪些文件类型在编译阶段需要被预处理。在 build settings 中，我们可以配置每个任务（之前在 build log 输出中看到的任务）的详细内容。</p>

<p>你会发现 build 过程的每一个阶段，都有许多选项：从编译、链接一直到 code signing 和 packaging。注意，settings 是如何被分割为不同的部分 &#8211; 其实这大部分会与 build phases 有关联，有时候也会指定编译的文件类型。</p>

<p>这些选项基本都有很好的文档介绍，你可以在右边面板中的 quick help inspector 或者 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html#//apple_ref/doc/uid/TP40003931-CH3-SW105">Build Setting Reference</a> 中查看到。</p>

<h2>工程文件</h2>

<p>上面我们介绍的所有内容都被保存在工程文件（<code>.pbxproj</code>）中，除了其它一些工程相关信息（例如 file groups），我们很少会深入该文件内部，除非在代码 merge 时发生冲突，或许会进去看看。</p>

<p>建议你用文本编辑器打开一个工程文件，从头到尾看一遍里面的内容。它的可读性非常高，里面的许多内容一看就知道什么意思了，不会存在太大的问题。通过阅读并完全理解工程文件，这对于合并工程文件的冲突非常有帮助。</p>

<p>首先，我们来看看文件中叫做 <code>rootObject</code> 的条目。在我的工程中，如下所示：</p>

<pre><code>rootObject = 1793817C17A9421F0078255E /* Project object */;
</code></pre>

<p>根据这个 ID（<code>1793817C17A9421F0078255E</code>），我们可以找到 main 工程的定义：</p>

<pre><code>/* Begin PBXProject section */
    1793817C17A9421F0078255E /* Project object */ = {
        isa = PBXProject;
...
</code></pre>

<p>在这部分中有一些 keys，顺从这些 key，我们可以了解到更多关于这个工程文件的组成。例如，<code>mainGroup</code> 指向了 root file group。如果你按照这个思路，你可以快速了解到在 <code>.pbxproj</code> 文件中工程的结构。下面我要来介绍一些与 build 过程相关的内容。其中 <code>target</code> key 指向了 build target 的定义：</p>

<pre><code>targets = (
    1793818317A9421F0078255E /* objcio */,
    170E83CE17ABF256006E716E /* objcio Tests */,
);
</code></pre>

<p>根据第一个内容，我们找到一个 target 的定义：</p>

<pre><code>1793818317A9421F0078255E /* objcio */ = {
    isa = PBXNativeTarget;
    buildConfigurationList = 179381B617A9421F0078255E /* Build configuration list for PBXNativeTarget "objcio" */;
    buildPhases = (
        F3EB8576A1C24900A8F9CBB6 /* Check Pods Manifest.lock */,
        1793818017A9421F0078255E /* Sources */,
        1793818117A9421F0078255E /* Frameworks */,
        1793818217A9421F0078255E /* Resources */,
        FF25BB7F4B7D4F87AC7A4265 /* Copy Pods Resources */,
    );
    buildRules = (
    );
    dependencies = (
        1769BED917CA8239008B6F5D /* PBXTargetDependency */,
        1769BED717CA8236008B6F5D /* PBXTargetDependency */,
    );
    name = objcio;
    productName = objcio;
    productReference = 1793818417A9421F0078255E /* objcio.app */;
    productType = "com.apple.product-type.application";
};
</code></pre>

<p>其中 <code>buildConfigurationList</code> 指向了可用的配置项，一般是 <code>Debug</code> 和 <code>Release</code>。根据 debug 对应的 id，我们可以找到 build setting tab 中所有选项存储的位置：</p>

<pre><code>179381B717A9421F0078255E /* Debug */ = {
    isa = XCBuildConfiguration;
    baseConfigurationReference = 05D234D6F5E146E9937E8997 /* Pods.xcconfig */;
    buildSettings = {
        ALWAYS_SEARCH_USER_PATHS = YES;
        ASSETCATALOG_COMPILER_LAUNCHIMAGE_NAME = LaunchImage;
        CODE_SIGN_ENTITLEMENTS = objcio/objcio.entitlements;
...
</code></pre>

<p><code>buildPhases</code> 属性则简单的列出了在 Xcode 中定义的所有 build phases。这非常容易识别出来（Xcode 中的参数使用了它们原本真正的名字，并以 C 风格进行注释）。<code>buildRules</code> 属性是空的：因为在该工程中，我没有自定义 build rules。<code>dependencies</code> 列出了在 Xcode build phase tab 中列出的 target 依赖项。</p>

<p>没那么吓人，不是吗？工程中剩下的内容就留给你去当做练习来了解吧。只需要顺着对象的 ID 走，即可，一旦你找到了敲门，理解了Xcode中工程设置的不同 section ，那么对于 merge 工程文件的冲突时，将变得非常简单。甚至可以在 GitHub 中就能阅读工程文件，而不用将工程文件 clone 到本地，并用 Xcode 打开。</p>

<h2>小结</h2>

<p>当今的软件是都用其它复杂的一些软件和资源开发出来的，例如 library 和 build 工具等。反过来，这些工具是构建于底层架构的，这犹如剥洋葱一样，一层包着一层。虽然这样一层一层的，给人感觉太复杂，但是你完全可以去深入了解它们，这非常有助于你对软件的深入理解，实际上当你了解之后，这并没有想象中的那么神奇，只不过它是一层一层堆砌起来的，每一层都是基于下一层构建起来的。</p>

<p>本文所探索 build system 的内部机制犹如剥掉洋葱的一层。其实当我们点击 Xcode 中的运行按钮时，我们并没必要理解这个动作涉及到的所有内容。我们只是深入理解某一层，然后找到一个有组织的、并且可控的调用其它工具的顺序，如果我们愿意的话，可以做进一步的探索。我建议你阅读本期中的其它文章，以进一步了解这个洋葱的下一层内容！</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-10T09:42:56+08:00" data-updated="true" itemprop="datePublished">Apr 10<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/shi-ge/'>诗歌</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/10/dang-wo-zhen-zheng-kai-shi-ai-zi-ji/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/10/dang-wo-zhen-zheng-kai-shi-ai-zi-ji/" itemprop="url">当我真正开始爱自己</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><img src="http://ww1.sinaimg.cn/large/626e5d69gw1efahu2mtk8j20e60aadh6.jpg" alt="" /></p>
<p>当我真正开始爱自己，</p>

<p>我才认识到，所有的痛苦和情感的折磨，</p>

<p>都只是提醒我：活着，不要违背自己的本心。</p>

<p>今天我明白了，这叫做</p>

<p>『真实』。</p>

<p>当我真正开始爱自己，</p>

<p>我才懂得，把自己的愿望强加于人，</p>

<p>是多么的无礼，就算我知道，时机并不成熟，</p>

<p>那人也还没有做好准备，</p>

<p>就算那个人就是我自己，</p>

<p>今天我明白了，这叫做</p>

<p>『尊重』。</p>

<p>当我开始爱自己，</p>

<p>我不再渴求不同的人生，</p>

<p>我知道任何发生在我身边的事情，</p>

<p>都是对我成长的邀请。</p>

<p>如今，我称之为</p>

<p>『成熟』。</p>

<p>当我开始真正爱自己，</p>

<p>我才明白，我其实一直都在正确的时间，</p>

<p>正确的地方，发生的一切都恰如其分。</p>

<p>由此我得以平静。</p>

<p>今天我明白了，这叫做</p>

<p>『自信』。</p>

<p>当我开始真正爱自己，</p>

<p>我不再牺牲自己的自由时间，</p>

<p>不再去勾画什么宏伟的明天。</p>

<p>今天我只做有趣和快乐的事，</p>

<p>做自己热爱，让心欢喜的事，</p>

<p>用我的方式，以我的韵律。</p>

<p>今天我明白了，这叫做</p>

<p>『单纯』。</p>

<p>当我开始真正爱自己，</p>

<p>我开始远离一切不健康的东西。</p>

<p>不论是饮食和人物，还是事情和环境，</p>

<p>我远离一切让我远离本真的东西。</p>

<p>从前我把这叫做“追求健康的自私自利”，</p>

<p>但今天我明白了，这是</p>

<p>『自爱』。</p>

<p>当我开始真正爱自己，</p>

<p>我不再总想着要永远正确，不犯错误。</p>

<p>我今天明白了，这叫做</p>

<p>『谦逊』。</p>

<p>我当开始真正爱自己，</p>

<p>我不再继续沉溺于过去，</p>

<p>也不再为明天而忧虑，</p>

<p>现在我只活在一切正在发生的当下，</p>

<p>今天，我活在此时此地，</p>

<p>如此日复一日。这就叫</p>

<p>『完美』。</p>

<p>当我开始真正爱自己，</p>

<p>我明白，我的思虑让我变得贫乏和病态，</p>

<p>但当我唤起了心灵的力量，</p>

<p>理智就变成了一个重要的伙伴，</p>

<p>这种组合我称之为，</p>

<p>『心的智慧』。</p>

<p>我们无须再害怕自己和他人的分歧，矛盾和问题，因为即使星星有时也会碰在一起，形成新的世界，今天我明白，这就是</p>

<p>『生命』！</p>
<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-10T09:09:08+08:00" data-updated="true" itemprop="datePublished">Apr 10<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/10/uikit-dynamicsji-yu-wu-li-yin-qing-xin-te-xing/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/10/uikit-dynamicsji-yu-wu-li-yin-qing-xin-te-xing/" itemprop="url">UIKit-Dynamics基于物理引擎新特性</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>UIKit Dynamics 是 iOS 7 中基于物理动画引擎的一个新功能&#8211;它被特别设计使其能很好地与 collection views 配合工作，而后者是在 iOS 6 中才被引入的新特性。接下来，我们要好好看看如何将这两个特性结合在一起。 </p>

<p>这篇文章将讨论两个结合使用 UIkit Dynamics 和 collection view 的例子。第一个例子展示了如何去实现像 iOS 7 里信息 app 中的消息泡泡的弹簧动效，然后再进一步结合平铺机制来实现布局的可伸缩性。第二个例子展现了如何用 UIKit Dynamics 来模拟<a href="http://zh.wikipedia.org/wiki/牛顿摆">牛顿摆</a>，这个例子中物体可以一个个地加入到 collection view 中，并和其他物体发生相互作用。</p>

<p>在我们开始之前，我假定你们对 <code>UICollectionView</code> 是如何工作是有基本的了解——查看<a href="http://www.objccn.io/issue-3-3/">这篇 objc.io 文章</a>会有你想要的所有细节。我也假定你已经理解了 <code>UIKit Dynamics</code> 的工作原理&#8211;阅读这篇<a href="http://www.teehanlax.com/blog/introduction-to-uikit-dynamics/">博客</a>，可以了解更多 UIKit Dynamics 的知识。</p>

<blockquote>
  <p><span class="secondary radius label">编者注</span> 如果您阅读本篇文章感觉有点吃力的话，可以先来看看 <a href="http://im.onevcat.com">@onevcat</a> 的<a href="http://onevcat.com/2012/06/introducing-collection-views/">《UICollectionView 入门》</a> 和<a href="http://onevcat.com/2013/06/uikit-dynamics-started/">《UIKit Dynamics 入门》</a>这两篇入门文章，帮助您快速补充相关知识。</p>
</blockquote>

<p>文章中的两个例子项目都已经在 GitHub 中:</p>

<ul>
<li><a href="https://github.com/objcio/issue-5-springy-collection-view">ASHSpringyCollectionView</a>（基于 <a href="https://github.com/TeehanLax/UICollectionView-Spring-Demo">UICollectionView Spring Demo</a>）</li>
<li><a href="https://github.com/objcio/issue-5-newtonian-collection-view">Newtownian UICollectionView</a></li>
</ul>

<h2 id="uidynamicanimator">关于 UIDynamicAnimator</h2>

<p>支持 <code>UICollectionView</code> 实现 UIKit Dynamics 的最关键部分就是 <code>UIDynamicAnimator</code>。要实现这样的 UIKit Dynamics 的效果，我们需要自己自定义一个继承于 <code>UICollectionViewFlowLayout</code> 的子类，并且在这个子类对象里面持有一个 UIDynamicAnimator 的对象。</p>

<p>当我们创建自定义的 dynamic animator 时，我们不会使用常用的初始化方法 <code>-initWithReferenceView:</code> ，因为我们不需要把这个 dynamic animator 关联一个 view ，而是给它关联一个 collection view layout。所以我们使用 <code>-initWithCollectionViewLayout:</code> 这个初始化方法，并把 collection view layout 作为参数传入。这很关键，当的 animator 的 behavior item 的属性应该被更新的时候，它必须能够确保 collection view 的 layout 失效。换句话说，dynamic animator 将会经常使旧的 layout 失效。</p>

<p>我们很快就能看到这些事情是怎么连接起来的，但是在概念上理解 collection view 如何与 dynamic animator 相互作用是很重要的。</p>

<p>Collection view layout 将会为 collection view 中的每个 <code>UICollectionViewLayoutAttributes</code> 添加 behavior（稍后我们会讨论平铺它们）。在将这些 behaviors 添加到 dynamic animator 之后，UIKit 将会向 collection view layout 询问 atrribute 的状态。我们此时可以直接将由 dynamic animator 所提供的 items 返回，而不需要自己做任何计算。Animator 将在模拟时禁用 layout。这会导致 UIKit 再次查询 layout，这个过程会一直持续到模拟满足设定条件而结束。</p>

<p>所以重申一下，layout 创建了 dynamic animator，并且为其中每个 item 的 layout attribute 添加对应的 behaviors。当 collection view 需要 layout 信息时，由 dynamic animator 来提供需要的信息。</p>

<h2 id="uicollectionviewflowlayout">继承 UICollectionViewFlowLayout</h2>

<p>我们将要创建一个简单的例子来展示如何使用一个带 UIkit Dynamic 的 collection view layout。当然，我们需要做的第一件事就是，创建一个数据源去驱动我们的 collection view。我知道以你的能力完全可以独立实现一个数据源，但是为了完整性，我还是提供了一个给你:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">ASHCollectionViewController</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="n">NSString</span> <span class="o">*</span> <span class="n">CellIdentifier</span> <span class="o">=</span> <span class="s">@&quot;CellIdentifier&quot;</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span> <span class="nl">registerClass:</span><span class="p">[</span><span class="n">UICollectionViewCell</span> <span class="n">class</span><span class="p">]</span>
</span><span class="line">            <span class="nl">forCellWithReuseIdentifier:</span><span class="n">CellIdentifier</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="n">UIStatusBarStyle</span><span class="p">)</span><span class="nf">preferredStatusBarStyle</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">UIStatusBarStyleLightContent</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="nl">viewDidAppear:</span><span class="n">animated</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionViewLayout</span> <span class="n">invalidateLayout</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="cp">#pragma mark - UICollectionView Methods</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="n">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span>
</span><span class="line">    <span class="nf">numberOfItemsInSection:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">section</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">120</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="n">UICollectionViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="n">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span>
</span><span class="line">                 <span class="nf">cellForItemAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">UICollectionViewCell</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">collectionView</span>
</span><span class="line">        <span class="nl">dequeueReusableCellWithReuseIdentifier:</span><span class="n">CellIdentifier</span>
</span><span class="line">                                  <span class="nl">forIndexPath:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">cell</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">orangeColor</span><span class="p">];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">cell</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们注意到当 view 第一次出现的时候，这个 layout 是被无效的。这是因为没有用 Storyboard 的结果（使用或不使用 Storyboard，调用 prepareLayout 方法的时机是不同的，苹果在 WWDC 的视频中并没有告诉我们这一点）。所以，当这些视图一出现我们就需要手动使这个 collection view layout 无效。当我们用平铺（后面会详细介绍）的时候，就不需要这样。</p>

<p>现在来创建自定义的 collection view layout 吧，我们需要强引用一个 dynamic animator，并且使用它来驱动我们的 collcetion view layout 的 attribute。我们在实现文件里定义了一个私有属性：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">ASHSpringyCollectionViewFlowLayout</span> <span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">UIDynamicAnimator</span> <span class="o">*</span><span class="n">dynamicAnimator</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们将在 layout 的初始化方法中初始化我们的 dynamic animator。还要设置一些属于父类 <code>UICollectionViewFlowLayout</code> 中的属性:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">]))</span> <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">minimumInteritemSpacing</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">minimumLineSpacing</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">itemSize</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">44</span><span class="p">,</span> <span class="mi">44</span><span class="p">);</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">sectionInset</span> <span class="o">=</span> <span class="n">UIEdgeInsetsMake</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIDynamicAnimator</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithCollectionViewLayout:</span><span class="n">self</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们将实现的下一个方法是 prepareLayout。我们首先需要调用父类的方法。因为我们是继承 <code>UICollectionViewFlowLayout</code> 类，所以在调用父类的 prepareLayout 方法时，可以使 collection view layout 的各个 attribute 都放置在合适的位置。我们可以依靠父类的这个方法来提供一个默认的排布，并且能够使用 <code>[super layoutAttributesForElementsInRect:visibleRect];</code> 方法得到指定 rect 内的<em>所有</em> item 的 layout attributes。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">super</span> <span class="n">prepareLayout</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">CGSize</span> <span class="n">contentSize</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">contentSize</span><span class="p">;</span>
</span><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nl">layoutAttributesForElementsInRect:</span>
</span><span class="line">    <span class="n">CGRectMake</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="n">contentSize</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">contentSize</span><span class="p">.</span><span class="n">height</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这<em>真的</em>是效率低下的代码。因为我们的 collection view 中可能会有成千上万个 cell，一次性加载所有的 cell 是一个可能会产生难以置信的内存紧张的操作。我们要在一段时间内遍历所有的元素，这也成为耗时的操作。这真的是效率的双重打击！别担心——我们是负责任的开发者，所以我们会很快解决这个问题的。我们先暂时继续使用简单、粗暴的实现方式。</p>

<p>当加载完我们所有的 collection view layout attribute 之后，我们需要检查他们是否都已经被加载到我们的 animator 里了。如果一个 behavior 已经在 animator 中存在，那么我们就不能重新添加，否则就会得到一个非常难懂的运行异常提示:</p>

<pre><code>&lt;UIDynamicAnimator: 0xa5ba280&gt; (0.004987s) in 
&lt;ASHSpringyCollectionViewFlowLayout: 0xa5b9e60&gt; \{\{0, 0}, \{0, 0\}\}: 
body &lt;PKPhysicsBody&gt; type:&lt;Rectangle&gt; representedObject:
[&lt;UICollectionViewLayoutAttributes: 0xa281880&gt; 
index path: (&lt;NSIndexPath: 0xa281850&gt; {length = 2, path = 0 - 0}); 
frame = (10 10; 300 44); ] 0xa2877c0  
PO:(159.999985,32.000000) AN:(0.000000) VE:(0.000000,0.000000) AV:(0.000000) 
dy:(1) cc:(0) ar:(1) rs:(0) fr:(0.200000) re:(0.200000) de:(1.054650) gr:(0) 
without representedObject for item &lt;UICollectionViewLayoutAttributes: 0xa3833e0&gt; 
index path: (&lt;NSIndexPath: 0xa382410&gt; {length = 2, path = 0 - 0}); 
frame = (10 10; 300 44);
</code></pre>

<p>如果看到了这个错误，那么这基本表明你添加了两个 behavior 给同一个 <code>UICollectionViewLayoutAttribute</code>，这使得系统不知道该怎么处理。</p>

<p>无论如何，一旦我们已经检查好我们是否已经将 behavior 添加到 dynamic animator 之后，我们就需要遍历每个 collection view layout attribute 来创建和添加新的 dynamic animator：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span><span class="p">.</span><span class="n">behaviors</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">items</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">UIDynamicItem</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">UIAttachmentBehavior</span> <span class="o">*</span><span class="n">behaviour</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIAttachmentBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItem:</span><span class="n">obj</span>
</span><span class="line">                                                                    <span class="nl">attachedToAnchor:</span><span class="p">[</span><span class="n">obj</span> <span class="n">center</span><span class="p">]];</span>
</span><span class="line">
</span><span class="line">        <span class="n">behaviour</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span><span class="line">        <span class="n">behaviour</span><span class="p">.</span><span class="n">damping</span> <span class="o">=</span> <span class="mf">0.8f</span><span class="p">;</span>
</span><span class="line">        <span class="n">behaviour</span><span class="p">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="nl">addBehavior:</span><span class="n">behaviour</span><span class="p">];</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这段代码非常简单。我们为每个 item 创建了一个以物体的中心为附着点的 <code>UIAttachmentBehavior</code> 对象。然后又设置了我们的 attachment behavior 的 length 为 0 以便约束这个 cell 能一直以 behavior 的附着点为中心。然后又给 <code>damping</code> 和 <code>frequency</code> 这两个参数设置一个比较合适的值。</p>

<p>这就是 <code>prepareLayout</code>。我们现在需要实现 <code>layoutAttributesForElementsInRect:</code> 和 <code>layoutAttributesForItemAtIndexPath:</code> 这两个方法，UIKit 会调用它们来询问 collection view 每一个 item 的布局信息。我们写的代码会把这些查询交给专门做这些事的 dynamic animator:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">layoutAttributesForElementsInRect:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">rect</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="nl">itemsInRect:</span><span class="n">rect</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="n">UICollectionViewLayoutAttributes</span> <span class="o">*</span><span class="p">)</span><span class="nf">layoutAttributesForItemAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="nl">layoutAttributesForCellAtIndexPath:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h1>响应滚动事件</h1>

<p>我们目前实现的代码给我们展示的只是一个在正常滑动下只有静态感觉的 <code>UICollectionView</code>，运行起来没什么特别的。看上去很好，但不是真的<em>动态</em>，不是么？</p>

<p>为了使它表现地动态点，我们需要 layout 和 dynamic animator 能够对 collection view 中滑动位置的变化做出反应。幸好这里有个非常适合这个要求的方法 <code>shouldInvalidateLayoutForBoundsChange:</code>。这个方法会在 collection view 的 bound 发生改变的时候被调用，根据最新的 <a href="http://www.objccn.io/issue-3-2/">content offset</a> 调整我们的 dynamic animator 中的 behaviors 的参数。在重新调整这些 behavior 的 item 之后，我们在这个方法中返回 NO；因为 dynamic animator 会关心 layout 的无效问题，所以在这种情况下，它不需要去主动使其无效：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">shouldInvalidateLayoutForBoundsChange:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">newBounds</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">UIScrollView</span> <span class="o">*</span><span class="n">scrollView</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">;</span>
</span><span class="line">    <span class="n">CGFloat</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">newBounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">scrollView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">CGPoint</span> <span class="n">touchLocation</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">panGestureRecognizer</span> <span class="nl">locationInView:</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span><span class="p">.</span><span class="n">behaviors</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">UIAttachmentBehavior</span> <span class="o">*</span><span class="n">springBehaviour</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">yDistanceFromTouch</span> <span class="o">=</span> <span class="n">fabsf</span><span class="p">(</span><span class="n">touchLocation</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">springBehaviour</span><span class="p">.</span><span class="n">anchorPoint</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">xDistanceFromTouch</span> <span class="o">=</span> <span class="n">fabsf</span><span class="p">(</span><span class="n">touchLocation</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">springBehaviour</span><span class="p">.</span><span class="n">anchorPoint</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">scrollResistance</span> <span class="o">=</span> <span class="p">(</span><span class="n">yDistanceFromTouch</span> <span class="o">+</span> <span class="n">xDistanceFromTouch</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1500.0f</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="n">UICollectionViewLayoutAttributes</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">springBehaviour</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">firstObject</span><span class="p">;</span>
</span><span class="line">        <span class="n">CGPoint</span> <span class="n">center</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">delta</span><span class="o">*</span><span class="n">scrollResistance</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">else</span> <span class="p">{</span>
</span><span class="line">            <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">delta</span><span class="o">*</span><span class="n">scrollResistance</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">item</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="nl">updateItemUsingCurrentState:</span><span class="n">item</span><span class="p">];</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>让我们仔细查看这个代码的细节。首先我们得到了这个 scroll view（就是我们的 collection view ），然后计算它的 content offset 中 y 的变化（在这个例子中，我们的 collection view 是垂直滑动的）。一旦我们得到这个增量，我们需要得到用户接触的位置。这是非常重要的，因为我们希望离接触位置比较近的那些物体能移动地更迅速些，而离接触位置比较远的那些物体则应该滞后些。</p>

<p>对于 dynamic animator 中的每个 behavior，我们将接触点到该 behavior 物体的 x 和 y 的距离之和除以 1500，1500 是我根据经验设的。分母越小，这个 collection view 的的交互就越有弹簧的感觉。一旦我们拿到了这个“滑动阻力”的值，我们就可以用它的增量乘上 <code>scrollResistance</code> 这个变量来指定这个 behavior 物体的中心点的 y 值。最后，我们在滑动阻力大于增量的情况下对增量和滑动阻力的结果进行了选择（这意味着物体开始往错误的方向移动了）。在本例我们用了这么大的分母，那么这种情况是不可能的，但是在一些更具弹性的 collection view layout 中还是需要注意的。</p>

<p>就是这么一回事。以我的经验，这个方法对多达几百个物体的 collection view 来说也是是适用的。超过这个数量的话，一次性加载所有物体到内存中就会变成很大的负担，并且在滑动的时候就会开始卡顿了。</p>

<p><img src="http://img.objccn.io/issue-5/springyCollectionView.gif" alt="Springy Collection View" /></p>

<h2 id="tilingdynamicbehaviors">平铺（Tiling）你的 Dynamic Behaviors 来优化性能</h2>

<p>当你的 collection view 中只有几百个 cell 的时候，他运行的很好，但当数据源超过这个范围的时候会发生什么呢？或者在运行的时你不能预测你的数据源有多大呢？我们的简单粗暴的方法就不管用了。</p>

<p>除了在 <code>prepareLayout</code> 中加载<em>所有</em>的物体，如果我们能<em>更聪明地</em>知道哪些物体会加载那该多好啊。是的，就是仅加载显示的和即将显示的物体。这正是我们要采取的办法。</p>

<p>我们需要做的第一件事就是是跟踪 dynamic animator 中的所有 behavior 物体的 index path。我在 collection view 中添加一个属性来做这件事:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSMutableSet</span> <span class="o">*</span><span class="n">visibleIndexPathsSet</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们用 set 是因为它具有常数复杂度的查找效率，并且我们<em>经常</em>地查找 <code>visibleIndexPathsSet</code> 中是否已经包含了某个 index path。</p>

<p>在我们实现全新的 <code>prepareLayout</code> 方法之前——有一个问题就是什么是<strong>平铺 behavior</strong> —— 理解平铺的意思是非常重要的。当我们平铺behavior 的时候，我们会在这些 item 离开 collection view 的可视范围的时候删除对应的 behavior，在这些 item 进入可视范围的时候又添加对应的 behavior。这是一个大麻烦：我们需要在<em>滚动中</em>创建新的 behavior。这就意味着让人觉得创建它们就好像它们本来就已经在 dynamic animator 里了一样，并且它们是在 <code>shouldInvalidateLayoutForBoundsChange:</code> 方法被修改的。</p>

<p>因为我们是在滚动中创建这些新的 behavior，所以我们需要维持现在 collection view 的一些状态。尤其我们需要跟踪最近一次我们 <code>bound</code> 变化的增量。我们会在滚动时用这个状态去创建我们的 behavior：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">latestDelta</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>添加完这个 property 后，我们将要在 <code>shouldInvalidateLayoutForBoundsChange:</code> 方法中添加下面这行代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">self</span><span class="p">.</span><span class="n">latestDelta</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这就是我们需要修改我们的方法来响应滚动事件。我们的这两个方法是为了将 collection view 中 items 的 layout 信息传给 dynamic animator，这种方式没有变化。事实上，当你的 collection view 实现了 dynamic animator 的大部分情况下，都需要实现我们上面提到的两个方法 <code>layoutAttributesForElementsInRect:</code> 和 <code>layoutAttributesForItemAtIndexPath:</code>。</p>

<p>这里最难懂的部分就是平铺机制。我们将要完全重写我们的 prepareLayout。</p>

<p>这个方法的第一步是将那些物体的 index path 已经不在屏幕上显示的 behavior 从 dynamic animator 上删除。第二步是添加那些即将显示的物体的 behavior。</p>

<p>让我们先看一下第一步。</p>

<p>像以前一样，我们要调用 <code>super prepareLayout</code>，这样我们就能依赖父类 <code>UICollectionViewFlowLayout</code> 提供的默认排布。还像以前一样，我们通过父类获取一个矩形内的所有元素的 layout attribute。不同的是我们不是获取整个 collection view 中的元素属性，而只是获取显示范围内的。</p>

<p>所以我们需要计算这个显示矩形。但是别着急！有件事要记住。我们的用户可能会非常快地滑动 collection view，导致了 dynamic animator 不能跟上，所以我们需要稍微扩大显示范围，这样就能包含到那些将要显示的物体了。否则，在滑动很快的时候就会出现频闪现象了。让我们计算一下显示范围:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGRect</span> <span class="n">originalRect</span> <span class="o">=</span> <span class="p">(</span><span class="n">CGRect</span><span class="p">){.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">,</span> <span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">};</span>
</span><span class="line"><span class="n">CGRect</span> <span class="n">visibleRect</span> <span class="o">=</span> <span class="n">CGRectInset</span><span class="p">(</span><span class="n">originalRect</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我确信在实际显示矩形上的每个方向都扩大100个像素对我的 demo 来说是可行的。仔细查看这些值是否适合你们的 collection view，尤其是当你们的 cell 很小的情况下。</p>

<p>接下来我们就需要收集在显示范围内的 collection view layout attributes。还有它们的 index paths:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">itemsInVisibleRectArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nl">layoutAttributesForElementsInRect:</span><span class="n">visibleRect</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">NSSet</span> <span class="o">*</span><span class="n">itemsIndexPathsInVisibleRectSet</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSSet</span> <span class="nl">setWithArray:</span><span class="p">[</span><span class="n">itemsInVisibleRectArray</span> <span class="nl">valueForKey:</span><span class="s">@&quot;indexPath&quot;</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意我们是在用一个 NSSet。这是因为它具有常数复杂度的查找效率，并且我们经常的查找 <code>visibleIndexPathsSet</code> 是否已经包含了某个 index path:</p>

<p>接下来我们要做的就是遍历 dynamic animator 的 behaviors，过滤掉那些已经在 <code>itemsIndexPathsInVisibleRectSet</code> 中的 item。因为我们已经过滤掉我们的 behavior，所以我们将要遍历的这些 item 都是不在显示范围里的，我们就可以将这些 item 从 animator 中删除掉（连同 <code>visibleIndexPathsSet</code> 属性中的 index path）:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSPredicate</span> <span class="o">*</span><span class="n">predicate</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSPredicate</span> <span class="nl">predicateWithBlock:</span><span class="o">^</span><span class="kt">BOOL</span><span class="p">(</span><span class="n">UIAttachmentBehavior</span> <span class="o">*</span><span class="n">behaviour</span><span class="p">,</span> <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">bindings</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">BOOL</span> <span class="n">currentlyVisible</span> <span class="o">=</span> <span class="p">[</span><span class="n">itemsIndexPathsInVisibleRectSet</span> <span class="nl">member:</span><span class="p">[[[</span><span class="n">behaviour</span> <span class="n">items</span><span class="p">]</span> <span class="n">firstObject</span><span class="p">]</span> <span class="n">indexPath</span><span class="p">]]</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="o">!</span><span class="n">currentlyVisible</span><span class="p">;</span>
</span><span class="line"><span class="p">}]</span>
</span><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">noLongerVisibleBehaviours</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span><span class="p">.</span><span class="n">behaviors</span> <span class="nl">filteredArrayUsingPredicate:</span><span class="n">predicate</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">noLongerVisibleBehaviours</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">index</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="nl">removeBehavior:</span><span class="n">obj</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">visibleIndexPathsSet</span> <span class="nl">removeObject:</span><span class="p">[[[</span><span class="n">obj</span> <span class="n">items</span><span class="p">]</span> <span class="n">firstObject</span><span class="p">]</span> <span class="n">indexPath</span><span class="p">]];</span>
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>下一步就是要得到<em>新</em>出现 item 的 <code>UICollectionViewLayoutAttributes</code> 数组——那些 item 的 index path 在 <code>itemsIndexPathsInVisibleRectSet</code> 而不在 <code>visibleIndexPathsSet</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSPredicate</span> <span class="o">*</span><span class="n">predicate</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSPredicate</span> <span class="nl">predicateWithBlock:</span><span class="o">^</span><span class="kt">BOOL</span><span class="p">(</span><span class="n">UICollectionViewLayoutAttributes</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">bindings</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">BOOL</span> <span class="n">currentlyVisible</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">visibleIndexPathsSet</span> <span class="nl">member:</span><span class="n">item</span><span class="p">.</span><span class="n">indexPath</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="o">!</span><span class="n">currentlyVisible</span><span class="p">;</span>
</span><span class="line"><span class="p">}];</span>
</span><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">newlyVisibleItems</span> <span class="o">=</span> <span class="p">[</span><span class="n">itemsInVisibleRectArray</span> <span class="nl">filteredArrayUsingPredicate:</span><span class="n">predicate</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>一旦我们有新的 layout attribute 出现，我就可以遍历他们来创建新的 behavior，并且将他们的 index path 添加到 <code>visibleIndexPathsSet</code> 中。首先，无论如何，我都需要获取到用户手指触碰的位置。如果它是 <code>CGPointZero</code> 的话，那就表示这个用户没有在滑动 collection view，这时我就<em>假定</em>我们不需要在滚动时创建新的 behavior 了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGPoint</span> <span class="n">touchLocation</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">panGestureRecognizer</span> <span class="nl">locationInView:</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这是一个潜藏危险的假定。如果用户很快地滑动了 collection view 之后释放了他的手指呢？这个 collection view 就会一直滚动，但是我们的方法就不会在滚动时创建新的 behavior 了。但幸运的是，那也就意味这时 scroll view 滚动太快很难被注意到！好哇！但是，对于那些拥有大型 cell 的 collection view 来说，这仍然是个问题。那么在这种情况下，就需要增加你的可视范围的 bounds 来加载更多物体以解决这个问题。</p>

<p>现在我们需要枚举我们刚显示的 item，为他们创建 behavior，再将他们的 index path 添加到 <code>visibleIndexPathsSet</code>。我们还需要在滚动时做些<a href="http://www.youtube.com/watch?v=gENVB6tjq_M">数学运算</a>来创建 behavior：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">newlyVisibleItems</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">UICollectionViewLayoutAttributes</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">CGPoint</span> <span class="n">center</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class="line">    <span class="n">UIAttachmentBehavior</span> <span class="o">*</span><span class="n">springBehaviour</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIAttachmentBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItem:</span><span class="n">item</span> <span class="nl">attachedToAnchor:</span><span class="n">center</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">springBehaviour</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span><span class="line">    <span class="n">springBehaviour</span><span class="p">.</span><span class="n">damping</span> <span class="o">=</span> <span class="mf">0.8f</span><span class="p">;</span>
</span><span class="line">    <span class="n">springBehaviour</span><span class="p">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CGPointEqualToPoint</span><span class="p">(</span><span class="n">CGPointZero</span><span class="p">,</span> <span class="n">touchLocation</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">yDistanceFromTouch</span> <span class="o">=</span> <span class="n">fabsf</span><span class="p">(</span><span class="n">touchLocation</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">springBehaviour</span><span class="p">.</span><span class="n">anchorPoint</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">xDistanceFromTouch</span> <span class="o">=</span> <span class="n">fabsf</span><span class="p">(</span><span class="n">touchLocation</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">springBehaviour</span><span class="p">.</span><span class="n">anchorPoint</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">scrollResistance</span> <span class="o">=</span> <span class="p">(</span><span class="n">yDistanceFromTouch</span> <span class="o">+</span> <span class="n">xDistanceFromTouch</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1500.0f</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">latestDelta</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">latestDelta</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">latestDelta</span><span class="o">*</span><span class="n">scrollResistance</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">else</span> <span class="p">{</span>
</span><span class="line">            <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">latestDelta</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">latestDelta</span><span class="o">*</span><span class="n">scrollResistance</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">item</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="nl">addBehavior:</span><span class="n">springBehaviour</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">visibleIndexPathsSet</span> <span class="nl">addObject:</span><span class="n">item</span><span class="p">.</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>大部分代码看起来还是挺熟悉的。大概有一半是来自没有实现平铺的 <code>prepareLayout</code>。另一半是来自 <code>shouldInvalidateLayoutForBoundsChange:</code> 这个方法。我们用 latestDelta 这个属性来表示 <code>bound</code> 变化的增量，适当地调整 <code>UICollectionViewLayoutAttributes</code> 使这些 cell 表现地就像被 attachment behavior “拉”着一样。</p>

<p>就这样就完成了，真的！我已经在真机上测试过显示上千个 cell 的情况了，它运行地非常完美。<a href="https://github.com/objcio/issue-5-springy-collection-view">去试试吧</a>。</p>

<h2>超越瀑布流布局</h2>

<p>一般来说，当我们使用 <code>UICollectionView</code> 的时候，继承 <code>UICollectionViewFlowLayout</code> 会比直接继承 <code>UICollectionViewLayout</code> 更容易。这是因为 <em>flow</em> layout 会为我们做很多事。然而，瀑布流布局是严格基于它们的尺寸一个接一个的展现出来。如果你有一个布局不能适应这个标准怎么办？好的，如果你已经尝试用 <code>UICollectionViewFlowLayout</code> 来适应，而且你很确定它不能很好运行，那么就应该抛弃 <code>UICollectionViewFlowLayout</code> 这个定制性比较弱的子类，而应该直接在 <code>UICollectionViewLayout</code> 这个基类上进行定制。</p>

<p>这个原则在处理 UIKit Dynamic 时也是适用的。</p>

<p>让我们先创建 <code>UICollectionViewLayout</code> 的子类。当继承 <code>UICollectionViewLayout</code> 的时候需要实现 <code>collectionViewContentSize</code> 方法，这点非常重要。否则这个 collection view 就不知道如果去显示自己，也不会有显示任何东西。因为我们想要 collection view 不能滚动，所以这里要返回 collection view 的 frame 的 size，减去它的 <code>contentInset.top</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span><span class="p">(</span><span class="n">CGSize</span><span class="p">)</span><span class="nf">collectionViewContentSize</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">contentInset</span><span class="p">.</span><span class="n">top</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在这个（有点教学式）的例子中，我们的 collection view <em>总是会以零个cell开始</em>，物体通过 <code>performBatchUpdates:</code> 这个方法添加。这就意味着我们必须使用 <code>-[UICollectionViewLayout prepareForCollectionViewUpdates:]</code> 这个方法来添加我们的 behavior（即这个 collection view 的数据源总是以零开始）。</p>

<p>除了给各个 item 添加 attachment behavior 外，我们还将保留另外两个 behavior：重力和碰撞。对于添加在这个 collection view 中的每个 item 来说，我们必须把这些 item 添加到我们的碰撞和 attachment behavior 中。最后一步就是设置这些 item 的初始位置为屏幕外的某些地方，这样就有被 attachment behavior 拉入到屏幕内的效果了:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">prepareForCollectionViewUpdates:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">updateItems</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="nl">prepareForCollectionViewUpdates:</span><span class="n">updateItems</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">updateItems</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">UICollectionViewUpdateItem</span> <span class="o">*</span><span class="n">updateItem</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">updateItem</span><span class="p">.</span><span class="n">updateAction</span> <span class="o">==</span> <span class="n">UICollectionUpdateActionInsert</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">UICollectionViewLayoutAttributes</span> <span class="o">*</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">UICollectionViewLayoutAttributes</span>
</span><span class="line">                <span class="nl">layoutAttributesForCellWithIndexPath:</span><span class="n">updateItem</span><span class="p">.</span><span class="n">indexPathAfterUpdate</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">            <span class="n">attributes</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">CGRectGetMaxX</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">frame</span><span class="p">)</span> <span class="o">+</span> <span class="n">kItemSize</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="n">kItemSize</span><span class="p">,</span> <span class="n">kItemSize</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">            <span class="n">UIAttachmentBehavior</span> <span class="o">*</span><span class="n">attachmentBehaviour</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIAttachmentBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItem:</span><span class="n">attributes</span>
</span><span class="line">                                                                                  <span class="nl">attachedToAnchor:</span><span class="n">attachmentPoint</span><span class="p">];</span>
</span><span class="line">            <span class="n">attachmentBehaviour</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mf">300.0f</span><span class="p">;</span>
</span><span class="line">            <span class="n">attachmentBehaviour</span><span class="p">.</span><span class="n">damping</span> <span class="o">=</span> <span class="mf">0.4f</span><span class="p">;</span>
</span><span class="line">            <span class="n">attachmentBehaviour</span><span class="p">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span><span class="line">            <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="nl">addBehavior:</span><span class="n">attachmentBehaviour</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">            <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">gravityBehaviour</span> <span class="nl">addItem:</span><span class="n">attributes</span><span class="p">];</span>
</span><span class="line">            <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collisionBehaviour</span> <span class="nl">addItem:</span><span class="n">attributes</span><span class="p">];</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://img.objccn.io/issue-5/newtonianCollectionView.gif" alt="Demo" /></p>

<p>删除就有点复杂了。我们希望这些物体有“掉落”的效果而不是简单的消失。这就不仅仅是从 collection view 中删除个 cell 这么简单了，因为我们希望在它离开了屏幕之前还是保留它。我已经在代码中实现了这样的效果，但是做法有点取巧。</p>

<p>基本上我们要做的是在 layout 中提供一个方法，在它删除 attachment behavior 两秒之后，将这个 cell 从 collection view 中删除。我们希望在这段时间里，这个 cell 能掉出屏幕，但是这不一定会发生。如果没有发生，也没关系。只要淡出就行了。然而，我们必须保证在这两秒内既没有新的 cell 被添加，也没有旧的 cell 被删除。（我说了有点取巧。）</p>

<p>欢迎提交 pull request。</p>

<p>这个方法是有局限性的。我将 cell 数量的上限设为 10，但是即使这样，在像 iPad2 这样比较旧的设备中，动画就会运行地很慢。当然，这个例子只是为了展示如何模拟有趣的动力学的一个方法——它并不是一个可以解决任何问题的万金油。你个人在实践中如何来进行模拟，包括性能等各个方面，都取决于你自己了。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
        <a href="/Blog/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/Blog/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    Rick


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
</body>
</html>
