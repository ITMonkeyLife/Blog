
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>IT Monkey Life</title>
	<meta name="author" content="Rick">

	
	<meta name="description" content="关于 这篇文章简要介绍了苹果于WWDC 2014发布的编程语言——Swift。 原文作者： Lucida Blog
新浪微博
豆瓣 转载前请保留出处链接，谢谢。 前言 在这里我认为有必要提一下Bret Victor的Inventing on Principle， &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/Blog/atom.xml" rel="alternate" title="IT Monkey Life" type="application/atom+xml">
	
	<link rel="canonical" href="http://ITMonkeyLife.github.io/Blog/">
	<link href="/Blog/favicon.png" rel="shortcut icon">
	<link href="/Blog/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/Blog/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-52658428-1']);
		_gaq.push(['_setDomainName','github.io']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>


</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/Blog/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("382542165@qq.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>

<nav id="main-nav">
<section class="aboutme">
  <p class = "subtitle">
    心无所恃，随遇而安
  </p>
</section>

<ul class="main">
    <li><a href="/Blog/">我的Blog</a></li>
    <li><a href="/Blog/about/">关于我</a></li>
    <li><a href="/Blog/blog/archives">全部文章</a></li>
</ul></nav>
<nav id="sub-nav">
	<div class="social">
    	
			<a class="sina" href="http://weibo.com/1651400041" title="Sina">Sina</a>
		
		
			<a class="email" href="mailto:382542165@qq.com" title="Email">Email</a>
		
		
		
		
		
		
		
		
		
		
		
		
			<a class="douban" href="https://www.douban.com/people/47445127" title="Douban">Douban</a>
		
		
		
    	
    	
			<a class="rss" href="/Blog/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-09-18T13:38:34+08:00" data-updated="true" itemprop="datePublished">Sep 18<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/swift/'>Swift</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/09/18/swiftde-qiang-da-zhi-chu/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/09/18/swiftde-qiang-da-zhi-chu/" itemprop="url">Swift的强大之处</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>在写任何东西之前我需要承认我是带有偏见的：我爱 Swift。我认为这是从我开始接触 Cocoa 生态系统以来这个平台上发生的最好的事情。我想通过分享我在 Swift，Objective-C 和 Haskell 上的经验让大家知道我为何这样认为。写这篇文章并不是为了介绍一些最好的实践 (写这些的时候 Swift 还太年轻，还没最好实践被总结出来)，而是举几个关于 Swift 强大之处的例子。</p>

<p>给大家一些我的个人背景：在成为全职 iOS/Mac 工程师之前我花了几年的时间做 Haskell (包括一些其他函数式编程语言) 开发。我仍然认为 Haskell 是我所有使用过的语言中最棒的之一。然而我转战到了 Objective-C，是因为我相信 iOS 是最令人激动的平台。刚开始接触 Objective-C 的时候我有些许沮丧，但我慢慢地学会了欣赏它。</p>

<p>当苹果在 WWDC 发布 Swift 的时候我非常的激动。我已经很久没有对新技术的发布感的如此兴奋了。在看过文档之后我意识到 Swift 使我们能够将现有的函数式编程知识和 Cocoa API 无缝地整合到一起。我觉得这两者的组合非常独特：没有任何其他的语言将它们融合地如此完美。就拿 Haskell 来说，想要用它来使用 Objective-C API 相当的困难。同样，想用 Objective-C 去做函数式编程也是十分困难的。</p>

<p>在 Utrecht 大学期间我学会了函数式编程。因为是在很学术的环境下学习所以并没有觉得很多复杂的术语 (moands，applicative functors 以及很多其他的东西) 有多么难懂。我觉得对很多想学习函数式编程的人来说这些名称是一个很大的阻碍。</p>

<p>不仅仅名称很不同，风格也不一样。作为 Objective-C 程序员，我们很习惯于面向对象编程。而且因为大多数语言不是面对对象编程就是与之类似，我们可以看懂很多不同语言的代码。阅读函数式编程语言的时候则大不相同 &#8211; 如果你没有习惯的话看起来简直莫名其妙。</p>

<p>那么，为什么你要使用函数式编程呢？它很奇怪，很多人都不习惯而且学习它要花费大量的时间。并且对于大多数问题面向对象编程都能解决，所以没有必要去学习任何新的东西对吧？</p>

<p>对于我来说，函数式编程只是工具箱中的一件工具。它是一个改变了我对编程的理解的强大工具。在解决问题的时候它非常强大。对于大多数问题面向对象编程都很棒，但是对于其他一些问题应用函数式编程会给你带来巨大的时间/精力的节省。</p>

<p>开始学习函数式编程或许有些痛苦。第一，你必须放手一些老的模式。而因为我们很多人常年用面对对象的方式去思考，做到这一点是很困难的。在函数式编程当中你想的是不变的数据结构以及那些转换它们的函数。在面对对象编程当中你考虑的是互相发送信息的对象。如果你没有马上理解函数式编程，这是一个好的信号。你的大脑很可能已经完全适应了用面对对象的方法来解决问题。</p>

<h2>例子</h2>

<p>我最喜欢的 Swift 功能之一是对 optionals 的使用。Optionals 让我们能够应对有可能存在也有可能不存在的值。在 Objective-C 里我们必须在文档中清晰地说明 nil 是否是允许的。Optionals 让我们将这份责任交给了类型系统。如果你有一个可选值，你就知道它可以是 nil。如果它不是可选值，你知道它不可能是 nil。</p>

<p>举个例子，看看下面一小段 Objective-C 代码</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSAttributedString</span> <span class="o">*</span><span class="p">)</span><span class="nf">attributedString:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">input</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[[</span><span class="n">NSAttributedString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithString:</span><span class="n">input</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>看上去没有什么问题，但是如果 <code>input</code> 是 nil, 它就会崩溃。这种问题你只能在运行的时候才能发现。取决于你如何使用它，你可能很快能发现问题，但是你也有可能在发布应用之后才发现，导致用户正在使用的应用崩溃。</p>

<p>用相同的 Swift 的 API 来做对比。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">extension</span> <span class="n">NSAttributedString</span> <span class="p">{</span>
</span><span class="line">    <span class="n">init</span><span class="p">(</span><span class="n">string</span> <span class="nl">str:</span> <span class="n">String</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>看起来像对Objective-C的直接翻译，但是 Swift 不允许 <code>nil</code> 被传入。如果要达到这个目的，API 需要变成这个样子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">extension</span> <span class="n">NSAttributedString</span> <span class="p">{</span>
</span><span class="line">    <span class="n">init</span><span class="p">(</span><span class="n">string</span> <span class="nl">str:</span> <span class="n">String</span><span class="o">?</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意新加上的问号。这意味着你可以使用一个值或者是 nil。类非常的精确：只需要看一眼我们就知道什么值是允许的。使用 optionals 一段时间之后你会发现你只需要阅读类型而不用再去看文档了。如果犯了一个错误，你会得到一个编译时警告而不是一个运行时错误。</p>

<h2>建议</h2>

<p>如果可能的话避免使用 optionals。Optionals 对于使用你 API 的人们来说是一个多余的负担。话虽如此，还是有很多地方可以很好使用它们。如果你有一个函数会因为一个明显的原因失败你可以返回一个 optional。举例来说，比如将一个  #00ff00 字符串转换成颜色。如果你的参数不符合正确的格式，你应该返回一个 <code>nil</code> 。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">parseColorFromHexString</span><span class="p">(</span><span class="nl">input:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UIColor</span><span class="o">?</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// ...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果你需要阐明错误信息，你可以使用 <code>Either</code> 或者 <code>Result</code> 类型 (不在标准库里面)。当失败的原因很重要的时候，这种做法会非常有用。<a href="http://nomothetis.svbtle.com/error-handling-in-swift">“Error Handling in Swift”</a> 一文中有个很好的例子。</p>

<h2 id="enums">Enums</h2>

<p>Enums 是一个随 Swift 推出的新东西，它和我们在 Objective-C 中见过的东西都大不相同。在 Objective-C 里面我们有一个东西叫做 enums, 但是它们差不多就是升级版的整数。</p>

<p>我们来看看布尔类型。一个布尔值是两种可能性 &#8211; true 或者 false &#8211; 中的一个。很重要的一点是没有办法再添加另外一个值 &#8211; 布尔类型是<strong>封闭的</strong>。布尔类型的封闭性的好处是每当使用布尔值的时候我们只需要考虑 true 或者 false 这两种情况。</p>

<p>在这一点上面 optionals 是一样的。总共只有两种情况：<code>nil</code> 或者有值。在 Swift 里面布尔和 optional 都可以被定义为 enums。但有一个不同点：在 optional enum 中有一种可能性有一个相关值。我们来看看它们不同的定义：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">enum</span> <span class="n">Boolean</span> <span class="p">{</span>
</span><span class="line">    <span class="k">case</span> <span class="n">False</span>
</span><span class="line">    <span class="k">case</span> <span class="n">True</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">enum</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Nil</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Some</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>它们非常的相似。如果你把它们的名称改成一样的话，那么唯一的区别就是括号里的相关值。如果你给 optional 中的 <code>Nil</code>  情况也加上一个值，你就会得到一个 <code>Either</code> 类型：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">enum</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Left</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Right</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在函数式编程当中，在你想表示两件事情之间的选择时候你会经常用到 <code>Either</code> 类型。举个例子：如果你有一个函数返回一个整数或者一个错误，你就可以用 <code>Either&lt;Int, NSError&gt;</code>。如果你想在一个字典中储存布尔值或者字符串，你就可以使用 <code>Either&lt;Bool,String&gt;</code> 作为键。</p>

<blockquote>
  <p>理论旁白：有些时候 enums 被称为 <strong>sum 类型</strong>，因为它们是几个不同类型的总和。在 <code>Either</code> 类型的例子中，它们表达的是 <code>A</code> 类型和 <code>B</code> 类型的和。Structs 和 tuples 被称为 <strong>product 类型</strong>，因为它们代表几个不同类型的乘积。参见<a href="http://en.wikipedia.org/wiki/Algebraic_data_type">“algebraic data types.”</a></p>
</blockquote>

<p>理解什么时候使用 enums 什么时候使用其他的数据类型 (比如 <a href="http://objccn.io/issue-16-2">class 或者 structs</a>)会有一些难度。当你有一个固定数量的值的集合的时候，enum 是最有用的。比如说，如果我们设计一个 Github API 的 wrapper，我们可以用 enum 来表示端点。比如有一个不需要任何参数的 <code>/zen</code> 的 API 端点。再比如为了获取用户的资料我们需要提供用户名。最后我们显示用户的仓库时，我们需要提供用户名以及一个值去说明是否从小到大地排列结果。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">enum</span> <span class="n">Github</span> <span class="p">{</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Zen</span>
</span><span class="line">    <span class="k">case</span> <span class="n">UserProfile</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Repositories</span><span class="p">(</span><span class="nl">username:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">sortAscending:</span> <span class="n">Bool</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>定义 API 端点是很好的使用 enum 的场景。API 的端点是有限的，所以我们可以为每一个端点定义一个情况。如果我们在对这些端点使用 switch 的时候没有包含所有情况的话，我们会被给予警告。所以说当我们需要添加一个情况的时候我们需要更新每一个用到这个 enum 的函数。</p>

<p>除非能够拿到源代码，其他使用我们 enum 的人不能添加新的情况，这是一个非常有用的限制。想想要是你能够加一种新情况到 <code>Bool</code> 或者 <code>Optional</code> 里会怎么样吧 &#8211; 所有用到 它的函数都需要重写。</p>

<p>比如说我们正在开发一个货币转换器。我们可以将货币给定义成 enum：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">enum</span> <span class="n">Currency</span> <span class="p">{</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Eur</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Usd</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们现在可以做一个获取任何货币符号的函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">symbol</span><span class="p">(</span><span class="nl">input:</span> <span class="n">Currency</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class="line">    <span class="k">switch</span> <span class="n">input</span> <span class="p">{</span>
</span><span class="line">        <span class="k">case</span> <span class="p">.</span><span class="nl">Eur:</span> <span class="k">return</span> <span class="s">&quot;€&quot;</span>
</span><span class="line">        <span class="k">case</span> <span class="p">.</span><span class="nl">Usd:</span> <span class="k">return</span> <span class="s">&quot;$&quot;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后，我们可以用我们的 <code>symbol</code> 函数，来依据系统本地设置得到一个很好地格式化过的字符串：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">format</span><span class="p">(</span><span class="nl">amount:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">currency:</span> <span class="n">Currency</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class="line">    <span class="n">let</span> <span class="n">formatter</span> <span class="o">=</span> <span class="n">NSNumberFormatter</span><span class="p">()</span>
</span><span class="line">    <span class="n">formatter</span><span class="p">.</span><span class="n">numberStyle</span> <span class="o">=</span> <span class="p">.</span><span class="n">CurrencyStyle</span>
</span><span class="line">    <span class="n">formatter</span><span class="p">.</span><span class="n">currencySymbol</span> <span class="o">=</span> <span class="n">symbol</span><span class="p">(</span><span class="n">currency</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span> <span class="n">formatter</span><span class="p">.</span><span class="n">stringFromNumber</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样一来有一个很大的限制。我们可能会想让我们 API 的使用者在将来可以修改一些情况。在 Objective-C 当中向一个接口里添加更多类型的常见解决方法是子类化。在 Objective-C 里面理论上你可以子类化任何一个类，然后通过这种办法来扩展它。在 Swift 里面你仍然可以使用子类化，但是只能对 <code>class</code> 使用，对于 <code>enum</code> 则不行。然而，我们可以用另一种技术来达到目的 (这种办法在 Objetive-C 和 Swift 的 protocol 中都可行）。</p>

<p>假设我们定义一个货币符号的协议：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">protocol</span> <span class="n">CurrencySymbol</span> <span class="p">{</span>
</span><span class="line">    <span class="n">func</span> <span class="n">symbol</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在我们让 <code>Currency</code> 类型遵守这个协议。注意我们可以将 <code>input</code> 参数去掉，因为这里它被作为 self 隐式地进行传递：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">extension</span> <span class="n">Currency</span> <span class="o">:</span> <span class="n">CurrencySymbol</span> <span class="p">{</span>
</span><span class="line">   <span class="n">func</span> <span class="n">symbol</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class="line">        <span class="k">switch</span> <span class="n">self</span> <span class="p">{</span>
</span><span class="line">            <span class="k">case</span> <span class="p">.</span><span class="nl">Eur:</span> <span class="k">return</span> <span class="s">&quot;€&quot;</span>
</span><span class="line">            <span class="k">case</span> <span class="p">.</span><span class="nl">Usd:</span> <span class="k">return</span> <span class="s">&quot;$&quot;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在我们可以重写 <code>format</code> 方法来格式化任何遵守我们协议的类型：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">format</span><span class="p">(</span><span class="nl">amount:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">currency:</span> <span class="n">CurrencySymbol</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class="line">    <span class="n">let</span> <span class="n">formatter</span> <span class="o">=</span> <span class="n">NSNumberFormatter</span><span class="p">()</span>
</span><span class="line">    <span class="n">formatter</span><span class="p">.</span><span class="n">numberStyle</span> <span class="o">=</span> <span class="p">.</span><span class="n">CurrencyStyle</span>
</span><span class="line">    <span class="n">formatter</span><span class="p">.</span><span class="n">currencySymbol</span> <span class="o">=</span> <span class="n">currency</span><span class="p">.</span><span class="n">symbol</span><span class="p">()</span>
</span><span class="line">    <span class="k">return</span> <span class="n">formatter</span><span class="p">.</span><span class="n">stringFromNumber</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样一来我们将我们代码的可延展性大大提升类 &#8211; 任何遵守 <code>CurrencySymbol</code> 协议的类型都可以被格式化。比如说，我们建立一个新的类型来储存比特币，我们可以立刻让它拥有格式化功能：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">struct</span> <span class="n">Bitcoin</span> <span class="o">:</span> <span class="n">CurrencySymbol</span> <span class="p">{</span>
</span><span class="line">    <span class="n">func</span> <span class="n">symbol</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="s">&quot;B⃦&quot;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这是一种写出具有延展性函数的很好的方法。通过使用一个需要遵守协议，而不是一个实实在在的类型，你的 API 的用户能够加入更多的类型。你仍然可以利用 enum 的灵活性，但是通过让它们遵守协议，你可以更好地表达自己的意思。根据你的具体情况，你现在可以轻松地选择是否开放你的 API。</p>

<h2>类型安全</h2>

<p>我认为类型的安全性是 Swift 一个很大的优势。就像我们在讨论 optionals 时看见的一样，我们可以用一些聪明的手段将某些检测从运行时转移到编译时。Swift 中数组的工作方式就是一个例子：一个数组是泛型的，它只能容纳一个类型的对象。将一个整数附加在一个字符组数组后面是做不到的。这样以来就消灭了一个类的潜在 bug。(值得注意的是如果你需要同时将字符串或者整数放到一个数组里的话，你可以使用上面谈到过的 <code>Either</code> 类型。)</p>

<p>再比如说，我们要将我们到货币转换器延展为一个通用的单位换算器。如果我们使用 <code>Double</code> 去表示数量，会有一点点误导性。比如说，100.0 可以表示 100 美元，100 千克或者任何能用 100 表示的东西。我们可以借助类型系统来制作不同的类型来表示不同的物理上的数量。比如说我们可以定义一个类型来表示钱：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">struct</span> <span class="n">Money</span> <span class="p">{</span>
</span><span class="line">    <span class="n">let</span> <span class="n">amount</span> <span class="o">:</span> <span class="n">Double</span>
</span><span class="line">    <span class="n">let</span> <span class="nl">currency:</span> <span class="n">Currency</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们可以定义另外一个结构来表示质量：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">struct</span> <span class="n">Mass</span> <span class="p">{</span>
</span><span class="line">    <span class="n">let</span> <span class="nl">kilograms:</span> <span class="n">Double</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在我们就消除了不小心将 <code>Money</code>  和 <code>Mass</code> 相加的可能性。基于你应用的特质有时候将一些简单的类型包装成这样是很有效的。不仅如此，阅读代码也会变得更加简单。假设我们遇到一个 <code>pounds</code> 函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">pounds</span><span class="p">(</span><span class="nl">input:</span> <span class="n">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Double</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>光看类型定义很难看出来这个函数的功能。它将欧元装换成英镑？还是将千克转换成磅？ (英文中英镑和磅均为 pound) 我们可以用不同的名字，或者可以建立文档 (都是很好的办法)，但是我们有第三种选择。我们可以将这个类型变得更明确：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">pounds</span><span class="p">(</span><span class="nl">input:</span> <span class="n">Mass</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Double</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们不仅让这个函数的用户能够立刻理解这个函数的功能，我们也防止了不小心传入其他单位的参数。如果你试图将 <code>Money</code> 作为参数来使用这个函数，编译器是不会接受的。另外一个可能的提升是使用一个更精确的返回值。现在它只是一个 <code>Double</code>。</p>

<h2>不可变性</h2>

<p>Swift 另外一个很棒的功能是内置的不可变性。在 Cocoa 当中很多的 API 都已经体现出了不可变性的价值。想了解这一点为什么如此重要，<a href="http://nomothetis.svbtle.com/error-handling-in-swift">“Error Handling in Swift”</a> 是一个很好的参考。比如，作为一个 Cocoa 开发者，我们使用很多成对的类 (<code>NSString</code> vs. <code>NSMutableString</code>，<code>NSArray</code> vs. <code>NSMutableArray</code>)。当你得到一个字符串值，你可以假设它不会被改变。但是如果你要完全确信，你依然要复制它。然后你才知道你有一份不可变的版本。</p>

<p>在 Swifit 里面，不可变性被直接加入这门语言。比如说如果你想建立一个可变的字符串，你可以如下的代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">var</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然而，如果你想要一个不可变的字符串，你可以做如下的事情：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">let</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>不可变的数据在创建可能会被未知用户使用的 API 时会给你很大的帮助。比如说，你有一个需要字符串作为参数的函数，在你迭代它的时候，确定它不会被改变是很重要的。在 Swift 当中这是默认的行为。正是因为这个原因，在写多线程代码的时候使用不可变资料会使难度大大降低。</p>

<p>还有另外一个巨大的优势。如果你的函数只使用不可变的数据，你的类型签名就会成为很好的文档。在 Objective-C 当中则不然。比如说，假设你准备在 OS X 上使用 <code>CIFilter</code>。在实例化之后你需要使用 <code>setDefaults</code> 方法。这一点在文档中有提到。有很多这样类都是这个样子。在实例化之后，在你使用它之前你必须要使用另外一个方法。问题在于，如果不阅读文档的话，经常会不清楚哪些函数需要被使用，最后你有可能遇到很奇怪的状况。</p>

<p>当使用不可变资料的时候，类型签名让事情变得很清晰。比如说，<code>map</code> 的类签名。我们知道有一个可选的 <code>T</code> 值，而且有一个将 <code>T</code> 转换成 <code>U</code> 的函数。结果是一个可选的 <code>U</code> 值。原始值是不可能改变的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">x:</span> <span class="n">T</span><span class="o">?</span><span class="p">,</span> <span class="nl">f:</span> <span class="n">T</span> <span class="o">-&gt;</span> <span class="n">U</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">U</span><span class="o">?</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于数组的 <code>map</code> 来说是一样的。它被定义成一个数组的延伸，所以参数本身是 <code>self</code>。我们可以看到它用一个函数将 <code>T</code> 转化成 <code>U</code>，并且生成一个 <code>U</code> 的数组。因为它是一个不可变的函数，我们知道原数组是不会变化的，而且我们知道结果也是不会改变的。将这些限制内置在l类型系统中，并有编译器来监督执行，让我们不再需要去查看文档并记住什么会变化。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">extension</span> <span class="n">Array</span> <span class="p">{</span>
</span><span class="line">    <span class="n">func</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">transform:</span> <span class="n">T</span> <span class="o">-&gt;</span> <span class="n">U</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">U</span><span class="p">]</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2>总结</h2>

<p>Swift 带来了很多有趣的可能性。我尤其喜欢的一点是过去我们需要手动检测或者阅读文档的事情现在编译器可以帮我们来完成。我们可以选择在合适的时机去使用这些可能性。我们依然会用我们现有的，成熟的办法去写代码，但是我们可以在合适的时候在我们代码的某些地方应用这些新的可能性。</p>

<p>我预测：Swift 会很大程度上改变我们写代码的方式，而且是向好的方向改变。脱离 Objective-C 会需要几年的时间，但是我相信我们中的大多数人会做出这个改变并且不会后悔。有些人会很快的适应，对另外一些人可能会花上很长的时间。但是我相信总有一天绝大多数人会看到 Swift 带给我们的种种好处。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-09-18T10:19:05+08:00" data-updated="true" itemprop="datePublished">Sep 18<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/swift/'>Swift</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/09/18/swiftde-han-shu-shi-api/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/09/18/swiftde-han-shu-shi-api/" itemprop="url">Swift的函数式API</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>在过去的时间里，人们对于设计 API 总结了很多通用的模式和最佳实践方案。一般情况下，我们总是可以从苹果的 Foundation、Cocoa、Cocoa Touch 和很多其他框架中总结出一些开发中的范例。毫无疑问，对于“特定情境下的 API 应该如何设计”这个问题，不同的人总是有着不同的意见，对于这个问题有很大的讨论空间。不过对于很多 Objective-C 的开发者来说，对于那些常用的模式早已习以为常。</p>

<p>随着 Swift 的出现，设计 API 引起了更多的问题。绝大多数情况下，我们只能继续做着手头的工作，然后把现有的方法翻译成 Swift 版本。不过，这对于 Swift 来说并不公平，因为和 Objective-C 相比，Swift 添加了很多新的特性。引用 Swift 创始人 <a href="https://twitter.com/clattner_llvm">Chris Lattner</a> 的一段话：</p>

<blockquote>
  <p>Swift 引入了泛型和函数式编程的思想，极大地扩展了设计的空间。</p>
</blockquote>

<p>在这篇文章里，我们将会围绕 <code>Core Image</code> 进行 API 封装，以此为例，探索如何在 API 设计中使用这些新的工具。 <code>Core Image</code> 是一个功能强大的图像处理框架，但是它的 API 有时有点笨重。 <code>Core Image</code> 的 API 是弱类型的 - 它通过键值对 (key-value) 设置图像滤镜。这样在设置参数的类型和名字时很容易失误，会导致运行时错误。新的 API 将会十分的安全和模块化，通过使用类型而不是键值对来规避这样的运行时错误。</p>

<h2>目标</h2>

<p>我们的目标是构建一个 API ，让我们可以简单安全的组装自定义滤镜。举个例子，在文章的结尾，我们可以这样写：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">let</span> <span class="n">myFilter</span> <span class="o">=</span> <span class="n">blur</span><span class="p">(</span><span class="n">blurRadius</span><span class="p">)</span> <span class="o">&gt;|&gt;</span> <span class="n">colorOverlay</span><span class="p">(</span><span class="n">overlayColor</span><span class="p">)</span>
</span><span class="line"><span class="n">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">myFilter</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面构建了一个自定义的滤镜，先模糊图像，然后再添加一个颜色蒙版。为了达到这个目标，我们将充分利用 Swift 函数是一等公民这一特性。项目源码可以在 Github 上的这个<a href="https://github.com/objcio/issue-16-functional-apis">示例项目</a>中下载。</p>

<h2 id="filter">Filter 类型</h2>

<p><code>CIFilter</code> 是 <code>Core Image</code> 中的一个核心类，用来创建图像滤镜。当实例化一个 <code>CIFilter</code> 对象之后，你 (几乎) 总是通过 <code>kCIInputImageKey</code> 来输入图像，然后通过 <code>kCIOutputImageKey</code> 获取返回的图像，返回的结果可以作为下一个滤镜的参数输入。</p>

<p>在我们即将开发的 API 里，我们会把这些键值对 (key-value) 对应的真实内容抽离出来，为用户提供一个安全的强类型 API。我们定义了自己的滤镜类型 <code>Filter</code>，它是一个可以传入图片作为参数的函数，并且返回一个新的图片。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">typealias</span> <span class="n">Filter</span> <span class="o">=</span> <span class="n">CIImage</span> <span class="o">-&gt;</span> <span class="n">CIImage</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

		
		<a href="/Blog/blog/2014/09/18/swiftde-han-shu-shi-api/" class="more-link">Read on &rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-08-04T15:05:26+08:00" data-updated="true" itemprop="datePublished">Aug 4<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/08/04/ioshui-tu-xiang-xi-jie-xi/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/08/04/ioshui-tu-xiang-xi-jie-xi/" itemprop="url">iOS绘图详细解析</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<div id="cnblogs_post_body"><p><span style="font-family: 'comic sans ms', sans-serif;">　　本文是《<a href="http://www.amazon.com/Programming-iOS-Fundamentals-iPhone-Development/dp/1449319343/ref=sr_1_3?ie=UTF8&amp;qid=1357784362&amp;sr=8-3&amp;keywords=ios" target="_blank">Programming iOS5</a>》中Drawing一章的翻译，考虑到主题完整性，翻译版本中加入了一些书中未涉及到的内容。希望本文能够对你有所帮助。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp; &nbsp; &nbsp; Core Graphics Framework是一套基于C的API框架，使用了Quartz作为绘图引擎。它提供了低级别、轻量级、高保真度的2D渲染。该框架可以用于基于路径的绘图、变换、颜色管理、脱屏渲染，模板、渐变、遮蔽、图像数据管理、图像的创建、遮罩以及PDF文档的创建、显示和分析。为了从感官上对这些概念做一个入门的认识，你可以运行一下官方的<a href="http://developer.apple.com/library/ios/samplecode/QuartzDemo/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007531">example code</a>。<span><br />
</span></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp; &nbsp; &nbsp;iOS支持两套图形API族：Core Graphics/QuartZ 2D 和OpenGL ES。OpenGL ES是跨平台的图形API，属于OpenGL的一个简化版本。QuartZ 2D是苹果公司开发的一套API，它是Core Graphics Framework的一部分。需要注意的是：OpenGL ES是应用程序编程接口，该接口描述了方法、结构、函数应具有的行为以及应该如何被使用的语义。也就是说它只定义了一套规范，具体的实现由设备制造商根据规范去做。而往往很多人对接口和实现存在误解。举一个不恰当的比喻：上发条的时钟和装电池的时钟都有相同的可视行为，但两者的内部<strong>实现</strong>截然不同。因为制造商可以自由的实现Open GL ES，所以不同系统实现的OpenGL ES也存在着巨大的性能差异。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp; &nbsp; &nbsp; &nbsp;Core Graphics API所有的操作都在上下文中进行。所以在绘图之前需要获取该上下文并传入执行渲染的函数内。如果你正在渲染一副在内存中的图片，此时就需要传入图片所属的上下文。获得一个图形上下文是我们完成绘图任务的第一步，你可以将图形上下文理解为一块画布。如果你没有得到这块画布，那么你就无法完成任何绘图操作。有许多方式获得一个图形上下文，这里我介绍两种最为常用的获取方法。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　第一种方法就是创建一个图片类型的上下文。调用<strong>UIGraphicsBeginImageContextWithOptions</strong>函数就可获得用来处理图片的图形上下文。利用该上下文，你就可以在其上进行绘图，并生成图片。调用<strong>UIGraphicsGetImageFromCurrentImageContext</strong>函数可从当前上下文中获取一个UIImage对象。记住在你所有的绘图操作后别忘了调用<strong>UIGraphicsEndImageContext</strong>函数关闭图形上下文。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　第二种方法是利用cocoa为你生成的图形上下文。当你子类化了一个UIView并实现了自己的<strong>drawRect：</strong>方法后，一旦<strong>drawRect</strong>：方法被调用，Cocoa就会为你创建一个图形上下文，此时你对图形上下文的所有绘图操作都会显示在UIView上。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　判断一个上下文是否为当前图形上下文需要注意的几点：</span></p>
<ul>
     <li><span style="font-family: 'comic sans ms', sans-serif;"><strong>UIGraphicsBeginImageContextWithOptions</strong>函数不仅仅是创建了一个适用于图形操作的上下文，并且该上下文也属于当前上下文。</span></li>
     <li><span style="font-family: 'comic sans ms', sans-serif;">当<strong>drawRect</strong>方法被调用时，UIView的绘图上下文属于当前图形上下文。</span></li>
     <li><span style="font-family: 'comic sans ms', sans-serif;">回调方法所持有的context：参数并不会让任何上下文成为当前图形上下文。此参数仅仅是对一个图形上下文的引用罢了。</span></li>
</ul>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　作为初学者，很容易被UIKit和Core Graphics两个支持绘图的框架迷惑。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　UIKit</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　像UIImage、NSString（绘制文本）、UIBezierPath（绘制形状）、UIColor都知道如何绘制自己。这些类提供了功能有限但使用方便的方法来让我们完成绘图任务。一般情况下，UIKit就是我们所需要的。</span></p>
<p>使用UiKit，<span style="color: #ff0000;">你只能在当前上下文中绘图</span>，所以如果你当前处于</p>
<p><strong>UIGraphicsBeginImageContextWithOptions</strong>函数或<strong>drawRect</strong>：方法中，你就可以直接使用UIKit提供的方法进行绘图。如果你持有一个context：参数，那么使用UIKit提供的方法之前，必须将该上下文参数转化为当前上下文。幸运的是，调用<strong>UIGraphicsPushContext</strong> 函数可以方便的将context：参数转化为当前上下文，记住最后别忘了调用<strong>UIGraphicsPopContext函数</strong>恢复上下文环境。</p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　Core Graphics</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　这是一个绘图专用的API族，它经常被称为QuartZ或QuartZ 2D。Core Graphics是iOS上所有绘图功能的基石，包括UIKit。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　使用Core Graphics之前需要指定一个用于绘图的图形上下文（CGContextRef），这个图形上下文会在每个绘图函数中都会被用到。如果你持有一个图形上下文context：参数，那么你等同于有了一个图形上下文，这个上下文也许就是你需要用来绘图的那个。如果你当前处于<strong>UIGraphicsBeginImageContextWithOptions函数</strong>或<strong>drawRect：</strong>方法中，并没有引用一个上下文。为了使用Core Graphics，你可以调用<strong>UIGraphicsGetCurrentContext</strong>函数获得当前的图形上下文。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　至此，我们有了两大绘图框架的支持以及三种获得图形上下文的方法（<strong>drawRect:</strong><strong>、drawRect: inContext:、</strong><strong>UIGraphicsBeginImageContextWithOptions</strong><strong>）</strong>。那么我们就有6种绘图的形式。如果你有些困惑了，不用怕，我接下来将说明这6种情况。无需担心还没有具体的绘图命令，你只需关注上下文如何被创建以及我们是在使用UIKit还是Core Graphics。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　第一种绘图形式：在UIView的子类方法drawRect：中绘制一个蓝色圆，使用<strong>UIKit</strong>在Cocoa为我们提供的当前上下文中完成绘图任务。</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">drawRect:</span> <span class="p">(</span><span class="n">CGRect</span><span class="p">)</span> <span class="n">rect</span> <span class="p">{</span>
</span><span class="line">	<span class="n">UIBezierPath</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="nl">UIBezierPathbezierPathWithOvalInRect:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)];</span>
</span><span class="line">	<span class="p">[[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">]</span> <span class="n">setFill</span><span class="p">];</span>
</span><span class="line">	<span class="p">[</span><span class="n">p</span> <span class="n">fill</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

		
		<a href="/Blog/blog/2014/08/04/ioshui-tu-xiang-xi-jie-xi/" class="more-link">Read on &rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-08-04T10:03:56+08:00" data-updated="true" itemprop="datePublished">Aug 4<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/08/04/cong-uikitdao-appkit/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/08/04/cong-uikitdao-appkit/" itemprop="url">从UIKit到APPKit</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Mac 不仅是一个强大的生产平台，也十分值得你<em>为其</em>开发一些东西。去年我们开始构建我们的第一款 <a href="http://decksetapp.com">Mac 应用</a>，成功为我们日常工作所在的平台开发点东西是一次十分美好的体验。但是，和为 iOS 系统开发应用相比，在我们了解 Mac 特性的过程中也遇到了一些困难。这篇文章总结了我们从这一过渡中得到的经验，希望能启发你们去开发自己的第一个 Mac 应用。</p>

<p>在这篇文章中，我们假定 OS X Yosemite 为我们默认使用的系统。今年，为了融合 iOS 和 OS X，苹果站在开发者的角度对 OS X 做出了巨大的改进。不过，我们会指出哪些特性仅适用于 Yosemite，而哪些特性也适用于之前的系统版本。</p>

<h2>相似点</h2>

<p>尽管 iOS 和 OS X 是两个独立的系统，它们却有很多共性。先就开发环境而言，它们使用同样的开发语言，同样的IDE。所以你会对这一切都感到非常熟悉。</p>

<p>更重要的是，OS X 和你已经熟悉的 iOS 共用许多框架，像 Foundation，Core Data 和 Core Animation。今年，Apple 进一步整合两个平台，并给 Mac 带来了一些之前仅能在 iOS 上面使用的框架，其中一个例子就是 Multipeer Connectivity。在更底层的地方，你立刻可以看到你熟悉的 API：Core Graphics，Core Text，libdispatch 等等。</p>

<p>真正开始有区别的是 UI 框架 — AppKit 早在 NeXT 时代就已面世并不断进化，而 UIKit 就像是简约版及现代版的 AppKit。出现这种情况的原因，是当 Apple 推出 iPhone 时可以从头开始，并吸取 AppKit 的经验：把已证实过可行的概念和部件拿过来用，并改进不够精良的设计。</p>

<p>如果你对这个转换是怎么发生的感兴趣，请观看前 Apple iOS 应用总监 <a href="https://twitter.com/nitinganatra">Nitin Ganatra</a> 播客上的精彩剧集：<a href="http://www.imore.com/debug-39-nitin-ganatra-episode-i-system-7-carbon">System 7 to Carbon</a>，<a href="http://www.imore.com/debug-40-nitin-ganatra-episode-ii-os-x-ios">OS X to iOS</a>，以及 <a href="http://www.imore.com/debug-41-nitin-ganatra-episode-iii-iphone-ipad">iPhone to iPad</a>。</p>

<p>考虑到这一点，也就不奇怪为什么 UIKit 和 AppKit 仍旧共享许多概念了。UI 是基于 window 和 view 构建起来的，消息像 iOS 一样通过响应者链传递。此外，<code>UIView</code> 是 <code>NSView</code>，<code>UIControl</code> 是 <code>NSControl</code>，<code>UIImage</code> 是 <code>NSImage</code>，<code>UIViewController</code> 是 <code>NSViewController</code>，<code>UITextView</code> 是 <code>NSTextView</code>&#8230;这样的例子不胜枚举。</p>

<p>看起来就像你仅需把 <code>UI</code> 前缀替换为 <code>NS</code> 前缀，你就可以用同样的方法使用这些类。但事实是在很多情况下这并不奏效。它们在实现上并没有在概念上那么相似。你在 iOS 上的经验至多能帮你大致了解构建用户界面的基础，以及使用很多设计模式，比如代理，都是类似的。但是细节是魔鬼 — 你真的应该通过阅读文档来学习如果使用这些类。</p>

<p>下一节，我们来看看那些常见的陷阱。</p>

<h2>不同点</h2>

<h3 id="windowwindowcontroller">Window 和 Window Controller</h3>

		
		<a href="/Blog/blog/2014/08/04/cong-uikitdao-appkit/" class="more-link">Read on &rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-23T17:35:44+08:00" data-updated="true" itemprop="datePublished">Jul 23<span>rd</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/swift/'>Swift</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/07/23/swiftchu-bu-liao-jie/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/07/23/swiftchu-bu-liao-jie/" itemprop="url">Swift初步了解</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<div class="entry-content"><h2>关于</h2>

<p>这篇文章简要介绍了苹果于<a href="https://developer.apple.com/wwdc/">WWDC 2014</a>发布的编程语言——Swift。</p>

<p>原文作者：</p>

<ul>
<li><a href="http://zh.lucida.me/">Lucida Blog</a></li>
<li><a href="http://www.weibo.com/pegong/">新浪微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p>转载前请保留出处链接，谢谢。</p>

<h2>前言</h2>

<p>在这里我认为有必要提一下<a href="http://worrydream.com/">Bret Victor</a>的<a href="http://vimeo.com/36579366">Inventing on Principle</a>，Swift编程环境的大部分概念都源自于<a href="http://worrydream.com/">Bret</a>这个演讲。</p>

<p>接下来进入正题。</p>

<h2>Swift是什么？</h2>

<p>Swift是苹果于WWDC 2014发布的编程语言，这里引用<strong><a href="https://itunes.apple.com/gb/book/swift-programming-language/id881256329?mt=11">The Swift Programming Language</a></strong>的原话：</p>

<blockquote><p>Swift is a new programming language for iOS and OS X apps that builds on the best of C and Objective-C, without the constraints of C compatibility.</p>

<p>Swift adopts safe programming patterns and adds modern features to make programming easier, more flexible and more fun.</p>

<p>Swift&rsquo;s clean slate, backed by the mature and much-loved Cocoa and Cocoa Touch frameworks, is an opportunity to imagine how software development works.</p>

<p>Swift is the first industrial-quality systems programming language that is as expressive and enjoyable as a scripting language.</p></blockquote>

<p>简单的说：</p>

<ol>
<li>Swift用来写iOS和OS X程序。（估计也不会支持其它屌丝系统）</li>
<li>Swift吸取了C和Objective-C的优点，且更加强大易用。</li>
<li>Swift可以使用现有的Cocoa和Cocoa Touch框架。</li>
<li>Swift兼具编译语言的高性能（Performance）和脚本语言的交互性（Interactive）。</li>
</ol>


<h2>Swift语言概览</h2>


		
		<a href="/Blog/blog/2014/07/23/swiftchu-bu-liao-jie/" class="more-link">Read on &rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-23T15:38:46+08:00" data-updated="true" itemprop="datePublished">Jul 23<span>rd</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/07/23/iosde-cha-jian/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/07/23/iosde-cha-jian/" itemprop="url">苹果的插件</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<div class="entry-content">
<p>插件是给你已经发布的 App 增加功能的一个好办法，Mac 上的 App 支持插件已经有很长的历史了，比如 Adobe Photoshop，在 1991 年的 version 2.0 就开始支持了。</p>

<p>在以前的 OS X 系统中，给你的 App 在运行时动态载入可执行代码比较困难。现在，在 <code>NSBundle</code> 的帮助和你的一些前瞻性思维的帮助下下，它从未如此简单。 </p>

<h2 id="bundlesinterfaces">包 (Bundles) 和接口 (Interfaces)</h2>

<p>如果你打开 Xcode 5 并且创建一个新项目，你会看见 OS X 选项卡下有一个 &#8220;Application Plug-in&#8221; 的分类和 &#8220;System Plug-in&#8221; 的分类，从 Screen Savers 到 Image Units，在 Xcode 里面一共有 12 中不同的模板可以编写 App 的插件。如果你点击 &#8220;Framework &amp; Library&#8221; 的选项卡，你将可以看见一个 Bundle 条目。我会在今天探索一个非常简单的的项目，那就是在一个修改过的 TextEdit 里面加入加载 bundle 的功能。</p>

<blockquote>
  <p>注意：Apple 称这些为 plug-ins ，而通常大家更喜欢用 plugins 称呼。为了一致性，在开发和 UI 相关的东西的时候，我想用和平台一致的 plug-in 称呼会更好。虽然在应用的 UI 里你会看到 &#8220;plug-ins&#8221;，但是在这篇文章和代码里面，我会用 plugin。（同时我偶尔会混用 bundle 和 plugin 这两个词。）(译者注：在本译文中会把 plugin 统一翻译成插件，伟大的中文)</p>
</blockquote>

<p>什么是 bundle ？如果你创建一个 Xcode 的 bundle 模版项目，你会发现它内容并不多。当构建它的时候你会得到一个很像构建 App 时产生的目录 —— 一个 Contents 目录，里面包含了 Info.plist 和 Resource 目录。如果你在你的项目下加入了新的类，你可以看见包含一个可执行文件的 MacOS 目录。Bundle 工程里缺少的一个东西是 main() 函数。它是被宿主 App 调用执行的。</p>

		
		<a href="/Blog/blog/2014/07/23/iosde-cha-jian/" class="more-link">Read on &rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-04T14:48:57+08:00" data-updated="true" itemprop="datePublished">Jul 4<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/07/04/bi-bao-%2Cni-liao-jie-duo-shao-%3F/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/07/04/bi-bao-%2Cni-liao-jie-duo-shao-%3F/" itemprop="url">闭包，你了解多少？</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。
闭包的概念出现于60年代，最早实现闭包的程序语言是Scheme。之后，闭包被广泛使用于函数式编程语言如ML语言和LISP。很多命令式程序语言也开始支持闭包。
在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。运行时，一旦外部的 函数被执行，一个闭包就形成了，闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。其中所引用的变量称作上值(upvalue)。
闭包一词经常和匿名函数混淆。这可能是因为两者经常同时使用，但是它们是不同的概念。</p>

<p>闭包和状态表达闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。变量的作用域仅限于包含它们的函数，因此无法从其它程序代码部分进行访问。不过，变量的生存期是可以很长，在一次函数调用期间所创建所生成的值在下次函数调用时仍然存在。正因为这一特点，闭包可以用来完成信息隐藏，并进而应用于需要状态表达的某些编程范型中。
不过，用这种方式来使用闭包时，闭包不再具有引用透明性，因此也不再是纯函数。即便如此，在某些“近似于函数式编程语言”的语言，例如Scheme中，闭包还是得到了广泛的使用。</p>

<p>闭包和第一类函数</p>

<p>典型的支持闭包的语言中，通常将函数当作第一类对象——在这些语言中，函数可以被当作参数传递、也可以作为函数返回值、绑定到变量名、就像字符串、整数等简单类型。例如以下Scheme代码：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="scheme"><span class="line"><span class="c1">; Return a list  of all books with at least THRESHOLD copies sold.</span>
</span><span class="line"><span class="p">(</span><span class="k">define </span> <span class="p">(</span><span class="nf">best-selling-books</span>  <span class="nv">threshold</span><span class="p">)</span>
</span><span class="line">   <span class="p">(</span><span class="nf">filter</span>
</span><span class="line">    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">book</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nf">book-sales</span> <span class="nv">book</span><span class="p">)</span>  <span class="nv">threshold</span><span class="p">))</span>
</span><span class="line">    <span class="nv">book-list</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>在这个例子中，lambda表达式(lambda (book) (&gt;= (book-sales book) threshold))出现在函数best-selling-books中。当这个lambda表达式被执行时，Scheme创造了一个包含此表达式以及对threshold变量的引用的闭包，其中threshold变量在lambda表达式中是自由变量。
这个闭包接着被传递到filter函数。这个函数的功能是重复调用这个闭包以判断哪些书需要增加到列表那些需要丢弃。因为闭包中引用了变量threshold，所以它在每次被filter调用时都可以使用这个变量，虽然filter可能定义在另一个文件中。

		
		<a href="/Blog/blog/2014/07/04/bi-bao-%2Cni-liao-jie-duo-shao-%3F/" class="more-link">Read on &rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-07-02T11:55:11+08:00" data-updated="true" itemprop="datePublished">Jul 2<span>nd</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/07/02/ios-8-ti-yan-tui-song/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/07/02/ios-8-ti-yan-tui-song/" itemprop="url">iOS 8 体验推送</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p> 一直更新了iOS8，但是一直没有开始研究这个iOS8，今天因为项目用到了推送，于是体验了iOS8的推送，先讲讲这个推送。目前分为四个推送：用户推送，本地推送，远程推送，地理位置推送。
</p>
<p><img src="http://ww3.sinaimg.cn/large/626e5d69gw1ehyeq298goj21kw0sadmt.jpg" alt="推送界面" /></p>

<h2>用户推送</h2>
<p>我们先开始讲这个用户推送,我们要使用之前必须先注册这个推送，用户要允许这个程序进行推送</p>
<p>注册过程：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">didFinishLaunchingWithOptions:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">launchOptions</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// Override point for customization after application launch.</span>
</span><span class="line">    <span class="n">UIUserNotificationType</span>  <span class="n">types</span> <span class="o">=</span> <span class="n">UIUserNotificationTypeBadge</span> <span class="o">|</span> <span class="n">UIUserNotificationTypeSound</span> <span class="o">|</span> <span class="n">UIUserNotificationTypeAlert</span> <span class="p">;</span>
</span><span class="line">    <span class="n">UIUserNotificationSettings</span>  <span class="o">*</span><span class="n">mySettings</span>  <span class="o">=</span> <span class="p">[</span><span class="n">UIUserNotificationSettings</span> <span class="nl">settingsForTypes:</span><span class="n">types</span> <span class="nl">categories:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line">    <span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">registerUserNotificationSettings:</span><span class="n">mySettings</span><span class="p">];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">didRegisterUserNotificationSettings:</span><span class="p">(</span><span class="n">UIUserNotificationSettings</span> <span class="o">*</span><span class="p">)</span><span class="nv">notificationSettings</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">UIUserNotificationType</span> <span class="n">allowTypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">notificationSettings</span> <span class="n">types</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">getReadyForNotification</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">UIUserNotificationSettings</span> <span class="o">*</span><span class="n">currentNotificationSettings</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="n">currentUserNotificationSettings</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">checkSetting:</span><span class="n">currentNotificationSettings</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>总结就是三个方法进行注册</p>
<p><img src="http://ww4.sinaimg.cn/large/626e5d69gw1ehyeumz8inj21f80d40up.jpg" alt="推送注册三个方法" /></p>

<p>我们现在仅仅是注册了通知的设置，还要注册推送通知的行为，在iOS8中，行为能直接在推送消息进行，如回复消息，拒绝消息等</p>
<p><img src="http://ww1.sinaimg.cn/large/626e5d69gw1ehyeyi825mj21aa12ggoc.jpg" alt="直接在推送消息进行回复" /></p>
<p>这个真心碉堡了</p>
<p>我们如何能进行这些行为，首先我们需注册这些行为。</p>

		
		<a href="/Blog/blog/2014/07/02/ios-8-ti-yan-tui-song/" class="more-link">Read on &rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-06-20T09:00:36+08:00" data-updated="true" itemprop="datePublished">Jun 20<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/06/20/shi-yong-vipergou-jian-iosying-yong/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/06/20/shi-yong-vipergou-jian-iosying-yong/" itemprop="url">使用VIPER构建iOS应用</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<script type="text/javascript">
    var wumiiPermaLink = ""; //请用代码生成文章永久的链接
    var wumiiTitle = ""; //请用代码生成文章标题
    var wumiiTags = ""; //请用代码生成文章标签，以英文逗号分隔，如："标签1,标签2"
    var wumiiCategories = []; //请用代码生成文章分类，分类名放在 JSONArray 中，如: ["分类1", "分类2"]
    var wumiiSitePrefix = "http://itmonkeylife.github.io/Blog/";
    var wumiiParams = "&num=5&mode=3&pf=JAVASCRIPT";
</script>

<script type="text/javascript" src="http://widget.wumii.cn/ext/relatedItemsWidget"></script>

<p><a href="http://www.wumii.com/widget/relatedItems" style="border:0;">
    <img src="http://static.wumii.cn/images/pixel.png" alt="无觅关联推荐，快速提升流量" style="border:0;padding:0;margin:0;" />
</a></p>

<p>建筑领域流行这样一句话，“我们虽然在营造建筑，但建筑也会重新塑造我们”。正如所有开发者最终领悟到的，这句话同样适用于构建软件。</p>

<p>编写代码中至关重要的是，需要使每一部分容易被识别，赋有一个特定而明显的目的，并与其他部分在逻辑关系中完美契合。这就是我们所说的软件架构。好的架构不仅让一个产品成功投入使用，还可以让产品具有可维护性，并让人不断头脑清醒的对它进行维护！</p>

		
		<a href="/Blog/blog/2014/06/20/shi-yong-vipergou-jian-iosying-yong/" class="more-link">Read on &rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-06-18T09:23:01+08:00" data-updated="true" itemprop="datePublished">Jun 18<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/06/18/ocde-zi-lei/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/06/18/ocde-zi-lei/" itemprop="url">OC的子类</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>这篇文章跟我以往的文章有点不一样。它主要是一些思想与模式的汇集，而不是一篇指南。下面我所写的模式几乎全都来之不易，都是我犯了错之后才学到的。我并不认为自己是子类方面的权威，但我确实想把我学到的一些东西分享出来。别把本文当做权威指南，它只是一些例子的汇集。</p>

<p>在被问到 OOP（面向对象编程）的时候，Alan Kay（OOP 的发明人）写到：它跟类无关，但跟消息有关。<a href="http://c2.com/cgi/wiki?AlanKayOnMessaging">^1</a>然而，很多人的关注点仍然还在类层次上。在本文中，我们会看几个我们可能会把注意力放在创建复杂的类结构上的例子，并给出更有用的替代方案。根据经验，这样会让代码更简单，更易维护。关于这个话题，在 <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code</a>（中文版：<a href="http://www.amazon.cn/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E9%A9%AC%E4%B8%81/dp/B0031M9GHC/ref=pd_bxgy_b_img_y">代码整洁之道</a>）和 <a href="http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670">Code Complete</a>（中文版：<a href="http://www.amazon.cn/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E5%8F%B2%E8%92%82%E5%A4%AB%E2%80%A2%E8%BF%88%E5%85%8B%E5%BA%B7%E5%A5%88%E5%B0%94/dp/B0061XKRXA/ref=pd_bxgy_b_img_z">代码大全</a>）中已经有大量讨论。推荐你阅读这两本书。</p>

<h2>何时用子类</h2>

<p>首先，我们讨论几种使用子类比较合适的场景。如果你要写一个自定义布局的 <code>UITableViewCell</code> ，那就创建一个子类。这同样适用于几乎每个视图。一旦你开始布局，把这块代码放入子类就更合理一些，不光代码得到了更好的封装，你也能得到一个可在工程之间重用的组件。</p>

		
		<a href="/Blog/blog/2014/06/18/ocde-zi-lei/" class="more-link">Read on &rarr;</a>
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
        <a href="/Blog/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/Blog/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    Rick


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
</body>
</html>
