<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[IT Monkey Life]]></title>
  <link href="http://ITMonkeyLife.github.io/Blog/atom.xml" rel="self"/>
  <link href="http://ITMonkeyLife.github.io/Blog/"/>
  <updated>2015-12-10T15:50:57+08:00</updated>
  <id>http://ITMonkeyLife.github.io/Blog/</id>
  <author>
    <name><![CDATA[Rick]]></name>
    <email><![CDATA[382542165@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[这些年我的不足]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2015/01/14/zhe-xie-nian-wo-de-bu-zu/"/>
    <updated>2015-01-14T17:54:14+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2015/01/14/zhe-xie-nian-wo-de-bu-zu</id>
    <content type="html"><![CDATA[<p>如果把人生比作跑步的话，我们都在用自己的节奏和姿势在完成比赛。这些跑步的技巧可能是小时候从老师，朋友，家人那得来的。随着时间的流逝，我们习惯了这种跑步的技能，看见那些跑得快的，会羡慕；跑得慢的，会不屑；跑得别扭的，会当作笑料。但是自己跑得怎么样，却很少关心。为什么要跑这条道？为什么这么慢？为什么这么累？</p>
<p>我们很难做到客观，尤其是面对自己的时候，那些缺点、曾经犯的错会自动进入盲区，躲避意识的雷达。尽管如此，我还是找到了数量可观的不足，才发现，原来这么些年，我一直在以这么别扭、丑陋的姿势在跑步。</p>
<h3>不够专注</h3>
<!-- more-->
<p>乔希·维茨金在《学习的艺术》里曾这么描述他当时的专注程度：『我太过于专注，以至于她觉得如果把手放在我眼前的话都会燃烧起来。』</p>
<p>如果足够专注的话，就会进入一种『流状态』，忘了时间，忘了身边的世界，只有自己当前所做的事。遗憾的是，我进入这种状态的机会不多，也没有有意识地去培养。</p>
<h3>不善于推迟满足感</h3>
<p>假设有两个任务，一个比较简单、有趣，另一个比较困难，但如果完成的话对自己的提升会比前一个任务高。这时你会选择先做哪一个？如果那个困难的任务并不强迫你必须完成，还会去做吗？</p>
<p>推迟满足感可以让我们享受解决问题带来的乐趣，更重要的是锻炼了自律能力。</p>
<h3>不善于制定计划</h3>
<p>做事往往是凭着一股热情，热度过了，事情也基本到尾声了，而事实上，没有人的热情可以持续很长一段时间。</p>
<p>把一个大目标，切分成多个合适的小目标，这是我不擅长的。如果是从A到D，那D就是我的目标，而不会加入B,C这两个里程碑，结果就是把自己弄的很累，作品也不够精致。</p>
<h3>缺少大局观</h3>
<p>我很少去考虑这个事情，很多时候都是跟着感觉去走，那些我看着或用着不舒服的，一概删掉。在上海的时候，我对旅行有点兴趣，但当时那些旅行方面的网站让我没有一点参与欲望，于是我组织几个人去旅游，并没有很好的统筹这个事情，反而大家花了冤枉钱也玩得不是很尽兴，当时真没想好该怎么去规划这个事情，人员通知完了，接下来该怎么办，就束手无策了。如果能够克制一下自己的偏执，能够细致地去了解这个事情，这些时间还能花在更有意义的事情上。</p>
<h3>缺少洞悉事物本质的能力</h3>
<p>这个能力不是天生就有的，需要后期不断地磨练。大前研一之前是核能博士，最后却在麦肯锡搞出了一番名堂。他总是能在很短的时间内就帮企业找到问题的原因，这得归功于他从小锻炼的逻辑思维能力和平日对每一个细小的事物都当作案例去对待的心态。</p>
<p>不找出真正的原因，就别期望能够解决问题。所以最重要的是思考“在各种现象之间，如何找出真正的原因”，绝不能在列举了各种现象之后就停止了思考。</p>
<h3>缺乏想象力</h3>
<p>爱因斯坦说过『想象力比知识重要』。由于从小反应就比较迟钝，加上缺少敏锐的观察力，当然还有老师们的辛勤扼杀，想象力已经生锈。</p>
<p>想象力是各种创造的源泉，想象力的缺失必然也导致创造力的低下，而如果不能去创造一些又酷又有创意的东西，那生活就太乏味了。</p>
<h3>好奇心不够</h3>
<p>大前研一在《思考的技术》里说：『一定要保持好奇心，因为好奇心可以转化为思考的养分』。好奇心可以促使我们思考，让我们始终保持学习的动力和乐趣，让我们更深刻地去理解周围的事物。</p>
<p>好奇心不够的人，更容易被『专家』蛊惑，他们喜欢『海绵式学习』而不是『淘金式学习』。The world is trying to keep you stupid，擦亮眼睛，在接纳一个观点前，先质疑。</p>
<h3>可用的模型不多</h3>
<p>每一个行业都有它的特殊性，同时又具有普遍性。从自己从事的行业中提取出可用于其他行业的模型是一个不小的考验。比如缓存，可以让用户能更快地获取数据，用在京东这样的B2C商城上，缓存可以是在多个地区设立货仓(其实更像cdn)，这样不同地区的顾客可以从离他们最近的货仓出货，加快货物到达时间。</p>
<p>把具体问题抽象化，找到问题的本质，然后套用掌握的一个或多个模型来解决问题。模型越多，了解得越透彻，解决问题的能力也就越强。</p>
<h3>阅读量不够</h3>
<p>查理·芒格在《穷查理宝典》里说：『我这辈子遇到的聪明人（来自各行各业的聪明人）没有不每天阅读的——没有，一个都没有。沃伦读书之多，我读书之多，可能会让你感到吃惊。我的孩子们都笑话我，觉得我是一本长了两条腿的书』。</p>
<p>阅读能够拓宽我们的视野，吸收他人的精华，指导我们的生活，愉悦我们的心灵。也曾经列了一些必读书目，由于重视程度不够，加上这些书比较厚，读起来颇费力，且没有一定要读的理由，就一拖再拖，结果就不了了之。</p>
<h3>没能把一件事情做到极致</h3>
<p>我喜欢做一些有意思或者自认为有价值的项目，如前面所说，很多都是憋足一股劲，凭着热情，直到做到自己还算满意，然后，就没有然后了。</p>
<p>这世界平庸的项目有很多，不要再去凑热闹了，把精力集中在少数几个最有兴趣和意义的项目上，让它们发挥出最大的价值。</p>
<h3>不够开放的心态</h3>
<p>想到一个解决方案时，不要急着实现，跟过来人探讨一下，看看这个实现有没有问题，有没有更好的方案。我总是怕打扰别人，有了想法就去实现，经常会走了不少弯路。</p>
<p>多去看看外面的世界，接触各行各业的人，分享各自的经历。北京open party曾经去过一次，给我的感觉很好，大家分享自己在某一领域的经验，或旅行心得，能学到不少东西。</p>
<p>所谓开放的心态，就是愿意去听听别人的看法，即使自己已经有了想法。自己看到的，想到的很可能不够全面，别人尤其是过来人的想法往往能够弥补这些思维漏洞。</p>
<h3>信念不够坚定</h3>
<p>坚定的信念是战胜困难的强有力武器。我在遇到一些感觉超出了自己能力范围的问题时，会有退缩心理。搞不定这个问题时，就会犹豫：我一定要从事这个行业吗？我在其他行业会不会更有天赋？这种心态越严重，越不利于问题的解决，到最后搞得自己心神不宁。</p>
<p>结婚前要睁大双眼看清楚，结婚后要睁一只眼闭一只眼。在选择行业时也一样，一定要谨慎，同时结合自己的兴趣和能力。一旦决定了，就不要再给自己留退路。</p>

<p>PS:大前研一，是日本著名管理学家。并非是研究生一年级，请勿望文生义。</p>
<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift的强大之处]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-qiang-da-zhi-chu/"/>
    <updated>2014-09-18T13:38:34+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-qiang-da-zhi-chu</id>
    <content type="html"><![CDATA[<p>在写任何东西之前我需要承认我是带有偏见的：我爱 Swift。我认为这是从我开始接触 Cocoa 生态系统以来这个平台上发生的最好的事情。我想通过分享我在 Swift，Objective-C 和 Haskell 上的经验让大家知道我为何这样认为。写这篇文章并不是为了介绍一些最好的实践 (写这些的时候 Swift 还太年轻，还没最好实践被总结出来)，而是举几个关于 Swift 强大之处的例子。</p>

<p>给大家一些我的个人背景：在成为全职 iOS/Mac 工程师之前我花了几年的时间做 Haskell (包括一些其他函数式编程语言) 开发。我仍然认为 Haskell 是我所有使用过的语言中最棒的之一。然而我转战到了 Objective-C，是因为我相信 iOS 是最令人激动的平台。刚开始接触 Objective-C 的时候我有些许沮丧，但我慢慢地学会了欣赏它。</p>

<p>当苹果在 WWDC 发布 Swift 的时候我非常的激动。我已经很久没有对新技术的发布感的如此兴奋了。在看过文档之后我意识到 Swift 使我们能够将现有的函数式编程知识和 Cocoa API 无缝地整合到一起。我觉得这两者的组合非常独特：没有任何其他的语言将它们融合地如此完美。就拿 Haskell 来说，想要用它来使用 Objective-C API 相当的困难。同样，想用 Objective-C 去做函数式编程也是十分困难的。</p>

<p>在 Utrecht 大学期间我学会了函数式编程。因为是在很学术的环境下学习所以并没有觉得很多复杂的术语 (moands，applicative functors 以及很多其他的东西) 有多么难懂。我觉得对很多想学习函数式编程的人来说这些名称是一个很大的阻碍。</p>

<p>不仅仅名称很不同，风格也不一样。作为 Objective-C 程序员，我们很习惯于面向对象编程。而且因为大多数语言不是面对对象编程就是与之类似，我们可以看懂很多不同语言的代码。阅读函数式编程语言的时候则大不相同 &#8211; 如果你没有习惯的话看起来简直莫名其妙。</p>

<p>那么，为什么你要使用函数式编程呢？它很奇怪，很多人都不习惯而且学习它要花费大量的时间。并且对于大多数问题面向对象编程都能解决，所以没有必要去学习任何新的东西对吧？</p>

<p>对于我来说，函数式编程只是工具箱中的一件工具。它是一个改变了我对编程的理解的强大工具。在解决问题的时候它非常强大。对于大多数问题面向对象编程都很棒，但是对于其他一些问题应用函数式编程会给你带来巨大的时间/精力的节省。</p>

<p>开始学习函数式编程或许有些痛苦。第一，你必须放手一些老的模式。而因为我们很多人常年用面对对象的方式去思考，做到这一点是很困难的。在函数式编程当中你想的是不变的数据结构以及那些转换它们的函数。在面对对象编程当中你考虑的是互相发送信息的对象。如果你没有马上理解函数式编程，这是一个好的信号。你的大脑很可能已经完全适应了用面对对象的方法来解决问题。</p>

<h2>例子</h2>
<!-- more-->
<p>我最喜欢的 Swift 功能之一是对 optionals 的使用。Optionals 让我们能够应对有可能存在也有可能不存在的值。在 Objective-C 里我们必须在文档中清晰地说明 nil 是否是允许的。Optionals 让我们将这份责任交给了类型系统。如果你有一个可选值，你就知道它可以是 nil。如果它不是可选值，你知道它不可能是 nil。</p>

<p>举个例子，看看下面一小段 Objective-C 代码</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSAttributedString</span> <span class="o">*</span><span class="p">)</span><span class="nf">attributedString:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">input</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[[</span><span class="n">NSAttributedString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithString:</span><span class="n">input</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>看上去没有什么问题，但是如果 <code>input</code> 是 nil, 它就会崩溃。这种问题你只能在运行的时候才能发现。取决于你如何使用它，你可能很快能发现问题，但是你也有可能在发布应用之后才发现，导致用户正在使用的应用崩溃。</p>

<p>用相同的 Swift 的 API 来做对比。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">extension</span> <span class="n">NSAttributedString</span> <span class="p">{</span>
</span><span class="line">    <span class="n">init</span><span class="p">(</span><span class="n">string</span> <span class="nl">str:</span> <span class="n">String</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>看起来像对Objective-C的直接翻译，但是 Swift 不允许 <code>nil</code> 被传入。如果要达到这个目的，API 需要变成这个样子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">extension</span> <span class="n">NSAttributedString</span> <span class="p">{</span>
</span><span class="line">    <span class="n">init</span><span class="p">(</span><span class="n">string</span> <span class="nl">str:</span> <span class="n">String</span><span class="o">?</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意新加上的问号。这意味着你可以使用一个值或者是 nil。类非常的精确：只需要看一眼我们就知道什么值是允许的。使用 optionals 一段时间之后你会发现你只需要阅读类型而不用再去看文档了。如果犯了一个错误，你会得到一个编译时警告而不是一个运行时错误。</p>

<h2>建议</h2>

<p>如果可能的话避免使用 optionals。Optionals 对于使用你 API 的人们来说是一个多余的负担。话虽如此，还是有很多地方可以很好使用它们。如果你有一个函数会因为一个明显的原因失败你可以返回一个 optional。举例来说，比如将一个  #00ff00 字符串转换成颜色。如果你的参数不符合正确的格式，你应该返回一个 <code>nil</code> 。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">parseColorFromHexString</span><span class="p">(</span><span class="nl">input:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UIColor</span><span class="o">?</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// ...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果你需要阐明错误信息，你可以使用 <code>Either</code> 或者 <code>Result</code> 类型 (不在标准库里面)。当失败的原因很重要的时候，这种做法会非常有用。<a href="http://nomothetis.svbtle.com/error-handling-in-swift">“Error Handling in Swift”</a> 一文中有个很好的例子。</p>

<h2 id="enums">Enums</h2>

<p>Enums 是一个随 Swift 推出的新东西，它和我们在 Objective-C 中见过的东西都大不相同。在 Objective-C 里面我们有一个东西叫做 enums, 但是它们差不多就是升级版的整数。</p>

<p>我们来看看布尔类型。一个布尔值是两种可能性 &#8211; true 或者 false &#8211; 中的一个。很重要的一点是没有办法再添加另外一个值 &#8211; 布尔类型是<strong>封闭的</strong>。布尔类型的封闭性的好处是每当使用布尔值的时候我们只需要考虑 true 或者 false 这两种情况。</p>

<p>在这一点上面 optionals 是一样的。总共只有两种情况：<code>nil</code> 或者有值。在 Swift 里面布尔和 optional 都可以被定义为 enums。但有一个不同点：在 optional enum 中有一种可能性有一个相关值。我们来看看它们不同的定义：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">enum</span> <span class="n">Boolean</span> <span class="p">{</span>
</span><span class="line">    <span class="k">case</span> <span class="n">False</span>
</span><span class="line">    <span class="k">case</span> <span class="n">True</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">enum</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Nil</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Some</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>它们非常的相似。如果你把它们的名称改成一样的话，那么唯一的区别就是括号里的相关值。如果你给 optional 中的 <code>Nil</code>  情况也加上一个值，你就会得到一个 <code>Either</code> 类型：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">enum</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Left</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Right</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在函数式编程当中，在你想表示两件事情之间的选择时候你会经常用到 <code>Either</code> 类型。举个例子：如果你有一个函数返回一个整数或者一个错误，你就可以用 <code>Either&lt;Int, NSError&gt;</code>。如果你想在一个字典中储存布尔值或者字符串，你就可以使用 <code>Either&lt;Bool,String&gt;</code> 作为键。</p>

<blockquote>
  <p>理论旁白：有些时候 enums 被称为 <strong>sum 类型</strong>，因为它们是几个不同类型的总和。在 <code>Either</code> 类型的例子中，它们表达的是 <code>A</code> 类型和 <code>B</code> 类型的和。Structs 和 tuples 被称为 <strong>product 类型</strong>，因为它们代表几个不同类型的乘积。参见<a href="http://en.wikipedia.org/wiki/Algebraic_data_type">“algebraic data types.”</a></p>
</blockquote>

<p>理解什么时候使用 enums 什么时候使用其他的数据类型 (比如 <a href="http://objccn.io/issue-16-2">class 或者 structs</a>)会有一些难度。当你有一个固定数量的值的集合的时候，enum 是最有用的。比如说，如果我们设计一个 Github API 的 wrapper，我们可以用 enum 来表示端点。比如有一个不需要任何参数的 <code>/zen</code> 的 API 端点。再比如为了获取用户的资料我们需要提供用户名。最后我们显示用户的仓库时，我们需要提供用户名以及一个值去说明是否从小到大地排列结果。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">enum</span> <span class="n">Github</span> <span class="p">{</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Zen</span>
</span><span class="line">    <span class="k">case</span> <span class="n">UserProfile</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Repositories</span><span class="p">(</span><span class="nl">username:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">sortAscending:</span> <span class="n">Bool</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>定义 API 端点是很好的使用 enum 的场景。API 的端点是有限的，所以我们可以为每一个端点定义一个情况。如果我们在对这些端点使用 switch 的时候没有包含所有情况的话，我们会被给予警告。所以说当我们需要添加一个情况的时候我们需要更新每一个用到这个 enum 的函数。</p>

<p>除非能够拿到源代码，其他使用我们 enum 的人不能添加新的情况，这是一个非常有用的限制。想想要是你能够加一种新情况到 <code>Bool</code> 或者 <code>Optional</code> 里会怎么样吧 &#8211; 所有用到 它的函数都需要重写。</p>

<p>比如说我们正在开发一个货币转换器。我们可以将货币给定义成 enum：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">enum</span> <span class="n">Currency</span> <span class="p">{</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Eur</span>
</span><span class="line">    <span class="k">case</span> <span class="n">Usd</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们现在可以做一个获取任何货币符号的函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">symbol</span><span class="p">(</span><span class="nl">input:</span> <span class="n">Currency</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class="line">    <span class="k">switch</span> <span class="n">input</span> <span class="p">{</span>
</span><span class="line">        <span class="k">case</span> <span class="p">.</span><span class="nl">Eur:</span> <span class="k">return</span> <span class="s">&quot;€&quot;</span>
</span><span class="line">        <span class="k">case</span> <span class="p">.</span><span class="nl">Usd:</span> <span class="k">return</span> <span class="s">&quot;$&quot;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后，我们可以用我们的 <code>symbol</code> 函数，来依据系统本地设置得到一个很好地格式化过的字符串：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">format</span><span class="p">(</span><span class="nl">amount:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">currency:</span> <span class="n">Currency</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class="line">    <span class="n">let</span> <span class="n">formatter</span> <span class="o">=</span> <span class="n">NSNumberFormatter</span><span class="p">()</span>
</span><span class="line">    <span class="n">formatter</span><span class="p">.</span><span class="n">numberStyle</span> <span class="o">=</span> <span class="p">.</span><span class="n">CurrencyStyle</span>
</span><span class="line">    <span class="n">formatter</span><span class="p">.</span><span class="n">currencySymbol</span> <span class="o">=</span> <span class="n">symbol</span><span class="p">(</span><span class="n">currency</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span> <span class="n">formatter</span><span class="p">.</span><span class="n">stringFromNumber</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样一来有一个很大的限制。我们可能会想让我们 API 的使用者在将来可以修改一些情况。在 Objective-C 当中向一个接口里添加更多类型的常见解决方法是子类化。在 Objective-C 里面理论上你可以子类化任何一个类，然后通过这种办法来扩展它。在 Swift 里面你仍然可以使用子类化，但是只能对 <code>class</code> 使用，对于 <code>enum</code> 则不行。然而，我们可以用另一种技术来达到目的 (这种办法在 Objetive-C 和 Swift 的 protocol 中都可行）。</p>

<p>假设我们定义一个货币符号的协议：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">protocol</span> <span class="n">CurrencySymbol</span> <span class="p">{</span>
</span><span class="line">    <span class="n">func</span> <span class="n">symbol</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在我们让 <code>Currency</code> 类型遵守这个协议。注意我们可以将 <code>input</code> 参数去掉，因为这里它被作为 self 隐式地进行传递：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">extension</span> <span class="n">Currency</span> <span class="o">:</span> <span class="n">CurrencySymbol</span> <span class="p">{</span>
</span><span class="line">   <span class="n">func</span> <span class="n">symbol</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class="line">        <span class="k">switch</span> <span class="n">self</span> <span class="p">{</span>
</span><span class="line">            <span class="k">case</span> <span class="p">.</span><span class="nl">Eur:</span> <span class="k">return</span> <span class="s">&quot;€&quot;</span>
</span><span class="line">            <span class="k">case</span> <span class="p">.</span><span class="nl">Usd:</span> <span class="k">return</span> <span class="s">&quot;$&quot;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在我们可以重写 <code>format</code> 方法来格式化任何遵守我们协议的类型：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">format</span><span class="p">(</span><span class="nl">amount:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">currency:</span> <span class="n">CurrencySymbol</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class="line">    <span class="n">let</span> <span class="n">formatter</span> <span class="o">=</span> <span class="n">NSNumberFormatter</span><span class="p">()</span>
</span><span class="line">    <span class="n">formatter</span><span class="p">.</span><span class="n">numberStyle</span> <span class="o">=</span> <span class="p">.</span><span class="n">CurrencyStyle</span>
</span><span class="line">    <span class="n">formatter</span><span class="p">.</span><span class="n">currencySymbol</span> <span class="o">=</span> <span class="n">currency</span><span class="p">.</span><span class="n">symbol</span><span class="p">()</span>
</span><span class="line">    <span class="k">return</span> <span class="n">formatter</span><span class="p">.</span><span class="n">stringFromNumber</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样一来我们将我们代码的可延展性大大提升类 &#8211; 任何遵守 <code>CurrencySymbol</code> 协议的类型都可以被格式化。比如说，我们建立一个新的类型来储存比特币，我们可以立刻让它拥有格式化功能：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">struct</span> <span class="n">Bitcoin</span> <span class="o">:</span> <span class="n">CurrencySymbol</span> <span class="p">{</span>
</span><span class="line">    <span class="n">func</span> <span class="n">symbol</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="s">&quot;B⃦&quot;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这是一种写出具有延展性函数的很好的方法。通过使用一个需要遵守协议，而不是一个实实在在的类型，你的 API 的用户能够加入更多的类型。你仍然可以利用 enum 的灵活性，但是通过让它们遵守协议，你可以更好地表达自己的意思。根据你的具体情况，你现在可以轻松地选择是否开放你的 API。</p>

<h2>类型安全</h2>

<p>我认为类型的安全性是 Swift 一个很大的优势。就像我们在讨论 optionals 时看见的一样，我们可以用一些聪明的手段将某些检测从运行时转移到编译时。Swift 中数组的工作方式就是一个例子：一个数组是泛型的，它只能容纳一个类型的对象。将一个整数附加在一个字符组数组后面是做不到的。这样以来就消灭了一个类的潜在 bug。(值得注意的是如果你需要同时将字符串或者整数放到一个数组里的话，你可以使用上面谈到过的 <code>Either</code> 类型。)</p>

<p>再比如说，我们要将我们到货币转换器延展为一个通用的单位换算器。如果我们使用 <code>Double</code> 去表示数量，会有一点点误导性。比如说，100.0 可以表示 100 美元，100 千克或者任何能用 100 表示的东西。我们可以借助类型系统来制作不同的类型来表示不同的物理上的数量。比如说我们可以定义一个类型来表示钱：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">struct</span> <span class="n">Money</span> <span class="p">{</span>
</span><span class="line">    <span class="n">let</span> <span class="n">amount</span> <span class="o">:</span> <span class="n">Double</span>
</span><span class="line">    <span class="n">let</span> <span class="nl">currency:</span> <span class="n">Currency</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们可以定义另外一个结构来表示质量：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">struct</span> <span class="n">Mass</span> <span class="p">{</span>
</span><span class="line">    <span class="n">let</span> <span class="nl">kilograms:</span> <span class="n">Double</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在我们就消除了不小心将 <code>Money</code>  和 <code>Mass</code> 相加的可能性。基于你应用的特质有时候将一些简单的类型包装成这样是很有效的。不仅如此，阅读代码也会变得更加简单。假设我们遇到一个 <code>pounds</code> 函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">pounds</span><span class="p">(</span><span class="nl">input:</span> <span class="n">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Double</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>光看类型定义很难看出来这个函数的功能。它将欧元装换成英镑？还是将千克转换成磅？ (英文中英镑和磅均为 pound) 我们可以用不同的名字，或者可以建立文档 (都是很好的办法)，但是我们有第三种选择。我们可以将这个类型变得更明确：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">pounds</span><span class="p">(</span><span class="nl">input:</span> <span class="n">Mass</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Double</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们不仅让这个函数的用户能够立刻理解这个函数的功能，我们也防止了不小心传入其他单位的参数。如果你试图将 <code>Money</code> 作为参数来使用这个函数，编译器是不会接受的。另外一个可能的提升是使用一个更精确的返回值。现在它只是一个 <code>Double</code>。</p>

<h2>不可变性</h2>

<p>Swift 另外一个很棒的功能是内置的不可变性。在 Cocoa 当中很多的 API 都已经体现出了不可变性的价值。想了解这一点为什么如此重要，<a href="http://nomothetis.svbtle.com/error-handling-in-swift">“Error Handling in Swift”</a> 是一个很好的参考。比如，作为一个 Cocoa 开发者，我们使用很多成对的类 (<code>NSString</code> vs. <code>NSMutableString</code>，<code>NSArray</code> vs. <code>NSMutableArray</code>)。当你得到一个字符串值，你可以假设它不会被改变。但是如果你要完全确信，你依然要复制它。然后你才知道你有一份不可变的版本。</p>

<p>在 Swifit 里面，不可变性被直接加入这门语言。比如说如果你想建立一个可变的字符串，你可以如下的代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">var</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然而，如果你想要一个不可变的字符串，你可以做如下的事情：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">let</span> <span class="n">myString</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>不可变的数据在创建可能会被未知用户使用的 API 时会给你很大的帮助。比如说，你有一个需要字符串作为参数的函数，在你迭代它的时候，确定它不会被改变是很重要的。在 Swift 当中这是默认的行为。正是因为这个原因，在写多线程代码的时候使用不可变资料会使难度大大降低。</p>

<p>还有另外一个巨大的优势。如果你的函数只使用不可变的数据，你的类型签名就会成为很好的文档。在 Objective-C 当中则不然。比如说，假设你准备在 OS X 上使用 <code>CIFilter</code>。在实例化之后你需要使用 <code>setDefaults</code> 方法。这一点在文档中有提到。有很多这样类都是这个样子。在实例化之后，在你使用它之前你必须要使用另外一个方法。问题在于，如果不阅读文档的话，经常会不清楚哪些函数需要被使用，最后你有可能遇到很奇怪的状况。</p>

<p>当使用不可变资料的时候，类型签名让事情变得很清晰。比如说，<code>map</code> 的类签名。我们知道有一个可选的 <code>T</code> 值，而且有一个将 <code>T</code> 转换成 <code>U</code> 的函数。结果是一个可选的 <code>U</code> 值。原始值是不可能改变的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">x:</span> <span class="n">T</span><span class="o">?</span><span class="p">,</span> <span class="nl">f:</span> <span class="n">T</span> <span class="o">-&gt;</span> <span class="n">U</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">U</span><span class="o">?</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于数组的 <code>map</code> 来说是一样的。它被定义成一个数组的延伸，所以参数本身是 <code>self</code>。我们可以看到它用一个函数将 <code>T</code> 转化成 <code>U</code>，并且生成一个 <code>U</code> 的数组。因为它是一个不可变的函数，我们知道原数组是不会变化的，而且我们知道结果也是不会改变的。将这些限制内置在l类型系统中，并有编译器来监督执行，让我们不再需要去查看文档并记住什么会变化。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">extension</span> <span class="n">Array</span> <span class="p">{</span>
</span><span class="line">    <span class="n">func</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">transform:</span> <span class="n">T</span> <span class="o">-&gt;</span> <span class="n">U</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">U</span><span class="p">]</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2>总结</h2>

<p>Swift 带来了很多有趣的可能性。我尤其喜欢的一点是过去我们需要手动检测或者阅读文档的事情现在编译器可以帮我们来完成。我们可以选择在合适的时机去使用这些可能性。我们依然会用我们现有的，成熟的办法去写代码，但是我们可以在合适的时候在我们代码的某些地方应用这些新的可能性。</p>

<p>我预测：Swift 会很大程度上改变我们写代码的方式，而且是向好的方向改变。脱离 Objective-C 会需要几年的时间，但是我相信我们中的大多数人会做出这个改变并且不会后悔。有些人会很快的适应，对另外一些人可能会花上很长的时间。但是我相信总有一天绝大多数人会看到 Swift 带给我们的种种好处。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift的函数式API]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-han-shu-shi-api/"/>
    <updated>2014-09-18T10:19:05+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-han-shu-shi-api</id>
    <content type="html"><![CDATA[<p>在过去的时间里，人们对于设计 API 总结了很多通用的模式和最佳实践方案。一般情况下，我们总是可以从苹果的 Foundation、Cocoa、Cocoa Touch 和很多其他框架中总结出一些开发中的范例。毫无疑问，对于“特定情境下的 API 应该如何设计”这个问题，不同的人总是有着不同的意见，对于这个问题有很大的讨论空间。不过对于很多 Objective-C 的开发者来说，对于那些常用的模式早已习以为常。</p>

<p>随着 Swift 的出现，设计 API 引起了更多的问题。绝大多数情况下，我们只能继续做着手头的工作，然后把现有的方法翻译成 Swift 版本。不过，这对于 Swift 来说并不公平，因为和 Objective-C 相比，Swift 添加了很多新的特性。引用 Swift 创始人 <a href="https://twitter.com/clattner_llvm">Chris Lattner</a> 的一段话：</p>

<blockquote>
  <p>Swift 引入了泛型和函数式编程的思想，极大地扩展了设计的空间。</p>
</blockquote>

<p>在这篇文章里，我们将会围绕 <code>Core Image</code> 进行 API 封装，以此为例，探索如何在 API 设计中使用这些新的工具。 <code>Core Image</code> 是一个功能强大的图像处理框架，但是它的 API 有时有点笨重。 <code>Core Image</code> 的 API 是弱类型的 - 它通过键值对 (key-value) 设置图像滤镜。这样在设置参数的类型和名字时很容易失误，会导致运行时错误。新的 API 将会十分的安全和模块化，通过使用类型而不是键值对来规避这样的运行时错误。</p>

<h2>目标</h2>

<p>我们的目标是构建一个 API ，让我们可以简单安全的组装自定义滤镜。举个例子，在文章的结尾，我们可以这样写：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">let</span> <span class="n">myFilter</span> <span class="o">=</span> <span class="n">blur</span><span class="p">(</span><span class="n">blurRadius</span><span class="p">)</span> <span class="o">&gt;|&gt;</span> <span class="n">colorOverlay</span><span class="p">(</span><span class="n">overlayColor</span><span class="p">)</span>
</span><span class="line"><span class="n">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">myFilter</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面构建了一个自定义的滤镜，先模糊图像，然后再添加一个颜色蒙版。为了达到这个目标，我们将充分利用 Swift 函数是一等公民这一特性。项目源码可以在 Github 上的这个<a href="https://github.com/objcio/issue-16-functional-apis">示例项目</a>中下载。</p>

<h2 id="filter">Filter 类型</h2>

<p><code>CIFilter</code> 是 <code>Core Image</code> 中的一个核心类，用来创建图像滤镜。当实例化一个 <code>CIFilter</code> 对象之后，你 (几乎) 总是通过 <code>kCIInputImageKey</code> 来输入图像，然后通过 <code>kCIOutputImageKey</code> 获取返回的图像，返回的结果可以作为下一个滤镜的参数输入。</p>

<p>在我们即将开发的 API 里，我们会把这些键值对 (key-value) 对应的真实内容抽离出来，为用户提供一个安全的强类型 API。我们定义了自己的滤镜类型 <code>Filter</code>，它是一个可以传入图片作为参数的函数，并且返回一个新的图片。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">typealias</span> <span class="n">Filter</span> <span class="o">=</span> <span class="n">CIImage</span> <span class="o">-&gt;</span> <span class="n">CIImage</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<!-- more-->
<p>这里我们用 <code>typealias</code> 关键字，为 <code>CIImage -&gt; CIImage</code>类型定义了我们自己的名字，这个类型是一个函数，它的参数是一个 <code>CIImage</code> ，返回值也是 <code>CIImage</code> 。这是我们后面开发需要的基础类型。</p>

<p>如果你不太熟悉函数式编程，你可能对于把一个函数类型命名为 <code>Filter</code> 感觉有点奇怪，通常来说，我们会用这样的命名来定义一个类。如果我们很想以某种方式来表现这个类型的函数式的特性，我们可以把它命名成 <code>FilterFunction</code> 或者一些其他的类似的名字。但是，我们有意识的选择了 <code>Filter</code> 这个名字，因为在函数式编程的核心哲学里，函数就是值，函数和结构体、整数、多元组、或者类，并没有任何区别。一开始我也不是很适应，不过一段时间之后发现，这样做确实很有意义。</p>

<h2>构建滤镜</h2>

<p>现在我们已经定义了 <code>Filter</code> 类型，接下来可以定义函数来构建特定的滤镜了。这些函数需要参数来设置特定的滤镜，并且返回一个类型为 <code>Filter</code> 的值。这些函数大概是这个样子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">myFilter</span><span class="p">(</span><span class="cm">/* parameters */</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Filter</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意返回的值 <code>Filter</code> 本身就是一个函数，在后面有利于我们将多个滤镜组合起来，以达到理想的处理效果。</p>

<p>为了让后面的开发更轻松一点，我们扩展了 <code>CIFilter</code> 类，添加了一个 convenience 的初始化方法，以及一个用来获取输出图像的计算属性：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">typealias</span> <span class="n">Parameters</span> <span class="o">=</span> <span class="n">Dictionary</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">AnyObject</span><span class="o">&gt;</span>
</span><span class="line">
</span><span class="line"><span class="n">extension</span> <span class="n">CIFilter</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="n">convenience</span> <span class="n">init</span><span class="p">(</span><span class="nl">name:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">parameters:</span> <span class="n">Parameters</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nl">name:</span> <span class="n">name</span><span class="p">)</span>
</span><span class="line">        <span class="n">setDefaults</span><span class="p">()</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">:</span> <span class="n">AnyObject</span><span class="p">)</span> <span class="k">in</span> <span class="n">parameters</span> <span class="p">{</span>
</span><span class="line">            <span class="n">setValue</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nl">forKey:</span> <span class="n">key</span><span class="p">)</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">var</span> <span class="nl">outputImage:</span> <span class="n">CIImage</span> <span class="p">{</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">valueForKey</span><span class="p">(</span><span class="n">kCIOutputImageKey</span><span class="p">)</span> <span class="n">as</span> <span class="n">CIImage</span> <span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这个 convenience 初始化方法有两个参数，第一个参数是滤镜的名字，第二个参数是一个字典。字典中的键值对将会被设置成新滤镜的参数。我们 convenience 初始化方法先调用了指定的初始化方法，这符合 Swift 的开发规范。</p>

<p>计算属性 <code>outputImage</code> 可以方便地从滤镜对象中获取到输出的图像。它查找 <code>kCIOutputImageKey</code> 对应的值并且将其转换成一个 <code>CIImage</code> 对象。通过提供这个属性， API 的用户不再需要对返回的结果手动进行类型转换了。</p>

<h2>模糊</h2>

<p>有了这些东西，现在我们就可以定义属于自己的简单滤镜了。高斯模糊滤镜只需要一个模糊半径作为参数，我们可以非常容易的完成一个模糊滤镜：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">blur</span><span class="p">(</span><span class="nl">radius:</span> <span class="n">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Filter</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">{</span> <span class="n">image</span> <span class="k">in</span>
</span><span class="line">        <span class="n">let</span> <span class="n">parameters</span> <span class="o">:</span> <span class="n">Parameters</span> <span class="o">=</span> <span class="p">[</span><span class="nl">kCIInputRadiusKey:</span> <span class="n">radius</span><span class="p">,</span> <span class="nl">kCIInputImageKey:</span> <span class="n">image</span><span class="p">]</span>
</span><span class="line">        <span class="n">let</span> <span class="n">filter</span> <span class="o">=</span> <span class="n">CIFilter</span><span class="p">(</span><span class="nl">name:</span><span class="s">&quot;CIGaussianBlur&quot;</span><span class="p">,</span> <span class="nl">parameters:</span><span class="n">parameters</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">filter</span><span class="p">.</span><span class="n">outputImage</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>就是这么简单，这个模糊函数返回了一个函数，新的函数的参数是一个类型为 <code>CIImage</code> 的图片，返回值 (<code>filter.outputImage</code>) 是一个新的图片 。这个模糊函数的格式是 <code>CIImage -&gt; CIImage</code> ，满足我们前面定义的 <code>Filter</code> 类型的格式。</p>

<p>这个例子只是对 <code>Core Image</code> 中已有滤镜的一个简单的封装，我们可以多次重复同样的模式，创建属于我们自己的滤镜函数。</p>

<h2>颜色蒙版</h2>

<p>现在让我们定义一个颜色滤镜，可以在现有的图片上面加上一层颜色蒙版。 <code>Core Image</code> 默认没有提供这个滤镜，不过我们可以通过已有的滤镜组装一个。</p>

<p>我们使用两个模块来完成这个工作，一个是颜色生成滤镜 (<code>CIConstantColorGenerator</code>)，另一个是资源合成滤镜 (<code>CISourceOverCompositing</code>)。让我们先定义一个生成一个常量颜色面板的滤镜：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">colorGenerator</span><span class="p">(</span><span class="nl">color:</span> <span class="n">UIColor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Filter</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
</span><span class="line">        <span class="n">let</span> <span class="n">filter</span> <span class="o">=</span> <span class="n">CIFilter</span><span class="p">(</span><span class="nl">name:</span><span class="s">&quot;CIConstantColorGenerator&quot;</span><span class="p">,</span> <span class="nl">parameters:</span> <span class="p">[</span><span class="nl">kCIInputColorKey:</span> <span class="n">color</span><span class="p">])</span>
</span><span class="line">        <span class="k">return</span> <span class="n">filter</span><span class="p">.</span><span class="n">outputImage</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这段代码看起来和前面的模糊滤镜差不多，不过有一个较为明显的差异：颜色生成滤镜不会检测输入的图片。所以在函数里我们不需要给传入的图片参数命名，我们使用了一个匿名参数 <code>_</code> 来强调这个 filter 的图片参数是被忽略的。</p>

<p>接下来，我们来定义合成滤镜：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">compositeSourceOver</span><span class="p">(</span><span class="nl">overlay:</span> <span class="n">CIImage</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Filter</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">{</span> <span class="n">image</span> <span class="k">in</span>
</span><span class="line">        <span class="n">let</span> <span class="n">parameters</span> <span class="o">:</span> <span class="n">Parameters</span> <span class="o">=</span> <span class="p">[</span>
</span><span class="line">            <span class="nl">kCIInputBackgroundImageKey:</span> <span class="n">image</span><span class="p">,</span>
</span><span class="line">            <span class="nl">kCIInputImageKey:</span> <span class="n">overlay</span>
</span><span class="line">        <span class="p">]</span>
</span><span class="line">        <span class="n">let</span> <span class="n">filter</span> <span class="o">=</span> <span class="n">CIFilter</span><span class="p">(</span><span class="nl">name:</span><span class="s">&quot;CISourceOverCompositing&quot;</span><span class="p">,</span> <span class="nl">parameters:</span> <span class="n">parameters</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">filter</span><span class="p">.</span><span class="n">outputImage</span><span class="p">.</span><span class="n">imageByCroppingToRect</span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">extent</span><span class="p">())</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在这里我们将输出图像裁剪到和输入大小一样。这并不是严格需要的，要取决于我们想让滤镜如何工作。不过，在后面我们的例子中我们可以看出来这是一个明智之举。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">colorOverlay</span><span class="p">(</span><span class="nl">color:</span> <span class="n">UIColor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Filter</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">{</span> <span class="n">image</span> <span class="k">in</span>
</span><span class="line">        <span class="n">let</span> <span class="n">overlay</span> <span class="o">=</span> <span class="n">colorGenerator</span><span class="p">(</span><span class="n">color</span><span class="p">)(</span><span class="n">image</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">compositeSourceOver</span><span class="p">(</span><span class="n">overlay</span><span class="p">)(</span><span class="n">image</span><span class="p">)</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们再一次返回了一个参数为图片的函数，<code>colorOverlay</code> 在一开始先调用了 <code>colorGenerator</code> 滤镜。<code>colorGenerator</code> 滤镜需要一个颜色作为参数，并且返回一个滤镜。因此 <code>colorGenerator(color)</code> 是 <code>Filter</code> 类型的。但是 <code>Filter</code> 类型本身是一个 <code>CIImage</code> 向 <code>CIImage</code> 转换的函数，我们可以在 <code>colorGenerator(color)</code> 后面加上一个类型为 <code>CIImage</code> 的参数，这样可以得到一个类型为 <code>CIImage</code> 的蒙版图片。这就是在定义 <code>overlay</code> 的时候发生的事情：我们用 <code>colorGenerator</code> 函数创建了一个滤镜，然后把图片作为一个参数传给了这个滤镜，从而得到了一张新的图片。返回值 <code>compositeSourceOver(overlay)(image)</code> 和这个基本相似，它由一个滤镜 <code>compositeSourceOver(overlay)</code> 和一个图片参数 <code>image</code> 组成。</p>

<h2>组合滤镜</h2>

<p>现在我们已经定义了一个模糊滤镜和一个颜色滤镜，我们在使用的时候可以把它们组合在一起：我们先将图片做模糊处理，然后再在上面放一个红色的蒙层。让我们先加载一张图片：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">let</span> <span class="n">url</span> <span class="o">=</span> <span class="n">NSURL</span><span class="p">(</span><span class="nl">string:</span> <span class="s">&quot;http://tinyurl.com/m74sldb&quot;</span><span class="p">);</span>
</span><span class="line"><span class="n">let</span> <span class="n">image</span> <span class="o">=</span> <span class="n">CIImage</span><span class="p">(</span><span class="nl">contentsOfURL:</span> <span class="n">url</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在我们可以把滤镜组合起来，同时应用到一张图片上：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">let</span> <span class="n">blurRadius</span> <span class="o">=</span> <span class="mf">5.0</span>
</span><span class="line"><span class="n">let</span> <span class="n">overlayColor</span> <span class="o">=</span> <span class="n">UIColor</span><span class="p">.</span><span class="n">redColor</span><span class="p">().</span><span class="n">colorWithAlphaComponent</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
</span><span class="line"><span class="n">let</span> <span class="n">blurredImage</span> <span class="o">=</span> <span class="n">blur</span><span class="p">(</span><span class="n">blurRadius</span><span class="p">)(</span><span class="n">image</span><span class="p">)</span>
</span><span class="line"><span class="n">let</span> <span class="n">overlaidImage</span> <span class="o">=</span> <span class="n">colorOverlay</span><span class="p">(</span><span class="n">overlayColor</span><span class="p">)(</span><span class="n">blurredImage</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们又一次的通过滤镜组装了图片。比如在倒数第二行，我们先得到了模糊滤镜 <code>blur(blurRadius)</code> ，然后再把这个滤镜应用到图片上。</p>

<h2>函数组装</h2>

<p>不过，我们可以做的比上面的更好。我们可以简单的把两行滤镜的调用组合在一起变成一行，这是我脑海中想到的第一个能改进的地方：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">colorOverlay</span><span class="p">(</span><span class="n">overlayColor</span><span class="p">)(</span><span class="n">blur</span><span class="p">(</span><span class="n">blurRadius</span><span class="p">)(</span><span class="n">image</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>不过，这些圆括号让这行代码完全不具有可读性，更好的方式是定义一个函数来完成这项任务：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">composeFilters</span><span class="p">(</span><span class="nl">filter1:</span> <span class="n">Filter</span><span class="p">,</span> <span class="nl">filter2:</span> <span class="n">Filter</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Filter</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">{</span> <span class="n">img</span> <span class="k">in</span> <span class="n">filter2</span><span class="p">(</span><span class="n">filter1</span><span class="p">(</span><span class="n">img</span><span class="p">))</span> <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>composeFilters</code> 函数的两个参数都是 Filter ，并且返回了一个新的 Filter 滤镜。组装后的滤镜需要一个 <code>CIImage</code> 类型的参数，并且会把这个参数分别传给 <code>filter1</code> 和 <code>filter2</code> 。现在我们可以用 <code>composeFilters</code> 来定义我们自己的组合滤镜：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">let</span> <span class="n">myFilter</span> <span class="o">=</span> <span class="n">composeFilters</span><span class="p">(</span><span class="n">blur</span><span class="p">(</span><span class="n">blurRadius</span><span class="p">),</span> <span class="n">colorOverlay</span><span class="p">(</span><span class="n">overlayColor</span><span class="p">))</span>
</span><span class="line"><span class="n">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">myFilter</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们还可以更进一步的定义一个滤镜运算符，让代码更具有可读性，</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">infix</span> <span class="n">operator</span> <span class="o">&gt;|&gt;</span> <span class="p">{</span> <span class="n">associativity</span> <span class="n">left</span> <span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">func</span> <span class="o">&gt;|&gt;</span> <span class="p">(</span><span class="nl">filter1:</span> <span class="n">Filter</span><span class="p">,</span> <span class="nl">filter2:</span> <span class="n">Filter</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Filter</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">{</span> <span class="n">img</span> <span class="k">in</span> <span class="n">filter2</span><span class="p">(</span><span class="n">filter1</span><span class="p">(</span><span class="n">img</span><span class="p">))</span> <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>运算符通过 <code>infix</code> 关键字定义，表明运算符具有 <code>左</code> 和 <code>右</code> 两个参数。<code>associativity left</code> 表明这个运算满足左结合律，即：f1 &gt;|&gt; f2 &gt;|&gt; f3 等价于 (f1 &gt;|&gt; f2) &gt;|&gt; f3。通过使这个运算满足左结合律，再加上运算内先应用了左侧的滤镜，所以在使用的时候滤镜顺序是从左往右的，就像 Unix 管道一样。</p>

<p>剩余的部分是一个函数，内容和 <code>composeFilters</code> 基本相同，只不过函数名变成了 <code>&gt;|&gt;</code>。</p>

<p>接下来我们把这个组合滤镜运算器应用到前面的例子中：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">let</span> <span class="n">myFilter</span> <span class="o">=</span> <span class="n">blur</span><span class="p">(</span><span class="n">blurRadius</span><span class="p">)</span> <span class="o">&gt;|&gt;</span> <span class="n">colorOverlay</span><span class="p">(</span><span class="n">overlayColor</span><span class="p">)</span>
</span><span class="line"><span class="n">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">myFilter</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>运算符让代码变得更易于阅读和理解滤镜使用的顺序，调用滤镜的时候也更加的方便。就好比是 <code>1 + 2 + 3 + 4</code> 要比 <code>add(add(add(1, 2), 3), 4)</code> 更加清晰，更加容易理解。</p>

<h2>自定义运算符</h2>

<p>很多 Objective-C 的开发者对于自定义运算符持有怀疑态度。在 Swift 刚发布的时候，这是一个并没有很受欢迎的特性。很多人在 C++ 中遭遇过自定义运算符过度使用 (甚至滥用) 的情况，有些是个人经历过的，有些是听到别人谈起的。</p>

<p>你可能对于前面定义的运算符 <code>&gt;|&gt;</code> 持有同样的怀疑态度，毕竟如果每个人都定义自己的运算符，那代码岂不是很难理解了？值得庆幸的是在函数式编程里有很多的操作，为这些操作定义一个运算符并不是一件很罕见的事情。</p>

<p>我们定义的滤镜组合运算符是一个<a href="http://en.wikipedia.org/wiki/Function_composition_%28computer_science%29">函数组合</a>的例子，这是一个在函数式编程中广泛使用的概念。在数学里，两个函数 <code>f</code> 和 <code>g</code> 的组合有时候写做 <code>f ∘ g</code>，这样定义了一种全新的函数，将输入的 <code>x</code> 映射到 <code>f(g(x))</code> 上。这恰好就是我们的 <code>&gt;|&gt;</code> 所做的工作 (除了函数的逆向调用)。 </p>

<h2>泛型</h2>

<p>仔细想想，其实我们并没有必要去定义一个用来专门组装滤镜的运算符，我们可以用一个泛型的运算符来组装函数。目前我们的 <code>&gt;|&gt;</code> 是这样的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="o">&gt;|&gt;</span> <span class="p">(</span><span class="nl">filter1:</span> <span class="n">Filter</span><span class="p">,</span> <span class="nl">filter2:</span> <span class="n">Filter</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Filter</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样定义之后，我们传入的参数只能是 <code>Filter</code> 类型的滤镜。</p>

<p>但是，我们可以利用 Swift 的通用特性来定义一个泛型的函数组合运算符：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="o">&gt;|&gt;</span> <span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">lhs:</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span><span class="p">,</span> <span class="nl">rhs:</span> <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">C</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">C</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">{</span> <span class="n">x</span> <span class="k">in</span> <span class="n">rhs</span><span class="p">(</span><span class="n">lhs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这个一开始可能很难理解 &#8211; 至少对我来说是这样。但是分开的看了各个部分之后，一切都变得清晰起来。</p>

<p>首先，我们来看一下函数名后面的尖括号。尖括号定义了这个函数适用的泛型类型。在这个例子里我们定义了三个类型：A、B 和 C。因为我们并没有指定这些类型，所以它们可以代表任何东西。</p>

<p>接下来让我们来看看函数的参数：第一个参数：lhs (left-hand side 的缩写)，是一个类型为 A -&gt; B 的函数。这代表一个函数的参数为 A，返回值的类型为 B。第二个参数：rhs (right-hand side 的缩写)，是一个类型为 B -&gt; C 的函数。参数命名为 lhs 和 rhs，因为它们分别对应操作符左边和右边的值。</p>

<p>重写了没有 <code>Filter</code> 的滤镜组合运算符之后，我们很快就发现其实前面实现的组合运算符只是泛型函数中的一个特殊情况：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="o">&gt;|&gt;</span> <span class="p">(</span><span class="nl">filter1:</span> <span class="n">CIImage</span> <span class="o">-&gt;</span> <span class="n">CIImage</span><span class="p">,</span> <span class="nl">filter2:</span> <span class="n">CIImage</span> <span class="o">-&gt;</span> <span class="n">CIImage</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CIImage</span> <span class="o">-&gt;</span> <span class="n">CIImage</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>把我们脑海中的泛型类型 A、B、C 都换成 <code>CIImage</code>，这样可以清晰的理解用通用运算符的来替换滤镜组合运算符是多么的有用。</p>

<h2>结论</h2>

<p>至此，我们成功的用函数式 API 封装了 <code>Core Image</code>。希望这个例子能够很好的说明，对于 Objective-C 的开发者来说，在我们所熟知的 API 的设计模式之外有一片完全不同的世界。有了 Swift，我们现在可以动手探索那些全新的领域，并且将它们充分地利用起来。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS绘图详细解析]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/08/04/ioshui-tu-xiang-xi-jie-xi/"/>
    <updated>2014-08-04T15:05:26+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/08/04/ioshui-tu-xiang-xi-jie-xi</id>
    <content type="html"><![CDATA[<div id="cnblogs_post_body"><p><span style="font-family: 'comic sans ms', sans-serif;">　　本文是《<a href="http://www.amazon.com/Programming-iOS-Fundamentals-iPhone-Development/dp/1449319343/ref=sr_1_3?ie=UTF8&amp;qid=1357784362&amp;sr=8-3&amp;keywords=ios" target="_blank">Programming iOS5</a>》中Drawing一章的翻译，考虑到主题完整性，翻译版本中加入了一些书中未涉及到的内容。希望本文能够对你有所帮助。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp; &nbsp; &nbsp; Core Graphics Framework是一套基于C的API框架，使用了Quartz作为绘图引擎。它提供了低级别、轻量级、高保真度的2D渲染。该框架可以用于基于路径的绘图、变换、颜色管理、脱屏渲染，模板、渐变、遮蔽、图像数据管理、图像的创建、遮罩以及PDF文档的创建、显示和分析。为了从感官上对这些概念做一个入门的认识，你可以运行一下官方的<a href="http://developer.apple.com/library/ios/samplecode/QuartzDemo/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007531">example code</a>。<span><br />
</span></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp; &nbsp; &nbsp;iOS支持两套图形API族：Core Graphics/QuartZ 2D 和OpenGL ES。OpenGL ES是跨平台的图形API，属于OpenGL的一个简化版本。QuartZ 2D是苹果公司开发的一套API，它是Core Graphics Framework的一部分。需要注意的是：OpenGL ES是应用程序编程接口，该接口描述了方法、结构、函数应具有的行为以及应该如何被使用的语义。也就是说它只定义了一套规范，具体的实现由设备制造商根据规范去做。而往往很多人对接口和实现存在误解。举一个不恰当的比喻：上发条的时钟和装电池的时钟都有相同的可视行为，但两者的内部<strong>实现</strong>截然不同。因为制造商可以自由的实现Open GL ES，所以不同系统实现的OpenGL ES也存在着巨大的性能差异。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp; &nbsp; &nbsp; &nbsp;Core Graphics API所有的操作都在上下文中进行。所以在绘图之前需要获取该上下文并传入执行渲染的函数内。如果你正在渲染一副在内存中的图片，此时就需要传入图片所属的上下文。获得一个图形上下文是我们完成绘图任务的第一步，你可以将图形上下文理解为一块画布。如果你没有得到这块画布，那么你就无法完成任何绘图操作。有许多方式获得一个图形上下文，这里我介绍两种最为常用的获取方法。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　第一种方法就是创建一个图片类型的上下文。调用<strong>UIGraphicsBeginImageContextWithOptions</strong>函数就可获得用来处理图片的图形上下文。利用该上下文，你就可以在其上进行绘图，并生成图片。调用<strong>UIGraphicsGetImageFromCurrentImageContext</strong>函数可从当前上下文中获取一个UIImage对象。记住在你所有的绘图操作后别忘了调用<strong>UIGraphicsEndImageContext</strong>函数关闭图形上下文。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　第二种方法是利用cocoa为你生成的图形上下文。当你子类化了一个UIView并实现了自己的<strong>drawRect：</strong>方法后，一旦<strong>drawRect</strong>：方法被调用，Cocoa就会为你创建一个图形上下文，此时你对图形上下文的所有绘图操作都会显示在UIView上。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　判断一个上下文是否为当前图形上下文需要注意的几点：</span></p>
<ul>
     <li><span style="font-family: 'comic sans ms', sans-serif;"><strong>UIGraphicsBeginImageContextWithOptions</strong>函数不仅仅是创建了一个适用于图形操作的上下文，并且该上下文也属于当前上下文。</span></li>
     <li><span style="font-family: 'comic sans ms', sans-serif;">当<strong>drawRect</strong>方法被调用时，UIView的绘图上下文属于当前图形上下文。</span></li>
     <li><span style="font-family: 'comic sans ms', sans-serif;">回调方法所持有的context：参数并不会让任何上下文成为当前图形上下文。此参数仅仅是对一个图形上下文的引用罢了。</span></li>
</ul>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　作为初学者，很容易被UIKit和Core Graphics两个支持绘图的框架迷惑。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　UIKit</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　像UIImage、NSString（绘制文本）、UIBezierPath（绘制形状）、UIColor都知道如何绘制自己。这些类提供了功能有限但使用方便的方法来让我们完成绘图任务。一般情况下，UIKit就是我们所需要的。</span></p>
<p>使用UiKit，<span style="color: #ff0000;">你只能在当前上下文中绘图</span>，所以如果你当前处于</p>
<p><strong>UIGraphicsBeginImageContextWithOptions</strong>函数或<strong>drawRect</strong>：方法中，你就可以直接使用UIKit提供的方法进行绘图。如果你持有一个context：参数，那么使用UIKit提供的方法之前，必须将该上下文参数转化为当前上下文。幸运的是，调用<strong>UIGraphicsPushContext</strong> 函数可以方便的将context：参数转化为当前上下文，记住最后别忘了调用<strong>UIGraphicsPopContext函数</strong>恢复上下文环境。</p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　Core Graphics</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　这是一个绘图专用的API族，它经常被称为QuartZ或QuartZ 2D。Core Graphics是iOS上所有绘图功能的基石，包括UIKit。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　使用Core Graphics之前需要指定一个用于绘图的图形上下文（CGContextRef），这个图形上下文会在每个绘图函数中都会被用到。如果你持有一个图形上下文context：参数，那么你等同于有了一个图形上下文，这个上下文也许就是你需要用来绘图的那个。如果你当前处于<strong>UIGraphicsBeginImageContextWithOptions函数</strong>或<strong>drawRect：</strong>方法中，并没有引用一个上下文。为了使用Core Graphics，你可以调用<strong>UIGraphicsGetCurrentContext</strong>函数获得当前的图形上下文。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　至此，我们有了两大绘图框架的支持以及三种获得图形上下文的方法（<strong>drawRect:</strong><strong>、drawRect: inContext:、</strong><strong>UIGraphicsBeginImageContextWithOptions</strong><strong>）</strong>。那么我们就有6种绘图的形式。如果你有些困惑了，不用怕，我接下来将说明这6种情况。无需担心还没有具体的绘图命令，你只需关注上下文如何被创建以及我们是在使用UIKit还是Core Graphics。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　第一种绘图形式：在UIView的子类方法drawRect：中绘制一个蓝色圆，使用<strong>UIKit</strong>在Cocoa为我们提供的当前上下文中完成绘图任务。</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">drawRect:</span> <span class="p">(</span><span class="n">CGRect</span><span class="p">)</span> <span class="n">rect</span> <span class="p">{</span>
</span><span class="line">	<span class="n">UIBezierPath</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="nl">UIBezierPathbezierPathWithOvalInRect:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)];</span>
</span><span class="line">	<span class="p">[[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">]</span> <span class="n">setFill</span><span class="p">];</span>
</span><span class="line">	<span class="p">[</span><span class="n">p</span> <span class="n">fill</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<!-- more-->
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;　 &nbsp;第二种绘图形式：使用Core Graphics实现绘制蓝色圆。</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">drawRect:</span> <span class="p">(</span><span class="n">CGRect</span><span class="p">)</span> <span class="n">rect</span> <span class="p">{</span>
</span><span class="line"><span class="n">CGContextRef</span> <span class="n">con</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line"><span class="n">CGContextAddEllipseInRect</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
</span><span class="line"><span class="n">CGContextSetFillColorWithColor</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextFillPath</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp; &nbsp; &nbsp; &nbsp;第三种绘图形式：我将在UIView子类的<strong>drawLayer:inContext</strong><strong>：</strong>方法中实现绘图任务。<strong>drawLayer:inContext</strong><strong>：</strong>方法是一个绘制图层内容的代理方法。为了能够调用<strong>drawLayer:inContext</strong><strong>：</strong>方法，我们需要设定图层的代理对象。但要注意，不应该将UIView对象设置为显示层的委托对象，这是因为UIView对象已经是隐式层的代理对象，再将它设置为另一个层的委托对象就会出问题。轻量级的做法是：编写负责绘图形的代理类。在MyView.h文件中声明如下代码：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">MyLayerDelegate</span> : <span class="nc">NSObject</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp; &nbsp; &nbsp; &nbsp; 然后MyView.m文件中实现接口代码：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">MyLayerDelegate</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawLayer:</span><span class="p">(</span><span class="n">CALayer</span><span class="o">*</span><span class="p">)</span><span class="nv">layer</span> <span class="nf">inContext:</span><span class="p">(</span><span class="n">CGContextRef</span><span class="p">)</span><span class="nv">ctx</span> <span class="p">{</span>
</span><span class="line">  <span class="n">UIGraphicsPushContext</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class="line">  <span class="n">UIBezierPath</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBezierPath</span> <span class="nl">bezierPathWithOvalInRect:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)];</span>
</span><span class="line">  <span class="p">[[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">]</span> <span class="n">setFill</span><span class="p">];</span>
</span><span class="line">  <span class="p">[</span><span class="n">p</span> <span class="n">fill</span><span class="p">];</span>
</span><span class="line">  <span class="n">UIGraphicsPopContext</span><span class="p">();</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><span style="font-family: 'comic sans ms', sans-serif;">直接将代理类的实现代码放在MyView.m文件的#import代码的下面，这样感觉好像在使用私有类完成绘图任务（虽然这不是私有类）。需要注意的是，我们所引用的上下文并不是当前上下文，所以为了能够使用UIKit，我们需要将引用的上下文转变成当前上下文。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">因为图层的代理是assign内存管理策略，那么这里就不能以局部变量的形式创建MyLayerDelegate实例对象赋值给图层代理。这里选择在MyView.m中增加一个实例变量，因为实例变量默认是strong:</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">MyView</span> <span class="p">()</span> <span class="p">{</span>
</span><span class="line"><span class="n">MyLayerDelegate</span><span class="o">*</span> <span class="n">_layerDeleagete</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><span style="font-family: 'comic sans ms', sans-serif;"><span style="line-height: 18px;">&nbsp; &nbsp; 使用该图层代理：</span></span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">MyView</span> <span class="o">*</span><span class="n">myView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">480</span><span class="p">)];</span>
</span><span class="line"><span class="n">CALayer</span> <span class="o">*</span><span class="n">myLayer</span> <span class="o">=</span> <span class="p">[</span><span class="n">CALayer</span> <span class="n">layer</span><span class="p">];</span>
</span><span class="line"><span class="n">_layerDelegate</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyLayerDelegate</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="n">myLayer</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">_layerDelegate</span><span class="p">;</span>
</span><span class="line"><span class="p">[</span><span class="n">myView</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">myLayer</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">myView</span> <span class="n">setNeedsDisplay</span><span class="p">];</span> <span class="c1">// 调用此方法，drawLayer: inContext:方法才会被调用。</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><span style="font-family: 'comic sans ms', sans-serif;">　第四种绘图形式： 使用Core Graphics在<strong>drawLayer:inContext</strong><strong>：</strong>方法中实现同样操作，代码如下：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawLayer:</span><span class="p">(</span><span class="n">CALayer</span><span class="o">*</span><span class="p">)</span><span class="nv">lay</span> <span class="nf">inContext:</span><span class="p">(</span><span class="n">CGContextRef</span><span class="p">)</span><span class="nv">con</span> <span class="p">{</span>
</span><span class="line">	<span class="n">CGContextAddEllipseInRect</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
</span><span class="line">	<span class="n">CGContextSetFillColorWithColor</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextFillPath</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　最后，演示<strong>UIGraphicsBeginImageContextWithOptions</strong>的用法，并从上下文中生成一个UIImage对象。生成UIImage对象的代码可以在任何地方被使用，它没有上述绘图方法那样的限制。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　第五种绘图形式： 使用UIKit实现：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span> <span class="n">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="n">UIBezierPath</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBezierPath</span> <span class="nl">bezierPathWithOvalInRect:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)];</span>
</span><span class="line"><span class="p">[[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">]</span> <span class="n">setFill</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">p</span> <span class="n">fill</span><span class="p">];</span>
</span><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">im</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class="line"><span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　解释一下<strong>UIGraphicsBeginImageContextWithOptions</strong>函数参数的含义：第一个参数表示所要创建的图片的尺寸；第二个参数用来指定所生成图片的背景是否为不透明，如上我们使用YES而不是NO，则我们得到的图片背景将会是黑色，显然这不是我想要的；第三个参数指定生成图片的缩放因子，这个缩放因子与UIImage的scale属性所指的含义是一致的。传入0则表示让图片的缩放因子根据屏幕的分辨率而变化，所以我们得到的图片不管是在单分辨率还是视网膜屏上看起来都会很好。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　 第六种绘图形式： 使用Core Graphics实现：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span> <span class="n">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextRef</span> <span class="n">con</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line"><span class="n">CGContextAddEllipseInRect</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
</span><span class="line"><span class="n">CGContextSetFillColorWithColor</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextFillPath</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">im</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class="line"><span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　UIKit和Core Graphics可以在相同的图形上下文中混合使用。在iOS 4.0之前，使用UIKit和UIGraphicsGetCurrentContext被认为是线程不安全的。而在iOS4.0以后苹果让绘图操作在第二个线程中执行解决了此问题。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　UIImage</strong><strong>常用的绘图操作</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　一个UIImage对象提供了向当前上下文绘制自身的方法。我们现在已经知道如何获取一个图片类型的上下文并将它转变成当前上下文。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif; line-height: 1.5;">　　<strong>平移操作</strong>：下面的代码展示了如何将UIImage绘制在当前的上下文中。</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">mars</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="err">@”</span><span class="n">Mars</span><span class="p">.</span><span class="n">png</span><span class="err">”</span><span class="p">];</span>
</span><span class="line"><span class="n">CGSize</span> <span class="n">sz</span> <span class="o">=</span> <span class="p">[</span><span class="n">mars</span> <span class="n">size</span><span class="p">];</span>
</span><span class="line"><span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="n">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="p">[</span><span class="n">mars</span> <span class="nl">drawAtPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">mars</span> <span class="nl">drawAtPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="mi">0</span><span class="p">)];</span>
</span><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">im</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class="line"><span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span><span class="line"><span class="n">UIImageView</span><span class="o">*</span> <span class="n">iv</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIImageView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithImage:</span><span class="n">im</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">rootViewController</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview:</span> <span class="n">iv</span><span class="p">];</span>
</span><span class="line"><span class="n">iv</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p style="text-align: center;"><span style="font-family: 'comic sans ms', sans-serif;"><img style="border: 1px solid black;" src="http://images.cnitblog.com/blog/429321/201212/23211637-5f8e8f19af4b47d49e43fe82084ff701.png" alt="" /></span></p>
<p align="center"><span style="font-family: 'comic sans ms', sans-serif;">图1 UIImage平移处理</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　<strong>缩放操作：</strong>下面代码展示了如何对UIImage进行缩放操作：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">mars</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="err">@”</span><span class="n">Mars</span><span class="p">.</span><span class="n">png</span><span class="err">”</span><span class="p">];</span>
</span><span class="line"><span class="n">CGSize</span> <span class="n">sz</span> <span class="o">=</span> <span class="p">[</span><span class="n">mars</span> <span class="n">size</span><span class="p">];</span>
</span><span class="line"><span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> <span class="n">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="p">[</span><span class="n">mars</span> <span class="nl">drawInRect:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="o">*</span><span class="mi">2</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">mars</span> <span class="nl">drawInRect:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">)</span> <span class="nl">blendMode:</span><span class="n">kCGBlendModeMultiply</span> <span class="nl">alpha:</span><span class="mf">1.0</span><span class="p">];</span>
</span><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">im</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class="line"><span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p style="text-align: center;"><span style="font-family: 'comic sans ms', sans-serif;"><img style="border: 1px solid black;" src="http://images.cnitblog.com/blog/429321/201212/23211917-efbb4cc54ca745a0b21539875527e763.png" alt="" /></span></p>
<p align="center"><span style="font-family: 'comic sans ms', sans-serif;">图2 UIImage缩放处理</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　UIImage没有提供截取图片指定区域的功能。但通过创建一个较小的图形上下文并移动图片到一个适当的图形上下文坐标系内，指定区域内的图片就会被获取。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　<strong>裁剪操作：</strong>下面代码展示了如何获取图片的右半边：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">mars</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="err">@”</span><span class="n">Mars</span><span class="p">.</span><span class="n">png</span><span class="err">”</span><span class="p">];</span>
</span><span class="line"><span class="n">CGSize</span> <span class="n">sz</span> <span class="o">=</span> <span class="p">[</span><span class="n">mars</span> <span class="n">size</span><span class="p">];</span>
</span><span class="line"><span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="n">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="p">[</span><span class="n">mars</span> <span class="nl">drawAtPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="o">-</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)];</span>
</span><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">im</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class="line"><span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　以上的代码首先创建一个一半图片宽度的图形上下文，然后将图片左上角原点移动到与图形上下文负X坐标对齐，从而让图片只有右半部分与图形上下文相交。</span></p>
<p style="text-align: center;"><span style="font-family: 'comic sans ms', sans-serif;"><img style="border: 1px solid black;" src="http://images.cnitblog.com/blog/429321/201212/24135912-e57ea08be2db4656b406d5657f1c7357.png" alt="" /></span></p>
<p align="center"><span style="font-family: 'comic sans ms', sans-serif;">图3 UIImage裁剪原理</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　CGImage常用的绘图操作</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　UIImage的Core Graphics版本是CGImage（具体类型是CGImageRef）。两者可以直接相互转化: 使用UIImage的CGImage属性可以访问Quartz图片数据；将CGImage作为UIImage方法<strong>imageWithCGImage:</strong>或<strong>initWithCGImage:</strong>的参数创建UIImage对象。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　一个CGImage对象可以让你获取原始图片中指定区域的图片（也可以获取指定区域外的图片，UIImage却办不到）。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　下面的代码展示了将图片拆分成两半，并分别绘制在上下文的左右两边：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">mars</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="err">@”</span><span class="n">Mars</span><span class="p">.</span><span class="n">png</span><span class="err">”</span><span class="p">];</span>
</span><span class="line"><span class="c1">// 抽取图片的左右半边</span>
</span><span class="line"><span class="n">CGSize</span> <span class="n">sz</span> <span class="o">=</span> <span class="p">[</span><span class="n">mars</span> <span class="n">size</span><span class="p">];</span>
</span><span class="line"><span class="n">CGImageRef</span> <span class="n">marsLeft</span> <span class="o">=</span> <span class="n">CGImageCreateWithImageInRect</span><span class="p">([</span><span class="n">mars</span> <span class="n">CGImage</span><span class="p">],</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">));</span>
</span><span class="line"><span class="n">CGImageRef</span> <span class="n">marsRight</span> <span class="o">=</span> <span class="n">CGImageCreateWithImageInRect</span><span class="p">([</span><span class="n">mars</span> <span class="n">CGImage</span><span class="p">],</span><span class="n">CGRectMake</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">));</span>
</span><span class="line"><span class="c1">// 将每一个CGImage绘制到图形上下文中</span>
</span><span class="line"><span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">*</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="n">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextRef</span> <span class="n">con</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line"><span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="n">marsLeft</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="n">marsRight</span><span class="p">);</span>
</span><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">im</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class="line"><span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span><span class="line"><span class="c1">// 记得释放内存，ARC在这里无效</span>
</span><span class="line"><span class="n">CGImageRelease</span><span class="p">(</span><span class="n">marsLeft</span><span class="p">);</span>
</span><span class="line"><span class="n">CGImageRelease</span><span class="p">(</span><span class="n">marsRight</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　你也许发现绘出的图是上下颠倒的！图片的颠倒并不是因为被旋转了。当你创建了一个CGImage并使用<strong>CGContextDrawImage</strong>方法绘图就会引起这种问题。这主要是因为原始的本地坐标系统（坐标原点在左上角）与目标上下文（坐标原点在左下角）不匹配。有很多方法可以修复这个问题，其中一种方法就是使用<strong>CGContextDrawImage</strong>方法先将CGImage绘制到UIImage上，然后获取UIImage对应的CGImage，此时就得到了一个倒转的CGImage。当再调用<strong>CGContextDrawImage</strong>方法，我们就将倒转的图片还原回来了。实现代码如下：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGImageRef</span> <span class="nf">flip</span> <span class="p">(</span><span class="n">CGImageRef</span> <span class="n">im</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="n">CGSize</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="n">CGImageGetWidth</span><span class="p">(</span><span class="n">im</span><span class="p">),</span> <span class="n">CGImageGetHeight</span><span class="p">(</span><span class="n">im</span><span class="p">));</span>
</span><span class="line">	<span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">UIGraphicsGetCurrentContext</span><span class="p">(),</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="n">im</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGImageRef</span> <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">()</span> <span class="n">CGImage</span><span class="p">];</span>
</span><span class="line">	<span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span><span class="line">	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　现在将之前的代码修改如下：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="n">flip</span><span class="p">(</span><span class="n">marsLeft</span><span class="p">));</span>
</span><span class="line"><span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="n">flip</span><span class="p">(</span><span class="n">marsRight</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　然而，这里又出现了另外一个问题：在双分辨率的设备上，如果我们的图片文件是高分辨率（@2x）版本，上面的绘图就是错误的。原因在于对于UIImage来说，在加载原始图片时使用<strong>imageNamed:</strong>方法，它会自动根据所在设备的分辨率类型选择图片，并且UIImage通过设置用来适配的<strong>scale</strong>属性补偿图片的两倍尺寸。但是一个CGImage对象并没有<strong>scale</strong>属性，它不知道图片文件的尺寸是否为两倍！所以当调用UIImage的<strong>CGImage</strong>方法，你不能假定所获得的CGImage尺寸与原始UIImage是一样的。在单分辨率和双分辨率下，一个UIImage对象的<strong>size</strong>属性值都是一样的，但是双分辨率UIImage对应的CGImage是单分辨率UIImage对应的CGImage的两倍大。所以我们需要修改上面的代码，让其在单双分辨率下都可以工作。代码如下：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">mars</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="err">@”</span><span class="n">Mars</span><span class="p">.</span><span class="n">png</span><span class="err">”</span><span class="p">];</span>
</span><span class="line"><span class="n">CGSize</span> <span class="n">sz</span> <span class="o">=</span> <span class="p">[</span><span class="n">mars</span> <span class="n">size</span><span class="p">];</span>
</span><span class="line"><span class="c1">// 转换CGImage并使用对应的CGImage尺寸截取图片的左右部分</span>
</span><span class="line"><span class="n">CGImageRef</span> <span class="n">marsCG</span> <span class="o">=</span> <span class="p">[</span><span class="n">mars</span> <span class="n">CGImage</span><span class="p">];</span>
</span><span class="line"><span class="n">CGSize</span> <span class="n">szCG</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="n">CGImageGetWidth</span><span class="p">(</span><span class="n">marsCG</span><span class="p">),</span> <span class="n">CGImageGetHeight</span><span class="p">(</span><span class="n">marsCG</span><span class="p">));</span>
</span><span class="line"><span class="n">CGImageRef</span> <span class="n">marsLeft</span> <span class="o">=</span> <span class="n">CGImageCreateWithImageInRect</span><span class="p">(</span><span class="n">marsCG</span><span class="p">,</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">szCG</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">szCG</span><span class="p">.</span><span class="n">height</span><span class="p">));</span>
</span><span class="line"><span class="n">CGImageRef</span> <span class="n">marsRight</span> <span class="o">=</span> <span class="n">CGImageCreateWithImageInRect</span><span class="p">(</span><span class="n">marsCG</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">szCG</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">szCG</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">szCG</span><span class="p">.</span><span class="n">height</span><span class="p">));</span>
</span><span class="line"><span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">*</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="n">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="c1">//剩下的和之前的代码一样，修复倒置问题</span>
</span><span class="line"><span class="n">CGContextRef</span> <span class="n">con</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line"><span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span><span class="n">flip</span><span class="p">(</span><span class="n">marsLeft</span><span class="p">));</span>
</span><span class="line"><span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span><span class="n">flip</span><span class="p">(</span><span class="n">marsRight</span><span class="p">));</span>
</span><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">im</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class="line"><span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span><span class="line"><span class="n">CGImageRelease</span><span class="p">(</span><span class="n">marsLeft</span><span class="p">);</span>
</span><span class="line"><span class="n">CGImageRelease</span><span class="p">(</span><span class="n">marsRight</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　上面的代码初看上去很繁杂，不过不用担心，这里还有另一种修复倒置问题的方案。相对于使用<strong>flip</strong>函数，你可以在绘图之前将CGImage包装进UIImage中，这样做有两大优点：</span></p>
<ul>
     <li><span style="font-family: 'comic sans ms', sans-serif;">当UIImage绘图时它会自动修复倒置问题</span></li>
     <li><span style="font-family: 'comic sans ms', sans-serif;">当你从CGImage转化为Uimage时，可调用imageWithCGImage:scale:orientation:方法生成CGImage作为对缩放性的补偿。</span></li>
</ul>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　所以这是一个解决倒置和缩放问题的自包含方法。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　代码如下：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">mars</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="err">@”</span><span class="n">Mars</span><span class="p">.</span><span class="n">png</span><span class="err">”</span><span class="p">];</span>
</span><span class="line"><span class="n">CGSize</span> <span class="n">sz</span> <span class="o">=</span> <span class="p">[</span><span class="n">mars</span> <span class="n">size</span><span class="p">];</span>
</span><span class="line"><span class="n">CGImageRef</span> <span class="n">marsCG</span> <span class="o">=</span> <span class="p">[</span><span class="n">mars</span> <span class="n">CGImage</span><span class="p">];</span>
</span><span class="line"><span class="n">CGSize</span> <span class="n">szCG</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="n">CGImageGetWidth</span><span class="p">(</span><span class="n">marsCG</span><span class="p">),</span> <span class="n">CGImageGetHeight</span><span class="p">(</span><span class="n">marsCG</span><span class="p">));</span>
</span><span class="line"><span class="n">CGImageRef</span> <span class="n">marsLeft</span> <span class="o">=</span> <span class="n">CGImageCreateWithImageInRect</span><span class="p">(</span><span class="n">marsCG</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">szCG</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">szCG</span><span class="p">.</span><span class="n">height</span><span class="p">));</span>
</span><span class="line"><span class="n">CGImageRef</span> <span class="n">marsRight</span> <span class="o">=</span> <span class="n">CGImageCreateWithImageInRect</span><span class="p">(</span><span class="n">marsCG</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">szCG</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">szCG</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span><span class="n">szCG</span><span class="p">.</span><span class="n">height</span><span class="p">));</span>
</span><span class="line"><span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">*</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="n">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="p">[[</span><span class="n">UIImage</span> <span class="nl">imageWithCGImage:</span><span class="n">marsLeft</span> <span class="nl">scale:</span><span class="p">[</span><span class="n">mars</span> <span class="n">scale</span><span class="p">]</span> <span class="nl">orientation:</span><span class="n">UIImageOrientationUp</span><span class="p">]</span> <span class="nl">drawAtPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)];</span>
</span><span class="line"><span class="p">[[</span><span class="n">UIImage</span> <span class="nl">imageWithCGImage:</span><span class="n">marsRight</span> <span class="nl">scale:</span><span class="p">[</span><span class="n">mars</span> <span class="n">scale</span><span class="p">]</span> <span class="nl">orientation:</span><span class="n">UIImageOrientationUp</span><span class="p">]</span> <span class="nl">drawAtPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="mi">0</span><span class="p">)];</span>
</span><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">im</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class="line"><span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span><span class="line"><span class="n">CGImageRelease</span><span class="p">(</span><span class="n">marsLeft</span><span class="p">);</span>
</span><span class="line"><span class="n">CGImageRelease</span><span class="p">(</span><span class="n">marsRight</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　还有另一种解决倒置问题的方案是在绘制CGImage之前，对上下文应用变换操作，有效地倒置上下文的内部坐标系统。这里先不做讨论。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　<strong>为什么会发生倒置问题</strong></span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　究其原因是因为Core Graphics源于Mac OS X系统，在Mac OS X中，坐标原点在左下方并且正y坐标是朝上的，而在iOS中，原点坐标是在左上方并且正y坐标是朝下的。在大多数情况下，这不会出现任何问题，因为图形上下文的坐标系统是会自动调节补偿的。但是创建和绘制一个CGImage对象时就会暴露出倒置问题。&nbsp;</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　CIFilter</strong><strong>与</strong><strong>CIImage</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　CIFilter与CIImage是iOS 5新引入的，虽然它们已在MAX OS X系统中存在多年。前缀&#8220;CI&#8221;表示Core Image，这是一种使用数学滤镜变换图片的技术。但是你不要去幻想iOS提供了像Photoshop软件那样强大的滤镜功能。使用Core Image之前你需要将<em>CoreImage.framework</em>框架导入到你的target之中。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　所谓滤镜指的是CIFilter类，滤镜可被分为以下几类：</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　模板与渐变类</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　这两类滤镜创建的CIImage可以和其他的CIImage进行合并，比如一种单色，一个棋盘，条纹，亦或是渐变。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　合成类&nbsp;</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　此类滤镜可以将一张图片与另外的图片合并，合成滤镜模式常见于图形处理软件Photoshop中。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　色彩类</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　此滤镜调整、修改图片的色彩。因此你可以改变一张图片的饱和度、色度、亮度、对比度、伽马、白点、曝光度、阴影、高亮等属性。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　几何变换类</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　此类滤镜可对图片执行基本的几何变换，比如缩放、旋转、裁剪。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;　&nbsp;CIFilter使用起来非常的简单。CIFilter看上去就像一个由键值组成的字典。它生成一个CIImage对象作为其输出。一般地，一个滤镜有一个或多个输入，而对于部分滤镜，生成的图片是基于其他类型的参数值。CIFilter对象是一个集合，可使用键值对进行检索。通过提供滤镜的字符串名称创建一个滤镜，如果想知道有哪些滤镜，可以查询苹果的<a href="https://developer.apple.com/library/mac/#documentation/graphicsimaging/reference/CoreImageFilterReference/Reference/reference.html"><em>Core Image Filter Reference</em></a>文档，或是调用CIFilter的类方法<strong>filterNamesInCategories</strong><strong>：</strong>，参数值为nil。每一个滤镜拥有一小部分用来确定其行为的键值。如果你想修改某一个键（比如亮度键）对应的值，你可以调用<strong>setValue</strong><strong>：</strong><strong>forKey</strong><strong>：</strong>方法或当你指定一个滤镜名时提供所有键值对。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp; &nbsp; &nbsp;需要处理的图片必须是CIImage类型，调用<strong>initWithCGImage</strong><strong>：</strong>方法可获得CIImage。因为CGImage又是作为滤镜的输出，因此滤镜之间可被连接在一起（将滤镜的输出作为<strong>initWithCGImage</strong><strong>：</strong>方法的输入参数）</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp; 当你构建一个滤镜链时，并没有做复杂的运算。只有当整个滤镜链需要输出一个CGImage时，密集型计算才会发生。调用<strong>contextWithOptions</strong><strong>：</strong>和<strong>createCGImage: fromRect:</strong>方法创建CIContext。与以往不同的地方是CIImage没有frame与bounds属性；只有extent属性。你将非常频繁的使用这个属性作为<strong>createCGImage: fromRect:</strong>方法的第二个参数。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp; &nbsp;接下来我将演示Core Image的使用。首先创建一个径向渐变的滤镜，该滤镜是从白到黑的渐变方式，白色区域的半径默认是100。接着将其与一张使用CIDarkenBlendMode滤镜的图片合成。CIDarkenBlendMode的作用是背景图片样本将被源图片的黑色部分替换掉。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">代码如下：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">moi</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="err">@”</span><span class="n">Mars</span><span class="p">.</span><span class="n">jpeg</span><span class="err">”</span><span class="p">];</span>
</span><span class="line"><span class="n">CIImage</span><span class="o">*</span> <span class="n">moi2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CIImage</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithCGImage:</span><span class="n">moi</span><span class="p">.</span><span class="n">CGImage</span><span class="p">];</span>
</span><span class="line"><span class="n">CIFilter</span><span class="o">*</span> <span class="n">grad</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIFilter</span> <span class="nl">filterWithName:</span><span class="err">@”</span><span class="n">CIRadialGradient</span><span class="err">”</span><span class="p">];</span>
</span><span class="line"><span class="n">CIVector</span><span class="o">*</span> <span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIVector</span> <span class="nl">vectorWithX:</span><span class="n">moi</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="nl">Y:</span><span class="n">moi</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">];</span>
</span><span class="line"><span class="c1">// 使用setValue：forKey：方法设置滤镜属性</span>
</span><span class="line"><span class="p">[</span><span class="n">grad</span> <span class="nl">setValue:</span><span class="n">center</span> <span class="nl">forKey:</span><span class="err">@”</span><span class="n">inputCenter</span><span class="err">”</span><span class="p">];</span>
</span><span class="line"><span class="c1">// 在指定滤镜名时提供所有滤镜键值对</span>
</span><span class="line"><span class="n">CIFilter</span><span class="o">*</span> <span class="n">dark</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIFilter</span> <span class="nl">filterWithName:</span><span class="err">@”</span><span class="n">CIDarkenBlendMode</span><span class="err">”</span> <span class="nl">keysAndValues:</span><span class="err">@”</span><span class="n">inputImage</span><span class="err">”</span><span class="p">,</span> <span class="n">grad</span><span class="p">.</span><span class="n">outputImage</span><span class="p">,</span> <span class="err">@”</span><span class="n">inputBackgroundImage</span><span class="err">”</span><span class="p">,</span> <span class="n">moi2</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
</span><span class="line"><span class="n">CIContext</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIContext</span> <span class="nl">contextWithOptions:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line"><span class="n">CGImageRef</span> <span class="n">moi3</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="nl">createCGImage:</span><span class="n">dark</span><span class="p">.</span><span class="n">outputImage</span> <span class="nl">fromRect:</span><span class="n">moi2</span><span class="p">.</span><span class="n">extent</span><span class="p">];</span>
</span><span class="line"><span class="n">UIImage</span><span class="o">*</span> <span class="n">moi4</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageWithCGImage:</span><span class="n">moi3</span> <span class="nl">scale:</span><span class="n">moi</span><span class="p">.</span><span class="n">scale</span> <span class="nl">orientation:</span><span class="n">moi</span><span class="p">.</span><span class="n">imageOrientation</span><span class="p">];</span>
</span><span class="line"><span class="n">CGImageRelease</span><span class="p">(</span><span class="n">moi3</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><span style="font-family: 'comic sans ms', sans-serif;"><img style="border: 1px solid black; display: block; margin-left: auto; margin-right: auto;" src="http://images.cnitblog.com/blog/429321/201212/27103647-2fcd19d1ca1e4a0d9f42e2c79687e881.png" alt="" width="693" height="199" /></span></p>
<p style="text-align: center;">&nbsp;<span style="font-family: 'comic sans ms', sans-serif; text-align: left; line-height: 1.5;">&nbsp;图4 图片合成快照　</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　这个例子可能没有什么吸引人的地方，因为所有一切都可以使用Core Graphics完成。除了Core Image是使用GPU处理，可能有点吸引人。Core Graphics也可以做到径向渐变并使用混合模式合成图片。但Core Image要简单得多，特别是当你有多个图片输入想重用一个滤镜链时。并且Core Image的颜色调整功能比Core Graphics更加强大。对了，Core Image还能实现自动人脸识别哦！</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　绘制一个</strong><strong>UIView</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　绘制一个UIVIew最灵活的方式就是由它自己完成绘制。实际上你不是绘制一个UIView，你只是子类化了UIView并赋予子类绘制自己的能力。当一个UIVIew需要执行绘图操作的时， <strong>drawRect</strong>:方法就会被调用。覆盖此方法让你获得绘图操作的机会。当<strong>drawRect</strong><strong>：</strong>方法被调用，当前图形上下文也被设置为属于视图的图形上下文。你可以使用Core Graphics或UIKit提供的方法将图形画到该上下文中。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　你不应该手动调用<strong>drawRect</strong><strong>：</strong>方法！如果你想调用<strong>drawRect：</strong>方法更新视图，只需发送<strong>setNeedsDisplay</strong>方法。这将使得<strong>drawRect：</strong>方法会在下一个适当的时间调用。当然，不要覆盖<strong>drawRect</strong><strong>：</strong>方法除非你知道这样做绝对合法。比方说，在UIImageView子类中覆盖<strong>drawRect</strong><strong>：</strong>方法是不合法的，你将得不到你绘制的图形。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在UIView子类的<strong>drawRect</strong><strong>：</strong>方法中无需调用super，因为本身UIView的<strong>drawRect</strong><strong>：</strong>方法是空的。为了提高一些绘图性能，你可以调用<strong>setNeedsDisplayInRect</strong>方法重新绘制视图的子区域，而视图的其他部分依然保持不变。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一般情况下，你不应该过早的进行优化。绘图代码可能看上去非常的繁琐，但它们是非常快的。并且iOS绘图系统自身也是非常高效，它不会频繁调用<strong>drawRect</strong><strong>：</strong>方法，除非迫不得已（或调用了<strong>setNeedsDisplay</strong>方法）。一旦一个视图已由自己绘制完成，那么绘制的结果会被缓存下来留待重用，而不是每次重头再来。(苹果公司将缓存绘图称为视图的位图存储回填（<em>bitmap backing store</em>）)。你可能会发现<strong>drawRect</strong><strong>：</strong>方法中的代码在整个应用程序生命周期内只被调用了一次！事实上，将代码移到<strong>drawRect</strong><strong>：</strong>方法中是提高性能的普遍做法。这是因为绘图引擎直接对屏幕进行渲染相对于先是脱屏渲染然后再将像素拷贝到屏幕要来的高效。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当视图的<strong>backgroundColor</strong>为nil并且<strong>opaque</strong>属性为YES，视图的背景颜色就会变成黑色。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　Core Graphics</strong><strong>上下文属性设置</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　当你在图形上下文中绘图时，当前图形上下文的相关属性设置将决定绘图的行为与外观。因此，绘图的一般过程是先设定好图形上下文参数，然后绘图。比方说，要画一根红线，接着画一根蓝线。那么首先需要将上下文的线条颜色属性设定为为红色，然后画红线；接着设置上下文的线条颜色属性为蓝色，再画出蓝线。表面上看,红线和蓝线是分开的，但事实上，在你画每一条线时，线条颜色却是整个上下文的属性。无论你用的是UIKit方法还是Core Graphics函数。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　因为图形上下文在每一时刻都有一个确定的状态，该状态概括了图形上下文所有属性的设置。为了便于操作这些状态，图形上下文提供了一个用来持有状态的栈。调用<strong>CGContextSaveGState</strong>函数，上下文会将完整的当前状态压入栈顶；调用<strong>CGContextRestoreGState</strong>函数，上下文查找处在栈顶的状态，并设置当前上下文状态为栈顶状态。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　因此一般绘图模式是：在绘图之前调用<strong>CGContextSaveGState</strong>函数保存当前状态，接着根据需要设置某些上下文状态，然后绘图，最后调用<strong>CGContextRestoreGState</strong>函数将当前状态恢复到绘图之前的状态。要注意的是，<strong>CGContextSaveGState</strong>函数和<strong>CGContextRestoreGState</strong>函数必须成对出现，否则绘图很可能出现意想不到的错误，这里有一个简单的做法避免这种情况。代码如下：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawRect:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">rect</span> <span class="p">{</span>
</span><span class="line">	<span class="n">CGContextRef</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line">	<span class="n">CGContextSaveGState</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class="line">	<span class="p">{</span>
</span><span class="line">		<span class="c1">// 绘图代码</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	
</span><span class="line">	<span class="n">CGContextRestoreGState</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span> <span class="err">　</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　但你不需要在每次修改上下文状态之前都这样做，因为你对某一上下文属性的设置并不一定会和之前的属性设置或其他的属性设置产生冲突。你完全可以在不调用保存和恢复函数的情况下先设置线条颜色为红色，然后再设置为蓝色。但在一定情况下，你希望你对状态的设置是可撤销的，我将在接下来讨论这样的情况。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　许多的属性组成了一个图形上下文状态，这些属性设置决定了在你绘图时图形的外观和行为。下面我列出了一些属性和对应修改属性的函数；虽然这些函数是关于Core Graphics的，但记住，实际上UIKit同样是调用这些函数操纵上下文状态。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　线条的宽度和线条的虚线样式</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　CGContextSetLineWidth</strong>、<strong>CGContextSetLineDash</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　线帽和线条联接点样式</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　CGContextSetLineCap</strong><strong>、</strong><strong>CGContextSetLineJoin</strong><strong>、</strong><strong>CGContextSetMiterLimit</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　线条颜色和线条模式</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>CGContextSetStrokeColorWithColor</strong><strong>、</strong><strong>CGContextSetStrokePattern</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　CGContextSetRGBStrokeColor</strong><strong>、</strong><strong>CGContextSetGrayStrokeColor</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　填充颜色和模式</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong style="line-height: 1.5;">　　CGContextSetRGBFillColor,CGContextSetGrayFillColor</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong style="line-height: 1.5;">　　CGContextSetFillColorWithColor, CGContextSetFillPattern</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　阴影</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　CGContextSetShadow</strong><strong>、</strong><strong>CGContextSetShadowWithColor</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　混合模式</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　CGContextSetBlendMode</strong>（决定你当前绘制的图形与已经存在的图形如何被合成）</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　整体透明度</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　CGContextSetAlpha</strong>（个别颜色也具有alpha成分）</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　文本属性</span></p>
<p><strong>　　CGContextSelectFont</strong><strong>、</strong><strong>CGContextSetFont</strong><strong>、

<p><strong>CGContextSetFontSize</strong><strong>、</strong><strong>CGContextSetTextDrawingMode</strong><strong>、</strong><strong>CGContextSetCharacterSpacing</strong>
</p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　是否开启反锯齿和字体平滑</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　CGContextSetShouldAntialias</strong><strong>、</strong><strong>CGContextSetShouldSmoothFonts</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　另外一些属性设置：</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　裁剪区域:在裁剪区域外绘图不会被实际的画出来。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　变换（或称为&#8220;CTM&#8220;，意为当前变换矩阵):&nbsp;改变你随后指定的绘图命令中的点如何被映射到画布的物理空间。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　许多这些属性设置接下来我都会举例说明。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　路径与绘图</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　通过编写移动虚拟画笔的代码描画一段路径，这样的路径并不构成一个图形。绘制路径意味着对路径描边或填充该路径，也或者两者都做。同样，你应该从某些绘图程序中得到过相似的体会。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　一段路径是由点到点的描画构成。想象一下绘图系统是你手里的一只画笔，你首先必须要设置画笔当前所处的位置，然后给出一系列命令告诉画笔如何描画随后的每段路径。每一段新增的路径开始于当前点，当完成一条路径的描画，路径的终点就变成了当前点。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; 下面列出了一些路径描画的命令：</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; 定位当前点</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; <strong>CGContextMoveToPoint</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; 描画一条线</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; <strong>CGContextAddLineToPoint</strong><strong>、</strong><strong>CGContextAddLines</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; 描画一个矩形</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; <strong>CGContextAddRect</strong><strong>、</strong><strong>CGContextAddRects</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; 描画一个椭圆或圆形</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; <strong>CGContextAddEllipseInRect</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; 描画一段圆弧</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; <strong>CGContextAddArcToPoint</strong><strong>、</strong><strong>CGContextAddArc</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; 通过一到两个控制点描画一段贝赛尔曲线</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>&nbsp;&nbsp;&nbsp; CGContextAddQuadCurveToPoint</strong><strong>、</strong><strong>CGContextAddCurveToPoint</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; 关闭当前路径</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; <strong>CGContextClosePath</strong> 这将从路径的终点到起点追加一条线。如果你打算填充一段路径，那么就不需要使用该命令，因为该命令会被自动调用。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; 描边或填充当前路径</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; <strong>CGContextStrokePath</strong><strong>、</strong><strong>CGContextFillPath</strong><strong>、</strong><strong>CGContextEOFillPath</strong><strong>、</strong><strong>CGContextDrawPath</strong>。<span style="color: #ff0000;">对当前路径描边或填充会清除掉路径。</span>如果你只想使用一条命令完成描边和填充任务，可以使用<strong>CGContextDrawPath</strong>命令，因为如果你只是使用<strong>CGContextStrokePath</strong>对路径描边，路径就会被清除掉，你就不能再对它进行填充了。</span></p>
<p>创建路径并描边路径或填充路径只需一条命令就可完成的函数：<strong>CGContextStrokeLineSegments</strong><strong>、</strong><strong>CGContextStrokeRect</strong><strong>、</strong><strong>CGContextStrokeRectWithWidth</strong><strong>、
<p><strong>CGContextFillRect</strong><strong>、</strong><strong>CGContextFillRects</strong><strong>、</strong><strong>CGContextStrokeEllipseInRect</strong><strong>、</strong><strong>CGContextFillEllipseInRect</strong></p>

<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; 一段路径是被合成的，意思是它是由多条独立的路径组成。举个例子，一条单独的路径可能由两个独立的闭合形状组成：一个矩形和一个圆形。当你在构造一条路径的中间过程（意思是在描画了一条路径后没有调用描边或填充命令，或调用<strong>CGContextBeginPath</strong>函数来清除路径）调用<strong>CGContextMoveToPoint</strong>函数，就像是你拾起画笔，并将画笔移动到一个新的位置，如此来准备开始一段独立的相同路径。如果你担心当你开始描画一条路径的时候，已经存在的路径和新的路径会被认为是已存在路径的一个合成部分，你可以调用<strong>CGContextBeginPath</strong>函数指定你绘制的路径是一条独立的路径；苹果的许多例子都是这样做的，但在实际开发中我发现这是非必要的。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; <strong>CGContextClearRect</strong>函数的功能是擦除一个区域。这个函数会擦除一个矩形内的所有已存在的绘图；并对该区域执行裁剪。结果像是打了一个贯穿所有已存在绘图的孔。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; <strong>CGContextClearRect</strong>函数的行为依赖于上下文是透明还是不透明。当在图形上下文中绘图时，这会尤为明显和直观。如果图片上下文是透明的（<strong>UIGraphicsBeginImageContextWithOptions</strong>第二个参数为NO），那么<strong>CGContextClearRect</strong>函数执行擦除后的颜色为透明，反之则为黑色。</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; 当在一个视图中直接绘图（使用<strong>drawRect：</strong>或<strong>drawLayer：inContext：</strong>方法），如果视图的背景颜色为nil或颜色哪怕有一点点透明度，那么CGContextClearRect的矩形区域将会显示为透明的，打出的孔将穿过视图包括它的背景颜色。如果背景颜色完全不透明，那么<strong>CGContextClearRect</strong>函数的结果将会是黑色。这是因为视图的背景颜色决定了是否视图的图形上下文是透明的还是不透明的。</span></p>
<p style="text-align: center;"><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;<img style="border: 1px solid black;" src="http://images.cnitblog.com/blog/429321/201301/04135105-c4e1981ec5e84cbfaba3e2dd641f7411.png" alt="" /></span></p>
<p style="text-align: center;"><span style="font-family: 'comic sans ms', sans-serif;">图5 CGContextClearRect函数的应用</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; 如图5，在左边的蓝色正方形被挖去部分留为黑色，然而在右边的蓝色正方形也被挖去部分留为透明。但这两个正方形都是UIView子类的实例，采用相同的绘图代码！不同之处在于视图的背景颜色，左边的正方形的背景颜色在nib文件中</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　但是这却完全改变了CGContextClearRect函数的效果。UIView子类的drawRect：方法看起来像这样：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGContextRef</span> <span class="n">con</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line"><span class="n">CGContextSetFillColorWithColor</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextFillRect</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">rect</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextClearRect</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">30</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　为了说明典型路径的描画命令，我将生成一个向上的箭头图案，我谨慎避免使用便利函数操作，也许这不是创建箭头最好的方式，但依然清楚的展示了各种典型命令的用法。</span></p>
<p align="center"><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;<img style="border: 1px solid black;" src="http://images.cnitblog.com/blog/429321/201301/03223022-6cc72c828292475eb6f9915454403b4d.png" alt="" /></span></p>
<p align="center"><span style="font-family: 'comic sans ms', sans-serif;">图6 一个简单的路径绘图</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGContextRef</span> <span class="n">con</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line"><span class="c1">// 绘制一个黑色的垂直黑色线，作为箭头的杆子</span>
</span><span class="line"><span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextSetLineWidth</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextStrokePath</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line"><span class="c1">// 绘制一个红色三角形箭头</span>
</span><span class="line"><span class="n">CGContextSetFillColorWithColor</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="p">[[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">]</span> <span class="n">CGColor</span><span class="p">]);</span>
</span><span class="line"><span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextFillPath</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line"><span class="c1">// 从箭头杆子上裁掉一个三角形，使用清除混合模式</span>
</span><span class="line"><span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">101</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">90</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">101</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextSetBlendMode</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">kCGBlendModeClear</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextFillPath</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　确切的说，为了以防万一，我们应该在绘图代码周围使用<strong>CGContextSaveGState</strong>和<strong>CGContextRestoreGState</strong>函数。可对于这个例子来说，添加与否不会有任何的区别。因为上下文在调用drawRect：方法中不会被持久，所以不会被破坏。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　如果一段路径需要重用或共享，你可以将路径封装为CGPath（具体类型是CGPathRef）。你可以创建一个新的CGMutablePathRef对象并使用多个类似于图形的路径函数的CGPath函数构造路径，或者使用CGContextCopyPath函数复制图形上下文的当前路径。有许多CGPath函数可用于创建基于简单几何形状的路径（<strong>CGPathCreateWithRect、CGPathCreateWithEllipseInRect</strong>）或基于已存在路径（<strong>CGPathCreateCopyByStrokingPath、CGPathCreateCopyDashingPath、CGPathCreateCopyByTransformingPath</strong>）。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　UIKit的UIBezierPath类包装了CGPath。它提供了用于绘制某种形状路径的方法，以及用于描边、填充、存取某些当前上下文状态的设置方法。类似地，UIColor提供了用于设置当前上下文描边与填充的颜色。因此我们可以重写我们之前绘制箭头的代码：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">UIBezierPath</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBezierPath</span> <span class="n">bezierPath</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">p</span> <span class="nl">moveToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">p</span> <span class="nl">addLineToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">19</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">p</span> <span class="nl">setLineWidth:</span><span class="mi">20</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">p</span> <span class="n">stroke</span><span class="p">];</span>
</span><span class="line"><span class="p">[[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">]</span> <span class="n">set</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">p</span> <span class="n">removeAllPoints</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">p</span> <span class="nl">moveToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span><span class="mi">25</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">p</span> <span class="nl">addLineToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">p</span> <span class="nl">addLineToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="mi">25</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">p</span> <span class="n">fill</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">p</span> <span class="n">removeAllPoints</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">p</span> <span class="nl">moveToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">90</span><span class="p">,</span><span class="mi">101</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">p</span> <span class="nl">addLineToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">90</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">p</span> <span class="nl">addLineToPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="mi">101</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">p</span> <span class="nl">fillWithBlendMode:</span><span class="n">kCGBlendModeClear</span> <span class="nl">alpha:</span><span class="mf">1.0</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　在这种特殊情况下，完成同样的工作并没有节省多少代码，但是UIBezierPath仍然还是有用的。如果你需要对象特性，UIBezierPath提供了一个便利方法：<strong>bezierPathWithRoundedRect</strong><strong>：</strong><strong>cornerRadius</strong><strong>：</strong>，它可用于绘制带有圆角的矩形，如果是使用Core Graphics就相当冗长乏味了。还可以只让圆角出现在左上角和右上角。</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawRect:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">rect</span> <span class="p">{</span>
</span><span class="line">  <span class="n">CGContextRef</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line">  <span class="n">CGContextSetStrokeColorWithColor</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">blackColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">);</span>
</span><span class="line">  <span class="n">CGContextSetLineWidth</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span><span class="line">  <span class="n">UIBezierPath</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
</span><span class="line">  <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBezierPath</span> <span class="nl">bezierPathWithRoundedRect:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="nl">byRoundingCorners:</span><span class="p">(</span><span class="n">UIRectCornerTopLeft</span> <span class="o">|</span><span class="n">UIRectCornerTopRight</span><span class="p">)</span> <span class="nl">cornerRadii:</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)];</span>
</span><span class="line">  <span class="p">[</span><span class="n">path</span> <span class="n">stroke</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p style="text-align: center;" align="left"><span style="font-family: 'comic sans ms', sans-serif;"><img style="border: 1px solid black;" src="http://images.cnitblog.com/blog/429321/201301/10164554-8b950cf0971d44788736463119e4eaf5.png" alt="" /></span></p>
<p style="text-align: center;" align="left"><span style="font-family: 'comic sans ms', sans-serif;">图7 左右圆角矩形</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　<strong style="line-height: 1.5;">裁剪</strong></span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　路径的另一用处是遮蔽区域，以防对遮蔽区域进一步绘图。这种用法被称为裁剪。<span style="color: #ff0000;">裁剪区域外</span>的图形不会被绘制到。默认情况下，一个图形上下文的裁剪区域是整个图形上下文。你可在上下文中的任何地方绘图。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　总的来说，裁剪区域是上下文的一个特性。与已存在的裁剪区域相交会出现新的裁剪区域。所以如果你应用了你自己的裁剪区域，稍后将它从图形上下文中移除的做法是使用<strong>CGContextSaveGState</strong>和<strong>CGContextRestoreGState</strong>函数将代码包装起来。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; 为了便于说明这一点，我使用裁剪而不是使用混合模式在箭头杆子上打孔的方法重写了生成箭头的代码。这样做有点小复杂，因为我们想要裁剪区域不在三角形内而在三角形外部。为了表明这一点，我们使用了一个三角形和一个矩形组成了一个组合路径。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; 当填充一个组合路径并使用它表示一个裁剪区域时，系统遵循以下两规则之一：</span></p>
<p><span style="font-family: 'comic sans ms', sans-serif;">　　环绕规则（Winding rule）</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　如果边界是顺时针绘制，那么在其内部逆时针绘制的边界所包含的内容为空。如果边界是逆时针绘制，那么在其内部顺时针绘制的边界所包含的内容为空。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　奇偶规则</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　最外层的边界代表内部都有效，都要填充；之后向内第二个边界代表它的内部无效，不需填充；如此规则继续向内寻找边界线。我们的情况非常简单，所以使用奇偶规则就很容易了。这里我们使用CGContextEOCllip设置裁剪区域然后进行绘图。（如果不是很明白，可以参见这篇文章：<span style="color: #ff0000;"><a style="line-height: 1.5; font-family: 'comic sans ms', sans-serif;" href="http://disanji.net/2010/12/05/5-ways-to-draw-2d-shape-with-hole-in-html/"><span style="color: #ff0000;">五种方法绘制有孔的2d形状</span></a></span>）</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGContextRef</span> <span class="n">con</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line"><span class="c1">// 在上下文裁剪区域中挖一个三角形状的孔</span>
</span><span class="line"><span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">90</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextClosePath</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddRect</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGContextGetClipBoundingBox</span><span class="p">(</span><span class="n">con</span><span class="p">));</span>
</span><span class="line"><span class="c1">// 使用奇偶规则，裁剪区域为矩形减去三角形区域</span>
</span><span class="line"><span class="n">CGContextEOClip</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line"><span class="c1">// 绘制垂线</span>
</span><span class="line"><span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextSetLineWidth</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextStrokePath</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line"><span class="c1">// 画红色箭头</span>
</span><span class="line"><span class="n">CGContextSetFillColorWithColor</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="p">[[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">]</span> <span class="n">CGColor</span><span class="p">]);</span>
</span><span class="line"><span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextFillPath</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　渐变</strong></span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　</strong>渐变可以很简单也可以很复杂。一个简单的渐变（接下来要讨论的）由一端点的颜色与另一端点的颜色决定，如果在中间点加入颜色（可选），那么渐变会在上下文的两个点之间线性的绘制或在上下文的两个圆之间放射状的绘制。不能使用渐变作为路径的填充色，但可使用裁剪限制对路径形状的渐变。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　我重写了绘制箭头的代码，箭杆使用了线性渐变。效果如图7所示。</span></p>
<p style="text-align: center;" align="left"><span style="font-family: 'comic sans ms', sans-serif;"><img style="border: 1px solid black;" src="http://images.cnitblog.com/blog/429321/201301/07162647-645fc1f5a9d2469b83ef7577f6d1a461.png" alt="" />&nbsp;</span></p>
<p style="text-align: center;" align="left"><span style="font-family: 'comic sans ms', sans-serif;">图8 箭头杆子渐变</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGContextRef</span> <span class="n">con</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line"><span class="n">CGContextSaveGState</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line"><span class="c1">// 在上下文裁剪区域挖一个三角形孔</span>
</span><span class="line"><span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">90</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextClosePath</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddRect</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGContextGetClipBoundingBox</span><span class="p">(</span><span class="n">con</span><span class="p">));</span>
</span><span class="line"><span class="n">CGContextEOClip</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line"><span class="c1">//绘制一个垂线，让它的轮廓形状成为裁剪区域</span>
</span><span class="line"><span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextSetLineWidth</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</span><span class="line"><span class="c1">// 使用路径的描边版本替换图形上下文的路径</span>
</span><span class="line"><span class="n">CGContextReplacePathWithStrokedPath</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line"><span class="c1">// 对路径的描边版本实施裁剪</span>
</span><span class="line"><span class="n">CGContextClip</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line"><span class="c1">// 绘制渐变</span>
</span><span class="line"><span class="n">CGFloat</span> <span class="n">locs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">};</span>
</span><span class="line"><span class="n">CGFloat</span> <span class="n">colors</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line"><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.8</span><span class="p">,</span> <span class="c1">// 开始颜色，透明灰</span>
</span><span class="line"><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span> <span class="c1">// 中间颜色，黑色</span>
</span><span class="line"><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.8</span> <span class="c1">// 末尾颜色，透明灰</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="n">CGColorSpaceRef</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">CGColorSpaceCreateDeviceGray</span><span class="p">();</span>
</span><span class="line"><span class="n">CGGradientRef</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">CGGradientCreateWithColorComponents</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">locs</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextDrawLinearGradient</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">89</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="n">CGColorSpaceRelease</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
</span><span class="line"><span class="n">CGGradientRelease</span><span class="p">(</span><span class="n">grad</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextRestoreGState</span><span class="p">(</span><span class="n">con</span><span class="p">);</span> <span class="c1">// 完成裁剪</span>
</span><span class="line"><span class="c1">// 绘制红色箭头</span>
</span><span class="line"><span class="n">CGContextSetFillColorWithColor</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="p">[[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">]</span> <span class="n">CGColor</span><span class="p">]);</span>
</span><span class="line"><span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextFillPath</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　调用<strong>CGContextReplacePathWithStrokedPath</strong>函数假装对当前路径描边，并使用当前线段宽度和与线段相关的上下文状态设置。但接着创建的是描边路径外部的一个新的路径。因此，相对于使用粗的线条，我们使用了一个矩形区域作为裁剪区域。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　虽然过程比较冗长但是非常的简单；我们将渐变描述为一组在一端点（0.0）和另一端点（1.0）之间连续区上的位置，以及设置与每个位置相对应的颜色。为了提亮边缘的渐变，加深中间的渐变，我使用了三个位置，黑色点的位置是0.5。为了创建渐变，还需要提供一个颜色空间。最后，我创建出了该渐变，并对裁剪区域绘制线性渐变，最后释放了颜色空间和渐变。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　<strong>颜色与模板</strong></span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　</strong>在iOS中，CGColor表示颜色（具体类型为CGColorRef）。使用UIColor的colorWithCGColor：和CGColor方法可bridged cast到UIColor。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　在iOS中，模板表示为CGPattern（具体类型为CGPatternRef）。你可以创建一个模板并使用它进行描边或填充。其过程是相当复杂的。作为一个非常简单的例子，我将使用红蓝相间的三角形替换箭头的三角形部分。现在移除下面行：</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　CGContextSetFillColorWithColor（con， [UIColor redColor].CGColor））；</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　在被移除的地方填入下面代码：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGColorSpaceRef</span> <span class="n">sp2</span> <span class="o">=</span> <span class="n">CGColorSpaceCreatePattern</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextSetFillColorSpace</span> <span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">sp2</span><span class="p">);</span>
</span><span class="line"><span class="n">CGColorSpaceRelease</span> <span class="p">(</span><span class="n">sp2</span><span class="p">);</span>
</span><span class="line"><span class="n">CGPatternCallbacks</span> <span class="n">callback</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drawStripes</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
</span><span class="line"><span class="n">CGAffineTransform</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">CGAffineTransformIdentity</span><span class="p">;</span>
</span><span class="line"><span class="n">CGPatternRef</span> <span class="n">patt</span> <span class="o">=</span> <span class="n">CGPatternCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">tr</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">kCGPatternTilingConstantSpacingMinimalDistortion</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">);</span>
</span><span class="line"><span class="n">CGFloat</span> <span class="n">alph</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</span><span class="line"><span class="n">CGContextSetFillPattern</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">patt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alph</span><span class="p">);</span>
</span><span class="line"><span class="n">CGPatternRelease</span><span class="p">(</span><span class="n">patt</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p align="left"><span style="line-height: 1.5; font-family: 'comic sans ms', sans-serif;">　　代码非常冗长，但它却是一个完整的样板。现在我们从后往前分析代码: 我们调用<strong>CGContextSetFillPattern</strong>不是设置填充颜色，我们设置的是填充的模板。函数的第三个参数是一个指向CGFloat的指针，所以我们事先设置CGFloat自身。第二个参数是一个CGPatternRef对象，所以我们需要事先创建CGPatternRef，并在最后释放它。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　现在开始讨论CGPatternCreate。一个模板是在一个矩形元中的绘图。我们需要矩形元的尺寸（第二个参数）以及矩形元原始点之间的间隙（第四和第五个参数）。这这种情况下，矩形元是4*4的，每一个矩形元与它的周围矩形元是紧密贴合的。我们需要提供一个应用到矩形元的变换参数（第三个参数）；在这种情况下，我们不需要变换做什么工作，所以我们应用了一个恒等变换。我们应用了一个瓷砖规则（第六个参数）。我们需要声明的是颜色模板不是漏印（stencil）模板，所以参数值为true。并且我们需要提供一个指向回调函数的指针，回调函数的工作是向矩形元绘制模板。第八个参数是一个指向CGPatternCallbacks结构体的指针。这个结构体由数字0和两个指向函数的指针构成。第一个函数指针指向的函数当模板被绘制到矩形元中被调用，第二个函数指针指向的函数当模板被释放后调用。第二个函数指针我们没有指定，它的存在主要是为了内存管理的需要。但在这个简单的例子中，我们并不需要。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　在你使用颜色模板调用<strong>CGContextSetFillPattern</strong>函数之前，你需要设置将应用到模板颜色空间的上下文填充颜色空间。如果你忽略这项工作，那么当你调用<strong>CGContextSetFillPattern</strong>函数时会发生错误。所以我们创建了颜色空间，设置它作为上下文的填充颜色空间，并在后面做了释放。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　到这里我们仍然没有完成绘图。因为我还没有编写向矩形元中绘图的函数！绘图函数地址被表示为&amp;drawStripes。绘图代码如下所示：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">void</span> <span class="nf">drawStripes</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">CGContextRef</span> <span class="n">con</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line"><span class="c1">// assume 4 x 4 cell</span>
</span><span class="line"><span class="n">CGContextSetFillColorWithColor</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="p">[[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">]</span> <span class="n">CGColor</span><span class="p">]);</span>
</span><span class="line"><span class="n">CGContextFillRect</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">));</span>
</span><span class="line"><span class="n">CGContextSetFillColorWithColor</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="p">[[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">]</span> <span class="n">CGColor</span><span class="p">]);</span>
</span><span class="line"><span class="n">CGContextFillRect</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p style="text-align: center;"><span style="font-family: 'comic sans ms', sans-serif;"><img style="border: 1px solid black;" src="http://images.cnitblog.com/blog/429321/201301/07163055-71996ba36a4f4a44bca579b8d6210dd4.png" alt="" /></span></p>
<p align="center"><span style="font-family: 'comic sans ms', sans-serif;">图9 模板填充&nbsp;</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　如你所见，实际的模板绘图代码是非常简单的。唯一的复杂点在于<strong>CGPatternCreate</strong>函数必须与模板绘图函数的矩形元尺寸相同。我们知道矩形元的尺寸为4*4，所以我们用红色填充它，并接着填充它的下半部分为绿色。当这些矩形元被水平垂直平铺时，我们得到了如图8所示的条纹图案。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　注意，最后图形上下文遗留下了一个不可取的状态，即填充颜色空间被设置为了一个模板颜色空间。如果稍后尝试设置填充颜色为常规颜色，就会引起错误。通常的解决方案是，使用<strong>CGContextSaveGState</strong>和<strong>CGContextRestoreGState</strong>函数将代码包起来。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　你可能观察到图8的平铺效果并不与箭头的三角形内部相符合：最底部的似乎只平铺了一半蓝色。这是因为一个模板的定位并不关心你填充（描边）的形状，总的来说它只关心图形上下文。我们可以调用<strong>CGContextSetPatternPhase</strong>函数改变模板的定位。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　<strong>图形上下文变换</strong></span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　就像UIView可以实现变换，同样图形上下文也具备这项功能。然而对图形上下文应用一个变换操作不会对已在图形上下文上的绘图产生什么影响，它只会影响到在上下文变换之后被绘制的图形，并改变被映射到图形上下文区域的坐标方式。一个图形上下文变换被称为CTM，意为&#8220;当前变换矩阵&#8220;（current transformation matrix）。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　完全利用图形上下文的CTM来免于即使是简单的计算操作是很常见的。你可以使用CGContextConcatCTM函数将当前变换乘上任何CGAffineTransform，还有一些便利函数可对当前变换应用平移、缩放，旋转变换。&nbsp;</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　当你获得上下文的时候，对图形上下文的基本变换已经设置好了；这就是系统能映射上下文绘图坐标到屏幕坐标的原因。无论你对当前变换应用了什么变换，基本变换变换依然有效并且绘图继续工作。通过将你的变换代码封装到CGContextSaveGState和CGContextRestoreGState函数调用中，对基本变换应用的变换操作可以被还原。&nbsp;</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　举个例子，对于我们迄今为止使用代码绘制的向上箭头来说，已知的放置箭头的方式仅仅只有一个位置：箭头矩形框的左上角被硬编码在坐标{80，0}。这样代码很难理解、灵活性差、且很难被重用。最明智的做法是通过将所有代码中的x坐标值减去80，让箭头矩形框左上角在坐标{0，0}。事先应用一个简单的平移变换，很容易将箭头画在任何位置。为了映射坐标到箭头的左上角，我们使用下面代码：</span></p>
<p class="MsoNormal" align="left" style="margin: 6pt 0cm; text-indent: 40pt; line-height: 15.75pt; background-color: #d9d9d9; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="font-size: 10pt; font-family: Consolas;">CGContextTranslateCTM</span><span style="font-size: 10pt; font-family: 宋体;">（</span><span lang="EN-US" style="font-size: 10pt; font-family: Consolas;">con, 80, 0</span><span style="font-size: 10pt; font-family: 宋体;">）</span><span lang="EN-US" style="font-size: 10pt; font-family: Consolas;">;&nbsp;</span><span style="text-indent: 0px; line-height: 15.75pt; font-size: 10pt; font-family: Consolas;">//</span><span style="text-indent: 0px; line-height: 15.75pt; font-size: 10pt; font-family: 宋体;">在坐标</span><span style="text-indent: 0px; line-height: 15.75pt; font-size: 10pt; font-family: Consolas;">{0,0}</span><span style="text-indent: 0px; line-height: 15.75pt; font-size: 10pt; font-family: 宋体;">处绘制箭头</span></p>
<p style="margin-top:3.75pt;margin-right:0cm;margin-bottom:3.75pt;margin-left: 0cm;line-height:15.75pt"><span style="font-size: 10.5pt; font-family: 'Comic Sans MS';">&nbsp; &nbsp; &nbsp; &nbsp;</span><span style="font-size: 10.5pt;">旋转变换特别的有用，它可以让你在一个被旋转的方向上进行绘制而无需使用任何复杂的三角函数。然而这略有点复杂，因为旋转变换围绕的点是原点坐标。这几乎不是你所想要的，所以你先是应用了一个平移变换，为的是映射原点到你真正想绕其旋转的点。但是接着，在旋转之后，为了算出你在哪里绘图，你可能需要做一次逆向平移变换。</span></p>
<p style="margin: 3.75pt 0cm; line-height: 15.75pt;"><span style="font-size: 10.5pt;">　　为了说明这个做法，我将绕箭头杆子尾部旋转多个角度重复绘制箭头，并把对箭头的绘图封装为</span><span style="font-size: 10.5pt; font-family: 'Comic Sans MS';">UIImage</span><span style="font-size: 10.5pt;">对象。接着我们简单重复绘制</span><span style="font-size: 10.5pt; font-family: 'Comic Sans MS';">UIImage</span><span style="font-size: 10.5pt;">对象。</span></p>
<p style="margin: 3.75pt 0cm; line-height: 15.75pt;"><span style="font-size: 10.5pt;">　　具体代码如下：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawRect:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">rect</span> <span class="p">{</span>
</span><span class="line">	<span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span> <span class="n">NO</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextRef</span> <span class="n">con</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line">	<span class="n">CGContextSaveGState</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">90</span> <span class="o">-</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">90</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">110</span> <span class="o">-</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">110</span> <span class="o">-</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">90</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">90</span> <span class="o">-</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextClosePath</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextAddRect</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGContextGetClipBoundingBox</span><span class="p">(</span><span class="n">con</span><span class="p">));</span>
</span><span class="line">	<span class="n">CGContextEOClip</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextSetLineWidth</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextReplacePathWithStrokedPath</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextClip</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGFloat</span> <span class="n">locs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">};</span>
</span><span class="line">	<span class="n">CGFloat</span> <span class="n">colors</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">			<span class="mf">0.3</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.8</span><span class="p">,</span>
</span><span class="line">			<span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span>
</span><span class="line">			<span class="mf">0.3</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.8</span>
</span><span class="line">		<span class="p">};</span>
</span><span class="line">	<span class="n">CGColorSpaceRef</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">CGColorSpaceCreateDeviceGray</span><span class="p">();</span>
</span><span class="line">	<span class="n">CGGradientRef</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">CGGradientCreateWithColorComponents</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">locs</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextDrawLinearGradient</span> <span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">89</span> <span class="o">-</span> <span class="mi">80</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">111</span> <span class="o">-</span> <span class="mi">80</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGColorSpaceRelease</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGGradientRelease</span><span class="p">(</span><span class="n">grad</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextRestoreGState</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGColorSpaceRef</span> <span class="n">sp2</span> <span class="o">=</span> <span class="n">CGColorSpaceCreatePattern</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextSetFillColorSpace</span> <span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">sp2</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGColorSpaceRelease</span> <span class="p">(</span><span class="n">sp2</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGPatternCallbacks</span> <span class="n">callback</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drawStripes</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
</span><span class="line">	<span class="n">CGAffineTransform</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">CGAffineTransformIdentity</span><span class="p">;</span>
</span><span class="line">	<span class="n">CGPatternRef</span> <span class="n">patt</span> <span class="o">=</span> <span class="n">CGPatternCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">tr</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="err">，</span><span class="n">kCGPatternTilingConstantSpacingMinimalDistortion</span><span class="p">,</span><span class="n">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGFloat</span> <span class="n">alph</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</span><span class="line">	<span class="n">CGContextSetFillPattern</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">patt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alph</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGPatternRelease</span><span class="p">(</span><span class="n">patt</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">80</span> <span class="o">-</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">120</span> <span class="o">-</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextFillPath</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span><span class="line">	<span class="n">UIImage</span><span class="o">*</span> <span class="n">im</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class="line">	<span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span><span class="line">	<span class="n">con</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line">	<span class="p">[</span><span class="n">im</span> <span class="nl">drawAtPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)];</span>
</span><span class="line">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">		<span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line">		<span class="n">CGContextRotateCTM</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">M_PI</span><span class="o">/</span><span class="mf">180.0</span><span class="p">);</span>
</span><span class="line">		<span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">);</span>
</span><span class="line">		<span class="p">[</span><span class="n">im</span> <span class="nl">drawAtPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)];</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p style="text-align: center;"><span style="font-family: 'comic sans ms', sans-serif;"><img style="border: 1px solid black;" src="http://images.cnitblog.com/blog/429321/201301/07163256-346e34bf3956474f9df5a94c73593174.png" alt="" /></span></p>
<p align="center"><span style="font-family: 'comic sans ms', sans-serif;">图10 使用CTM旋转变换</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　变换有多个方法解决我们早期使用CGContextDrawImage函数遇到的倒置问题。相对于逆向绘图，我们选择逆向我们绘图的上下文。实质上，我们对上下文坐标系统应用了一个&#8220;倒置&#8221;变换。你自上而下移动上下文，接着你通过应用一个让y坐标乘以-1的缩放变换逆向y坐标的方向。</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">theHeight</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextScaleCTM</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp;&nbsp; 上下文的顶部应该被你往下移动多远依赖于你绘制的图片。比如说我们可以绘制没有倒置问题的两个半边的火星图形（前面讨论的一个例子）。</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">);</span> <span class="c1">// sz为[mars size]</span>
</span><span class="line"><span class="n">CGContextScaleCTM</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="n">marsLeft</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="o">-</span><span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">sz</span><span class="p">.</span><span class="n">height</span><span class="p">),</span><span class="n">marsRight</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　阴影</strong></span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　为了在绘图上加入阴影，可在绘图之前设置上下文的阴影值。阴影的位置表示为CGSize，如果CGSize的两个值都是正数，则表示阴影是朝下和朝右的。模糊度被表示为任何一个正数。苹果没有解释缩放的工作方式，但实验表明12是最佳的模糊度，99及以上的模糊度会让阴影变得不成形。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;&nbsp;&nbsp; 我在图9的基础上给上下文加了一个阴影：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">con</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line"><span class="n">CGContextSetShadow</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="mi">12</span><span class="p">);</span>
</span><span class="line"><span class="p">[</span><span class="n">im</span> <span class="nl">drawAtPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　然而，使用这种方法有一个不太明显的问题。我们是在每绘制一个箭头的时候加上的阴影。因此，箭头的阴影会投射在另一个箭头上面。我们想要的是让所有的箭头集体地投射出一个阴影。解决方法是使用一个透明的图层；该图层类似一个先是叠加所有绘图然后加上阴影的一个子上下文。代码如下：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">con</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line"><span class="n">CGContextSetShadow</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="mi">12</span><span class="p">);</span>
</span><span class="line"><span class="n">CGContextBeginTransparencyLayer</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line"><span class="p">[</span><span class="n">im</span> <span class="nl">drawAtPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)];</span>
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextRotateCTM</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">M_PI</span><span class="o">/</span><span class="mf">180.0</span><span class="p">);</span>
</span><span class="line">	<span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">);</span>
</span><span class="line">	<span class="p">[</span><span class="n">im</span> <span class="nl">drawAtPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="c1">// 在调用了CGContextEndTransparencyLayer函数之后，</span>
</span><span class="line"><span class="c1">// 图层内容会在应用全局alpha和上下文阴影状态之后被合成到上下文中</span>
</span><span class="line"><span class="n">CGContextEndTransparencyLayer</span><span class="p">(</span><span class="n">con</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p style="text-align: center;"><span style="font-family: 'comic sans ms', sans-serif;">　<span style="text-align: center; line-height: 1.5;">&nbsp;</span><img style="border: 1px solid black;" src="http://images.cnitblog.com/blog/429321/201301/09171900-f4e5eee50a41417498caf7b95a9ae3da.png" alt="" /></span></p>
<p style="text-align: center;" align="left"><span style="font-family: 'comic sans ms', sans-serif;">图11 阴影效果</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　点与像素</strong></span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　一个点是由xy坐标描述的一个无穷小量的位置。通过指定点实现在图形上下文中的绘图。我们并没有关心设备的分辨率，因为Core Graphics已经精细地将绘图映射到物理输出设备（基于CTM、反锯齿和平滑技术）。因此，文章之前的讨论只关心图形上下文的点，不关注点与屏幕像素的关系。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　然而像素是真实存在的。一个像素是真实世界中一个具有完整物理尺寸的显示单元。整数的点实际上介于像素之间。在单分辨率设备上，这可能会让人感到迷惑。比方说，如果使用线宽为1的线条对一个整数坐标的垂直路径描边，那么线条将会被分为两半，分别落在路径的两侧。所以在单分辨率设备上线宽会变成2px（因为设备无法表示半个像素）。</span></p>
<p style="text-align: center;" align="left"><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;<img style="border: 1px solid black;" src="http://images.cnitblog.com/blog/429321/201301/10092953-804dd8b8a43f4dd1a5c5621e33aa5414.png" alt="" width="693" height="298" /></span></p>
<p style="text-align: center;" align="left"><span style="font-family: 'comic sans ms', sans-serif; line-height: 1.5;">图12 整数的点坐标与偏移0.5点的坐标对应的描边处理</span></p>
<p style="text-align: left;" align="center"><span style="font-family: 'comic sans ms', sans-serif; line-height: 1.5;">&nbsp; &nbsp; &nbsp; &nbsp;当你遇到显示效果不佳的时，可能会被建议通过对坐标增减0.5让它在像素中居中。这个建议可能有效，如图11。但它只是做了一些头脑简单的假设。一个复杂的做法是获得UIView的contentScaleFactor属性。这个值为1.0或2.0，所以你可以除以这个属性值得到从像素到点的转换。还可以想想用最精确的方式绘制一条水平或垂直的线条的方式不是描边路径，而是填充路径。使用这种方法UIView的子类代码将可以在任何设备上绘制一条完美的1px宽的垂线，代码如下：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGContextFillRect</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.0</span><span class="o">/</span><span class="n">self</span><span class="p">.</span><span class="n">contentScaleFactor</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;"><strong>　　内容模式</strong></span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　一个视图向它自身绘图，相对于只有背景颜色和子视图，它还有内容。这意味着每当视图被调整大小它的<strong>contentMode</strong>属性就变得非常重要。正如我之前提到的，绘图系统会尽可能避免重头开始绘制视图。相反，绘图系统将使用之前绘图操作的缓存结果（位图回填）。所以，如果视图被重新调整大小，系统可能简单的伸缩或重定位缓存绘图，前提是你的<strong>contentMode</strong>设置指令是是这样设置的。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　说明这一点略有点复杂。因为我需要安排调整视图大小而不引起重绘操作（调用<strong>drawRect：</strong>方法）。当程序启动时，我将创建一个MyView实例，并将它放在window上。接着将执行调整MyView尺寸的操作延迟到window出现和界面初次显示之后：</span></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">didFinishLaunchingWithOptions:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">launchOptions</span> <span class="p">{</span>
</span><span class="line">  <span class="n">self</span><span class="p">.</span><span class="n">window</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIWindow</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="p">[[</span><span class="n">UIScreen</span> <span class="n">mainScreen</span><span class="p">]</span> <span class="n">bounds</span><span class="p">]];</span>
</span><span class="line">  <span class="n">self</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">rootViewController</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIViewController</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line">  <span class="n">MyView</span><span class="o">*</span> <span class="n">mv</span> <span class="o">=</span><span class="p">[[</span><span class="n">MyView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">150</span><span class="p">)];</span>
</span><span class="line">  <span class="n">mv</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class="line">  <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">rootViewController</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview:</span> <span class="n">mv</span><span class="p">];</span>
</span><span class="line">  <span class="n">mv</span><span class="p">.</span><span class="n">opaque</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class="line">  <span class="n">mv</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="mi">111</span><span class="p">;</span> <span class="c1">// so I can get a reference to this view later</span>
</span><span class="line">  <span class="p">[</span><span class="n">self</span> <span class="nl">performSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">resize:</span><span class="p">)</span> <span class="nl">withObject:</span><span class="nb">nil</span> <span class="nl">afterDelay:</span><span class="mf">0.1</span><span class="p">];</span>
</span><span class="line">  <span class="n">self</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">whiteColor</span><span class="p">];</span>
</span><span class="line">  <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">window</span> <span class="n">makeKeyAndVisible</span><span class="p">];</span>
</span><span class="line">  <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　我们将视图的高度调成之前的2倍。没有触发drawRect：方法的调用。如果我们视图的drawRect：方法代码和生成图9的代码相同，则我们得到如图12的结果，视图被显示在正确高度上。</span></p>
<p style="text-align: center;" align="left"><span style="font-family: 'comic sans ms', sans-serif;">&nbsp;<img style="border: 1px solid black;" src="http://images.cnitblog.com/blog/429321/201301/09172048-10bd46b975944316bca85b7f3451b54d.png" alt="" /></span></p>
<p align="center"><span style="font-family: 'comic sans ms', sans-serif;">图13 内容自动伸展</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　可是早晚drawRect：方法会被调用，绘图将按照<strong>drawRect：</strong>方法中的代码被刷新。代码不会将箭头绘制在相对于视图边界的高度。它是在一个固定的高度。因此箭头会伸展，而且会在以后某个时间返回到原始的尺寸。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　通常我们的视图的<strong>contentMode</strong>属性需要与视图绘制自己的方式一致。假设我们的<strong>drawRect：</strong>方法中的代码让箭头的尺寸和位置相对于视图的边界原点，即它的左上方。所以我们可以设置它的<strong>contentMode</strong>为<strong>UIViewContentModeTopLeft</strong>。又或者，我们可以将<strong>contentMode</strong>设置为<strong>UIVIewContentModeRedraw，</strong>这将引起缓存内容的自动缩放和重定位被关闭，最终结果是视图的<strong>setNeedsDisplay</strong>方法将被调用，触发<strong>drawRect：</strong>方法重绘视图内容。</span></p>
<p align="left"><span style="font-family: 'comic sans ms', sans-serif;">　　在另一方面，如果一个视图只是暂时被调整大小。假设是作为动画的一部分，那么伸缩行为正是你所想要的。假设我们的动画是想要让视图变大然后还原回原始大小以达到作为吸引用户的一种手段。这就需要视图伸缩的时候视图的内容也跟着伸缩，正确的<strong>contentMode</strong>的值是<strong>UIViewContentModeScaleToFill</strong>，被伸缩的内容仅仅是视图内容的一副缓存图片，所以它运行起来十分的高效。</span>&nbsp;</p>
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
</strong></p></strong></p></span></p></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从UIKit到APPKit]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/08/04/cong-uikitdao-appkit/"/>
    <updated>2014-08-04T10:03:56+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/08/04/cong-uikitdao-appkit</id>
    <content type="html"><![CDATA[<p>Mac 不仅是一个强大的生产平台，也十分值得你<em>为其</em>开发一些东西。去年我们开始构建我们的第一款 <a href="http://decksetapp.com">Mac 应用</a>，成功为我们日常工作所在的平台开发点东西是一次十分美好的体验。但是，和为 iOS 系统开发应用相比，在我们了解 Mac 特性的过程中也遇到了一些困难。这篇文章总结了我们从这一过渡中得到的经验，希望能启发你们去开发自己的第一个 Mac 应用。</p>

<p>在这篇文章中，我们假定 OS X Yosemite 为我们默认使用的系统。今年，为了融合 iOS 和 OS X，苹果站在开发者的角度对 OS X 做出了巨大的改进。不过，我们会指出哪些特性仅适用于 Yosemite，而哪些特性也适用于之前的系统版本。</p>

<h2>相似点</h2>

<p>尽管 iOS 和 OS X 是两个独立的系统，它们却有很多共性。先就开发环境而言，它们使用同样的开发语言，同样的IDE。所以你会对这一切都感到非常熟悉。</p>

<p>更重要的是，OS X 和你已经熟悉的 iOS 共用许多框架，像 Foundation，Core Data 和 Core Animation。今年，Apple 进一步整合两个平台，并给 Mac 带来了一些之前仅能在 iOS 上面使用的框架，其中一个例子就是 Multipeer Connectivity。在更底层的地方，你立刻可以看到你熟悉的 API：Core Graphics，Core Text，libdispatch 等等。</p>

<p>真正开始有区别的是 UI 框架 — AppKit 早在 NeXT 时代就已面世并不断进化，而 UIKit 就像是简约版及现代版的 AppKit。出现这种情况的原因，是当 Apple 推出 iPhone 时可以从头开始，并吸取 AppKit 的经验：把已证实过可行的概念和部件拿过来用，并改进不够精良的设计。</p>

<p>如果你对这个转换是怎么发生的感兴趣，请观看前 Apple iOS 应用总监 <a href="https://twitter.com/nitinganatra">Nitin Ganatra</a> 播客上的精彩剧集：<a href="http://www.imore.com/debug-39-nitin-ganatra-episode-i-system-7-carbon">System 7 to Carbon</a>，<a href="http://www.imore.com/debug-40-nitin-ganatra-episode-ii-os-x-ios">OS X to iOS</a>，以及 <a href="http://www.imore.com/debug-41-nitin-ganatra-episode-iii-iphone-ipad">iPhone to iPad</a>。</p>

<p>考虑到这一点，也就不奇怪为什么 UIKit 和 AppKit 仍旧共享许多概念了。UI 是基于 window 和 view 构建起来的，消息像 iOS 一样通过响应者链传递。此外，<code>UIView</code> 是 <code>NSView</code>，<code>UIControl</code> 是 <code>NSControl</code>，<code>UIImage</code> 是 <code>NSImage</code>，<code>UIViewController</code> 是 <code>NSViewController</code>，<code>UITextView</code> 是 <code>NSTextView</code>&#8230;这样的例子不胜枚举。</p>

<p>看起来就像你仅需把 <code>UI</code> 前缀替换为 <code>NS</code> 前缀，你就可以用同样的方法使用这些类。但事实是在很多情况下这并不奏效。它们在实现上并没有在概念上那么相似。你在 iOS 上的经验至多能帮你大致了解构建用户界面的基础，以及使用很多设计模式，比如代理，都是类似的。但是细节是魔鬼 — 你真的应该通过阅读文档来学习如果使用这些类。</p>

<p>下一节，我们来看看那些常见的陷阱。</p>

<h2>不同点</h2>

<h3 id="windowwindowcontroller">Window 和 Window Controller</h3>
<!-- more -->
<p>虽然在 iOS 上你几乎从来不用与 window 交互（因为它们占据了整个屏幕），window 在 Mac 上却是一个关键组件。从历史上看， Mac 应用包含多个 window，每个 window 有其自己的角色，非常类似于 iOS 上面的 view controller。因此, AppKit 有 <code>NSWindowController</code>，它接管很多在 iOS 上你会在 view controller 里面处理的任务。view controller 被添加到 AppKit 的时间并不长，而且直到现在，它们默认不接受 action，并且缺失很多生命周期的方法、view controller 容器，以及很多你在 UIKit 中熟悉的特性。</p>

<p>但 AppKit 框架已经改变，因为 Mac 应用越来越依赖于一个单一的 window。就 OS X 10.10 Yosemite 而言，<code>NSViewController</code> 在许多方面与 <code>UIViewController</code> 类似。它也默认是响应者链中的一环。但要记住，如果你的 Mac 应用需要兼容 OS X 10.9 或更早版本的系统，Mac 上的 window controller 更类似于 iOS 上你熟悉的 view controller。正如 <a href="https://www.mikeash.com/pyblog/friday-qa-2013-04-05-windows-and-window-controllers.html">Mike Ash 所言</a>，在 Mac 上实例化窗口的一个好的模式是：每个窗口类型对应一个 nib 文件和一个 window controller。</p>

<p>此外，<code>NSWindow</code> 并不像 <code>UIWindow</code> 一样是一个 view 的子类。相反，每个 window 用 <code>contentView</code> 属性持有一个指向其顶层 view 的引用。</p>

<h3>响应者链</h3>

<p>如果你在为 OS X 10.9 或者更低版本的系统开发，请注意在默认情况下 view controller 并不是响应者链的一环。相反，事件会沿着视图树向上传递然后直接到达 window 和 window controller。在这种情况下，如果你想在 view controller 处理事件，你需要<a href="http://www.cocoawithlove.com/2008/07/better-integration-for-nsviewcontroller.html">手动</a>把它添加到响应者链中。</p>

<p>除了在响应者链方面的不同，AppKit 在 action 的命名方法上还有一个严格的惯例，一个 action 方法看起来总是类似这样子的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performAction:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>以上方法在 iOS 上面所允许的没有参数，或者有一个 sender 和一个 event 参数，而这些变体在 OS X 上面是无法使用的。此外，控件（译者注：指 NSControl 及其子类）在 AppKit 中通常对应一个 target 和一个 action，而不像在 iOS 上可以通过 <code>addTarget:action:forControlEvents:</code> 方法为一个控件关联多个 target-action 对。</p>

<h3 id="view">View</h3>

<p>因为历史遗留问题，Mac 的视图系统和 iOS 的视图系统有很大区别。iOS 上的 view 一开始就由 Core Animation layer 驱动。但是 AppKit 比 Core Animation 早出来了很久，当 Apple 设计 AppKit 时，我们现在熟知的 GPU 还没有出现。因此，那时视图系统相关的任务主要靠 CPU 处理。</p>

<p>当你要开始进行 Mac 相关的开发时，我们强烈推荐你查看 Apple 的 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaViewsGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40002978">Introduction to View Programming Guide for Cocoa</a>。此外，你还应该看一下这两个精彩的 WWDC session：<a href="https://developer.apple.com/videos/wwdc/2012/#217">Layer-Backed Views: AppKit + Core Animation</a> 和 <a href="https://developer.apple.com/videos/wwdc/2013/#215">Optimizing Drawing and Scrolling</a>。</p>

<h4 id="layerbackedview">Layer-Backed View</h4>

<p>默认情况下，AppKit 的 view 不是由 Core Animation layer 驱动的；AppKit 整合 layer-backing 是 iOS 反哺的结果。一些在 AppKit 需要做的决定你在 UIKit 从来不需要关心。AppKit 区分 layer-backed view 和 layer-hosting view，可以在每个视图树的根节点启用或者禁用 layer backing。</p>

<p>把窗口的 contentView 的 <code>wantsLayer</code> 属性设置为 <code>YES</code> 是启用 layer backing 最简单的方法。这会导致 window 的视图树中所有的 view 都启用 layer backing，这样就没必要反复设置每个 view 的 wantsLayer 属性了。这个操作可以用代码或者在 Interface Builder 的 View Effects Inspector 面板完成。</p>

<p>和 iOS 相比而言，在 Mac 上你应该把 backing layer 看做是一个实现细节。这意味着你不应该和这些 layer 直接交互，因为 AppKit 才是这些 layer 的拥有者。举个例子，在 iOS 上你可以随意编写这样的代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">self</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>objc</p>

<p>但是在 AppKit，你不应该直接修改这些 layer。如果想用这种方式和 layer 交互，你还有一步工作要做。重写 <code>NSView</code> 的 <code>wantsUpdateLayer</code> 方法并返回 <code>YES</code>，这能让你可以改变 layer 的属性。如果你这样做，AppKit 将不会再调用 view 的 <code>drawRect:</code> 方法。取而代之，你应该在 <code>updateLayer</code> 里修改 Layer，这个方法会在 view 的更新周期中被调用。</p>

<p>举个例子，你可以用这方法去实现一个非常简单的有纯色背景的 view（没错，<code>NSView</code> 没有 <code>backgroundColor</code> 属性）：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">ColoredView</span>: <span class="nc">NSView</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSColor</span> <span class="o">*</span><span class="n">backgroundColor</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">ColoredView</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">wantsUpdateLayer</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">updateLayer</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">backgroundColor</span><span class="p">.</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setBackgroundColor:</span><span class="p">(</span><span class="n">NSColor</span> <span class="o">*</span><span class="p">)</span><span class="nv">backgroundColor</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">_backgroundColor</span> <span class="o">=</span> <span class="n">backgroundColor</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">setNeedsDisplay:</span><span class="n">YES</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这个例子的前提是这个 view 的父 view 已经为其视图树启用了 layer backing。另一种可行的实现则只需要重写 <code>drawRect:</code> 方法并在其中绘制背景颜色。</p>

<h5 id="layer">合并 Layer</h5>

<p>选择使用众多 layer-backed view 会带来巨大的内存消耗（每一个 layer 有其自己的 backing store，还有可能和其他 view 的 backing store 重叠）而且会带来潜在的合成这些 layer 的消耗。从 OS X 10.9 开始，你可以通过设置 <code>canDrawSubviewsIntoLayer</code> 属性来让 AppKit 合并一个视图树中所有 layer 的内容到一个共有的 layer。如果你不需要单独对一个 view 中的子 view 做动画，这将是一个很好的选择。</p>

<p>所有隐式 layer-backed 的子 view（比如，你没有显式地对这些子 view 设置 <code>wantsLayer = YES</code>）现在将会被绘制到同一个 layer 中。不过，<code>wantsLayer</code> 设置为 <code>YES</code> 的子 view 仍然持有它们自己的 backing layer， 而且不管 <code>wantsUpdateLayer</code> 返回什么，它们的 <code>drawRect:</code> 方法仍然会被调用。</p>

<h5 id="layer">Layer 重绘策略</h5>

<p>另外一个需要注意的地方：layer-backed view 会默认设置重绘策略为 <code>NSViewLayerContentsRedrawDuringViewResize</code>。在行为上，这个非 layer-backed view 是类似的，不过如果动画的每一帧都引入一个绘制步骤的话可能会对动画的性能造成不利影响。</p>

<p>为了避免这个问题，你可以把 <code>layerContentsRedrawPolicy</code> 属性设置为 <code>NSViewLayerContentsRedrawOnSetNeedsDisplay</code> 。这样子的话，便由你来决定 layer 的内容何时需要重绘。帧的改变将不再自动触发重绘；现在你要负责调用 <code>-setNeedsDisplay:</code> 来触发重绘操作。</p>

<p>一旦你这样更改了重绘策略，你也许会想了解下 view 中和 layer 的 <code>contentGravity</code> 属性等价的 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/layerContentsPlacement"><code>layerContentsPlacement</code></a> 属性。这个属性允许你指定在调整大小的时候当前的 layer 内容该怎么映射到 layer 上。</p>

<h4 id="layerhostingview">Layer-Hosting View</h4>

<p><code>NSView</code> 的 layer 故事并没有完结。你可以用另一种完全不一样的方式来使用 Core Animation layer — 称为 layer-hosting view。简单来说，你可以对一个 layer-hosting view 的 layer 及其子 layer 做任何操作，代价是你再也不能给该 view 添加任何子 view。layer-hosting view 是视图树中的叶子节点。</p>

<p>要创建一个 layer-hosting view，你首先要为 view 的 <code>layer</code> 属性分配一个 layer 对象，然后把 <code>wantsLayer</code> 设置为 <code>YES</code>。注意，这些步骤的顺序是非常关键的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithFrame:</span><span class="p">(</span><span class="n">NSRect</span><span class="p">)</span><span class="nv">frame</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nl">initWithFrame:</span><span class="n">frame</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">layer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CALayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">wantsLayer</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在你设置了你自定义的 layer <em>之后</em>才设置 <code>wantsLayer</code> 是非常重要的。</p>

<h4 id="view">其他与 View 相关的陷阱</h4>

<p>默认情况下，Mac 上视图的坐标系统原点位于左下角，而不是像 iOS 的左上角。刚开始这可能会让人混乱，不过你可以通过重写 <code>isFlipped</code> 并返回 <code>YES</code> 来恢复到你熟悉的左上角。</p>

<p>由于 AppKit 中的 view 没有背景颜色属性可以让你直接设置为 <code>[NSColor clearColor]</code> 来让其变得透明，许多 <code>NSView</code> 的子类比如 <code>NSTextView</code> 和 <code>NSScrollView</code> 开放了一个 <code>drawsBackground</code> 属性，如果你想让这一类 view 透明，你必须设置该属性为 <code>NO</code>。</p>

<p>为了能接收光标进出一个 view 或者在 view 里面移动的事件，你需要创建一个追踪区域。你可以在 <code>NSView</code> 中指定的 <code>updateTrackingAreas</code> 方法中来做这件事情。一个通用的写法看起来是这样子的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">updateTrackingAreas</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">removeTrackingArea:</span><span class="n">self</span><span class="p">.</span><span class="n">trackingArea</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">trackingArea</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSTrackingArea</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithRect:</span><span class="n">CGRectZero</span>
</span><span class="line">                                                     <span class="nl">options:</span><span class="n">NSTrackingMouseEnteredAndExited</span><span class="o">|</span><span class="n">NSTrackingInVisibleRect</span><span class="o">|</span><span class="n">NSTrackingActiveInActiveApp</span>
</span><span class="line">                                                       <span class="nl">owner:</span><span class="n">self</span>
</span><span class="line">                                                    <span class="nl">userInfo:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">addTrackingArea:</span><span class="n">self</span><span class="p">.</span><span class="n">trackingArea</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>AppKit 的控件之前是由 <code>NSCell</code> 的子类驱动的。不要混淆这些 cell 和 UIKit 里 table view 的 cell 及 collection view 的 cell。AppKit 最初区分 view 和 cell 是为了节省资源 - view 可以把所有的绘制工作代理给更轻量级的可以被所有同类型的 view 重用的 cell 对象。</p>

<p>Apple 正在一步步地抛弃这样的实现方法了，但是你还是会时不时碰到这样的问题。举个例子，如果你想创建一个自定义的按钮，你首先要继承 <code>NSButton</code> <em>和</em> <code>NSButtonCell</code>，然后在这个 cell 子类里面进行你自定义的绘制，然后通过重写 <code>+[NSControl cellClass]</code> 方法告诉自定义按钮使用你的 cell 子类。</p>

<p>最后，如果你想知道在你自己的 <code>drawRect:</code> 方法里怎么获取当前的 Core Graphics 上下文，答案是 <code>NSGraphicsContext</code> 的 <code>graphicsPort</code> 属性。详细内容请查看 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaDrawingGuide/">Cocoa Drawing Guide</a>。</p>

<h3>动画</h3>

<p>归结于上面提到的视图系统的差异，动画在 Mac 上的运作方式也十分不同。想要一个好的概述，请观看 WWDC session：<a href="https://developer.apple.com/videos/wwdc/2013/#213">Best Practices for Cocoa Animation</a></p>

<p>如果你的 view 不是由 layer 驱动的，那你的动画自然是完全由 CPU 处理，这意味着动画的每一步都必须相应地绘制到 window-backing store 上。因为现今我们主要是对 layer-backed view 做动画以获得流畅的动画效果，所以我们在这儿就专注于这种情况。</p>

<p>正如上面说的，在 AppKit 中你不应该修改 layer-backed view 中的 layer (看 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/CreatingBasicAnimations/CreatingBasicAnimations.html#//apple_ref/doc/uid/TP40004514-CH3-SW18">Core Animation Programming Guide</a> 这篇文档底部 “Rules for Modifying Layers in OS X” 那一节）。这些 layer 由 AppKit 管理，而且和 iOS 相反，view 的几何属性并不仅仅是对应的 layer 的几何属性的映射，但 AppKit 却会把 view 内部的几何属性同步到 layer。</p>

<p>你可以用几种不同的方法对一个 view 进行动画。第一种，你可以使用 <a href="file:///Users/florian/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.AppleOSX10.9.CoreReference.docset/Contents/Resources/Documents/documentation/Cocoa/Reference/NSAnimatablePropertyContainer_protocol/Introduction/Introduction.html#//apple_ref/occ/intfm/NSAnimatablePropertyContainer/animator">animator proxy</a>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">view</span><span class="p">.</span><span class="n">animator</span><span class="p">.</span><span class="n">alphaValue</span> <span class="o">=</span> <span class="mf">.5</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在幕后，这句代码会启用 layer 的隐式动画，设置其透明度，然后再次禁用 layer 的隐式动画。</p>

<p>你还可以把这句代码封装到一个 <a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/NSAnimationContext_class/Introduction/Introduction.html">animation context</a> 中，这样你就能得到它的结束回调：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">NSAnimationContext</span> <span class="nl">runAnimationGroup:</span><span class="o">^</span><span class="p">(</span><span class="n">NSAnimationContext</span> <span class="o">*</span><span class="n">context</span><span class="p">){</span>
</span><span class="line">    <span class="n">view</span><span class="p">.</span><span class="n">animator</span><span class="p">.</span><span class="n">alphaValue</span> <span class="o">=</span> <span class="mf">.5</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span> <span class="nl">completionHandler:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">    <span class="c1">// ...</span>
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果想改变持续时间和缓动类型，我们必须对其动画上下文进行设置：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">NSAnimationContext</span> <span class="nl">runAnimationGroup:</span><span class="o">^</span><span class="p">(</span><span class="n">NSAnimationContext</span> <span class="o">*</span><span class="n">context</span><span class="p">){</span>
</span><span class="line">    <span class="n">context</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="n">context</span><span class="p">.</span><span class="n">timingFunction</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nl">functionWithName:</span><span class="n">kCAMediaTimingFunctionEaseIn</span><span class="p">];</span>
</span><span class="line">    <span class="n">view</span><span class="p">.</span><span class="n">animator</span><span class="p">.</span><span class="n">alphaValue</span> <span class="o">=</span> <span class="mf">.5</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span> <span class="nl">completionHandler:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">    <span class="c1">// ...</span>
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果你不需要结束回调，你可以用这种简化形式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">NSAnimationContext</span> <span class="n">currentContext</span><span class="p">].</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="n">view</span><span class="p">.</span><span class="n">animator</span><span class="p">.</span><span class="n">alphaValue</span> <span class="o">=</span> <span class="mf">.5</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后，你可以启用隐式动画，这样你就不必每次都明确地使用 animator proxy 了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">NSAnimationContext</span> <span class="n">currentContext</span><span class="p">].</span><span class="n">allowsImplicitAnimations</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line"><span class="n">view</span><span class="p">.</span><span class="n">alphaValue</span> <span class="o">=</span> <span class="mf">.5</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>要更全面地控制动画，你可以使用 <code>CAAnimation</code> 实例。和 iOS 相反，你不能直接把它们加到 layer 上（因为 layer 不应该由你来修改），不过你可以使用 <a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/NSAnimatablePropertyContainer_protocol/Introduction/Introduction.html"><code>NSAnimatablePropertyContainer</code></a> 协议中定义的 API，<code>NSView</code> 和 <code>NSWindow</code> 已经实现了该协议。举个例子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CAKeyframeAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAKeyframeAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">values</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="err">@</span><span class="mi">1</span><span class="p">,</span> <span class="err">@</span><span class="mf">.9</span><span class="p">,</span> <span class="err">@</span><span class="mf">.8</span><span class="p">,</span> <span class="err">@</span><span class="mf">.7</span><span class="p">,</span> <span class="err">@</span><span class="mf">.6</span><span class="p">];</span>
</span><span class="line"><span class="n">view</span><span class="p">.</span><span class="n">animations</span> <span class="o">=</span> <span class="err">@</span><span class="p">{</span><span class="s">@&quot;alphaValue&quot;</span><span class="o">:</span> <span class="n">animation</span><span class="p">};</span>
</span><span class="line"><span class="n">view</span><span class="p">.</span><span class="n">animator</span><span class="p">.</span><span class="n">alphaValue</span> <span class="o">=</span> <span class="mf">.5</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于<code>帧</code>动画来说，把 view 的 <code>layerContentsRedrawPolicy</code> 设置为 <code>NSViewLayerContentsRedrawOnSetNeedsDisplay</code> 是非常重要的，不然的话 view 的内容在每一帧都会被重绘。</p>

<p>很遗憾，<code>NSView</code> 没有开放 Core Animation layer 所有可以进行动画的属性，<code>transform</code> 是其中最重要的例子。看看 <a href="https://twitter.com/willing">Jonathan Willings</a> 的<a href="http://jwilling.com/osx-animations">这篇文章</a>，它描述了你可以如何解决这些限制。不过注意，文章中的解决方案是不受官方支持的。</p>

<p>上面提到的所有东西都适用于 <em>layer-backed</em> view。对于 <em>layer-hosting</em> view 来说，你可以直接对 view 的 layer 或者子 layer 使用 <code>CAAnimations</code>，因为你拥有它们的控制权。</p>

<h3 id="collectionview">Collection View</h3>

<p>尽管 AppKit 有 <code>NSCollectionView</code> 类，它的功能却比 UIKit 里对应的类滞后很多。鉴于 <code>UICollectionView</code> 是 iOS 上一个如此多功能的控件（当然，这取决于你的 UI 观念），AppKit 里对应的控件一点都不像它这件事相当难以忍受。所以当你要规划你的用户界面的时候，要考虑构建一个网格布局有可能会非常麻烦，相反，在 iOS 上这很容易实现。</p>

<h3>图像</h3>

<p>来自 iOS 的你对 <code>UIImage</code> 肯定非常熟悉，正巧，AppKit 也有一个对应的 <code>NSImage</code> 类。不过很快你就会意识到这两个类简直是天差地别。从很多方面来说，<code>NSImage</code> 都比 <code>UIImage</code> 强大很多，但这是建立在复杂性增加的代价上的。Apple 的 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Images/Images.html#//apple_ref/doc/uid/TP40003290-CH208-BCIBBFGJ">Cocoa Drawing Guide</a> 很好地介绍了如何使用 AppKit 中的图像。</p>

<p>概念上最重要的不同是 <code>NSImage</code> 由一个或者多个图像表示（image representation，译者注：这里的图像表示为名词，可以参考<a href="http://baike.baidu.com/view/4301255.htm">百度百科</a>，本节下同）驱动，这些图像表示在 AppKit 表现为一些 <code>NSImageRep</code> 的子类，像 <code>NSBitmapImageRep</code>，<code>NSPDFImageRep</code> 和 <code>NSEPSImageRep</code>。举个例子，一个 <code>NSImage</code> 对象为了打印同样的内容可以持有缩略图，全尺寸和 PDF 三个图像表示。当你绘制图像时，图像表示会匹配当前的图形上下文，而绘图尺寸会根据颜色空间，维度，分辨率以及绘图深度得出。</p>

<p>此外，Mac 上的图像除了尺寸还有分辨率的概念。图像表示的分辨率由三个属性构成：<code>size</code>，<code>pixelsWide</code> 以及 <code>pixelsHigh</code>。size 属性决定了图像表示被渲染时的尺寸，而 pixelsWide 和 pixelsHigh 指定了源于图像数据的原始尺寸。这三个属性共同决定了图像表示的分辨率。像素尺寸可以和<strong>图像表示</strong>的尺寸不一样，正如<strong>图像表示</strong>的尺寸可以和它所属的图片的尺寸不一样。</p>

<p>另外一个和 <code>UIImage</code> 不一样的地方是当它被绘制到屏幕上时 <code>NSImage</code> 会缓存绘制结果（可以通过 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/instm/NSImage/cacheMode"><code>cacheMode</code></a> 属性配置）。当你改变底层的图像表示，你必须对图像调用 <code>recache</code> 才能使其生效。</p>

<p>不过在 Mac 上面处理图像并不总是比 iOS 复杂。<code>NSImage</code> 提供了一个很简单的方法去绘制一个新图像，而在 iOS 上，你需要创建一个位图上下文，然后用位图上下文创建 <code>CGImage</code>，最终用该 CGImage 初始化一个 <code>UIImage</code> 实例。用 <code>NSImage</code> 你仅需：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">NSImage</span> <span class="nl">imageWithSize:</span><span class="p">(</span><span class="n">NSSize</span><span class="p">)</span><span class="n">size</span>
</span><span class="line">            <span class="nl">flipped:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">drawingHandlerShouldBeCalledWithFlippedContext</span>
</span><span class="line">     <span class="nl">drawingHandler:</span><span class="o">^</span><span class="kt">BOOL</span> <span class="p">(</span><span class="n">NSRect</span> <span class="n">dstRect</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">// your drawing commands here...</span>
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3>颜色</h3>

<p>Mac 支持完全的 color-calibrated 工作流，所有跟颜色相关的任何东西都有可能变得更复杂。颜色管理是一个复杂的主题，我们也不精通这方面的东西。所以，我们希望你看看 Apple 关于这方面的指南： <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/DrawColor/DrawColor.html#//apple_ref/doc/uid/10000082-SW1">Introduction to Color Programming Topics for Cocoa</a> 和 <a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/csintro/csintro_intro/csintro_intro.html#//apple_ref/doc/uid/TP30001148">Introduction to Color Management</a>。</p>

<p>你经常需要在你的应用里使用一个你的设计师给你指定的颜色。要取得正确的颜色，设计模板使用的颜色空间和你以编程方式指定的颜色空间保持一致是非常重要的。系统标准的颜色选择器有一个下拉菜单，你可以在这里选择你想要的颜色空间。我们建议使用 device-independent sRGB 颜色空间，然后在代码里面用 <code>+[NSColor colorWithSRGBRed:green:blue:alpha:]</code> 类方法来创建颜色。</p>

<p><img src="http://img.objccn.io/issue-14/color-picker.png" alt="" /></p>

<h3>文字系统</h3>

<p>有了 <a href="http://objccn.io/issue-5-1/">TextKit</a>，iOS 7 终于有了和 Mac 上早就有了的 <a href="https://developer.apple.com/library/mac/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TextSystemArchitecture/ArchitectureOverview.html">Cocoa Text System</a> 等效的东西。但 Apple 并不仅仅是把文字系统从 Mac 上转移到 iOS；相反，Apple 对其做了些显著的改变。</p>

<p>举个例子，AppKit 开放 <code>NSTypesetter</code> 和 <code>NSGlyphGenerator</code>，你可以通过继承这两者来自定义它们的一些特性。iOS 并不开放这些类，但是你可以通过 <code>NSLayoutManagerDelegate</code> 协议达到定制的目的。</p>

<p>总体来说，两个平台的文字系统还是非常相似的，所有你在 iOS 上能做的在 Mac 上都可以做（甚至更多），但对于一些东西，你必须从不同的地方寻找合适的方法实现。</p>

<h3>沙盒</h3>

<p>符合沙盒机制的 Mac 应用才能通过 Mac App Store 销售。鉴于沙盒从一开始就是 iOS 的基本规范（所以你会对它非常熟悉），你可能会好奇我们为什么要在这里提起它。然而，我们已经习惯了沙盒机制还没出现之前的 Mac 开发环境，所以有时候会忽视一些你想要实现的功能会和沙盒的限制出现冲突。</p>

<p>Mac 的文件系统是一直对用户开放的，所以如果用户明确表示，沙盒应用可以访问自身应用外的文件。同样的机制同时引进了 iOS 8。不过，和通过这种方式放宽对 iOS 的限制相反，它却加强了对 Mac 的限制。这让它容易被忽视和遗忘。</p>

<p>对此我们也十分惭愧，所以希望能阻止你犯同样的错误。当我们开始开发 <a href="http://decksetapp.com">Deckset</a> — 一款把简单 Markdown 文件转换为演示幻灯片的应用 — 时，我们从来没想过我们会碰到什么关于沙盒的问题。毕竟，我们只需要读 Markdown 文件的权限。</p>

<p>我们忘记了我们还要显示 Markdown 文件中引用的图片。尽管你在 Markdown 文件中输入了图片文件的路径，但沙盒系统并不认为这是用户的意图。最后，我们通过一个像通知中心一样的 UI 来提示用户授权我们访问 Markdown 文件中的所有图片‘解决’了该问题。</p>

<p>及早看一下 Apple 的 <a href="https://developer.apple.com/app-sandboxing/">sandboxing guides</a> 以防以后在相关的问题上犯错误。</p>

<h2>独有特性</h2>

<p>有很多事情你只能在 Mac 上做，这主要是因为它不同的交互模型和它更为宽松的安全策略。在本期话题中，我们有一些文章深入探讨了其中的一些内容：<a href="http://objccn.io/issue-14-4/">进程间通讯</a>，<a href="http://objccn.io/issue-14-1/">使 Mac 应用脚本化</a>, <a href="http://objccn.io/issue-14-2/">在沙盒中脚本化其他应用</a>, <a href="http://objccn.io/issue-14-3/">为你的应用构建插件</a>。</p>

<p>当然，这只是 Mac 独有特性中很小的一部分，但这给了你一个很好的视角看待 iOS 8 从头开始打造其可扩展性和 app 间通讯。最后，还有很多东西等待你去探索：Drag and Drop，Printing，Bindings，OpenCL 等等，这里仅仅是举几个例子。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[苹果的插件]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/07/23/iosde-cha-jian/"/>
    <updated>2014-07-23T15:38:46+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/07/23/iosde-cha-jian</id>
    <content type="html"><![CDATA[<div class="entry-content">
<p>插件是给你已经发布的 App 增加功能的一个好办法，Mac 上的 App 支持插件已经有很长的历史了，比如 Adobe Photoshop，在 1991 年的 version 2.0 就开始支持了。</p>

<p>在以前的 OS X 系统中，给你的 App 在运行时动态载入可执行代码比较困难。现在，在 <code>NSBundle</code> 的帮助和你的一些前瞻性思维的帮助下下，它从未如此简单。 </p>

<h2 id="bundlesinterfaces">包 (Bundles) 和接口 (Interfaces)</h2>

<p>如果你打开 Xcode 5 并且创建一个新项目，你会看见 OS X 选项卡下有一个 &#8220;Application Plug-in&#8221; 的分类和 &#8220;System Plug-in&#8221; 的分类，从 Screen Savers 到 Image Units，在 Xcode 里面一共有 12 中不同的模板可以编写 App 的插件。如果你点击 &#8220;Framework &amp; Library&#8221; 的选项卡，你将可以看见一个 Bundle 条目。我会在今天探索一个非常简单的的项目，那就是在一个修改过的 TextEdit 里面加入加载 bundle 的功能。</p>

<blockquote>
  <p>注意：Apple 称这些为 plug-ins ，而通常大家更喜欢用 plugins 称呼。为了一致性，在开发和 UI 相关的东西的时候，我想用和平台一致的 plug-in 称呼会更好。虽然在应用的 UI 里你会看到 &#8220;plug-ins&#8221;，但是在这篇文章和代码里面，我会用 plugin。（同时我偶尔会混用 bundle 和 plugin 这两个词。）(译者注：在本译文中会把 plugin 统一翻译成插件，伟大的中文)</p>
</blockquote>

<p>什么是 bundle ？如果你创建一个 Xcode 的 bundle 模版项目，你会发现它内容并不多。当构建它的时候你会得到一个很像构建 App 时产生的目录 —— 一个 Contents 目录，里面包含了 Info.plist 和 Resource 目录。如果你在你的项目下加入了新的类，你可以看见包含一个可执行文件的 MacOS 目录。Bundle 工程里缺少的一个东西是 main() 函数。它是被宿主 App 调用执行的。</p>
<!-- more -->
<h2 id="texteditplugin">为 TextEdit 加入 Plugin 支持</h2>

<p>我会介绍两种插件的方式，第一个用最少的工作来为你的 app 加入插件支持，希望让你知道实现这个有多简单。</p>

<p>第二个技术有点复杂，它展现来一个为你的 app 加入插件的合理的方式，这可以使你不会在未来陷入到被锁死在某一种实现的窘境中。</p>

<p>本文章的项目文件仍然会放在 <a href="https://github.com/objcio/issue-14-plugins">GitHub</a> 供大家参考。</p>

<h3 id="texteditbundle">在 TextEdit 中扫描 Bundle</h3>

<p>请打开 &#8220;01 TextEdit&#8221; 目录下面的 TextEdit.xcodeproj 工程，同时浏览它里面包含的代码。</p>

<p>这个改写过的 TextEdit 里面有三个简单的组成部分：扫描 bundle，加载 bundle，并且添加了调用 bundle 的 UI。</p>

<p>打开 Controller.m，你可以看见 <code>-(void)loadPlugins</code> 方法 (它在 <code>applicationDidFinishLaunching:</code> 中被调用)。</p>

<p><code>loadPlugins</code> 方法在你的界面菜单右侧加入了一个新的 <code>NSMenuItem</code>，来为你调用你的插件提供一个入口（通常你会在 MainMenu.xib 做这件事情并且链接 outlets，但是我们这次偷下懒）。然后获得你的插件目录（在 ~/Library/Application Support/Text Edit/Plug-Ins/ ）下，并且扫描这个目录。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="n">NSString</span> <span class="o">*</span><span class="n">pluginsFolder</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">pluginsFolder</span><span class="p">];</span>
</span><span class="line"> <span class="n">NSFileManager</span> <span class="o">*</span><span class="n">fm</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSFileManager</span> <span class="n">defaultManager</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"> <span class="n">NSError</span> <span class="o">*</span><span class="n">outErr</span><span class="p">;</span>
</span><span class="line"> <span class="k">for</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">item</span> <span class="k">in</span> <span class="p">[</span><span class="n">fm</span> <span class="nl">contentsOfDirectoryAtPath:</span><span class="n">pluginsFolder</span> <span class="nl">error:</span><span class="o">&amp;</span><span class="n">outErr</span><span class="p">])</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">item</span> <span class="nl">hasSuffix:</span><span class="s">@&quot;.bundle&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class="line">         <span class="k">continue</span><span class="p">;</span>
</span><span class="line">     <span class="p">}</span>
</span><span class="line">
</span><span class="line">     <span class="n">NSString</span> <span class="o">*</span><span class="n">bundlePath</span> <span class="o">=</span> <span class="p">[</span><span class="n">pluginsFolder</span> <span class="nl">stringByAppendingPathComponent:</span><span class="n">item</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">     <span class="n">NSBundle</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSBundle</span> <span class="nl">bundleWithPath:</span><span class="n">bundlePath</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">         <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Could not make a bundle from %@&quot;</span><span class="p">,</span> <span class="n">bundlePath</span><span class="p">);</span>
</span><span class="line">         <span class="k">continue</span><span class="p">;</span>
</span><span class="line">     <span class="p">}</span>
</span><span class="line">
</span><span class="line">     <span class="kt">id</span> <span class="o">&lt;</span><span class="n">TextEditPlugin</span><span class="o">&gt;</span> <span class="n">plugin</span> <span class="o">=</span> <span class="p">[[</span><span class="n">b</span> <span class="n">principalClass</span><span class="p">]</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">     <span class="n">NSMenuItem</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="p">[</span><span class="n">pluginsMenu</span> <span class="nl">addItemWithTitle:</span><span class="p">[</span><span class="n">plugin</span> <span class="n">menuItemTitle</span><span class="p">]</span> <span class="nl">action:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">pluginMenuItemCalledAction:</span><span class="p">)</span> <span class="nl">keyEquivalent:</span><span class="s">@&quot;&quot;</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">     <span class="p">[</span><span class="n">item</span> <span class="nl">setRepresentedObject:</span><span class="n">plugin</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>到目前，看起来是非常简单的。扫描插件目录，确保得到的是一个 .bundle 文件（你当然不希望载入 .DS_Store 文件），然后用 <code>NSBundle</code> 载入你找到的 bundle 并且实例化里面的类。</p>

<p>你会注意到一个 TextEditPlugin 的 protocol 的引用。在 TextEditMisc.h 能找它的定义:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="k">@protocol</span> <span class="nc">TextEditPlugin</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
</span><span class="line"> <span class="o">-</span> <span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="n">menuItemTitle</span><span class="p">;</span>
</span><span class="line"> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">actionCalledWithTextView:</span><span class="p">(</span><span class="n">NSTextView</span><span class="o">*</span><span class="p">)</span><span class="n">textView</span> <span class="nl">inDocument:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">document</span><span class="p">;</span>
</span><span class="line"> <span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这说明你实例化的类需要响应这两个方法。你可以验证这个类是否响应这两个方法（这是一个好主意），但是简单起见，我们现在就不这样做了。</p>

<p>OK，你在 bundle 里面调用的 <code>principalClass</code> 方法是什么呢？当你创建一个 Bundle 的时候，你可以在里面创建一个或者多个类，同时你需要让 TextEdit 知道哪一个类需要被实例化。为了帮助宿主 App 调用，你可以在 Info.plist 文件加入一个 <code>NSPrincipalClass</code> 的键，同时设置它的值为实现插件方法的类的名字。你可以用 <code>[NSBundle principalClass]</code> 方便地从 <code>NSPrincipalClass</code> 的值里面寻找并创建这个类。</p>

<p>继续：在 Plug-Ins 菜单加入一个新的按钮，设置 action 为 <code>pluginMenuItemCalledAction:</code>，并且设置它表示你已经实例化的对象。</p>

<p>注意你没有在 menu item 里面设置一个target。如果一个menu item的目标是nil，那么它会寻找响应链，来寻找第一个实现  <code>pluginMenuItemCalledAction:</code> 方法的对象。如果它找不到，那么这个菜单选项将会不能用。</p>

<p>举一个例子，实现 <code>pluginMenuItemCalledAction</code> 的最好的地方是在 <code>Document</code> 的 window controller 类中。打开 DocumentWindowController.m，然后定位到到 <code>pluginMenuItemCalledAction</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">pluginMenuItemCalledAction:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">id</span> <span class="o">&lt;</span><span class="n">TextEditPlugin</span><span class="o">&gt;</span><span class="n">plugin</span> <span class="o">=</span> <span class="p">[</span><span class="n">sender</span> <span class="n">representedObject</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">plugin</span> <span class="nl">actionCalledWithTextView:</span><span class="p">[</span><span class="n">self</span> <span class="n">firstTextView</span><span class="p">]</span> <span class="nl">inDocument:</span><span class="p">[</span><span class="n">self</span> <span class="n">document</span><span class="p">]];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>代码本身很清晰，搜集插件实例，调用 <code>actionCalledWithTextView:inDocument:</code> 方法（被定义在 protocol 里面的），运行你插件里面的代码。</p>

<h3>插件一瞥</h3>

<p>打开 &#8220;01 MarkYellow&#8221; 工程看一下。这是一个 Xcode (通过OS X ▸ Framework &amp; Library ▸ Bundle template 建立) 的标准工程，里面只添加了一个类：TEMarkYellow。</p>

<p>如果你打开 MarkYellow-Info.plist，你可以看到 <code>NSPrincipalClass</code> 的值设置成了上面提到的 <code>TEMarkYellow</code>。</p>

<p>接着，打开 TEMarkYellow.m，你将会看见定义在协议里面的方法。一个返回你插件的名字，就是在 menu 里面显示的那个，更有意思的是另外一个方法 (<code>actionCalledWithTextView:inDocument:</code>)，它把所有选中的文字变成黄色的背景。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">actionCalledWithTextView:</span><span class="p">(</span><span class="n">NSTextView</span><span class="o">*</span><span class="p">)</span><span class="nv">textView</span> <span class="nf">inDocument:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">document</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">textView</span> <span class="n">selectedRange</span><span class="p">].</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">        <span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="n">ats</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">textView</span> <span class="n">textStorage</span><span class="p">]</span> <span class="nl">attributedSubstringFromRange:</span><span class="p">[</span><span class="n">textView</span> <span class="n">selectedRange</span><span class="p">]]</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">        <span class="p">[</span><span class="n">ats</span> <span class="nl">addAttribute:</span><span class="n">NSBackgroundColorAttributeName</span> <span class="nl">value:</span><span class="p">[</span><span class="n">NSColor</span> <span class="n">yellowColor</span><span class="p">]</span> <span class="nl">range:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">ats</span> <span class="n">length</span><span class="p">])];</span>
</span><span class="line">
</span><span class="line">        <span class="c1">//  先测试text view是否能改变文字内容，这样可以自动做正确的撤销操作。</span>
</span><span class="line">
</span><span class="line">        <span class="n">By</span> <span class="n">asking</span> <span class="n">the</span> <span class="n">text</span> <span class="n">view</span> <span class="k">if</span> <span class="n">you</span> <span class="n">can</span> <span class="n">change</span> <span class="n">the</span> <span class="n">text</span> <span class="n">first</span><span class="p">,</span> <span class="n">it</span> <span class="n">will</span> <span class="n">automatically</span> <span class="k">do</span> <span class="n">the</span> <span class="n">right</span> <span class="n">thing</span> <span class="n">to</span> <span class="n">enable</span> <span class="n">undoing</span> <span class="n">of</span> <span class="n">attribute</span> <span class="n">changes</span>
</span><span class="line">        <span class="k">if</span> <span class="p">([</span><span class="n">textView</span> <span class="nl">shouldChangeTextInRange:</span><span class="p">[</span><span class="n">textView</span> <span class="n">selectedRange</span><span class="p">]</span> <span class="nl">replacementString:</span><span class="p">[</span><span class="n">ats</span> <span class="n">string</span><span class="p">]])</span> <span class="p">{</span>
</span><span class="line">            <span class="p">[[</span><span class="n">textView</span> <span class="n">textStorage</span><span class="p">]</span> <span class="nl">replaceCharactersInRange:</span><span class="p">[</span><span class="n">textView</span> <span class="n">selectedRange</span><span class="p">]</span> <span class="nl">withAttributedString:</span><span class="n">ats</span><span class="p">];</span>
</span><span class="line">            <span class="p">[</span><span class="n">textView</span> <span class="n">didChangeText</span><span class="p">];</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>运行 TextEdit （它会创建Plug-Ins目录），然后构建 MarkYellow 工程。把 MarkYellow.bundle 丢到你的 ~/Library/Application Support/Text Edit/Plug-Ins/ 目录下面，重启你的 TextEdit 应用。</p>

<p>一切看起来都很好，扫描，加载，插入一个菜单，然后，当你使用菜单项的时候，传递到参数到插件里面。试一试，点击 Plug-Ins ▸ Mark Selected Text Yellow，选择的文字的背景颜色就变成黄色的了。</p>

<p>这真是令人惊叹，但是其实它很脆弱，也不够先进。</p>

<p>所以关掉这两个项目，扔进废纸篓，然后尝试忘掉它们吧。</p>

<h2>好的，但是如何改进呢</h2>

<p>上述的途径有什么问题？</p>

<ul>
<li><p>Bundle 中只有一个方法被调用。对于插件的作者来说太不方便了。有没有更简单的方法为 bundle 加入更多功能和菜单按钮呢？</p></li>
<li><p>这不是一个有前瞻性的做法，在插件里面硬编码特定的方法名字固定了一些操作，让我们重新来写这个工程，让插件能做的事情更多吧。</p></li>
</ul>

<p>这一次，我们先从 bundle 开始探究。打开 02 MarkYellow 里面的 xcodeproj 工程，定位到 TEMarkYellow.m， 你马上可以看见这里有更多代码，同时它也做了更多事情。</p>

<p>这里实现了一个接收一个 interface 作为参数的 <code>pluginDidLoad:</code> 方法，而不是返回插件名字的方法。你可以用它来告诉 TextEdit 你的方法名字和调用它们的时候使用的 selector ，以及一个帮助存储一些特别的文本操作的状态的 user object。</p>

<p>这个插件从单一行为变成了实现了三个操作：一个把你的文本变成黄色，一个把你的文字变成蓝色，一个把你选中的文本作为 AppleScript 运行。我们充分发挥了 <code>userObject</code> 这个参数的优点，所以只需要实现两个方法。</p>

<p>这个方法比第一种有扩展性。然而，它也增加了 app 端的复杂度。</p>

<h2 id="textedit">为TextEdit加入更多功能</h2>

<p>打开 02 TextEdit 看看 Controler.m , 它没有做太多事情。但是它在 <code>applicationDidFinishLaunching:</code> 设置了一个新的类，叫 PluginManager，打开 PluginManager.m 并且导航到 <code>－loadPlugins</code> 里面。</p>

<p>这个和刚才的 <code>-loadPlugins</code> 几乎一样，只不过代替了原来使用 for 循环加入菜单项，现在只对从 bundle 中取到的 <code>principalClass</code> 进行初始化，然后调用了 <code>pluginDidLoad:</code>，以此来驱动影响 TextEdit 的执行。</p>

<p>看一下 <code>-addPluginsMenuWithTitle:…</code>，我们在这里创建了菜单项。并且这里不再设置菜单项的 <code>representedObject</code> 为插件实例本身，而是实例化一个 helper 类 (PluginTarget)，同时关联了对 text aciton 和 friends 的引用，然后设置它为菜单项的 representedObject 以备使用。</p>

<p>然而，设置到菜单项的 selector 仍然还是 <code>pluginMenuItemCalledAction:</code>，可以在 DocumentWindowController.m 里面看看这个方法到底干了什么:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">pluginMenuItemCalledAction:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="n">PluginTarget</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">sender</span> <span class="n">representedObject</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSMethodSignature</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="p">[[</span><span class="n">p</span> <span class="n">target</span><span class="p">]</span> <span class="nl">methodSignatureForSelector:</span><span class="p">[</span><span class="n">p</span> <span class="n">action</span><span class="p">]];</span>
</span><span class="line">    <span class="n">NSInvocation</span> <span class="o">*</span><span class="n">invocation</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSInvocation</span> <span class="nl">invocationWithMethodSignature:</span><span class="n">ms</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSTextView</span> <span class="o">*</span><span class="n">tv</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">firstTextView</span><span class="p">];</span>
</span><span class="line">    <span class="kt">id</span> <span class="n">document</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">document</span><span class="p">];</span>
</span><span class="line">    <span class="kt">id</span> <span class="n">userObject</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="n">userObject</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">invocation</span> <span class="nl">setTarget:</span><span class="p">[</span><span class="n">p</span> <span class="n">target</span><span class="p">]];</span>
</span><span class="line">    <span class="p">[</span><span class="n">invocation</span> <span class="nl">setSelector:</span><span class="p">[</span><span class="n">p</span> <span class="n">action</span><span class="p">]];</span>
</span><span class="line">    <span class="p">[</span><span class="n">invocation</span> <span class="nl">setArgument:</span><span class="o">&amp;</span><span class="n">tv</span> <span class="nl">atIndex:</span><span class="mi">2</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">invocation</span> <span class="nl">setArgument:</span><span class="o">&amp;</span><span class="n">document</span> <span class="nl">atIndex:</span><span class="mi">3</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">invocation</span> <span class="nl">setArgument:</span><span class="o">&amp;</span><span class="n">userObject</span> <span class="nl">atIndex:</span><span class="mi">4</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">invocation</span> <span class="n">invoke</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>因为你要处理更多信息，所以这个版本相比之前的实现有一点复杂，创建一个 <code>NSInvocation</code>，设置它的参数，然后从插件的实例里面调用它。</p>

<p>宿主 (app) 端需要更多工作，但是对于插件的作者来说写插件更加灵活了。</p>

<h2>下一步干什么</h2>

<p>基于这个接口，你可以写一个插件，加载其他的自定义的插件。假设你想要加入让你的用户用 Javascript 写插件的功能，那么在 <code>pluginDidLoad</code> 调用之后，扫描指定目录下面的 js 文件，在 <code>addPluginsMenuWithTitle:…</code> 中为每一个 js 文件增加对应的条目，然后，当插件被调用的时候，可以用 JavaScriptCore 来执行对应的脚本 。你也可以用 Python，Ruby，Lua 来做这些事情（我之前做过这些事情）。</p>

<h2>最后，关于安全</h2>

<p>“插件让安全的人抽搐” — 匿名</p>

<p>一个显而易见但是容易被忽略的事情是安全。当你在你的进程里面加载一个可执行的 bundle 
的时候，你相当于在说：“这里有一把我房间的钥匙，确保走的时候关上灯灯，不要把牛奶喝光，无论你干什么都请把火盆放在外面。” 你需要相信插件的作者不会犯错，但是有可能事与愿违。</p>

<p>可能会发生什么糟糕的情况呢？一个实现的不好的的插件可以占用所有可用的内存，让 CPU 占用始终保持 100%，crash 一大堆东西。或许有的家伙写了一个看起来很好的插件，但是一个月以后，它的代码把你的联系人数据库偷偷发给第三方……我还能举出很多例子，我相信你懂的&#8230;</p>

<p>如何解决这个问题？你可以在单独的地址空间运行你的插件（解决 crash 问题，同时可能可以解决内存和 cpu 问题），同时强制插件到沙盒里面运行。（如果你正确地确认插件的权限，那么你的联系人数据库就不会被读取了）。我一时就能想到很多方法，但是最好的解决方法是使用苹果的 XPC。</p>

<p>我把探索的过程留给读者，但是你在处理插件的时候应该一直有安全性的观念。当然，把一个插件放在沙盒里面或者另外一个进程里面会缺少一些乐趣，并且增加一些工作量，所以这对于你的 App 或许没那么重要。</p>

<hr />
</div>
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[闭包，你了解多少？]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/07/04/bi-bao-%2Cni-liao-jie-duo-shao-%3F/"/>
    <updated>2014-07-04T14:48:57+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/07/04/bi-bao-,ni-liao-jie-duo-shao-?</id>
    <content type="html"><![CDATA[<p>在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。
闭包的概念出现于60年代，最早实现闭包的程序语言是Scheme。之后，闭包被广泛使用于函数式编程语言如ML语言和LISP。很多命令式程序语言也开始支持闭包。
在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。运行时，一旦外部的 函数被执行，一个闭包就形成了，闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用。其中所引用的变量称作上值(upvalue)。
闭包一词经常和匿名函数混淆。这可能是因为两者经常同时使用，但是它们是不同的概念。</p>

<p>闭包和状态表达闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。变量的作用域仅限于包含它们的函数，因此无法从其它程序代码部分进行访问。不过，变量的生存期是可以很长，在一次函数调用期间所创建所生成的值在下次函数调用时仍然存在。正因为这一特点，闭包可以用来完成信息隐藏，并进而应用于需要状态表达的某些编程范型中。
不过，用这种方式来使用闭包时，闭包不再具有引用透明性，因此也不再是纯函数。即便如此，在某些“近似于函数式编程语言”的语言，例如Scheme中，闭包还是得到了广泛的使用。</p>

<p>闭包和第一类函数</p>

<p>典型的支持闭包的语言中，通常将函数当作第一类对象——在这些语言中，函数可以被当作参数传递、也可以作为函数返回值、绑定到变量名、就像字符串、整数等简单类型。例如以下Scheme代码：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="scheme"><span class="line"><span class="c1">; Return a list  of all books with at least THRESHOLD copies sold.</span>
</span><span class="line"><span class="p">(</span><span class="k">define </span> <span class="p">(</span><span class="nf">best-selling-books</span>  <span class="nv">threshold</span><span class="p">)</span>
</span><span class="line">   <span class="p">(</span><span class="nf">filter</span>
</span><span class="line">    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">book</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nf">book-sales</span> <span class="nv">book</span><span class="p">)</span>  <span class="nv">threshold</span><span class="p">))</span>
</span><span class="line">    <span class="nv">book-list</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>在这个例子中，lambda表达式(lambda (book) (&gt;= (book-sales book) threshold))出现在函数best-selling-books中。当这个lambda表达式被执行时，Scheme创造了一个包含此表达式以及对threshold变量的引用的闭包，其中threshold变量在lambda表达式中是自由变量。
这个闭包接着被传递到filter函数。这个函数的功能是重复调用这个闭包以判断哪些书需要增加到列表那些需要丢弃。因为闭包中引用了变量threshold，所以它在每次被filter调用时都可以使用这个变量，虽然filter可能定义在另一个文件中。
<!-- more --></p>
<p>下面是用ECMAScript (JavaScript)写的同一个例子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="c1">// Return a  list of all books with at least &#39;threshold&#39; copies sold.</span>
</span><span class="line"><span class="kd">function</span>  <span class="nx">bestSellingBooks</span><span class="p">(</span><span class="nx">threshold</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="k">return</span> <span class="nx">bookList</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span>
</span><span class="line">      <span class="kd">function</span>  <span class="p">(</span><span class="nx">book</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">book</span><span class="p">.</span><span class="nx">sales</span> <span class="o">&gt;=</span> <span class="nx">threshold</span><span class="p">;</span> <span class="p">}</span>
</span><span class="line">    <span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这里，关键字function取代了lambda，Array.filter方法[5]取代了filter函数，但两段代码的功能是一样的。</p>

<p>一个函数可以创建一个闭包并返回它，如下述javascript例子：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="c1">// Return a  function that approximates the derivative of f</span>
</span><span class="line"><span class="c1">// using an interval  of dx, which should be appropriately small.</span>
</span><span class="line"><span class="kd">function</span> <span class="nx">derivative</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span>  <span class="nx">dx</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="k">return</span>  <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">(</span><span class="nx">f</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">)</span> <span class="o">-</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="o">/</span> <span class="nx">dx</span><span class="p">;</span>
</span><span class="line">  <span class="p">};</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>因为在这个例子中闭包已经超出了创建它的函数的范围，所以变量f和dx将在函数derivative返回后继续存在。在没有闭包的语言中，变量的生命周期只限于创建它的环境。但在有闭包的语言中，只要有一个闭包引用了这个变量，它就会一直存在。清理不被任何函数引用的变量的工作通常由垃圾回收完成。</p>

<p>闭包的用途</p>

<ul>
  <li>因为闭包只有在被调用时才执行操作，即“惰性求值”，所以它可以被用来定义控制结构。例如：在Smalltalk语言中，所有的控制结构，包括分歧条件(if/then/else)和循环(while和for)，都是通过闭包实现的。用户也可以使用闭包定义自己的控制结构。</li>
  <li>多个函数可以使用一个相同的环境，这使得它们可以通过改变那个环境相互交流。比如在Scheme中：</li>
</ul>

<p />
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="scheme"><span class="line"><span class="p">(</span><span class="k">define </span><span class="nv">foo</span> <span class="no">#f</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="k">define </span> <span class="nv">bar</span> <span class="no">#f</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">secret-message</span> <span class="s">&quot;none&quot;</span><span class="p">))</span>
</span><span class="line">  <span class="p">(</span><span class="k">set! </span><span class="nv">foo</span>  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">msg</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">secret-message</span> <span class="nv">msg</span><span class="p">)))</span>
</span><span class="line">  <span class="p">(</span><span class="k">set! </span><span class="nv">bar</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">secret-message</span><span class="p">)))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nb">display </span> <span class="p">(</span><span class="nf">bar</span><span class="p">))</span> <span class="c1">; prints &quot;none&quot;</span>
</span><span class="line"><span class="p">(</span><span class="nf">newline</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="nf">foo</span> <span class="s">&quot;meet me by the docks at midnight&quot;</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nf">bar</span><span class="p">))</span> <span class="c1">; prints &quot;meet me by the docks at midnight&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<ul>
  <li>闭包可以用来实现对象系统。</li>
</ul>

<p>闭包的实现
典型实现方式是定义一个特殊的数据结构，保存了函数地址指针与闭包创建时的函数的词法环境表示（那些nonlocal变量的绑定）。使用函数调用栈的语言实现闭包比较困难，因而这也说明了为什么大多数实现闭包的语言是基于垃圾收集机制。
闭包的实现与函数对象很相似。这种技术也叫做lambda lifting。</p>

<p>各种语言中（类似）闭包的结构C语言的回调函数在C语言中，支持回调函数的库有时在注册时需要两个参数：一个函数指针，一个独立的void*指针用以保存用户数据。这样的做法允许回调函数恢复其调用时的状态。这样的惯用法在功能上类似于闭包，但语法上有所不同。gcc对C语言的扩展gcc编译器对C语言实现了一种闭包的程序特性。</p>
<p>C语言扩展：BlocksC语言 (使用LLVM编译器或苹果修改版的GCC)支持块。闭包变量用__block标记。同时，这个扩展也可以应用到Objective-C与C++中。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">^</span><span class="n">IntBlock</span><span class="p">)();</span>
</span><span class="line">
</span><span class="line"><span class="n">IntBlock</span> <span class="nf">downCounter</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	 <span class="n">__block</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
</span><span class="line">	 <span class="k">return</span> <span class="n">Block_copy</span><span class="p">(</span> <span class="o">^</span><span class="kt">int</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">		 <span class="k">return</span> <span class="n">i</span><span class="o">--</span><span class="p">;</span>
</span><span class="line">	 <span class="p">});</span>
</span><span class="line"> <span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">IntBlock</span> <span class="n">f</span> <span class="o">=</span> <span class="n">downCounter</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class="line"><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">());</span>
</span><span class="line"><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">());</span>
</span><span class="line"><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">());</span>
</span><span class="line"><span class="n">Block_release</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>C++函数对象C++早期标准允许通过重载operator()来定义函数对象。这种对象的行为在某种程度上与函数式编程语言中的函数类似。它们可以在运行时动态创建，保存状态，但是不能如闭包一般隐式获取局部变量。
C++11标准已经支持了闭包，这是一种特殊的函数对象，由特殊的语言结构——lambda表达式自动构建。C++闭包中保存了全部nonlocal变量的拷贝或引用。如果是对外界环境中的对象的引用，且闭包执行时该外界环境的变量已经不存在（如在调用栈上已经unwinding），那么可导致undefined behavior，因为C++并不扩展这些被引用的外界环境的变量的生命期。</p>
<p>示例代码如下</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">string</span> <span class="n">myname</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">	<span class="k">typedef</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">names</span><span class="p">;</span>
</span><span class="line">	<span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
</span><span class="line">	<span class="n">names</span> <span class="n">n</span><span class="p">;</span>
</span><span class="line">	<span class="c1">// ...</span>
</span><span class="line">	<span class="n">names</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span>
</span><span class="line">	 <span class="n">find_if</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">n</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">){</span><span class="k">return</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">myname</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">;});</span>
</span><span class="line">	<span class="c1">// &#39;i&#39; is now either &#39;n.end()&#39; or points to the first string in &#39;n&#39;</span>
</span><span class="line">	<span class="c1">// &#39;i&#39; 现在是&#39;n.end()&#39;或指向&#39;n&#39;中第一个</span>
</span><span class="line">	<span class="c1">// 不等于&#39;myname&#39;且长度大于&#39;y&#39;的字符串</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 8 体验推送]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/07/02/ios-8-ti-yan-tui-song/"/>
    <updated>2014-07-02T11:55:11+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/07/02/ios-8-ti-yan-tui-song</id>
    <content type="html"><![CDATA[<p> 一直更新了iOS8，但是一直没有开始研究这个iOS8，今天因为项目用到了推送，于是体验了iOS8的推送，先讲讲这个推送。目前分为四个推送：用户推送，本地推送，远程推送，地理位置推送。
</p>
<p><img src="http://ww3.sinaimg.cn/large/626e5d69gw1ehyeq298goj21kw0sadmt.jpg" alt="推送界面" /></p>

<h2>用户推送</h2>
<p>我们先开始讲这个用户推送,我们要使用之前必须先注册这个推送，用户要允许这个程序进行推送</p>
<p>注册过程：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">didFinishLaunchingWithOptions:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">launchOptions</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// Override point for customization after application launch.</span>
</span><span class="line">    <span class="n">UIUserNotificationType</span>  <span class="n">types</span> <span class="o">=</span> <span class="n">UIUserNotificationTypeBadge</span> <span class="o">|</span> <span class="n">UIUserNotificationTypeSound</span> <span class="o">|</span> <span class="n">UIUserNotificationTypeAlert</span> <span class="p">;</span>
</span><span class="line">    <span class="n">UIUserNotificationSettings</span>  <span class="o">*</span><span class="n">mySettings</span>  <span class="o">=</span> <span class="p">[</span><span class="n">UIUserNotificationSettings</span> <span class="nl">settingsForTypes:</span><span class="n">types</span> <span class="nl">categories:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line">    <span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">registerUserNotificationSettings:</span><span class="n">mySettings</span><span class="p">];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">didRegisterUserNotificationSettings:</span><span class="p">(</span><span class="n">UIUserNotificationSettings</span> <span class="o">*</span><span class="p">)</span><span class="nv">notificationSettings</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">UIUserNotificationType</span> <span class="n">allowTypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">notificationSettings</span> <span class="n">types</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">getReadyForNotification</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">UIUserNotificationSettings</span> <span class="o">*</span><span class="n">currentNotificationSettings</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="n">currentUserNotificationSettings</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">checkSetting:</span><span class="n">currentNotificationSettings</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>总结就是三个方法进行注册</p>
<p><img src="http://ww4.sinaimg.cn/large/626e5d69gw1ehyeumz8inj21f80d40up.jpg" alt="推送注册三个方法" /></p>

<p>我们现在仅仅是注册了通知的设置，还要注册推送通知的行为，在iOS8中，行为能直接在推送消息进行，如回复消息，拒绝消息等</p>
<p><img src="http://ww1.sinaimg.cn/large/626e5d69gw1ehyeyi825mj21aa12ggoc.jpg" alt="直接在推送消息进行回复" /></p>
<p>这个真心碉堡了</p>
<p>我们如何能进行这些行为，首先我们需注册这些行为。</p>
<!-- more -->
<li>Actions</li>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">UIMutableUserNotificationAction</span> <span class="o">*</span><span class="n">acceptAction</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIMutableUserNotificationAction</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="n">acceptAction</span><span class="p">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="s">@&quot;RickAction&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">acceptAction</span><span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="s">@&quot;Accept&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">acceptAction</span><span class="p">.</span><span class="n">activationMode</span> <span class="o">=</span> <span class="n">UIUserNotificationActivationModeBackground</span><span class="p">;</span>
</span><span class="line"><span class="n">acceptAction</span><span class="p">.</span><span class="n">destructive</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class="line"><span class="n">acceptAction</span><span class="p">.</span><span class="n">authenticationRequired</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<li>Categories</li>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">UIMutableUserNotificationCategory</span> <span class="o">*</span><span class="n">inviteCategory</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIMutableUserNotificationCategory</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="n">inviteCategory</span><span class="p">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="s">@&quot;INVITE_CATEGORY&quot;</span><span class="p">;</span>
</span><span class="line"><span class="p">[</span><span class="n">inviteCategory</span> <span class="nl">setActions:</span><span class="err">@</span><span class="p">[</span><span class="n">acceptAction</span><span class="p">]</span> <span class="nl">forContext:</span><span class="n">UIUserNotificationActionContextDefault</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>我们需要注意这个<code>UIUserNotificationActionContextDefault</code>,如果我们使用这个，我们会得到这个推送行为，Maybe和Accept</p>
<p><img src="http://ww1.sinaimg.cn/large/626e5d69gw1ehyf4bfhvrj20q80zytaw.jpg" alt="Maybe和Accept" /></p>
<p>我们还可以使用<code>UIUserNotificationActionContextMinimal</code>得到的是Decline和Accept行为</p>
<p><img src="http://ww3.sinaimg.cn/large/626e5d69gw1ehyf61ypo0j20q010476h.jpg" alt="Decline和Accept" /></p>

<li>Settings</li>
<p>在这些行为注册之后，我们加上之前提到的推送设置就完成了注册推送的这个流程了</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSSet</span> <span class="o">*</span><span class="n">categories</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSSet</span> <span class="nl">setWithObjects:</span><span class="n">inviteCategory</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
</span><span class="line"><span class="n">UIUserNotificationType</span>  <span class="n">types</span> <span class="o">=</span> <span class="n">UIUserNotificationTypeBadge</span> <span class="o">|</span> <span class="n">UIUserNotificationTypeSound</span> <span class="o">|</span> <span class="n">UIUserNotificationTypeAlert</span> <span class="p">;</span>
</span><span class="line"><span class="n">UIUserNotificationSettings</span>  <span class="o">*</span><span class="n">mySettings</span>  <span class="o">=</span> <span class="p">[</span><span class="n">UIUserNotificationSettings</span> <span class="nl">settingsForTypes:</span><span class="n">types</span> <span class="nl">categories:</span><span class="n">categories</span><span class="p">];</span>
</span><span class="line"><span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">registerUserNotificationSettings:</span><span class="n">mySettings</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<h2>远程推送</h2>
<p>远程推送，所有消息大小不超过2KB,我们获取远程推送的json格式的消息，解析这个消息就是我们的远程推送了：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="json"><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="err">“aps”:</span> <span class="err">{</span>
</span><span class="line">        <span class="nt">&quot;content-available&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class="line">        <span class="nt">&quot;alert&quot;</span><span class="p">:</span> <span class="s2">&quot;This is the alert text&quot;</span><span class="p">,</span>
</span><span class="line">        <span class="nt">&quot;badge&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class="line">        <span class="nt">&quot;sound&quot;</span><span class="p">:</span> <span class="s2">&quot;default&quot;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="err">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>若要使用远程推送，满足两个条件：一、用户需要调用注册用户推送<code>registerUserNotificationSettings</code>;二、在<code>info.plist</code>文件中<code>UIBackgroundModes</code>必须包含远程通知。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="n">registerForRemoteNotifications</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<blockquote>
	<p>这个注册通知的方法开始更改了</p>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">didRegisterForRemoteNotificationsWithDeviceToken:</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nv">deviceToken</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">didFailToRegisterForRemoteNotificationsWithError:</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="p">)</span><span class="nv">error</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>iOS7通知代理方法</p>
<p><img src="http://ww4.sinaimg.cn/large/626e5d69gw1ehyfq2omeij21kw0zc456.jpg" alt="iOS6的通知代理方法" /></p>
<p>后来又增加了本地通知的代理方法</p>
<p><img src="http://ww4.sinaimg.cn/large/626e5d69gw1ehyfvjws4ej21kw0uxn20.jpg" alt="添加本地推送的通知代理方法" /></p>
<p>iOS8的推送代理方法只有两个了</p>
<p><img src="http://ww4.sinaimg.cn/large/626e5d69gw1ehyfws0hdfj210g0oyq6d.jpg" alt="iOS 8推送的通知代理方法" /></p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">handleActionWithIdentifier:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">identifier</span> <span class="nf">forLocalNotification:</span><span class="p">(</span><span class="n">UILocalNotification</span> <span class="o">*</span><span class="p">)</span><span class="nv">notification</span> <span class="nf">completionHandler:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">completionHandler</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">handleActionWithIdentifier:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">identifier</span> <span class="nf">forRemoteNotification:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">userInfo</span> <span class="nf">completionHandler:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">completionHandler</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">handleActionWithIdentifier:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">identifier</span> <span class="nf">forLocalNotification:</span><span class="p">(</span><span class="n">UILocalNotification</span> <span class="o">*</span><span class="p">)</span><span class="nv">notification</span> <span class="nf">completionHandler:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">completionHandler</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">identifier</span> <span class="nl">isEqualToString:</span><span class="s">@&quot;RickAction&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">self</span> <span class="nl">handleAcceptActionWithNotification:</span><span class="n">notification</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">completionHandler</span><span class="p">();</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handleAcceptActionWithNotification:</span><span class="p">(</span><span class="n">UILocalNotification</span><span class="o">*</span><span class="p">)</span><span class="nv">notification</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<h2>地理位置推送</h2>
<p>这个推送是新的API才有的特性,必须配合CLLocation定位一起使用。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="c1">//Location Notification</span>
</span><span class="line">    <span class="n">CLLocationManager</span> <span class="o">*</span><span class="n">locMan</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CLLocationManager</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="n">locMan</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">locMan</span> <span class="n">requestWhenInUseAuthorization</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="cp">#pragma mark - CLLocationManager</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">locationManager:</span><span class="p">(</span><span class="n">CLLocationManager</span> <span class="o">*</span><span class="p">)</span><span class="nv">manager</span> <span class="nf">didChangeAuthorizationStatus:</span><span class="p">(</span><span class="n">CLAuthorizationStatus</span><span class="p">)</span><span class="nv">status</span>
</span><span class="line">
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">BOOL</span> <span class="n">canUseLocationNotifications</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">kCLAuthorizationStatusAuthorizedWhenInUse</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">canUseLocationNotifications</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">self</span> <span class="n">startShowLocationNotification</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">didReceiveLocalNotification:</span><span class="p">(</span><span class="n">UILocalNotification</span> <span class="o">*</span><span class="p">)</span><span class="nv">notification</span>
</span><span class="line">
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">CLRegion</span> <span class="o">*</span><span class="n">region</span> <span class="o">=</span> <span class="n">notification</span><span class="p">.</span><span class="n">region</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">startShowLocationNotification</span>
</span><span class="line">
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">CLLocationCoordinate2D</span> <span class="n">local2D</span> <span class="p">;</span>
</span><span class="line">    <span class="n">local2D</span><span class="p">.</span><span class="n">latitude</span> <span class="o">=</span> <span class="mf">123.0</span><span class="p">;</span>
</span><span class="line">    <span class="n">local2D</span><span class="p">.</span><span class="n">longitude</span> <span class="o">=</span> <span class="mf">223.0</span><span class="p">;</span>
</span><span class="line">    <span class="n">UILocalNotification</span> <span class="o">*</span><span class="n">locNotification</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UILocalNotification</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="n">locNotification</span><span class="p">.</span><span class="n">alertBody</span> <span class="o">=</span> <span class="s">@&quot;你接收到了&quot;</span><span class="p">;</span>
</span><span class="line">    <span class="n">locNotification</span><span class="p">.</span><span class="n">regionTriggersOnce</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line">    <span class="n">locNotification</span><span class="p">.</span><span class="n">region</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CLCircularRegion</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithCenter:</span><span class="n">local2D</span> <span class="nl">radius:</span><span class="mi">45</span> <span class="nl">identifier:</span><span class="s">@&quot;local-identity&quot;</span><span class="p">];</span>
</span><span class="line">    <span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">scheduleLocalNotification:</span><span class="n">locNotification</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<blockquote>
	<p>如果没有开启Core Location 那么上面的didReceiveLocalNotification不会被调用</p>
</blockquote>

<p>最后再总结一下，整个推送流程我觉得是这样子的，先注册推送，然后推送消息，客户端接收推送消息，执行推送行为。如果有错误，还请在文章下面评论，欢迎指正。</p>
<p><img src="http://ww2.sinaimg.cn/large/626e5d69gw1ehyg8u1o51j21ea0qkmz1.jpg" alt="推送的流程" /></p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用VIPER构建iOS应用]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/06/20/shi-yong-vipergou-jian-iosying-yong/"/>
    <updated>2014-06-20T09:00:36+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/06/20/shi-yong-vipergou-jian-iosying-yong</id>
    <content type="html"><![CDATA[<script type="text/javascript">
    var wumiiPermaLink = ""; //请用代码生成文章永久的链接
    var wumiiTitle = ""; //请用代码生成文章标题
    var wumiiTags = ""; //请用代码生成文章标签，以英文逗号分隔，如："标签1,标签2"
    var wumiiCategories = []; //请用代码生成文章分类，分类名放在 JSONArray 中，如: ["分类1", "分类2"]
    var wumiiSitePrefix = "http://itmonkeylife.github.io/Blog/";
    var wumiiParams = "&num=5&mode=3&pf=JAVASCRIPT";
</script>

<script type="text/javascript" src="http://widget.wumii.cn/ext/relatedItemsWidget"></script>

<p><a href="http://www.wumii.com/widget/relatedItems" style="border:0;">
    <img src="http://static.wumii.cn/images/pixel.png" alt="无觅关联推荐，快速提升流量" style="border:0;padding:0;margin:0;" />
</a></p>

<p>建筑领域流行这样一句话，“我们虽然在营造建筑，但建筑也会重新塑造我们”。正如所有开发者最终领悟到的，这句话同样适用于构建软件。</p>

<p>编写代码中至关重要的是，需要使每一部分容易被识别，赋有一个特定而明显的目的，并与其他部分在逻辑关系中完美契合。这就是我们所说的软件架构。好的架构不仅让一个产品成功投入使用，还可以让产品具有可维护性，并让人不断头脑清醒的对它进行维护！</p>
<!-- more -->
<p>在这篇文章中，我们介绍了一种称之为 <a href="http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/">VIPER</a> 的 iOS 应用架构的方式。VIPER 已经在很多大型的项目上成功实践，但是出于本文的目的我们将通过一个待办事项清单 (to-do app) 来介绍 VIPER 。你可以在 <a href="https://github.com/objcio/issue-13-viper">GitHub</a> 上关注这个项目。</p>

<p><video style="display:block;max-width:316px;height:auto;border:0;" poster="/issue-13/2014-06-07-viper-screenshot.png" controls="1"> <br />
  <source src="http://img.objccn.io//issue-13/2014-06-07-viper-preview.mp4" />
</video></p>

<h2 id="viper">什么是 VIPER？</h2>

<p>测试永远不是构建 iOS 应用的主要部分。当我们 (<a href="https://github.com/mutualmobile/">Mutual Mobile</a>) 着手改善我们的测试实践时，我们发现给 iOS 应用写测试代码非常困难。因此如果想要设法改变测试的现状，我们首先需要一个更好的方式来架构应用，我们称之为 VIPER。</p>

<p>VIPER 是一个创建 iOS 应用<a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html">简明构架</a>的程序。VIPER 可以是视图 (View)，交互器 (Interactor)，展示器 (Presenter)，实体 (Entity) 以及路由 (Routing) 的首字母缩写。简明架构将一个应用程序的逻辑结构划分为不同的责任层。这使得它更容易隔离依赖项 (如数据库)，也更容易测试各层间的边界处的交互：</p>

<p><img alt="VIPER stands for View Interactor Presenter Entity Routing." src="http://img.objccn.io/issue-13/2014-06-07-viper-intro.jpg" /></p>

<p>大部分 iOS 应用利用 MVC 构建，使用 MVC 应用程序架构可以引导你将每一个类看做模型，视图或控制器中的一个。但由于大部分应用程序的逻辑不会存在于模型或视图中，所以通常最终总是在控制器里实现。这就导致一个称为<a href="https://twitter.com/Colin_Campbell/status/293167951132098560">重量级视图控制器</a>的问题，在这里，视图控制器做了太多工作。为这些重量级视图控制器<a href="http://www.objc.io/issue-1/lighter-view-controllers.html">瘦身</a>并不是 iOS 开发者寻求提高代码的质量所要面临的唯一挑战，但至少这是一个很好的开端。</p>

<p>VIPER 的不同层提供了明确的程序逻辑以及导航控制代码来应对这个挑战，利用 VIPER ，你会注意到在我们的待办事项示例清单中的视图控制器可以简洁高效，意义明确地控制视图。你也会发现视图控制器中代码和所有的其他类很容易理解，容易测试，理所当然也更易维护。</p>

<h2>基于用例的应用设计</h2>

<p>应用通常是一些用户用例的集合。用例也被称为验收标准，或行为集，它们用来描述应用的用途。清单可以根据时间，类型以及名字排序，这就是一个用例。用例是应用程序中用来负责业务逻辑的一层，应独立于用户界面的实现，同时要足够小，并且有良好的定义。决定如何将一个复杂的应用分解成较小的用例非常具有挑战性，并且需要长期实践，但这对于缩小你解决的问题时所要面临的范围及完成的每个类的所要涉及的内容来说，是很有帮助的。</p>

<p>利用 VIPER 建立一个应用需要实施一组套件来满足所有的用例，应用逻辑是实现用例的主要组成部分，但却不是唯一。用例也会影响用户界面。另一个重要的方面，是要考虑用例如何与其他应用程序的核心组件相互配合，例如网络和数据持久化。组件就好比用例的插件，VIPER 则用来描述这些组件的作用是什么，如何进行交互。</p>

<p>我们其中一个用例，或者说待办事项清单中其中的一个需求是可以基于用户的选择来将待办事项分组。通过分离的逻辑将数据组织成一个用例，我们能够在测试时使用户界面代码保持干净，用例更易组装，从而确保它如我们预期的方式工作。</p>

<h2 id="viper">VIPER 的主要部分</h2>

<p>VIPER 的主要部分是：</p>

<ul>
<li>视图：根据展示器的要求显示界面，并将用户输入反馈给展示器。</li>
<li>交互器：包含由用例指定的业务逻辑。</li>
<li>展示器：包含为显示（从交互器接受的内容）做的准备工作的相关视图逻辑，并对用户输入进行反馈（从交互器获取新数据）。</li>
<li>实体：包含交互器要使用的基本模型对象。</li>
<li>路由：包含用来描述屏幕显示和显示顺序的导航逻辑。</li>
</ul>

<p>这种分隔形式同样遵循<a href="http://www.objectmentor.com/resources/articles/srp.pdf">单一责任原则</a>。交互器负责业务分析的部分，展示器代表交互设计师，而视图相当于视觉设计师。</p>

<p>以下则是不同组件的相关图解，并展示了他们之间是如何关联的：</p>

<p><img alt="VIPER breaks down an app into different components based around use cases, including components that create the user interface and the logic that powers it." src="http://img.objccn.io/issue-13/2014-06-07-viper-wireframe.png" /></p>

<p>虽然在应用中 VIPER 的组件可以以任意顺序实现，我们在这里选择按照我们推荐的顺序来进行介绍。你会注意到这个顺序与构建整个应用的进程大致符合 &#8211; 首先要讨论的是产品需要做什么，以及用户会如何与之交互。</p>

<h3>交互器</h3>

<p>交互器在应用中代表着一个独立的用例。它具有业务逻辑以操纵模型对象（实体）执行特定的任务。交互器中的工作应当独立与任何用户界面，同样的交互器可以同时运用于 iOS 应用或者 OS X 应用中。</p>

<p>由于交互器是一个 PONSO (Plain Old <code>NSObject</code>，普通的 <code>NSObject</code>)，它主要包含了逻辑，因此很容易使用 TDD 进行开发。</p>

<p>示例应用的主要用例是向用户展示所有的待办事项（比如任何截止于下周末的任务）。此类用例的业务逻辑主要是找出今天至下周末之间将要到期的待办事项，然后为它们分配一个相对的截止日期，比如今天，明天，本周以内，或者下周。</p>

<p>以下是来自 VTDListInteractor 的对应方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">findUpcomingItems</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">__weak</span> <span class="n">typeof</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="n">welf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line">    <span class="n">NSDate</span><span class="o">*</span> <span class="n">today</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">clock</span> <span class="n">today</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSDate</span><span class="o">*</span> <span class="n">endOfNextWeek</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSCalendar</span> <span class="n">currentCalendar</span><span class="p">]</span> <span class="nl">dateForEndOfFollowingWeekWithDate:</span><span class="n">today</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dataManager</span> <span class="nl">todoItemsBetweenStartDate:</span><span class="n">today</span> <span class="nl">endDate:</span><span class="n">endOfNextWeek</span> <span class="nl">completionBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSArray</span><span class="o">*</span> <span class="n">todoItems</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">welf</span><span class="p">.</span><span class="n">output</span> <span class="nl">foundUpcomingItems:</span><span class="p">[</span><span class="n">welf</span> <span class="nl">upcomingItemsFromToDoItems:</span><span class="n">todoItems</span><span class="p">]];</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3>实体</h3>

<p>实体是被交互器操作的模型对象，并且它们只被交互器所操作。交互器永远不会传输实体至表现层 (比如说展示器)。</p>

<p>实体也应该是 PONSOs。如果你使用 Core Data，最好是将托管对象保持在你的数据层之后，交互器不应与 NSManageObjects 协同工作。</p>

<p>这里是我们的待办事项服务的实体：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">VTDTodoItem</span> : <span class="nc">NSObject</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span>   <span class="n">NSDate</span><span class="o">*</span>     <span class="n">dueDate</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>     <span class="n">NSString</span><span class="o">*</span>   <span class="n">name</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">todoItemWithDueDate:</span><span class="p">(</span><span class="n">NSDate</span><span class="o">*</span><span class="p">)</span><span class="nv">dueDate</span> <span class="nf">name:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">name</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>不要诧异于你的实体仅仅是数据结构，任何依赖于应用的逻辑都应该放到交互器中。</p>

<h3>展示器</h3>

<p>展示器是一个主要包含了驱动用户界面的逻辑的 PONSO，它总是知道何时呈现用户界面。基于其收集来自用户交互的输入功能，它可以在合适的时候更新用户界面并向交互器发送请求。</p>

<p>当用户点击 “+” 键新建待办事项时，<code>addNewEntry</code> 被调用。对于此项操作，展示器会要求 <code>wireframe</code> 显示用户界面以增加新项目：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addNewEntry</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">listWireframe</span> <span class="n">presentAddInterface</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>展示器还会从交互器接收结果并将结果转换成能够在视图中有效显示的形式。</p>

<p>下面是如何从交互器接受待办事项的过程，其中包含了处理数据的过程并决定展现给用户哪些内容：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">foundUpcomingItems:</span><span class="p">(</span><span class="n">NSArray</span><span class="o">*</span><span class="p">)</span><span class="nv">upcomingItems</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">upcomingItems</span> <span class="n">count</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">userInterface</span> <span class="n">showNoContentMessage</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">else</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">self</span> <span class="nl">updateUserInterfaceWithUpcomingItems:</span><span class="n">upcomingItems</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>实体永远不会由交互器传输给展示器，取而代之，那些无行为的简单数据结构会从交互器传输到展示器那里。这就防止了那些“真正的工作”在展示器那里进行，展示器只能负责准备那些在视图里显示的数据。</p>

<h3>视图</h3>

<p>视图一般是被动的，它通常等待展示器下发需要显示的内容，而不会向其索取数据。视图（例如登录界面的登录视图控件）所定义的方法应该允许展示器在高度抽象的层次与之交流。展示器通过内容进行表达，而不关心那些内容所显示的样子。展示器不知道 <code>UILabel</code>，<code>UIButton</code> 等的存在，它只知道其中包含的内容以及何时需要显示。内容如何被显示是由视图来进行控制的。</p>

<p>视图是一个抽象的接口 (Interface)，在 Objective-C 中使用协议被定义。一个 <code>UIViewController</code> 或者它的一个子类会实现视图协议。比如我们的示例中 “添加” 界面会有以下接口：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@protocol</span> <span class="nc">VTDAddViewInterface</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
</span><span class="line">
</span><span class="line"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setEntryName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">name</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setEntryDueDate:</span><span class="p">(</span><span class="n">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="nv">date</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>视图和视图控制器同样会操纵用户界面和相关输入。因为通常来说视图控制器是最容易处理这些输入和执行某些操作的地方，所以也就不难理解为什么视图控制器总是这么大了。为了使视图控制器保持苗条，我们需要使它们在用户进行相关操作的时候可以有途径来通知相关部分。视图控制器不应当根据这些行为进行相关决定，但是它应当将发生的事件传递到能够做决定的部分。</p>

<p>在我们的例子中，Add View Controller 有一个事件处理的属性，它实现了如下接口：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@protocol</span> <span class="nc">VTDAddModuleInterface</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
</span><span class="line">
</span><span class="line"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">cancelAddAction</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">saveAddActionWithName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">dueDate:</span><span class="p">(</span><span class="n">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="nv">dueDate</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当用户点击取消键的时候，视图控制器告知这个事件处理程序用户需要其取消这次添加的动作。这样一来，事件处理程序便可以处理关闭 add view controller 并告知列表视图进行更新。</p>

<p>视图和展示器之间边界处是一个使用 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> 的好地方。在这个示例中，视图控制器可以返回一个代表按钮操作的信号。这将允许展示器在不打破职责分离的前提下轻松地对那些信号进行响应。</p>

<h3>路由</h3>

<p>屏幕间的路径会在交互设计师创建的线框 (wireframes) 里进行定义。在 VIPER 中，路由是由两个部分来负责的：展示器和线框。一个线框对象包括 <code>UIWindow</code>，<code>UINavigationController</code>，<code>UIViewController</code> 等部分，它负责创建视图/视图控制器并将其装配到窗口中。</p>

<p>由于展示器包含了响应用户输入的逻辑，因此它就拥有知晓何时导航至另一个屏幕以及具体是哪一个屏幕的能力。而同时，线框知道如何进行导航。在两者结合起来的情况下，展示器可以使用线框来进行实现导航功能，它们两者一起描述了从一个屏幕至另一个屏幕的路由过程。</p>

<p>线框同时也明显是一个处理导航转场动画的地方。来看看这个 add wireframe 中的例子吧：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">VTDAddWireframe</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">presentAddInterfaceFromViewController:</span><span class="p">(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">viewController</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">VTDAddViewController</span> <span class="o">*</span><span class="n">addViewController</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">addViewController</span><span class="p">];</span>
</span><span class="line">    <span class="n">addViewController</span><span class="p">.</span><span class="n">eventHandler</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">addPresenter</span><span class="p">;</span>
</span><span class="line">    <span class="n">addViewController</span><span class="p">.</span><span class="n">modalPresentationStyle</span> <span class="o">=</span> <span class="n">UIModalPresentationCustom</span><span class="p">;</span>
</span><span class="line">    <span class="n">addViewController</span><span class="p">.</span><span class="n">transitioningDelegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">viewController</span> <span class="nl">presentViewController:</span><span class="n">addViewController</span> <span class="nl">animated:</span><span class="n">YES</span> <span class="nl">completion:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">presentedViewController</span> <span class="o">=</span> <span class="n">viewController</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="cp">#pragma mark - UIViewControllerTransitioningDelegate Methods</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">UIViewControllerAnimatedTransitioning</span><span class="o">&gt;</span><span class="p">)</span><span class="nf">animationControllerForDismissedController:</span><span class="p">(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">dismissed</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[[</span><span class="n">VTDAddDismissalTransition</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">UIViewControllerAnimatedTransitioning</span><span class="o">&gt;</span><span class="p">)</span><span class="nf">animationControllerForPresentedController:</span><span class="p">(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">presented</span>
</span><span class="line">                                                                  <span class="nf">presentingController:</span><span class="p">(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">presenting</span>
</span><span class="line">                                                                      <span class="nf">sourceController:</span><span class="p">(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">source</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[[</span><span class="n">VTDAddPresentationTransition</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>应用使用了自定义的视图控制器转场来呈现 add view controller。因为线框部件负责实施这个转场，所以它成为了 add view controller 转场的委托，并且返回适当的转场动画。</p>

<h2 id="viper">利用 VIPER 组织应用组件</h2>

<p>iOS 应用的构架需要考虑到 UIKit 和 Cocoa Touch 是建立应用的主要工具。架构需要和应用的所有组件都能够和平相处，但又需要为如何使用框架的某些部分以及它们应该在什么位置提供一些指导和建议。</p>

<p>iOS 应用程序的主力是 <code>UIViewController</code>，我们不难想象找一个竞争者来取代 MVC 就可以避免大量使用视图控制器。但是视图控制器现在是这个平台的核心：它们处理设备方向的变化，回应用户的输入，和类似导航控制器之类的系统系统组件集成得很好，而现在在 iOS 7 中又能实现自定义屏幕之间的转换，功能实在是太强大了。</p>

<p>有了 VIPER，视图控制器便就能真正的做它本来应该做的事情了，那就是控制视图。 我们的待办事项应拥有两个视图控制器，一个是列表视图，另一个是新建待办。因为 add view controller 要做的所有事情就是控制视图，所以实现起来非常的简单基础：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">VTDAddViewController</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="nl">viewDidAppear:</span><span class="n">animated</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">UITapGestureRecognizer</span> <span class="o">*</span><span class="n">gestureRecognizer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UITapGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget:</span><span class="n">self</span>
</span><span class="line">                                                                                        <span class="nl">action:</span><span class="k">@selector</span><span class="p">(</span><span class="n">dismiss</span><span class="p">)];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">transitioningBackgroundView</span> <span class="nl">addGestureRecognizer:</span><span class="n">gestureRecognizer</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">transitioningBackgroundView</span><span class="p">.</span><span class="n">userInteractionEnabled</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dismiss</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">eventHandler</span> <span class="n">cancelAddAction</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setEntryName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">nameTextField</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setEntryDueDate:</span><span class="p">(</span><span class="n">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="nv">date</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">datePicker</span> <span class="nl">setDate:</span><span class="n">date</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">save:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">eventHandler</span> <span class="nl">saveAddActionWithName:</span><span class="n">self</span><span class="p">.</span><span class="n">nameTextField</span><span class="p">.</span><span class="n">text</span>
</span><span class="line">                                     <span class="nl">dueDate:</span><span class="n">self</span><span class="p">.</span><span class="n">datePicker</span><span class="p">.</span><span class="n">date</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">cancel:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">eventHandler</span> <span class="n">cancelAddAction</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="cp">#pragma mark - UITextFieldDelegate Methods</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">textFieldShouldReturn:</span><span class="p">(</span><span class="n">UITextField</span> <span class="o">*</span><span class="p">)</span><span class="nv">textField</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">textField</span> <span class="n">resignFirstResponder</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>应用在接入网络以后会变得更有用处，但是究竟该在什么时候联网呢？又由谁来负责启动网络连接呢？典型的情况下，由交互器来启动网络连接操作的项目，但是它不会直接处理网络代码。它会寻找一个像是 network manager 或者 API client 这样的依赖项。交互器可能聚合来自多个源的数据来提供所需的信息，从而完成一个用例。最终，就由展示器来采集交互器反馈的数据，然后组织并进行展示。</p>

<p>数据存储模块负责提供实体给交互器。因为交互器要完成业务逻辑，因此它需要从数据存储中获取实体并操纵它们，然后将更新后的实体再放回数据存储中。数据存储管理实体的持久化，而实体应该对数据库全然不知，正因如此，实体并不知道如何对自己进行持久化。</p>

<p>交互器同样不需要知道如何将实体持久化，有时交互器更希望使用一个 data manager 来使其与数据存储的交互变得容易。Data manager 可以处理更多的针对存储的操作，比如创建获取请求，构建查询等等。这就使交互器能够将更多的注意力放在应用逻辑上，而不必再了解实体是如何被聚集或持久化的。下面我们举一个例子来说明使用 data manager 有意义的，这个例子假设你在使用 Core Data。这是示例应用程序的 data manager 的接口：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">VTDListDataManager</span> : <span class="nc">NSObject</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">VTDCoreDataStore</span> <span class="o">*</span><span class="n">dataStore</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">todoItemsBetweenStartDate:</span><span class="p">(</span><span class="n">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="nv">startDate</span> <span class="nf">endDate:</span><span class="p">(</span><span class="n">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="nv">endDate</span> <span class="nf">completionBlock:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">todoItems</span><span class="p">))</span><span class="nv">completionBlock</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当使用 TDD 来开发一个交互器时，是可以用一个测试用的模拟存储来代替生产环境的数据存储的。避免与远程服务器通讯（网络服务）以及避免读取磁盘（数据库）可以加快你测试的速度并加强其可重复性。</p>

<p>将数据存储保持为一个界限清晰的特定层的原因之一是，这可以让你延迟选择一个特定的持久化技术。如果你的数据存储是一个独立的类，那你就可以使用一个基础的持久化策略来开始你的应用，然后等到有意义的时候升级至 SQLite 或者 Core Data。而因为数据存储层的存在，你的应用代码库中就不需要改变任何东西。</p>

<p>在 iOS 的项目中使用 Core Data 经常比构架本身还容易引起更多争议。然而，利用 VIPER 来使用 Core Data 将给你带来使用 Core Data 的前所未有的良好体验。在持久化数据的工具层面上，Core Data 可以保持快速存取和低内存占用方面，简直是个神器。但是有个很恼人的地方，它会像触须一样把 <code>NSManagedObjectContext</code>  延伸至你所有的应用实现文件中，特别是那些它们不该待的地方。VIPER 可以使 Core Data 待在正确的地方：数据存储层。</p>

<p>在待办事项示例中，应用仅有的两部分知道使用了 Core Data，其一是数据存储本身，它负责建立 Core Data 堆栈；另一个是 data manager。Data manager 执行了获取请求，将数据存储返回的 NSManagedObject 对象转换为标准的 PONSO 模型对象，并传输回业务逻辑层。这样一来，应用程序核心将不再依赖于 Core Data，附加得到的好处是，你也再也不用担心过期数据 (stale) 和没有良好组织的多线程 NSManagedObjects 来糟蹋你的工作成果了。</p>

<p>在通过请求访问 Core Data 存储时，data manager 中看起来是这样的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">VTDListDataManager</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">todoItemsBetweenStartDate:</span><span class="p">(</span><span class="n">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="nv">startDate</span> <span class="nf">endDate:</span><span class="p">(</span><span class="n">NSDate</span><span class="o">*</span><span class="p">)</span><span class="nv">endDate</span> <span class="nf">completionBlock:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">todoItems</span><span class="p">))</span><span class="nv">completionBlock</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSCalendar</span> <span class="o">*</span><span class="n">calendar</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSCalendar</span> <span class="n">autoupdatingCurrentCalendar</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSPredicate</span> <span class="o">*</span><span class="n">predicate</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSPredicate</span> <span class="nl">predicateWithFormat:</span><span class="s">@&quot;(date &gt;= %@) AND (date &lt;= %@)&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">calendar</span> <span class="nl">dateForBeginningOfDay:</span><span class="n">startDate</span><span class="p">],</span> <span class="p">[</span><span class="n">calendar</span> <span class="nl">dateForEndOfDay:</span><span class="n">endDate</span><span class="p">]];</span>
</span><span class="line">    <span class="n">NSArray</span> <span class="o">*</span><span class="n">sortDescriptors</span> <span class="o">=</span> <span class="err">@</span><span class="p">[];</span>
</span><span class="line">
</span><span class="line">    <span class="n">__weak</span> <span class="n">typeof</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="n">welf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dataStore</span>
</span><span class="line">     <span class="nl">fetchEntriesWithPredicate:</span><span class="n">predicate</span>
</span><span class="line">     <span class="nl">sortDescriptors:</span><span class="n">sortDescriptors</span>
</span><span class="line">     <span class="nl">completionBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSArray</span><span class="o">*</span> <span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">         <span class="k">if</span> <span class="p">(</span><span class="n">completionBlock</span><span class="p">)</span>
</span><span class="line">         <span class="p">{</span>
</span><span class="line">             <span class="n">completionBlock</span><span class="p">([</span><span class="n">welf</span> <span class="nl">todoItemsFromDataStoreEntries:</span><span class="n">entries</span><span class="p">]);</span>
</span><span class="line">         <span class="p">}</span>
</span><span class="line">     <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span><span class="o">*</span><span class="p">)</span><span class="nf">todoItemsFromDataStoreEntries:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">entries</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">entries</span> <span class="nl">arrayFromObjectsCollectedWithBlock:</span><span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="n">VTDManagedTodoItem</span> <span class="o">*</span><span class="n">todo</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="p">[</span><span class="n">VTDTodoItem</span> <span class="nl">todoItemWithDueDate:</span><span class="n">todo</span><span class="p">.</span><span class="n">date</span> <span class="nl">name:</span><span class="n">todo</span><span class="p">.</span><span class="n">name</span><span class="p">];</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>与 Core Data 一样极富争议的恐怕就是 UI 故事板了。故事板具有很多有用的功能，如果完全忽视它将会是一个错误。然而，调用故事版所能提供的所有功能来完成 VIPER 的所有目标仍然是很困难的。</p>

<p>我们所能做出的妥协就是选择不使用 segues 。有时候使用 segues 是有效的，但是使用 segues 的危险性在于它们很难原封不动地保持屏幕之间的分离，以及 UI 和应用逻辑之间的分离。一般来说，如果实现 prepareForSegue 方法是必须的话，我们就尽量不去使用 segues。</p>

<p>除此之外，故事板是一个实现用户界面布局有效方法，特别是在使用自动布局的时候。我们选择在实现待办事项两个界面的实例中使用故事板，并且使用这样的代码来执行自己的导航操作。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">static</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">ListViewControllerIdentifier</span> <span class="o">=</span> <span class="s">@&quot;VTDListViewController&quot;</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">VTDListWireframe</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">presentListInterfaceFromWindow:</span><span class="p">(</span><span class="n">UIWindow</span> <span class="o">*</span><span class="p">)</span><span class="nv">window</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">VTDListViewController</span> <span class="o">*</span><span class="n">listViewController</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">listViewControllerFromStoryboard</span><span class="p">];</span>
</span><span class="line">    <span class="n">listViewController</span><span class="p">.</span><span class="n">eventHandler</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">listPresenter</span><span class="p">;</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">listPresenter</span><span class="p">.</span><span class="n">userInterface</span> <span class="o">=</span> <span class="n">listViewController</span><span class="p">;</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">listViewController</span> <span class="o">=</span> <span class="n">listViewController</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">rootWireframe</span> <span class="nl">showRootViewController:</span><span class="n">listViewController</span>
</span><span class="line">                                      <span class="nl">inWindow:</span><span class="n">window</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">VTDListViewController</span> <span class="o">*</span><span class="p">)</span><span class="nf">listViewControllerFromStoryboard</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">UIStoryboard</span> <span class="o">*</span><span class="n">storyboard</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">mainStoryboard</span><span class="p">];</span>
</span><span class="line">    <span class="n">VTDListViewController</span> <span class="o">*</span><span class="n">viewController</span> <span class="o">=</span> <span class="p">[</span><span class="n">storyboard</span> <span class="nl">instantiateViewControllerWithIdentifier:</span><span class="n">ListViewControllerIdentifier</span><span class="p">];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">viewController</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">UIStoryboard</span> <span class="o">*</span><span class="p">)</span><span class="nf">mainStoryboard</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">UIStoryboard</span> <span class="o">*</span><span class="n">storyboard</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIStoryboard</span> <span class="nl">storyboardWithName:</span><span class="s">@&quot;Main&quot;</span>
</span><span class="line">                                                         <span class="nl">bundle:</span><span class="p">[</span><span class="n">NSBundle</span> <span class="n">mainBundle</span><span class="p">]];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">storyboard</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="viper">使用 VIPER 构建模块</h2>

<p>一般在使用 VIPER 的时候，你会发现一个屏幕或一组屏幕倾向于聚在一起作为一个模块。模块可以以多种形式体现，但一般最好把它想成是一种特性。在播客应用中，一个模块可能是音频播放器或订阅浏览器。然而在我们的待办事项应用中，列表和添加事项的屏幕都将作为单独的模块被建立。</p>

<p>将你的应用作为一组模块来设计有很多好处，其中之一就是模块可以有非常明确和定义良好的接口，并且独立于其他的模块。这就使增加或者移除特性变得更加简单，也使在界面中向用户展示各种可变模块变得更加简单。</p>

<p>我们希望能将待办事项中各模块之间分隔更加明确，我们为添加模块定义了两个协议。一个是模块接口，它定义了模块可以做什么；另一个则是模块的代理，用来描述该模块做了什么。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@protocol</span> <span class="nc">VTDAddModuleInterface</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
</span><span class="line">
</span><span class="line"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">cancelAddAction</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">saveAddActionWithName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="nf">dueDate:</span><span class="p">(</span><span class="n">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="nv">dueDate</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">@protocol</span> <span class="nc">VTDAddModuleDelegate</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
</span><span class="line">
</span><span class="line"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">addModuleDidCancelAddAction</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addModuleDidSaveAddAction</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>因为模块必须要被展示，才能对用户产生价值，所以模块的展示器通常需要实现模型的接口。当另一个模型想要展现当前模块时，它的展示器就需要实现模型的委托协议，这样它就能在展示时知道当前模块做了些什么。</p>

<p>一个模块可能包括实体，交互器和管理器的通用应用逻辑层，这些通常可用于多个屏幕。当然，这取决于这些屏幕之间的交互及它们的相似度。一个模块可以像在待办事项列表里面一样，简单的只代表一个屏幕。这样一来，应用逻辑层对于它的特定模块的行为来说就非常特有了。</p>

<p>模块同样是组织代码的简便途径。将模块所有的编码都放在它自己的文件夹中并在 Xcode 中建一个 group，这会在你需要寻找和改变更加容易。当你在要寻找一个类时，它恰到好处地就在你所期待的地方，这种感觉真是无法形容的棒。</p>

<p>利用 VIPER 建立模块的另一个好处是它使得扩展到多平台时变得更加简单。独立在交互器层中的所有用例的应用逻辑允许你可以专注于为平板，电话或者 Mac 构建新的用户界面，同时可以重用你的应用层。</p>

<p>进一步来说，iPad 应用的用户界面能够将部分 iPhone 应用的视图，视图控制器及展示器进行再利用。在这种情况下，iPad 屏幕将由 ‘super’ 展示器和线框来代表，这样可以利用 iPhone 使用过的展示器和线框来组成屏幕。建立进而维护一个跨多平台的应用是一个巨大的挑战，但是好的构架可以对整个模型和应用层的再利用有大幅度的提升，并使其实现起来更加容易。</p>

<h2 id="viper">利用 VIPER 进行测试</h2>

<p>VIPER 的出现激发了一个关注点的分离，这使得采用 TDD 变得更加简便。交互器包含独立与任何 UI 的纯粹逻辑，这使测试驱动开发更加简单。同时展示器包含用来为显示准备数据的逻辑，并且它也独立于任何一个 UIKit 部件。对于这个逻辑的开发也很容易用测试来驱动。</p>

<p>我们更倾向于先从交互器下手。用户界面里所有部分都服务于用例，而通过采用 TDD 来测试驱动交互器的 API 可以让你对用户界面和用例之间的关系有一个更好的了解。</p>

<p>作为实例，我们来看一下负责待办事项列表的交互器。寻找待办事项的策略是要找出所有的将在下周末前截止的项目，并将这些项目分别归类至截止于今天，明天，本周或者下周。</p>

<p>我们编写的第一个测试是为了保证交互器能够找到所有的截止于下周末的待办事项：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testFindingUpcomingItemsRequestsAllToDoItemsFromTodayThroughEndOfNextWeek</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[[</span><span class="n">self</span><span class="p">.</span><span class="n">dataManager</span> <span class="n">expect</span><span class="p">]</span> <span class="nl">todoItemsBetweenStartDate:</span><span class="n">self</span><span class="p">.</span><span class="n">today</span> <span class="nl">endDate:</span><span class="n">self</span><span class="p">.</span><span class="n">endOfNextWeek</span> <span class="nl">completionBlock:</span><span class="n">OCMOCK_ANY</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">interactor</span> <span class="n">findUpcomingItems</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>一旦知道了交互器找到了正确的待办事项后，我们就需要编写几个小测试用来确认它确实将待办事项分配到了正确的相对日期组内（比如说今天，明天，等等）。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testFindingUpcomingItemsWithOneItemDueTodayReturnsOneUpcomingItemsForToday</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSArray</span> <span class="o">*</span><span class="n">todoItems</span> <span class="o">=</span> <span class="err">@</span><span class="p">[[</span><span class="n">VTDTodoItem</span> <span class="nl">todoItemWithDueDate:</span><span class="n">self</span><span class="p">.</span><span class="n">today</span> <span class="nl">name:</span><span class="s">@&quot;Item 1&quot;</span><span class="p">]];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">dataStoreWillReturnToDoItems:</span><span class="n">todoItems</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSArray</span> <span class="o">*</span><span class="n">upcomingItems</span> <span class="o">=</span> <span class="err">@</span><span class="p">[[</span><span class="n">VTDUpcomingItem</span> <span class="nl">upcomingItemWithDateRelation:</span><span class="n">VTDNearTermDateRelationToday</span> <span class="nl">dueDate:</span><span class="n">self</span><span class="p">.</span><span class="n">today</span> <span class="nl">title:</span><span class="s">@&quot;Item 1&quot;</span><span class="p">]];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">expectUpcomingItems:</span><span class="n">upcomingItems</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">interactor</span> <span class="n">findUpcomingItems</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>既然我们已经知道了交互器的 API 长什么样，接下来就是开发展示器。一旦展示器接收到了交互器传来的待办事项，我们就需要测试看看我们是否适当的将数据进行格式化并且在用户界面中正确的显示它。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testFoundZeroUpcomingItemsDisplaysNoContentMessage</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[[</span><span class="n">self</span><span class="p">.</span><span class="n">ui</span> <span class="n">expect</span><span class="p">]</span> <span class="n">showNoContentMessage</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">presenter</span> <span class="nl">foundUpcomingItems:</span><span class="err">@</span><span class="p">[]];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testFoundUpcomingItemForTodayDisplaysUpcomingDataWithNoDay</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">VTDUpcomingDisplayData</span> <span class="o">*</span><span class="n">displayData</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">displayDataWithSectionName:</span><span class="s">@&quot;Today&quot;</span>
</span><span class="line">                                                          <span class="nl">sectionImageName:</span><span class="s">@&quot;check&quot;</span>
</span><span class="line">                                                                 <span class="nl">itemTitle:</span><span class="s">@&quot;Get a haircut&quot;</span>
</span><span class="line">                                                                <span class="nl">itemDueDay:</span><span class="s">@&quot;&quot;</span><span class="p">];</span>
</span><span class="line">    <span class="p">[[</span><span class="n">self</span><span class="p">.</span><span class="n">ui</span> <span class="n">expect</span><span class="p">]</span> <span class="nl">showUpcomingDisplayData:</span><span class="n">displayData</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSCalendar</span> <span class="o">*</span><span class="n">calendar</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSCalendar</span> <span class="n">gregorianCalendar</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSDate</span> <span class="o">*</span><span class="n">dueDate</span> <span class="o">=</span> <span class="p">[</span><span class="n">calendar</span> <span class="nl">dateWithYear:</span><span class="mi">2014</span> <span class="nl">month:</span><span class="mi">5</span> <span class="nl">day:</span><span class="mi">29</span><span class="p">];</span>
</span><span class="line">    <span class="n">VTDUpcomingItem</span> <span class="o">*</span><span class="n">haircut</span> <span class="o">=</span> <span class="p">[</span><span class="n">VTDUpcomingItem</span> <span class="nl">upcomingItemWithDateRelation:</span><span class="n">VTDNearTermDateRelationToday</span> <span class="nl">dueDate:</span><span class="n">dueDate</span> <span class="nl">title:</span><span class="s">@&quot;Get a haircut&quot;</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">presenter</span> <span class="nl">foundUpcomingItems:</span><span class="err">@</span><span class="p">[</span><span class="n">haircut</span><span class="p">]];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testFoundUpcomingItemForTomorrowDisplaysUpcomingDataWithDay</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">VTDUpcomingDisplayData</span> <span class="o">*</span><span class="n">displayData</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">displayDataWithSectionName:</span><span class="s">@&quot;Tomorrow&quot;</span>
</span><span class="line">                                                          <span class="nl">sectionImageName:</span><span class="s">@&quot;alarm&quot;</span>
</span><span class="line">                                                                 <span class="nl">itemTitle:</span><span class="s">@&quot;Buy groceries&quot;</span>
</span><span class="line">                                                                <span class="nl">itemDueDay:</span><span class="s">@&quot;Thursday&quot;</span><span class="p">];</span>
</span><span class="line">    <span class="p">[[</span><span class="n">self</span><span class="p">.</span><span class="n">ui</span> <span class="n">expect</span><span class="p">]</span> <span class="nl">showUpcomingDisplayData:</span><span class="n">displayData</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSCalendar</span> <span class="o">*</span><span class="n">calendar</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSCalendar</span> <span class="n">gregorianCalendar</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSDate</span> <span class="o">*</span><span class="n">dueDate</span> <span class="o">=</span> <span class="p">[</span><span class="n">calendar</span> <span class="nl">dateWithYear:</span><span class="mi">2014</span> <span class="nl">month:</span><span class="mi">5</span> <span class="nl">day:</span><span class="mi">29</span><span class="p">];</span>
</span><span class="line">    <span class="n">VTDUpcomingItem</span> <span class="o">*</span><span class="n">groceries</span> <span class="o">=</span> <span class="p">[</span><span class="n">VTDUpcomingItem</span> <span class="nl">upcomingItemWithDateRelation:</span><span class="n">VTDNearTermDateRelationTomorrow</span> <span class="nl">dueDate:</span><span class="n">dueDate</span> <span class="nl">title:</span><span class="s">@&quot;Buy groceries&quot;</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">presenter</span> <span class="nl">foundUpcomingItems:</span><span class="err">@</span><span class="p">[</span><span class="n">groceries</span><span class="p">]];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>同样需要测试的是应用是否在用户想要新建待办事项时正确启动了相应操作：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testAddNewToDoItemActionPresentsAddToDoUI</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[[</span><span class="n">self</span><span class="p">.</span><span class="n">wireframe</span> <span class="n">expect</span><span class="p">]</span> <span class="n">presentAddInterface</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">presenter</span> <span class="n">addNewEntry</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这时我们可以开发视图功能了，并且在没有待办事项的时候我们想要展示一个特殊的信息。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testShowingNoContentMessageShowsNoContentView</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="n">showNoContentMessage</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">XCTAssertEqualObjects</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">view</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">noContentView</span><span class="p">,</span> <span class="s">@&quot;the no content view should be the view&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>有待办事项出现时，我们要确保列表是显示出来的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testShowingUpcomingItemsShowsTableView</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">showUpcomingDisplayData:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">XCTAssertEqualObjects</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">view</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">tableView</span><span class="p">,</span> <span class="s">@&quot;the table view should be the view&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>首先建立交互器是一种符合 TDD 的自然规律。如果你首先开发交互器，紧接着是展示器，你就可以首先建立一个位于这些层的套件测试，并且为实现这是实例奠定基础。由于你不需要为了测试它们而去与用户界面进行交互，所以这些类可以进行快速迭代。在你需要开发视图的时候，你会有一个可以工作并测试过的逻辑和表现层来与其进行连接。在快要完成对视图的开发时，你会发现第一次运行程序时所有部件都运行良好，因为你所有已通过的测试已经告诉你它可以工作。</p>

<h2>结论</h2>

<p>我们希望你喜欢这篇对 VIPER 的介绍。或许你们都很好奇接下来应该做什么，如果你希望通过 VIPER 来对你下一个应用进行设计，该从哪里开始呢？</p>

<p>我们竭尽全力使这篇文章和我们利用 VIPER 实现的应用实例足够明确并且进行了很好的定义。我们的待办事项里列表程序相当直接简单，但是它准确地解释了如何利用 VIPER 来建立一个应用。在实际的项目中，你可以根据你自己的挑战和约束条件来决定要如何实践这个例子。根据以往的经验，我们的每个项目在使用 VIPER 时都或多或少地改变了一些策略，但它们无一例外的都从中得益，找到了正确的方向。</p>

<p>很多情况下由于某些原因，你可能会想要偏离 VIPER 所指引的道路。可能你遇到了很多 <a href="http://inessential.com/2014/03/16/smaller_please">&#8216;bunny&#8217;</a> 对象，或者你的应用使用了故事板的 segues。没关系的，在这些情况下，你只需要在做决定时稍微考虑下 VIPER 所代表的精神就好。VIPER 的核心在于它是建立在<a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">单一责任原则</a>上的架构。如果你碰到了些许麻烦，想想这些原则再考虑如何前进。</p>

<p>你一定想知道在现有的应用中能否只用 VIPER 。在这种情况下，你可以考虑使用 VIPER 构建新的特性。我们许多现有项目都使用了这个方法。你可以利用 VIPER 建立一个模块，这能帮助你发现许多建立在单一责任原则基础上造成难以运用架构的现有问题。</p>

<p>软件开发最伟大的事情之一就是每个应用程序都是不同的，而设计每个应用的架构的方式也是不同的。这就意味着每个应用对于我们来说都是一个学习和尝试的机遇，如果你决定开始使用 VIPER，你会受益匪浅。感谢你的阅读。</p>

<h2 id="swifit">Swifit 补充</h2>

<p>苹果上周在 WWDC 介绍了一门称之为 <a href="https://developer.apple.com/swift/">Swift</a> 的编程语言来作为 Cocoa 和 Cocoa Touch 开发的未来。现在发表关于 Swift 的完整意见还为时尚早，但众所周知编程语言对我们如何设计和构建应用有着重大影响。我们决定使用 <a href="https://github.com/objcio/issue-13-viper-swift">Swift 重写我们的待办事项清单</a>，帮助我们学习它对 VIPER 意味着什么。至今为止，收获颇丰。Swift 中的一些特性对于构建应用的体验有着显著的提升。</p>

<h3>结构体</h3>

<p>在 VIPER 中我们使用小型，轻量级的 model 类来在比如从展示器到视图这样不同的层间传递数据。这些 PONSOs 通常是只是简单地带有少量数据，并且通常这些类不会被继承。Swift 的结构体非常适合这个情况。下面的结构体的例子来自 VIPER Swift。这个结构体需要被判断是否相等，所以我们重载了 == 操作符来比较这个类型的两个实例。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">struct</span> <span class="n">UpcomingDisplayItem</span> <span class="o">:</span> <span class="n">Equatable</span><span class="p">,</span> <span class="n">Printable</span> <span class="p">{</span>
</span><span class="line">    <span class="n">let</span> <span class="n">title</span> <span class="o">:</span> <span class="n">String</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
</span><span class="line">    <span class="n">let</span> <span class="n">dueDate</span> <span class="o">:</span> <span class="n">String</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
</span><span class="line">
</span><span class="line">    <span class="n">var</span> <span class="n">description</span> <span class="o">:</span> <span class="n">String</span> <span class="p">{</span> <span class="n">get</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="s">&quot;\(title) -- \(dueDate)&quot;</span>
</span><span class="line">    <span class="p">}}</span>
</span><span class="line">
</span><span class="line">    <span class="n">init</span><span class="p">(</span><span class="nl">title:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">dueDate:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">dueDate</span> <span class="o">=</span> <span class="n">dueDate</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">func</span> <span class="o">==</span> <span class="p">(</span><span class="nl">leftSide:</span> <span class="n">UpcomingDisplayItem</span><span class="p">,</span> <span class="nl">rightSide:</span> <span class="n">UpcomingDisplayItem</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class="line">    <span class="n">var</span> <span class="n">hasEqualSections</span> <span class="o">=</span> <span class="n">false</span>
</span><span class="line">    <span class="n">hasEqualSections</span> <span class="o">=</span> <span class="n">rightSide</span><span class="p">.</span><span class="n">title</span> <span class="o">==</span> <span class="n">leftSide</span><span class="p">.</span><span class="n">title</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="n">hasEqualSections</span> <span class="o">==</span> <span class="n">false</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">false</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">hasEqualSections</span> <span class="o">=</span> <span class="n">rightSide</span><span class="p">.</span><span class="n">dueDate</span> <span class="o">==</span> <span class="n">rightSide</span><span class="p">.</span><span class="n">dueDate</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">hasEqualSections</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3>类型安全</h3>

<p>也许 Objective-C 和 Swift 的最大区别是它们在对于类型处理上的不同。 Objective-C 是动态类型，而 Swift 故意在编译时做了严格的类型检查。对于一个类似 VIPER 的架构， 应用由不同层构成，类型安全是提升程序员效率和设计架构有非常大的好处。编译器帮助你确保正确类型的容器和对象在层的边界传递。如上所示，这是一个使用结构体的好地方。如果一个结构体的被设计为存在于两层之间，那么由于类型安全，你可以保证它将永远无法脱离这些层之间。</p>

<h2>扩展阅读</h2>

<ul>
<li><a href="https://github.com/objcio/issue-13-viper">VIPER TODO, 文章示例</a></li>
<li><a href="https://github.com/objcio/issue-13-viper-swift">VIPER SWIFT, 基于 Swift 的文章示例</a></li>
<li><a href="https://github.com/mutualmobile/Counter">另一个计数器应用</a></li>
<li><a href="http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/">Mutual Mobile 关于 VIPER 的介绍</a></li>
<li><a href="http://blog.8thlight.com/uncle-bob/2011/11/22/Clean-Architecture.html">简明架构</a></li>
<li><a href="http://objccn.io/issue-1-1/">更轻量的 View Controllers</a></li>
<li><a href="http://objccn.io/issue-1-3/">测试 View Controllers</a></li>
<li><a href="http://inessential.com/2014/03/16/smaller_please">Bunnies</a></li>
</ul>

<script type="text/javascript" id="wumiiRelatedItems"></script>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC的子类]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/06/18/ocde-zi-lei/"/>
    <updated>2014-06-18T09:23:01+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/06/18/ocde-zi-lei</id>
    <content type="html"><![CDATA[<p>这篇文章跟我以往的文章有点不一样。它主要是一些思想与模式的汇集，而不是一篇指南。下面我所写的模式几乎全都来之不易，都是我犯了错之后才学到的。我并不认为自己是子类方面的权威，但我确实想把我学到的一些东西分享出来。别把本文当做权威指南，它只是一些例子的汇集。</p>

<p>在被问到 OOP（面向对象编程）的时候，Alan Kay（OOP 的发明人）写到：它跟类无关，但跟消息有关。<a href="http://c2.com/cgi/wiki?AlanKayOnMessaging">^1</a>然而，很多人的关注点仍然还在类层次上。在本文中，我们会看几个我们可能会把注意力放在创建复杂的类结构上的例子，并给出更有用的替代方案。根据经验，这样会让代码更简单，更易维护。关于这个话题，在 <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code</a>（中文版：<a href="http://www.amazon.cn/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E9%A9%AC%E4%B8%81/dp/B0031M9GHC/ref=pd_bxgy_b_img_y">代码整洁之道</a>）和 <a href="http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670">Code Complete</a>（中文版：<a href="http://www.amazon.cn/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E5%8F%B2%E8%92%82%E5%A4%AB%E2%80%A2%E8%BF%88%E5%85%8B%E5%BA%B7%E5%A5%88%E5%B0%94/dp/B0061XKRXA/ref=pd_bxgy_b_img_z">代码大全</a>）中已经有大量讨论。推荐你阅读这两本书。</p>

<h2>何时用子类</h2>

<p>首先，我们讨论几种使用子类比较合适的场景。如果你要写一个自定义布局的 <code>UITableViewCell</code> ，那就创建一个子类。这同样适用于几乎每个视图。一旦你开始布局，把这块代码放入子类就更合理一些，不光代码得到了更好的封装，你也能得到一个可在工程之间重用的组件。</p>
<!-- more -->
<p>假设你的代码是针对多平台多版本的，并且你需要针对每个平台每个版本写一些代码。这时候更合理的做法可能是创建一个 <code>OBJDevice</code> 类，让一些子类如 <code>OBJIPhoneDevice</code> 和 <code>OBJIPadDevice</code> ，甚至更深层的子类如 <code>OBJIPhone5Device</code> 来继承，并让这些子类重写特定的方法。例如，你的 OBJDevice 类可能包含了函数 <code>applyRoundedCornersToView:withRadius</code> ，它有一个默认的实现，但是也能被特定的子类重写。</p>

<p>另一个子类化可能很有用的场景是模型对象（model object）。绝大多数情况下，我的模型对象继承自一个实现了 <code>isEqual:</code> 、 <code>hash</code> 、 <code>copyWithZone:</code> 和 <code>description</code> 等方法的类。这些方法只被实现一次，并且迭代循环遍历所有属性，所以极不容易出错。（如果你也想找一个这样的基类，可以考虑使用 <a href="https://github.com/mantle/mantle">Mantle</a> ，它就是这么做的，并且做得更多。）</p>

<h2>何时不使用子类</h2>

<p>在以往工作过的很多工程中，我见到过很多继承层次很深的子类。当我也这么干的时候，总会感到内疚。除非继承的层次非常浅，否则你会很快发现它的局限性。<a href="http://c2.com/cgi/wiki?LimitsOfHierarchies">^2</a></p>

<p>幸运的是，如果你发现自己正在使用深层次的继承，还有很多替代方案可选。在下面的章节中，我们会逐个进行更详细地描述。如果你的子类只是使用相同的接口，协议会是个非常好的替代方案。如果你知道某个对象需要大量的修改，你可能会使用代理来动态改变和配置它。当你想给已有对象增加一些简单功能时，类别可能是个选择。当你有一堆重写了相同方法的子类时，你可以使用配置对象（configuration object）来代替。最后，当你想重用某些功能时，组合多个对象而不是扩展它们可能会更好。</p>

<h2>替代方案</h2>

<h3 id="protocols">替代方案：协议（Protocols）</h3>

<p>很多时候，使用子类的原因是你想保证某个对象可以响应某些消息。假设在 app 里你有一个播放器对象，它可以播放视频。现在你想添加对 YouTube 的支持，使用相同的接口，但是具体实现不同。你可以使像这样用子类来实现：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@class Player : NSObject
</span><span class="line">
</span><span class="line">- (void)play;
</span><span class="line">- (void)pause;
</span><span class="line">
</span><span class="line">@end
</span><span class="line">
</span><span class="line">
</span><span class="line">@class YouTubePlayer : Player
</span><span class="line">
</span><span class="line">@end</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>事实上可能这两个类并没有太多共用的代码，它们只不过具有相同的接口。如果这样的话，使用协议可能会是更好的方案。可以这样用协议来写你的代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@protocol</span> <span class="nc">VideoPlayer</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
</span><span class="line">
</span><span class="line"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">play</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">pause</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">@class</span> <span class="nc">Player</span> <span class="o">:</span> <span class="n">NSObject</span> <span class="o">&lt;</span><span class="n">VideoPlayer</span><span class="o">&gt;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">@class</span> <span class="nc">YouTubePlayer</span> <span class="o">:</span> <span class="n">NSObject</span> <span class="o">&lt;</span><span class="n">VideoPlayer</span><span class="o">&gt;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样，<code>YouTubePlayer</code> 类就不必知道 <code>Player</code> 类的内部实现了。</p>

<h3 id="delegation">替代方案：代理（Delegation）</h3>

<p>再一次假设你有一个像上面例子中的 <code>Player</code> 类。现在，你想在开始播放的时候在某个地方执行一个自定义的函数。这么做相对容易一些：创建一个自定义的子类，重写 <code>play</code> 方法，调用 <code>[super play ]</code>，然后开始做你自定义的工作。这么做是一种方法。另外一种方法是，改动你的 <code>Player</code> 对象，然后给它设置一个代理。如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@class</span> <span class="nc">Player</span>;
</span><span class="line">
</span><span class="line"><span class="k">@protocol</span> <span class="nc">PlayerDelegate</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">playerDidStartPlaying:</span><span class="p">(</span><span class="n">Player</span> <span class="o">*</span><span class="p">)</span><span class="nv">player</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">@class</span> <span class="nc">Player</span> <span class="o">:</span> <span class="n">NSObject</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span><span class="n">weak</span><span class="p">)</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">PlayerDelegate</span><span class="o">&gt;</span> <span class="n">delegate</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">play</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">pause</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在，在播放器的 <code>play</code> 方法里，就可以给代理发送 <code>playerDidStartPlaying:</code> 消息了。这个 <code>Player</code> 类的任何使用者都可以仅仅实现这个代理协议，而不用继承该该类， <code>Player</code> 类也能够保持通用性。这是个强大有效的技术，苹果在自己的框架里大量地使用它。你想想像 <code>UITextField</code> 这样的类，还有 <code>NSLayoutManager</code>。有时候你还会想把几个不同的方法打包分组到几个单独的协议里，比如 <code>UITableView</code> —— 它不仅有一个代理（delegate），还有一个数据源（dataSource）。</p>

<h3 id="categories">替代方案：类别（Categories）</h3>

<p>有时候，你可能会想给一个对象增加一点点额外的功能。比如你想给 <code>NSArray</code> 增加一个方法 <code>arrayByRemovingFirstObject</code>。不用子类，你可以把这个函数放到一个类别里。像这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">NSArray</span> <span class="nl">(OBJExtras)</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">obj_arrayByRemovingFirstObject</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在用类别扩展一个不是你自己的类的时候，在方法前添加前缀是个比较好的习惯做法。如果不这么做，有可能别人也用类别对此类添加了相同名字的函数。那时候程序的行为可能跟你想要的并不一样，未预期的事情可能会发生。</p>

<p>使用类别还有另外一个风险，那就是，到最后你可能会使用一大堆的类别，连你自己都会失去对代码全局的认识。假如那样的话，创建自定义的类可能更简单一些。</p>

<h3 id="configurationobjects">替代方案：配置对象（Configuration Objects）</h3>

<p>在我经常会犯的错误中（现在很快就能发现了），其中有一条是：使用一个含有几个抽象方法的类并让很多子类来重写某个方法。例如，在一个幻灯片应用里，你有一个主题类 <code>Theme</code> ，它有几个属性，比如 <code>backgroundColor</code> 和 <code>font</code> ，还有一些在一张幻灯片上如何布局的逻辑函数。</p>

<p>然后，对每种主题，你都创建一个 <code>Theme</code> 的子类，重写某个函数（例如 <code>setup</code> ）并配置其属性。直接使用父类对此做不了什么事。在这种情况下，你可以使用配置对象来让代码更简单些。你可以把共有的逻辑（比如幻灯片布局）放在 <code>Theme</code> 类中，把属性的配置放到较简单的对象中，这些对象中只含有这些属性。</p>

<p>例如，类 <code>ThemeConfiguration</code> 具有 <code>backgroundColor</code> 和 <code>font</code> 属性，而类 <code>Theme</code> 在其初始化函数中获取一个配置类 <code>ThemeConfiguration</code> 的值。</p>

<h3>替代方案：组合</h3>

<p>组合是代替子类化的最强大有效的方案。如果你想重用已有代码而不想共享同样的接口，组合就是你的首选武器。例如，假设你要设计一个缓存类：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">OBJCache</span> : <span class="nc">NSObject</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">cacheValue:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">value</span> <span class="nf">forKey:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeCachedValueForKey:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>简单点的做法是直接继承 <code>NSDictionary</code>，通过调用字典的函数来实现上面的两个方法。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">OBJCache</span> : <span class="nc">NSDictionary</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>但是这么做有几个弊端。它本来是应该被详细实现的，但只是通过字典来实现。现在，在任何需要一个 <code>NSDictionary</code> 参数的时候，你可以直接提供一个 <code>OBJCache</code> 值。但如果你想把它转为其它完全不同的东西（例如你自己的库），你就可能需要重构很多代码了。</p>

<p>更好的方式是，将这个字典存在一个私有属性（或者实例变量）中，对外仅仅暴露这两个 <code>cache</code> 方法。现在，当你有了更深入想法的时候，你可以在灵活地修改其实现，而该类的使用者们不用进行重构。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVVM介绍]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/06/17/mvvmjie-shao/"/>
    <updated>2014-06-17T11:48:19+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/06/17/mvvmjie-shao</id>
    <content type="html"><![CDATA[<p>有时我感觉就像我不知道在做什么。虽然我知道自己的设计模式——就像任何好的编程人员那样 —— 但我太接近我在做的产品以至于不能客观地衡量我的架构决策的有效性。当队伍中来了另外一位开发者时，我意识到我们陷入困境了。</p>

<p>从没听过 MVC ？有人称之为 Massive View Controller（重量级视图控制器），这就是我们那时候的感觉。我不打算介绍令人汗颜的细节，但说实在的，如果我不得不再次重来一次，我绝对会做出不同的决策。</p>

<p>我会修改一个关键架构，并将其带入我从那时起就在开发的各种应用，即使用一种叫做 Model-View-ViewModel 的架构替换 Model-View-Controller。</p>

<p>所以，MVVM 到底是什么？与其专注于说明 MVVM 的来历，不如让我们看一个典型的 iOS 是如何构建的，并从那里了解 MVVM：</p>

<p><img src="http://img.objccn.io/issue-13/mvvm1.png" alt="Typical Model-View-Controller setup" /></p>

<p>我们看到的是一个典型的 MVC 设置。Model 呈现数据，View 呈现用户界面，而 View Controller 调节它两者之间的交互。Cool！</p>

<p>稍微考虑一下，虽然 View 和 View Controller 是技术上不同的组件，但它们几乎总是手牵手在一起，成对的。你什么时候看到一个 View 能够与不同 View Controller 配对？或者反过来？所以，为什么不正规化它们的连接呢？</p>
<!-- more -->
<p><img src="http://img.objccn.io//issue-13/intermediate.png" alt="Intermediate" /></p>

<p>这更准确地描述了你可能已经编写的 MVC 代码。但它并没有做太多事情来解决 iOS 应用中日益增长的重量级视图控制器的问题。在典型的 MVC 应用里，<em>许多</em>逻辑被放在 View Controller 里。它们中的一些确实属于 View Controller，但更多的是所谓的“表示逻辑（presentation logic）”，以 MVVM 属术语来说，就是那些将 Model 数据转换为 View 可以呈现的东西的事情，例如将一个 <code>NSDate</code> 转换为一个格式化过的 <code>NSString</code>。</p>

<p>我们的图解里缺少某些东西，那些使我们可以把所有表示逻辑放进去的东西。我们打算将其称为 “View Model” —— 它位于 View/Controller 与 Model 之间：</p>

<p><img src="http://img.objccn.io//issue-13/mvvm.png" alt="Model-View-ViewModel" /></p>

<p>看起好多了！这个图解准确地描述了什么是 MVVM：一个 MVC 的增强版，我们正式连接了视图和控制器，并将表示逻辑从 Controller 移出放到一个新的对象里，即 View Model。MVVM 听起来很复杂，但它本质上就是一个精心优化的 MVC 架构，而 MVC 你早已熟悉。</p>

<p>现在我们知道了<em>什么</em>是 MVVM，但<em>为什么</em>我们会想要去使用它呢？在 iOS 上使用 MVVM 的动机，对我来说，无论如何，就是它能减少 View Controller 的复杂性并使得表示逻辑更易于测试。通过一些例子，我们将看到它如何达到这些目标。</p>

<p>此处有三个重点是我希望你看完本文能带走的：</p>

<ul>
<li>MVVM 可以兼容你当下使用的 MVC 架构。</li>
<li>MVVM 增加你的应用的可测试性。</li>
<li>MVVM 配合一个绑定机制效果最好。</li>
</ul>

<p>如我们之前所见，MVVM 基本上就是 MVC 的改进版，所以很容易就能看到它如何被整合到现有使用典型 MVC 架构的应用中。让我们看一个简单的 <code>Person</code> Model 以及相应的 View Controller：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">Person</span> : <span class="nc">NSObject</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initwithSalutation:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">salutation</span> <span class="nf">firstName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">firstName</span> <span class="nf">lastName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">lastName</span> <span class="nf">birthdate:</span><span class="p">(</span><span class="n">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="nv">birthdate</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">salutation</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">firstName</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">lastName</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">NSDate</span> <span class="o">*</span><span class="n">birthdate</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Cool！现在我们假设我们有一个 <code>PersonViewController</code> ，在 <code>viewDidLoad</code> 里，只需要基于它的 <code>model</code> 属性设置一些 Label 即可。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">salutation</span><span class="p">.</span><span class="n">length</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">nameLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%@ %@ %@&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">salutation</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">firstName</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">lastName</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">nameLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%@ %@&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">firstName</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">lastName</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSDateFormatter</span> <span class="o">*</span><span class="n">dateFormatter</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSDateFormatter</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">setDateFormat:</span><span class="s">@&quot;EEEE MMMM d, yyyy&quot;</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">birthdateLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">stringFromDate:</span><span class="n">model</span><span class="p">.</span><span class="n">birthdate</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这全都直截了当，标准的 MVC。现在来看看我们如何用一个 View Model 来增强它。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">PersonViewModel</span> : <span class="nc">NSObject</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithPerson:</span><span class="p">(</span><span class="n">Person</span> <span class="o">*</span><span class="p">)</span><span class="nv">person</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">Person</span> <span class="o">*</span><span class="n">person</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">nameText</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">birthdateText</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们的 View Model 的实现大概如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">PersonViewModel</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithPerson:</span><span class="p">(</span><span class="n">Person</span> <span class="o">*</span><span class="p">)</span><span class="nv">person</span> <span class="p">{</span>
</span><span class="line">    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">_person</span> <span class="o">=</span> <span class="n">person</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="n">salutation</span><span class="p">.</span><span class="n">length</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">_nameText</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%@ %@ %@&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">person</span><span class="p">.</span><span class="n">salutation</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">person</span><span class="p">.</span><span class="n">firstName</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">person</span><span class="p">.</span><span class="n">lastName</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">        <span class="n">_nameText</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%@ %@&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">person</span><span class="p">.</span><span class="n">firstName</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">person</span><span class="p">.</span><span class="n">lastName</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSDateFormatter</span> <span class="o">*</span><span class="n">dateFormatter</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSDateFormatter</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">setDateFormat:</span><span class="s">@&quot;EEEE MMMM d, yyyy&quot;</span><span class="p">];</span>
</span><span class="line">    <span class="n">_birthdateText</span> <span class="o">=</span> <span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">stringFromDate:</span><span class="n">person</span><span class="p">.</span><span class="n">birthdate</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Cool！我们已经将 <code>viewDidLoad</code> 中的表示逻辑放入我们的 View Model 里了。此时，我们新的 <code>viewDidLoad</code> 就会非常轻量：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">nameLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">.</span><span class="n">nameText</span><span class="p">;</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">birthdateLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">.</span><span class="n">birthdateText</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>所以，如你所见，并没有对我们的 MVC 架构做太多改变。还是同样的代码，只不过移动了位置。它与 MVC 兼容，带来<a href="http://objccn.io/issue-1/">更轻量的 View Controllers</a>。</p>

<p>可测试，嗯？是怎样？好吧，View Controller 是出了名的难以测试，因为它们做了太多事情。在 MVVM 里，我们试着尽可能多的将代码移入 View Model 里。测试 View Controller 就变得容易多了，因为它们不再做一大堆事情，并且 View Model 也非常易于测试。让我们来看看：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">SpecBegin</span><span class="p">(</span><span class="n">Person</span><span class="p">)</span>
</span><span class="line">    <span class="n">NSString</span> <span class="o">*</span><span class="n">salutation</span> <span class="o">=</span> <span class="s">@&quot;Dr.&quot;</span><span class="p">;</span>
</span><span class="line">    <span class="n">NSString</span> <span class="o">*</span><span class="n">firstName</span> <span class="o">=</span> <span class="s">@&quot;first&quot;</span><span class="p">;</span>
</span><span class="line">    <span class="n">NSString</span> <span class="o">*</span><span class="n">lastName</span> <span class="o">=</span> <span class="s">@&quot;last&quot;</span><span class="p">;</span>
</span><span class="line">    <span class="n">NSDate</span> <span class="o">*</span><span class="n">birthdate</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDate</span> <span class="nl">dateWithTimeIntervalSince1970:</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">it</span> <span class="p">(</span><span class="s">@&quot;should use the salutation available. &quot;</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">        <span class="n">Person</span> <span class="o">*</span><span class="n">person</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Person</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSalutation:</span><span class="n">salutation</span> <span class="nl">firstName:</span><span class="n">firstName</span> <span class="nl">lastName:</span><span class="n">lastName</span> <span class="nl">birthdate:</span><span class="n">birthdate</span><span class="p">];</span>
</span><span class="line">        <span class="n">PersonViewModel</span> <span class="o">*</span><span class="n">viewModel</span> <span class="o">=</span> <span class="p">[[</span><span class="n">PersonViewModel</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithPerson:</span><span class="n">person</span><span class="p">];</span>
</span><span class="line">        <span class="n">expect</span><span class="p">(</span><span class="n">viewModel</span><span class="p">.</span><span class="n">nameText</span><span class="p">).</span><span class="n">to</span><span class="p">.</span><span class="n">equal</span><span class="p">(</span><span class="s">@&quot;Dr. first last&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="p">});</span>
</span><span class="line">
</span><span class="line">    <span class="n">it</span> <span class="p">(</span><span class="s">@&quot;should not use an unavailable salutation. &quot;</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">        <span class="n">Person</span> <span class="o">*</span><span class="n">person</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Person</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSalutation:</span><span class="nb">nil</span> <span class="nl">firstName:</span><span class="n">firstName</span> <span class="nl">lastName:</span><span class="n">lastName</span> <span class="nl">birthdate:</span><span class="n">birthdate</span><span class="p">];</span>
</span><span class="line">        <span class="n">PersonViewModel</span> <span class="o">*</span><span class="n">viewModel</span> <span class="o">=</span> <span class="p">[[</span><span class="n">PersonViewModel</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithPerson:</span><span class="n">person</span><span class="p">];</span>
</span><span class="line">        <span class="n">expect</span><span class="p">(</span><span class="n">viewModel</span><span class="p">.</span><span class="n">nameText</span><span class="p">).</span><span class="n">to</span><span class="p">.</span><span class="n">equal</span><span class="p">(</span><span class="s">@&quot;first last&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="p">});</span>
</span><span class="line">
</span><span class="line">    <span class="n">it</span> <span class="p">(</span><span class="s">@&quot;should use the correct date format. &quot;</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">        <span class="n">Person</span> <span class="o">*</span><span class="n">person</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Person</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSalutation:</span><span class="nb">nil</span> <span class="nl">firstName:</span><span class="n">firstName</span> <span class="nl">lastName:</span><span class="n">lastName</span> <span class="nl">birthdate:</span><span class="n">birthdate</span><span class="p">];</span>
</span><span class="line">        <span class="n">PersonViewModel</span> <span class="o">*</span><span class="n">viewModel</span> <span class="o">=</span> <span class="p">[[</span><span class="n">PersonViewModel</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithPerson:</span><span class="n">person</span><span class="p">];</span>
</span><span class="line">        <span class="n">expect</span><span class="p">(</span><span class="n">viewModel</span><span class="p">.</span><span class="n">birthdateText</span><span class="p">).</span><span class="n">to</span><span class="p">.</span><span class="n">equal</span><span class="p">(</span><span class="s">@&quot;Thursday January 1, 1970&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="p">});</span>
</span><span class="line"><span class="n">SpecEnd</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果我们没有将这个逻辑移入 View Model，我们将不得不实例化一个完整的 View Controller 以及伴随的 View，然后去比较我们 View 中 Lable 的值。这样做不只是会变成一个麻烦的间接层，而且它只代表了一个十分脆弱的测试。现在，我们可以按意愿自由地修改视图层级而不必担心破坏我们的单元测试。使用 MVVM 带来的对于测试的好处非常清晰，甚至从这个简单的例子来看也可见一斑，而在有更复杂的表示逻辑的情况下，这个好处会更加明显。</p>

<p>注意到在这个简单的例子中， Model 是不可变的，所以我们可以只在初始化的时候指定我们 View Model 的属性。对于可变 Model，我们还需要使用一些绑定机制，这样 View Model 就能在背后的 Model 改变时更新自身的属性。此外，一旦 View Model 上的 Model 发生改变，那 View 的属性也需要更新。Model 的改变应该级联向下通过 View Model 进入 View。</p>

<p>在 OS X 上，我们可以使用 Cocoa 绑定，但在 iOS 上我们并没有这样好的配置可用。我们想到了 KVO（Key-Value Observation），而且它确实做了很伟大的工作。然而，对于一个简单的绑定都需要很大的样板代码，更不用说有许多属性需要绑定了。作为替代，我个人喜欢使用 ReactiveCocoa，但 MVVM 并未强制我们使用 ReactiveCocoa。MVVM 是一个伟大的典范，它自身独立，只是在有一个良好的绑定框架时做得更好。</p>

<p>我们覆盖了不少内容：从普通的 MVC 派生出 MVVM，看它们是如何相兼容的范式，从一个可测试的例子观察 MVVM，并看到 MVVM 在有一个配对的绑定机制时工作得更好。如果你有兴趣学习更多关于 MVVM 的知识，你可以看看<a href="http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/">这篇博客</a>，它用更多细节解释了 MVVM 的好处，或者<a href="http://www.teehanlax.com/blog/krush-ios-architecture/">这一篇</a>关于我们如何在最近的项目里使用 MVVM 获得巨大的成功的文章。我同样还有一个经过完整测试，基于 MVVM 的应用，叫做 <a href="https://github.com/AshFurrow/C-41">C-41</a> ，它是开源的。去看看吧，如果你有任何疑问，请<a href="http://weibo.com/u/1651400041">告诉我</a>。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[交互式动画]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/23/jiao-hu-shi-dong-hua/"/>
    <updated>2014-05-23T10:11:17+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/23/jiao-hu-shi-dong-hua</id>
    <content type="html"><![CDATA[<p>在2007年，乔布斯在第一次介绍 iPhone 的时候，iPhone 的触摸屏交互简直就像是一种魔法。最好的例子就是在他<a href="https://www.youtube.com/watch?v=t4OEsI0Sc_s&amp;t=16m9s">第一次滑动 TableView 的展示上</a>。你可以感受到当时观众的反应是多么惊讶，但是对于现在的我们来说早已习以为常。在展示的后面一部分，他特别指出当他给别人看了这个滑动例子，别人说的一句话: <a href="https://www.youtube.com/watch?v=t4OEsI0Sc_s&amp;t=16m9s">“当这个界面滑动的时候我就已经被征服了”</a>.</p>

<p>是什么样的滑动能让人有‘哇哦’的效果呢？</p>

<p>滑动是最完美地展示了通过触摸屏直接操作的例子。滚动视图遵从于你的手指，当你的手指离开屏幕的时，视图会自然地继续滑动直到该停止的时候停止。它用自然的方式减速，甚至在快到界限的时候也能表现出细腻的弹力效果。滑动在任何时候都保持相应，并且看上去非常真实。</p>

<h2>动画的状态</h2>

<p>在 iOS 中的大部分动画仍然没有按照最初 iPhone 指定的滑动标准实现。这里有很多动画一旦它们运行就不能交互（比如说解锁动画，主界面中打开文件夹和关闭文件夹的动画，和导航栏切换的动画，还有很多）。</p>

<p>然而现在有一些应用给我一种始终在控制动画的体验，我们可以直接操作那些我在用的动画。当我们将这些应用和其他的应用相比较之后，我们就能感觉到明显的区别。这些应用中最优秀的有最初的 Twitter iPad app， 和现在的 Facebook Paper。但目前，使用直接操作为主并且可以中断动画的应用仍然很少。这就给我们做出更好的应用提供了机会，让我们的应用有更不同的，更高质量的体验。</p>

<h2>真实交互式动画的挑战</h2>

<p>当我们用 UIView 或者 CAAnimation 来实现交互式动画时会有两个大问题: 这些动画会将你在屏幕上的内容和 layer 上的实际的特定属性分离开来，并且他们直接操作这些特定属性。</p>

<h3 id="modelpresentation">模型 (Model) 和显示 (Presentation) 的分离</h3>

<p>Core Animation 是通过分离 layer 的模型属性和你在屏幕上看到的界面 (显示层) 的方式来设计的，这就导致我们很难去创建一个可以在任何时候能交互的动画，因为在动画时，模型和界面已经不能匹配了。这时，我们不得不通过手动的方式来同步这两个的状态，来达到改变动画的效果：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">view</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">presentationLayer</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class="line"><span class="p">[</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">removeAnimationForKey:</span><span class="s">@&quot;animation&quot;</span><span class="p">];</span>
</span><span class="line"><span class="c1">// 添加新动画</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="vs">直接控制 vs 间接控制</h3>

<p><code>CAAnimation</code> 动画的更大的问题是它们是直接在 layer 上对属性进行操作的。这意味着什么呢？比如我们想指定一个 layer 从坐标为 (100, 100) 的位置运动到 (300, 300) 的位置，但是在它运动到中间的时候，我们想它停下来并且让它回到它原来的位置，事情就变得非常复杂了。如果你只是简单地删除当前的动画然后再添加一个新的，那么这个 layer 的速率就会不连续。</p>

<p><img src="http://img.objccn.io/issue-12/abrupt.png" width="600" /></p>

<p>然而，我们想要的是一个漂亮的，流畅地减速和加速的动画。</p>

<p><img src="http://img.objccn.io/issue-12/smooth.png" width="600" /></p>

<p>只有通过<em>间接</em>操作动画才能达到上面的效果，比如通过模拟力在界面上的表现。新的动画需要用 layer 的当前<em>速度矢量</em>作为参数传入来达到流畅的效果。</p>

<p>看一下 UIView 中关于弹簧动画的 API </p>
<p>animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:</p>
<p>，你会注意到速率是个 CGFloat。所以当我们给一个移动 view 的动画在其运动的方向上加一个初始的速率时，你没法告知动画这个 view 现在的运动状态，比如我们不知道要添加的动画的方向是不是和原来的 view 的速度方向垂直。为了使其成为可能，这个速度需要用向量来表示。</p>

<h2>解决方案</h2>
<!-- more -->
<p>让我们看一下我们怎样来正确实现一个可交互并且可以中断的动画。我们来做一个类似于控制中心板的东西来实现这个效果：</p>

<p><video controls="1" style="display:block;max-width:100%;height:auto;border:0;"> <br />
  <source src="http://www.objc.io/images/issue-12/interactive-animation.mov" />
</video></p>

<p>这个控制板有两个状态：打开和关闭。你可以通过点击来切换这两个状态，或者通过上下拖动来调调整它向上或向下。我要将这个控制面板的所有状态都做到可以交互，甚至是在动画的过程中也可以，这是一个很大的挑战。比如，当你在这个控制板还没有切换到打开状态的动画过程中，你点击了它，那么它应该从现在这个点的位置马上回到关闭状态的位置。在现在很多的应用中，大部分都是用默认的动画 API，你必须要等一个动画结束之后你才能做自己想做的事情。或者，如果你不等待的话，就会看到一个不连续的速度曲线。我们要解决这个问题。</p>

<h3 id="uikit">UIKit 力学</h3>

<p>随着 iOS7 的发布，苹果向我们展示了一个叫 UIKit 力学的动画框架 (可以参见 WWDC 2013 sessions <a href="https://developer.apple.com/videos/wwdc/2013/index.php?id=206">206</a> 和 <a href="https://developer.apple.com/videos/wwdc/2013/index.php?id=221">221</a>)。UIKit 力学是一个基于模拟物理引擎的框架，只要你添加指定的行为到动画对象上来实现 <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIDynamicItem_Protocol/Reference/Reference.html">UIDynamicItem</a> 协议就能实现很多动画。这个框架非常强大，并且它能够在多个物体间启用像是附着和碰撞这样的复杂行为。请看一下 <a href="https://developer.apple.com/library/ios/samplecode/DynamicsCatalog/Introduction/Intro.html">UIKit Dynamics Catalog</a>，确认一下什么是可用的。</p>

<p>因为 UIKit 力学中的的动画是被间接驱动的，就像我在上面提到的，这使我们实现真实的交互式动画成为可能，它能在任何时候被中断并且拥有连续的加速度。同时，UIKit 力学在物理层的抽象上能完全胜任我们一般情况下在用户界面中的所需要的所有动画。其实在大部分情况下，我们只会用到其中的一小部分功能。</p>

<h4>定义行为</h4>

<p>为了实现我们的控制板的行为，我们将使用 UIkit 力学中的两个不同行为：<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIAttachmentBehavior_Class/Reference/Reference.html">UIAttachmentBehavior</a> 和 <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIDynamicItemBehavior_Class/Reference/Reference.html">UIDynamicItemBehavior</a>。附着行为用来扮演弹簧的角色，它将界面向目标点拉动。另一方面，我们用动态 item behvaior 定义了比如摩擦系数这样的界面的内置属性。</p>

<p>我创建了一个我们自己的行为子类，以将这两个行为封装到我们的控制板上:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">PaneBehavior</span> : <span class="nc">UIDynamicBehavior</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">CGPoint</span> <span class="n">targetPoint</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">CGPoint</span> <span class="n">velocity</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithItem:</span><span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="n">UIDynamicItem</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">item</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们通过一个 dynamic item 来初始化这个行为，然后就可以设置它的目标点和我们想要的任何速度。在内部，我们创建了附着行为和 dynamic item 行为，并且将这些行为添加到我们自定义的行为中:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setup</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">UIAttachmentBehavior</span> <span class="o">*</span><span class="n">attachmentBehavior</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIAttachmentBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItem:</span><span class="n">self</span><span class="p">.</span><span class="n">item</span> <span class="nl">attachedToAnchor:</span><span class="n">CGPointZero</span><span class="p">];</span>
</span><span class="line">    <span class="n">attachmentBehavior</span><span class="p">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="mf">3.5</span><span class="p">;</span>
</span><span class="line">    <span class="n">attachmentBehavior</span><span class="p">.</span><span class="n">damping</span> <span class="o">=</span> <span class="mf">.4</span><span class="p">;</span>
</span><span class="line">    <span class="n">attachmentBehavior</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">addChildBehavior:</span><span class="n">attachmentBehavior</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">attachmentBehavior</span> <span class="o">=</span> <span class="n">attachmentBehavior</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">UIDynamicItemBehavior</span> <span class="o">*</span><span class="n">itemBehavior</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIDynamicItemBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItems:</span><span class="err">@</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">item</span><span class="p">]];</span>
</span><span class="line">    <span class="n">itemBehavior</span><span class="p">.</span><span class="n">density</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class="line">    <span class="n">itemBehavior</span><span class="p">.</span><span class="n">resistance</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">addChildBehavior:</span><span class="n">itemBehavior</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">itemBehavior</span> <span class="o">=</span> <span class="n">itemBehavior</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>为了用 <code>targetPoint</code> 和 <code>velocity</code> 属性来影响 item 的 behavior，我们需要重写它们的 setter 方法，并且分别修改在附着行为和 item behaviors 中的对应的属性。我们对目标点的 setter 方法来说，这个改动很简单：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setTargetPoint:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">targetPoint</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">_targetPoint</span> <span class="o">=</span> <span class="n">targetPoint</span><span class="p">;</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">attachmentBehavior</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">targetPoint</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于 <code>velocity</code> 属性，我们需要多做一些工作，因为 dynamic item behavior 只允许相对地改变速度。这就意味如果我们要将 <code>velocity</code> 设置为绝对值，首先我们就需要得到当前的速度，然后再加上速度差才能得到我们的目标速度。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setVelocity:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">velocity</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">_velocity</span> <span class="o">=</span> <span class="n">velocity</span><span class="p">;</span>
</span><span class="line">    <span class="n">CGPoint</span> <span class="n">currentVelocity</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">itemBehavior</span> <span class="nl">linearVelocityForItem:</span><span class="n">self</span><span class="p">.</span><span class="n">item</span><span class="p">];</span>
</span><span class="line">    <span class="n">CGPoint</span> <span class="n">velocityDelta</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">velocity</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">currentVelocity</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">velocity</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">currentVelocity</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">itemBehavior</span> <span class="nl">addLinearVelocity:</span><span class="n">velocityDelta</span> <span class="nl">forItem:</span><span class="n">self</span><span class="p">.</span><span class="n">item</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="behavior">将Behavior投入使用</h3>

<p>我们的控制板有三个不同状态：在开始或结束位置的静止状态，正在被用户拖动的状态，以及在没有用户控制时运动到结束位置的动画状态。</p>

<p>为了将从直接操作状态 (用户拖动这个滑动板) 过渡到动画状态这个过程做的流畅，我们还有很多其他的事要做。当用户停止拖动控制板时，它会发送一个消息到它的 delegate。根据这个方法，我们可以知道这个板应该朝哪个方向运动，然后在我们自定义的 <code>PaneBehavior</code> 上设置结束点，以及初始速度 (这非常重要)，并将行为添加到动画器中去，以此确保从拖动操作到动画状态这个过程能够非常流畅。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">draggableView:</span><span class="p">(</span><span class="n">DraggableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">view</span> <span class="nf">draggingEndedWithVelocity:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">velocity</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">PaneState</span> <span class="n">targetState</span> <span class="o">=</span> <span class="n">velocity</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">PaneStateClosed</span> <span class="o">:</span> <span class="n">PaneStateOpen</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">animatePaneToState:</span><span class="n">targetState</span> <span class="nl">initialVelocity:</span><span class="n">velocity</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animatePaneToState:</span><span class="p">(</span><span class="n">PaneState</span><span class="p">)</span><span class="nv">targetState</span> <span class="nf">initialVelocity:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">velocity</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">paneBehavior</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">PaneBehavior</span> <span class="o">*</span><span class="n">behavior</span> <span class="o">=</span> <span class="p">[[</span><span class="n">PaneBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItem:</span><span class="n">self</span><span class="p">.</span><span class="n">pane</span><span class="p">];</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">paneBehavior</span> <span class="o">=</span> <span class="n">behavior</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">paneBehavior</span><span class="p">.</span><span class="n">targetPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">targetPointForState:</span><span class="n">targetState</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CGPointEqualToPoint</span><span class="p">(</span><span class="n">velocity</span><span class="p">,</span> <span class="n">CGPointZero</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">paneBehavior</span><span class="p">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">velocity</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">animator</span> <span class="nl">addBehavior:</span><span class="n">self</span><span class="p">.</span><span class="n">paneBehavior</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">paneState</span> <span class="o">=</span> <span class="n">targetState</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>一旦用户用他的手指再次触动控制板时，我必须要将所有的 dynamic behavior 从 animator 删除，这样才不会影响控制板对拖动手势的响应：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">draggableViewBeganDragging:</span><span class="p">(</span><span class="n">DraggableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">view</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">animator</span> <span class="n">removeAllBehaviors</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们不仅仅允许控制板可以被拖动，还要允许它可以被点击，让它可以从一个位置跳转到另一个位置以达到开关的效果。一旦点击事件发生，我们就会立即调整这个滑动板的目标位置。因为我们不能直接控制动画，但是通过弹力和摩擦力，我们的动画可以非常流畅地执行这个动作：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">didTap:</span><span class="p">(</span><span class="n">UITapGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">tapRecognizer</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">PaneState</span> <span class="n">targetState</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">paneState</span> <span class="o">==</span> <span class="n">PaneStateOpen</span> <span class="o">?</span> <span class="n">PaneStateClosed</span> <span class="o">:</span> <span class="n">PaneStateOpen</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">animatePaneToState:</span><span class="n">targetState</span> <span class="nl">initialVelocity:</span><span class="n">CGPointZero</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样就实现了我们的大部分功能了。你可以在 <a href="https://github.com/objcio/issue-12-interactive-animations-uidynamics">GitHub</a> 上查看完整的例子。</p>

<p>重申一点：UIKit 力学可以通过在界面上模拟力来间接地驱动动画（我们的例子中，使用的是弹力和摩擦力）。这间接地使我们在任何时候都能以连续的速度曲线来与界面进行交互。</p>

<p>现在我们已经通过 UIKit 力学实现了整个交互，让我们回顾一下这个场景。这个例子的动画中我们只用了 UIKit 力学中一小部分功能，并且它的实现方式也非常简单。对于我们来说这是一个去理解它其中的过程的很好的例子，但是如果我们使用的环境中没有 UIKit  力学 (比如说在 Mac 上)，或者你的使用场景中不能很好的适用 UIKit 力学呢。</p>

<h2>自己操作动画</h2>

<p>至于在你的应用中大部分时间会用的动画，比如简单的弹力动画，我们控制它真的不难。我们可以做一个练习，来看看如何抛弃 UIKit 力学这个巨大的黑盒子，看要如何“手动”来实现一个简单的交互。想法非常简单：我们只要每秒修改这个 view 的 frame 60 次。每一帧我们都基于当前速度和作用在 view 上的力来调整 view 的 frame 就可以了。</p>

<h3>物理原理</h3>

<p>首先让我们看一下我们需要知道的基础物理知识，这样我们才能实现出刚才使用 UIKit 力学实现的那种弹簧动画效果。为了简化问题，虽然引入第二个维度也是很直接的，但我们在这里只关注一维的情况 (在我们的例子中就是这样的情况)。</p>

<p>我们的目标是依据控制面板当前的位置和上一次动画后到现在为止经过的时间，来计算它的新位置。我们可以把它表示成这样：</p>

<pre><code>y = y0 + Δy
</code></pre>

<p>位置的偏移量可以通过速度和时间的函数来表达：</p>

<pre><code>Δy = v ⋅ Δt
</code></pre>

<p>这个速度可以通过前一次的速度加上速度偏移量算出来，这个速度偏移量是由力在 view 上的作用引起的。</p>

<pre><code>v = v0 + Δv
</code></pre>

<p>速度的变化可以通过作用在这个 view 上的冲量计算出来：</p>

<pre><code>Δv = (F ⋅ Δt) / m
</code></pre>

<p>现在，让我们看一下作用在这个界面上的力。为了得到弹簧效果，我们必须要将摩擦力和弹力结合起来：</p>

<pre><code>F = F_spring + F_friction
</code></pre>

<p>弹力的计算方法我们可以从任何一本教科书中得到 (编者注：简单的胡克定律)：</p>

<pre><code>F_spring = k ⋅ x
</code></pre>

<p><code>k</code> 是弹簧的劲度系数，<code>x</code> 是 view 到目标结束位置的距离 (也就是弹簧的长度)。因此，我们可以把它写成这样：</p>

<pre><code>F_spring = k ⋅ abs(y_target - y0)
</code></pre>

<p>摩擦力和 view 的速度成正比：</p>

<pre><code>F_friction = μ ⋅ v
</code></pre>

<p><code>μ</code> 是一个简单的摩擦系数。你可以通过别的方式来计算摩擦力，但是这个方法能很好地做出我们想要的动画效果。</p>

<p>将上面的表达式放在一起，我们就可以算出作用在界面上的力：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">F</span> <span class="o">=</span> <span class="n">k</span> <span class="err">⋅</span> <span class="n">abs</span><span class="p">(</span><span class="n">y_target</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">+</span> <span class="err">μ</span> <span class="err">⋅</span> <span class="n">v</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>为了实现起来更简单点些，我们将 view 的质量设为 1，这样我们就能计算在位置上的变化：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="err">Δ</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">v0</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="err">⋅</span> <span class="n">abs</span><span class="p">(</span><span class="n">y_target</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">+</span> <span class="err">μ</span> <span class="err">⋅</span> <span class="n">v</span><span class="p">)</span> <span class="err">⋅</span> <span class="err">Δ</span><span class="n">t</span><span class="p">)</span> <span class="err">⋅</span> <span class="err">Δ</span><span class="n">t</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3>实现动画</h3>

<p>为了实现这个动画，我们首先需要创建我们自己的 <code>Animator</code> 类，它将扮演驱动动画的角色。这个类使用了 <code>CADisplayLink</code>，<code>CADisplayLink</code> 是专门用来将绘图与屏幕刷新频率相同步的定时器。换句话说，如果你的动画是流畅的，这个定时器就会每秒调用你的方法60次。接下来，我们需要实现 <code>Animation</code> 协议来和我们的 <code>Animator</code> 一起工作。这个协议只有一个方法，<code>animationTick:finished:</code>。屏幕每次被刷新时都会调用这个方法，并且在方法中会得到两个参数：第一个参数是前一个 frame 的持续时间，第二个参数是一个指向 <code>BOOL</code> 的指针。当我们设置这个指针的值为 <code>YES</code> 时，我们就可以与 <code>Animator</code> 取得通讯并汇报动画完成；</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@protocol</span> <span class="nc">Animation</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
</span><span class="line"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">animationTick:</span><span class="p">(</span><span class="n">CFTimeInterval</span><span class="p">)</span><span class="n">dt</span> <span class="nl">finished:</span><span class="p">(</span><span class="kt">BOOL</span> <span class="o">*</span><span class="p">)</span><span class="n">finished</span><span class="p">;</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们会在下面实现这个方法。首先，根据时间间隔我们来计算由弹力和摩擦力的合力。然后根据这个力来更新速度，并调整 view 的中心位置。最后，当这个速度降低并且 view 到达结束位置时，我们就停止这个动画：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animationTick:</span><span class="p">(</span><span class="n">CFTimeInterval</span><span class="p">)</span><span class="nv">dt</span> <span class="nf">finished:</span><span class="p">(</span><span class="kt">BOOL</span> <span class="o">*</span><span class="p">)</span><span class="nv">finished</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">static</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">frictionConstant</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span><span class="line">    <span class="k">static</span> <span class="k">const</span> <span class="kt">float</span> <span class="n">springConstant</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>
</span><span class="line">    <span class="n">CGFloat</span> <span class="n">time</span> <span class="o">=</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span> <span class="n">dt</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">//摩擦力 = 速度 * 摩擦系数</span>
</span><span class="line">    <span class="n">CGPoint</span> <span class="n">frictionForce</span> <span class="o">=</span> <span class="n">CGPointMultiply</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">velocity</span><span class="p">,</span> <span class="n">frictionConstant</span><span class="p">);</span>
</span><span class="line">    <span class="c1">//弹力 = (目标位置 - 当前位置) * 弹簧劲度系数</span>
</span><span class="line">    <span class="n">CGPoint</span> <span class="n">springForce</span> <span class="o">=</span> <span class="n">CGPointMultiply</span><span class="p">(</span><span class="n">CGPointSubtract</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">targetPoint</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">center</span><span class="p">),</span> <span class="n">springConstant</span><span class="p">);</span>
</span><span class="line">    <span class="c1">//力 = 弹力 - 摩擦力</span>
</span><span class="line">    <span class="n">CGPoint</span> <span class="n">force</span> <span class="o">=</span> <span class="n">CGPointSubtract</span><span class="p">(</span><span class="n">springForce</span><span class="p">,</span> <span class="n">frictionForce</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="c1">//速度 = 当前速度 + 力 * 时间 / 质量</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">CGPointAdd</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">velocity</span><span class="p">,</span> <span class="n">CGPointMultiply</span><span class="p">(</span><span class="n">force</span><span class="p">,</span> <span class="n">time</span><span class="p">));</span>
</span><span class="line">    <span class="c1">//位置 = 当前位置 + 速度 * 时间</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointAdd</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">center</span><span class="p">,</span> <span class="n">CGPointMultiply</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">velocity</span><span class="p">,</span> <span class="n">time</span><span class="p">));</span>
</span><span class="line">
</span><span class="line">    <span class="n">CGFloat</span> <span class="n">speed</span> <span class="o">=</span> <span class="n">CGPointLength</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">velocity</span><span class="p">);</span>
</span><span class="line">    <span class="n">CGFloat</span> <span class="n">distanceToGoal</span> <span class="o">=</span> <span class="n">CGPointLength</span><span class="p">(</span><span class="n">CGPointSubtract</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">targetPoint</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">center</span><span class="p">));</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="mf">0.05</span> <span class="o">&amp;&amp;</span> <span class="n">distanceToGoal</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">targetPoint</span><span class="p">;</span>
</span><span class="line">        <span class="o">*</span><span class="n">finished</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这就是这个方法里的全部内容。我们把这个方法封装到一个 <code>SpringAnimation</code> 对象中。除了这个方法之外，这个对象中还有一个初始化方法，它指定了 view 中心的目标位置 (在我们的例子中，就是打开状态时界面的中心位置，或者关闭状态时界面的中心位置) 和初始的速度。</p>

<h3 id="view">将动画添加到 view 上</h3>

<p>我们的 view 类刚好和使用 UIDynamic 的例子一样：它有一个拖动手势，并且根据拖动手势来更新中心位置。它也有两个同样的 delegate 方法，这两个方法会实现动画的初始化。首先，一旦用户开始拖动控制板时，我们就取消所有动画：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">draggableViewBeganDragging:</span><span class="p">(</span><span class="n">DraggableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">view</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="n">cancelSpringAnimation</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>一旦停止拖动，我们就根据从拖动手势中得到的最后一个速率值来开始我们的动画。我们根据拖动状态 <code>paneState</code> 计算出动画的结束位置：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">draggableView:</span><span class="p">(</span><span class="n">DraggableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">view</span> <span class="nf">draggingEndedWithVelocity:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">velocity</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">PaneState</span> <span class="n">targetState</span> <span class="o">=</span> <span class="n">velocity</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">PaneStateClosed</span> <span class="o">:</span> <span class="n">PaneStateOpen</span><span class="p">;</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">paneState</span> <span class="o">=</span> <span class="n">targetState</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">startAnimatingView:</span><span class="n">view</span> <span class="nl">initialVelocity:</span><span class="n">velocity</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">startAnimatingView:</span><span class="p">(</span><span class="n">DraggableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">view</span> <span class="nf">initialVelocity:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">velocity</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="n">cancelSpringAnimation</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">springAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="n">UINTSpringAnimation</span> <span class="nl">animationWithView:</span><span class="n">view</span> <span class="nl">target:</span><span class="n">self</span><span class="p">.</span><span class="n">targetPoint</span> <span class="nl">velocity:</span><span class="n">velocity</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">view</span><span class="p">.</span><span class="n">animator</span> <span class="nl">addAnimation:</span><span class="n">self</span><span class="p">.</span><span class="n">springAnimation</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>剩下来要做的就是添加点击动画了，这很简单。一旦我们触发这个状态，就开始动画。如果这里正在进行弹簧动画，我们就用当时的速度作为开始。如果这个弹簧动画是 nil，那么这个开始速度就是 CGPointZero。想要知道为什么依然可以进行动画，可以看看 <code>animationTick:finished:</code> 里的代码。当这个起始速度为 0 的时候，弹力就会使速度缓慢地增长，直到面板到达目标位置：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">didTap:</span><span class="p">(</span><span class="n">UITapGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">tapRecognizer</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">PaneState</span> <span class="n">targetState</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">paneState</span> <span class="o">==</span> <span class="n">PaneStateOpen</span> <span class="o">?</span> <span class="n">PaneStateClosed</span> <span class="o">:</span> <span class="n">PaneStateOpen</span><span class="p">;</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">paneState</span> <span class="o">=</span> <span class="n">targetState</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">startAnimatingView:</span><span class="n">self</span><span class="p">.</span><span class="n">pane</span> <span class="nl">initialVelocity:</span><span class="n">self</span><span class="p">.</span><span class="n">springAnimation</span><span class="p">.</span><span class="n">velocity</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3>动画驱动</h3>

<p>最后，我们需要一个 <code>Animator</code>，也就是动画的驱动者。Animator 封装了 display link。因为每个 display link 都链接一个指定的 <code>UIScreen</code>，所以我们根据这个指定的 UIScreen 来初始化我们的 animator。我们初始化一个 display link，并且将它加入到 run loop 中。因为现在还没有动画，所以我们是从暂停状态开始的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithScreen:</span><span class="p">(</span><span class="n">UIScreen</span> <span class="o">*</span><span class="p">)</span><span class="nv">screen</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">displayLink</span> <span class="o">=</span> <span class="p">[</span><span class="n">screen</span> <span class="nl">displayLinkWithTarget:</span><span class="n">self</span> <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">animationTick:</span><span class="p">)];</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">displayLink</span><span class="p">.</span><span class="n">paused</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line">        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">displayLink</span> <span class="nl">addToRunLoop:</span><span class="p">[</span><span class="n">NSRunLoop</span> <span class="n">mainRunLoop</span><span class="p">]</span> <span class="nl">forMode:</span><span class="n">NSRunLoopCommonModes</span><span class="p">];</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">animations</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableSet</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>一旦我们添加了这个动画，我们要确保这个 display link 不再是停止状态：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addAnimation:</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">Animation</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">animation</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">animations</span> <span class="nl">addObject:</span><span class="n">animation</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">animations</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">displayLink</span><span class="p">.</span><span class="n">paused</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们设置这个 display link 来调用 <code>animationTick:</code> 方法，在每个 Tick 中，我们都遍历它的动画数组，并且给这些动画数组中的每个动画发送一个消息。如果这个动画数组中已经没有动画了，我们就暂停这个 display link。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">animationTick:</span><span class="p">(</span><span class="n">CADisplayLink</span> <span class="o">*</span><span class="p">)</span><span class="n">displayLink</span>
</span><span class="line"> <span class="p">{</span>
</span><span class="line">     <span class="n">CFTimeInterval</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">displayLink</span><span class="p">.</span><span class="n">duration</span><span class="p">;</span>
</span><span class="line">     <span class="k">for</span> <span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">Animation</span><span class="o">&gt;</span> <span class="n">a</span> <span class="k">in</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">animations</span> <span class="n">copy</span><span class="p">])</span> <span class="p">{</span>
</span><span class="line">         <span class="kt">BOOL</span> <span class="n">finished</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class="line">         <span class="p">[</span><span class="n">a</span> <span class="nl">animationTick:</span><span class="n">dt</span> <span class="nl">finished:</span><span class="o">&amp;</span><span class="n">finished</span><span class="p">];</span>
</span><span class="line">         <span class="k">if</span> <span class="p">(</span><span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">             <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">animations</span> <span class="nl">removeObject:</span><span class="n">a</span><span class="p">];</span>
</span><span class="line">         <span class="p">}</span>
</span><span class="line">     <span class="p">}</span>
</span><span class="line">     <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">animations</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">         <span class="n">self</span><span class="p">.</span><span class="n">displayLink</span><span class="p">.</span><span class="n">paused</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line">     <span class="p">}</span>
</span><span class="line"> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>完整的项目在 <a href="https://github.com/objcio/issue-12-interactive-animations">GitHub</a> 上。</p>

<h3>权衡</h3>

<p>我们必须记住，通过 display link 来驱动动画 (就像我们刚才演示的例子，或者我们使用UIkit力学来做的例子，又或者是使用 Facebook 的 Pop 框架) 是有代价需要进行权衡的。就像 <a href="https://twitter.com/andy_matuschak/status/464790108072206337">Andy Matuschar 指出的</a>那样，UIView 和 CAAnimation 动画比其他任务更少受系统的影响，因为比起你的应用来说，渲染处于更高的优先级。</p>

<h2 id="mac">回到 Mac</h2>

<p>现在 Mac 中还没有 UIKit 力学。如果你想在 Mac 中创建一个真实的交互式动画，你必须自己去实现这些动画。我们已经向你展示了如何在 iOS 中实现这些动画，所以在 OS X 中实现相似的功能也是非常简单的。你可以查看在 GitHub 中的<a href="https://github.com/objcio/issue-12-interactive-animations-osx">完整项目</a>，如果你想要应用到 OS X 中，这里还有一些地方需要修改：</p>

<ul>
<li>第一个要修改的就是 <code>Animator</code>。在Mac中没有 <code>CADisplayLink</code>，但是取而代之的有 <code>CVDisplayLink</code>，它是以 C 语言为基础的 API。创建它需要做更多的工作，但也是很直接。</li>
<li>iOS 中的弹簧动画是基于调整 view 的中心位置来实现的。而 OS X 中的 <code>NSView</code> 类没有 center 这个属性，所以我们用为 frame 中的 origin 做动画来代替。</li>
<li>在 Mac 中是没有手势识别，所以我要在我们自定义的 view 子类中实现 <code>mouseDown:</code>，<code>mouseUp:</code> 和 <code>mouseDragged:</code> 方法。</li>
</ul>

<p>上面就是我们需要在 Mac 中使用我们的动画效果在代码所需要做的修改。对于像这样的简单 view，它能很好的胜任。但对于更复杂的动画，你可能就不会想通过为 frame 做动画来实现了，我们可以用 <code>transform</code> 来代替，浏览 Jonathan Willing 写的关于 <a href="http://jwilling.com/osx-animations">OS X 动画</a>的博客，你会获益良多。</p>

<h3 id="facebookpop">Facebook 的 POP 框架</h3>

<p>上个星期围绕着 Facebook 的 <a href="https://github.com/facebook/pop">POP 框架</a>的讨论络绎不绝。POP 框架是 Paper 应用背后支持的动画引擎。它的操作非常像我们上面讲的驱动动画的例子，但是它以非常灵活的方式巧妙地封装到了一个程序包中。</p>

<p>让我们动手用 POP 来驱动我们的动画吧。因为我们自己的类中已经封装了弹簧动画，这些改变就非常简单了。我们所要做的就是初始化一个 POP 动画来代替我们刚才自己做的动画，并将下面这段代码加入到 view
 中：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animatePaneWithInitialVelocity:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">initialVelocity</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">pane</span> <span class="n">pop_removeAllAnimations</span><span class="p">];</span>
</span><span class="line">    <span class="n">POPSpringAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">POPSpringAnimation</span> <span class="nl">animationWithPropertyNamed:</span><span class="n">kPOPViewCenter</span><span class="p">];</span>
</span><span class="line">    <span class="n">animation</span><span class="p">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGPoint:</span><span class="n">initialVelocity</span><span class="p">];</span>
</span><span class="line">    <span class="n">animation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGPoint:</span><span class="n">self</span><span class="p">.</span><span class="n">targetPoint</span><span class="p">];</span>
</span><span class="line">    <span class="n">animation</span><span class="p">.</span><span class="n">springSpeed</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
</span><span class="line">    <span class="n">animation</span><span class="p">.</span><span class="n">springBounciness</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">pane</span> <span class="nl">pop_addAnimation:</span><span class="n">animation</span> <span class="nl">forKey:</span><span class="s">@&quot;animation&quot;</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">animation</span> <span class="o">=</span> <span class="n">animation</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>你可以在 <a href="https://github.com/objcio/issue-12-interactive-animations-pop">GitHub</a> 中找到使用 POP 框架的完整例子。</p>

<p>让其工作非常简单，并且通过它我们可以实现很多更复杂的动画。但是它真正强大的地方在于它能够实现真正的可交互和可中断的动画，就像我们上面提到的那样，因为它直接支持以速度作为输入参数。如果你打算从一开始到被中断这过程中的任何时候都能交互，像 POP 这样的框架就能帮你实现这些动画，并且它能始终保证动画一直很平滑。</p>

<p>如果你不满足于用 <code>POPSpringAnimation</code> 和 <code>POPDecayAnimation</code> 的开箱即用的处理方式的话，POP 还提供了 <code>POPCustomAnimation</code> 类，它基本上是一个 display link 的方便的转换，来在动画的每一个 tick 的回调 block 中驱动你自己的动画。</p>

<h2>展望未来</h2>

<p>随着 iOS7 中从对拟物化的视觉效果的远离，以及对 UI 行为的关注，真实的交互式动画通向未来的大道变得越来越明显。它们也是将初代 iPhone 中滑动行为的魔力延续到交互的各个方面的一条康庄大道。为了让这些魔力成为现实，我们就不能在开发过程中才想到这些动画，而是应该在设计时就要考虑这些交互，这一点非常重要。</p>

<p>非常感谢 <a href="https://twitter.com/lorenb">Loren Brichter</a> 给这篇文章提出的一些意见。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS动画解释]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/18/iosdong-hua-jie-shi/"/>
    <updated>2014-05-18T10:03:54+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/18/iosdong-hua-jie-shi</id>
    <content type="html"><![CDATA[<p>我们写的应用程序往往都不是静态的，因为它们需要适应用户的需求以及为执行各种任务而改变状态。</p>

<p>在这些状态之间转换时，清晰的揭示正在发生什么是非常重要的。而不是在页面之间跳跃，动画帮助我们解释用户从哪里来，要到哪里去。</p>

<p>键盘在 view 中滑进滑出给了我们一个错觉，让我们以为它是简单的被隐藏在屏幕下方的，并且是手机很自然的一个部分。View controller 转场加强了我们的应用程序的导航结构，并且给了用户正在移向哪个方向的提示。微妙的反弹和碰撞使界面栩栩如生，并且激发出了物理的质感。要是没有这些的话，我们就只有一个没有视觉修饰的干巴巴环境了。</p>

<p>动画是叙述你的应用的故事的绝佳方式，在了解动画背后的基本原理之后，设计它们会轻松很多。</p>

<h2>首要任务</h2>

<p>在这篇文章 (以及这个话题中其余大多数文章) 中，我们将特别地针对 Core Animation 进行探讨。虽然你将看到的很多东西也可以用更高层级的 UIKit 的方法来完成，但是 Core Animation 将会让你更好的理解正在发生什么。它以一种更明确的方式来描述动画，这对这篇文章读者以及你自己的代码的读者来说都非常有用。</p>

<p>在看动画如何与我们在屏幕上看到的内容交互之前，我们需要快速浏览一下 Core Animation 的 <code>CALayer</code>，这是动画产生作用的地方。</p>

<p>你大概知道 <code>UIView</code> 实例，以及 layer-backed 的 <code>NSView</code>，修改它们的 <code>layer</code> 来委托强大的 Core Graphics 框架来进行渲染。然而，你务必要理解，当把动画添加到一个 layer 时，是不直接修改它的属性的。</p>

<p>取而代之，Core Animation 维护了两个平行 layer 层次结构： <em>model layer tree（模型层树）</em> 和 <em>presentation layer tree（表示层树）</em>。前者中的 layers 反映了我们能直接看到的 layers 的状态，而后者的 layers 则是动画正在表现的值的近似。</p>

<blockquote>
  <p>实际上还有所谓的第三个 layer 树，叫做 <em>rendering tree（渲染树）</em>。因为它对 Core Animation 而言是私有的，所以我们在这里不讨论它。</p>
</blockquote>

<p>考虑在 view 上增加一个渐出动画。如果在动画中的任意时刻，查看 layer 的 <code>opacity</code> 值，你是得不到与屏幕内容对应的透明度的。取而代之，你需要查看 presentation layer 以获得正确的结果。</p>

<p>虽然你可能不会去直接设置 presentation layer 的属性，但是使用它的当前值来创建新的动画或者在动画发生时与 layers 交互是非常有用的。</p>

<p>通过使用 <code>-[CALayer presentationLayer]</code> 和 <code>-[CALayer modelLayer]</code>，你可以在两个 layer 之间轻松切换。</p>

<h2>基本动画</h2>

<p>可能最常见的情况是将一个 view 的属性从一个值改变为另一个值，考虑下面这个例子：</p>

<p><center><img src="http://img.objccn.io/issue-12/rocket-linear.gif" width="400px" /></center></p>

<p>在这里，我们让红色小火箭的 x-position 从 <code>77.0</code> 变为 <code>455.0</code>，刚好超过它的 parent view 的边。为了填充所有路径，我们需要确定我们的火箭在任意时刻所到达的位置。这通常使用线性插值法来完成：</p>

<p><center><img src="http://img.objccn.io/issue-12/lerp.png" width="135" /></center></p>

<p>也就是说，对于动画给定的一个分数 <code>t</code>，火箭的 x 坐标就是起始点的 x 坐标 <code>77</code>，加上一个到终点的距离 <code>∆x = 378</code> 乘以该分数的值。</p>

<p>使用 <code>CABasicAnimation</code>，我们可以如下实现这个动画：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">keyPath</span> <span class="o">=</span> <span class="s">@&quot;position.x&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">77</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">455</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">rocket</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addAnimation:</span><span class="n">animation</span> <span class="nl">forKey:</span><span class="s">@&quot;basic&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<!-- more -->
<p>请注意我们要动画的键路径，也就是 <code>position.x</code>，实际上包含一个存储在 <code>position</code> 属性中的 <code>CGPoint</code> 结构体成员。这是 Core Animation 一个非常方便的特性。请务必查看<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html">支持的键路径的完整列表</a>。</p>

<p>然而，当我们运行该代码时，我们意识到火箭在完成动画后马上回到了初始位置。这是因为在默认情况下，动画不会在超出其持续时间后还修改 presentation layer。实际上，在结束时它甚至会被彻底移除。</p>

<p>一旦动画被移除，presentation layer 将回到 model layer 的值，并且因为我们从未修改该 layer 的 <code>position</code> 属性，所以我们的飞船将重新出现在它开始的地方。</p>

<p>这里有两种解决这个问题的方法：</p>

<p>第一种方法是直接在 model layer 上更新属性。<em>这是推荐的的做法</em>，因为它使得动画完全可选。</p>

<p>一旦动画完成并且从 layer 中移除，presentation layer 将回到 model layer 设置的值，而这个值恰好与动画最后一个步骤相匹配。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">keyPath</span> <span class="o">=</span> <span class="s">@&quot;position.x&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">77</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">455</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">rocket</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addAnimation:</span><span class="n">animation</span> <span class="nl">forKey:</span><span class="s">@&quot;basic&quot;</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">rocket</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">455</span><span class="p">,</span> <span class="mi">61</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>或者，你可以通过设置动画的 <code>fillMode</code> 属性为 <code>kCAFillModeForward</code> 以留在最终状态，并设置<code>removedOnCompletion</code> 为 <code>NO</code> 以防止它被自动移除：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">keyPath</span> <span class="o">=</span> <span class="s">@&quot;position.x&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">77</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">455</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">fillMode</span> <span class="o">=</span> <span class="n">kCAFillModeForward</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">removedOnCompletion</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">rectangle</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addAnimation:</span><span class="n">animation</span> <span class="nl">forKey:</span><span class="s">@&quot;basic&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><a href="https://twitter.com/andy_matuschak/status/464799423785336832">Andy Matuschak 指出了</a>，如果将已完成的动画保持在 layer 上时，会造成额外的开销，因为渲染器会去进行额外的绘画工作。</p>

<p>值得指出的是，实际上我们创建的动画对象在被添加到 layer 时立刻就复制了一份。这个特性在多个 view 中重用动画时这非常有用。比方说我们想要第二个火箭在第一个火箭起飞不久后起飞：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">keyPath</span> <span class="o">=</span> <span class="s">@&quot;position.x&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">byValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">378</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">rocket1</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addAnimation:</span><span class="n">animation</span> <span class="nl">forKey:</span><span class="s">@&quot;basic&quot;</span><span class="p">];</span>
</span><span class="line"><span class="n">rocket1</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">455</span><span class="p">,</span> <span class="mi">61</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">beginTime</span> <span class="o">=</span> <span class="n">CACurrentMediaTime</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">rocket2</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addAnimation:</span><span class="n">animation</span> <span class="nl">forKey:</span><span class="s">@&quot;basic&quot;</span><span class="p">];</span>
</span><span class="line"><span class="n">rocket2</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">455</span><span class="p">,</span> <span class="mi">111</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>设置动画的 <code>beginTime</code> 为未来 0.5 秒将只会影响 <code>rocket2</code>，因为动画在执行语句 <code>[rocket1.layer addAnimation:animation forKey:@"basic"];</code> 时已经被复制了，并且之后 <code>rocket1</code> 也不会考虑对动画对象的改变。</p>

<p>不妨看一看 David 的 <a href="http://ronnqvi.st/controlling-animation-timing/">关于动画时间的一篇很棒的文章</a>，通过它可以学习如何更精确的控制你的动画。</p>

<p>我决定再使用 <code>CABasicAnimation</code> 的 <code>byValue</code> 属性创建一个动画，这个动画从 presentation layer 的当前值开始，加上 <code>byValue</code> 的值后结束。这使得动画更易于重用，因为你不需要精确的指定可能无法提前知道的 <code>from-</code> 和 <code>toValue</code> 的值。</p>

<p><code>fromValue</code>, <code>byValue</code> 和 <code>toValue</code> 的不同组合可以用来实现不同的效果，如果你需要创建一个可以在你的不同应用中重用的动画，你可以<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004496-CH1-SW4">查看文档</a>。</p>

<h2>多步动画</h2>

<p>这很容易想到一个场景，你想要为你的动画定义超过两个步骤，我们可以使用更通用的 <code>CAKeyframeAnimation</code>，而不是去链接多个 <code>CABasicAnimation</code> 实例。</p>

<p>关键帧（keyframe）使我们能够定义动画中任意的一个点，然后让 Core Animation 填充所谓的中间帧。</p>

<p>比方说我们正在制作我们下一个 iPhone 应用程序上的登陆表单，我们希望当用户输入错误的密码时表单会晃动。使用关键帧动画，看起来大概像下面这样：</p>

<p><center><img src="http://img.objccn.io/issue-12/form.gif" width="320px" /></center></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CAKeyframeAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAKeyframeAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">keyPath</span> <span class="o">=</span> <span class="s">@&quot;position.x&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">values</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span> <span class="err">@</span><span class="mi">0</span><span class="p">,</span> <span class="err">@</span><span class="mi">10</span><span class="p">,</span> <span class="err">@</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="err">@</span><span class="mi">10</span><span class="p">,</span> <span class="err">@</span><span class="mi">0</span> <span class="p">];</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">keyTimes</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span> <span class="err">@</span><span class="mi">0</span><span class="p">,</span> <span class="err">@</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">6.0</span><span class="p">),</span> <span class="err">@</span><span class="p">(</span><span class="mi">3</span> <span class="o">/</span> <span class="mf">6.0</span><span class="p">),</span> <span class="err">@</span><span class="p">(</span><span class="mi">5</span> <span class="o">/</span> <span class="mf">6.0</span><span class="p">),</span> <span class="err">@</span><span class="mi">1</span> <span class="p">];</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">additive</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">form</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addAnimation:</span><span class="n">animation</span> <span class="nl">forKey:</span><span class="s">@&quot;shake&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>values</code> 数组定义了表单应该到哪些位置。</p>

<p>设置 <code>keyTimes</code> 属性让我们能够指定关键帧动画发生的时间。它们被指定为关键帧动画总持续时间的一个分数。</p>

<blockquote>
  <p>请注意我是如何选择不同的值从 0 到 10 和从 10 到 -10 转换以维持恒定的速度的。</p>
</blockquote>

<p>设置 <code>additive</code> 属性为 <code>YES</code> 使 Core Animation 在更新 presentation layer 之前将动画的值添加到 model layer 中去。这使我们能够对所有形式的需要更新的元素重用相同的动画，且无需提前知道它们的位置。因为这个属性从 <code>CAPropertyAnimation</code> 继承，所以你也可以在使用 <code>CABasicAnimation</code> 时使用它。</p>

<h2>沿路径的动画</h2>

<p>虽然用代码实现一个简单的水平晃动并不难，但是沿着复杂路径的动画就需要我们在关键帧的 <code>values</code> 数组中存储大量 box 化的 <code>CGPoint</code>。 值得庆幸的是，<code>CAKeyframeAnimation</code>  提供了更加便利的 <code>path</code> 属性作为代替。</p>

<p>举个例子，我们如何让一个 view 做圆周运动：</p>

<p><center><img src="http://img.objccn.io/issue-12/planets.gif" width="400px" /></center></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGRect</span> <span class="n">boundingRect</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="o">-</span><span class="mi">150</span><span class="p">,</span> <span class="o">-</span><span class="mi">150</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="n">CAKeyframeAnimation</span> <span class="o">*</span><span class="n">orbit</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAKeyframeAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class="line"><span class="n">orbit</span><span class="p">.</span><span class="n">keyPath</span> <span class="o">=</span> <span class="s">@&quot;position&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">orbit</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">CFAutorelease</span><span class="p">(</span><span class="n">CGPathCreateWithEllipseInRect</span><span class="p">(</span><span class="n">boundingRect</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>
</span><span class="line"><span class="n">orbit</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class="line"><span class="n">orbit</span><span class="p">.</span><span class="n">additive</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line"><span class="n">orbit</span><span class="p">.</span><span class="n">repeatCount</span> <span class="o">=</span> <span class="n">HUGE_VALF</span><span class="p">;</span>
</span><span class="line"><span class="n">orbit</span><span class="p">.</span><span class="n">calculationMode</span> <span class="o">=</span> <span class="n">kCAAnimationPaced</span><span class="p">;</span>
</span><span class="line"><span class="n">orbit</span><span class="p">.</span><span class="n">rotationMode</span> <span class="o">=</span> <span class="n">kCAAnimationRotateAuto</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">satellite</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addAnimation:</span><span class="n">orbit</span> <span class="nl">forKey:</span><span class="s">@&quot;orbit&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>使用 <code>CGPathCreateWithEllipseInRect()</code>，我们创建一个圆形的 <code>CGPath</code> 作为我们的关键帧动画的 <code>path</code>。</p>

<p>使用 <code>calculationMode</code> 是控制关键帧动画时间的另一种方法。我们通过将其设置为 <code>kCAAnimationPaced</code>，让 Core Animation 向被驱动的对象施加一个恒定速度，不管路径的各个线段有多长。将其设置为 <code>kCAAnimationPaced</code> 将无视所有我们已经设置的 <code>keyTimes</code>。</p>

<p>设置 <code>rotationMode</code> 属性为 <code>kCAAnimationRotateAuto</code> 确保飞船沿着路径旋转。作为对比，如果我们将该属性设置为 <code>nil</code> 那动画会是什么样的呢。</p>

<p><center><img src="http://img.objccn.io/issue-12/planets-incorrect.gif" width="400px" /></center></p>

<p>你可以使用带路径的动画来实现几个有趣的效果；资深 objc.io 作者 <a href="https://twitter.com/olebegemann">Ole Begemann</a> 写了<a href="http://oleb.net/blog/2010/12/animating-drawing-of-cgpath-with-cashapelayer">一篇文章</a>，阐述了如何将 <code>CAShapeLayer</code> 与基于路径的动画组合起来使用，并只用几行代码来创建酷炫的绘图动画。</p>

<h2>时间函数</h2>

<p>让我们再次来看看第一个例子：</p>

<p><center><img src="http://img.objccn.io/issue-12/rocket-linear.gif" width="400px" /></center></p>

<p>你会发现我们的火箭的动画有一些看起来非常不自然的地方。那是因为我们在现实世界中看到的大部分运动需要时间来加速或减速。对象瞬间达到最高速度，然后再立即停止往往看起来非常不自然。除非你在让<a href="https://www.youtube.com/watch?v=o8HkEprSaAs&amp;t=1m2s">机器人跳舞</a>，但这很少是想要的效果。</p>

<p>为了给我们的动画一个存在惯性的感觉，我们可以使用我们上面提到的参数因子来进行插值。然而，如果我们接下来需要为每个需要加速或减速的行为创建一个新的插值函数，这将是一个很难扩展的方法。</p>

<p>取而代之，常见的做法是把要进行动画的属性的插值从动画的速度中解耦出来。这样一来，给动画提速会产生一种小火箭加速运动的效果，而不用改变我们的插值函数。</p>

<p>我们可以通过引入一个 <em>时间函数 (timing function)</em> （有时也被称为 easing 函数）来实现这个目标。该函数通过修改持续时间的分数来控制动画的速度。</p>

<p><center><img src="http://img.objccn.io/issue-12/lerp-with-easing.png" width="145" /></center></p>

<p>最简单的 easing 函数是 <em>linear</em>。它在整个动画上维持一个恒定的速度。在 Core Animation 中，这个功能由 <code>CAMediaTimingFunction</code> 类表示。</p>

<p><img src="http://img.objccn.io/issue-12/rect-linear.gif" width="540px" /></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">keyPath</span> <span class="o">=</span> <span class="s">@&quot;position.x&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">50</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">150</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">timingFunction</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nl">functionWithName:</span><span class="n">kCAMediaTimingFunctionLinear</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">rectangle</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addAnimation:</span><span class="n">animation</span> <span class="nl">forKey:</span><span class="s">@&quot;basic&quot;</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">rectangle</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Core Animation 附带了一些 linear 之外的内置 easing 函数，如：</p>

<ul>
<li>Ease in (<code>kCAMediaTimingFunctionEaseIn</code>): <br />
<center><img src="http://img.objccn.io/issue-12/rect-easein.gif" width="540px" /></center></li>
<li>Ease out (<code>kCAMediaTimingFunctionEaseOut</code>): <br />
<center><img src="http://img.objccn.io/issue-12/rect-easeout.gif" width="540px" /></center></li>
<li>Ease in ease out (<code>kCAMediaTimingFunctionEaseInEaseOut</code>): <br />
<center><img src="http://img.objccn.io/issue-12/rect-easeineaseout.gif" width="540px" /></center></li>
<li>默认 (<code>kCAMediaTimingFunctionDefault</code>): <br />
<center><img src="http://img.objccn.io/issue-12/rect-default.gif" width="540px" /></center></li>
</ul>

<p>在一定限度内，你也可以使用 <code>+functionWithControlPoints::::</code> 创建自己的 easing 函数。通过传递 cubic Bézier 曲线的两个控制点的 <em>x</em> 和 <em>y</em> 坐标，你可以轻松的创建自定义 easing 函数，比如我为我们的红色小火箭选择的那个。</p>

<blockquote>
  <p>这个方法因为有三个无名参数而声名狼藉，我们并不推荐在你的 API 中使用这种蛋疼的写法。</p>
</blockquote>

<p><center><img src="http://img.objccn.io/issue-12/rocket-custom.gif" width="400px" /></center></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">keyPath</span> <span class="o">=</span> <span class="s">@&quot;position.x&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">77</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">455</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">timingFunction</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nl">functionWithControlPoints:</span><span class="mf">0.5</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mf">0.9</span><span class="o">:</span><span class="mf">0.7</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">rocket</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addAnimation:</span><span class="n">animation</span> <span class="nl">forKey:</span><span class="s">@&quot;basic&quot;</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">rocket</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我不打算讲太多关于 Bézier 曲线的细节，在计算机图形学中，它们是创建平滑曲线的常用技术。你可能在基于矢量的绘图工具，比如 Sketch 或 Adobe Illustrator 中见过它们。</p>

<p><center><img src="http://img.objccn.io/issue-12/bezier.png" /></center></p>

<p>传递给 <code>+functionWithControlPoints::::</code> 的值有效地控制了控制点的位置。所得到的定时函数将基于得到的路径来调整动画的速度。x 轴代表时间的分数，而 y 轴是插值函数的输入值。</p>

<p>遗憾的是，由于这些部分被锁定在 <code>[0–1]</code> 的范围内，我们不可能用它来创建一些像预期动作 (Anticipation，一种像目标进发前先回退一点，到达目标后还过冲一会儿，见下图) 这样的常见效果。</p>

<p>我写了一个小型库，叫做 <a href="https://github.com/robb/RBBAnimation">RBBAnimation</a>，它包含一个允许使用 <a href="https://github.com/robb/RBBAnimation#rbbtweenanimation">更多复杂 easing 函数</a> 的自定义子类 <code>CAKeyframeAnimation</code>，包括反弹和包含负分量的 cubic Bézier 函数：</p>

<p><center><img src="http://img.objccn.io/issue-12/anticipate.gif" width="140" /></center></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">RBBTweenAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">RBBTweenAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">keyPath</span> <span class="o">=</span> <span class="s">@&quot;position.x&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">50</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">150</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">easing</span> <span class="o">=</span> <span class="n">RBBCubicBezier</span><span class="p">(</span><span class="mf">0.68</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.55</span><span class="p">,</span> <span class="mf">0.735</span><span class="p">,</span> <span class="mf">1.55</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><center><img src="http://img.objccn.io/issue-12/bounce.gif" width="140" /></center></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">RBBTweenAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">RBBTweenAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">keyPath</span> <span class="o">=</span> <span class="s">@&quot;position.x&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">50</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">150</span><span class="p">;</span>
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">animation</span><span class="p">.</span><span class="n">easing</span> <span class="o">=</span> <span class="n">RBBEasingFunctionEaseOutBounce</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2>动画组</h2>

<p>对于某些复杂的效果，可能需要同时为多个属性进行动画。想象一下，在一个媒体播放程序中，当切换到到随机曲目时我们让随机动画生效。看起来就像下面这样：</p>

<p><center><img src="http://img.objccn.io/issue-12/covers.gif" width="440" /></center></p>

<p>你可以看到，我们需要同时对上面的封面的 position，rotation 和 z-position 进行动画。使用 <code>CAAnimationGroup</code> 来动画其中一个封面的代码大概如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">zPosition</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class="line"><span class="n">zPosition</span><span class="p">.</span><span class="n">keyPath</span> <span class="o">=</span> <span class="s">@&quot;zPosition&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">zPosition</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="n">zPosition</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="n">zPosition</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">CAKeyframeAnimation</span> <span class="o">*</span><span class="n">rotation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAKeyframeAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class="line"><span class="n">rotation</span><span class="p">.</span><span class="n">keyPath</span> <span class="o">=</span> <span class="s">@&quot;transform.rotation&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">rotation</span><span class="p">.</span><span class="n">values</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span> <span class="err">@</span><span class="mi">0</span><span class="p">,</span> <span class="err">@</span><span class="mf">0.14</span><span class="p">,</span> <span class="err">@</span><span class="mi">0</span> <span class="p">];</span>
</span><span class="line"><span class="n">rotation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span>
</span><span class="line"><span class="n">rotation</span><span class="p">.</span><span class="n">timingFunctions</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span>
</span><span class="line">    <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nl">functionWithName:</span><span class="n">kCAMediaTimingFunctionEaseInEaseOut</span><span class="p">],</span>
</span><span class="line">    <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nl">functionWithName:</span><span class="n">kCAMediaTimingFunctionEaseInEaseOut</span><span class="p">]</span>
</span><span class="line"><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">CAKeyframeAnimation</span> <span class="o">*</span><span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAKeyframeAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class="line"><span class="n">position</span><span class="p">.</span><span class="n">keyPath</span> <span class="o">=</span> <span class="s">@&quot;position&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">position</span><span class="p">.</span><span class="n">values</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span>
</span><span class="line">    <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGPoint:</span><span class="n">CGPointZero</span><span class="p">],</span>
</span><span class="line">    <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">)],</span>
</span><span class="line">    <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGPoint:</span><span class="n">CGPointZero</span><span class="p">]</span>
</span><span class="line"><span class="p">];</span>
</span><span class="line"><span class="n">position</span><span class="p">.</span><span class="n">timingFunctions</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span>
</span><span class="line">    <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nl">functionWithName:</span><span class="n">kCAMediaTimingFunctionEaseInEaseOut</span><span class="p">],</span>
</span><span class="line">    <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nl">functionWithName:</span><span class="n">kCAMediaTimingFunctionEaseInEaseOut</span><span class="p">]</span>
</span><span class="line"><span class="p">];</span>
</span><span class="line"><span class="n">position</span><span class="p">.</span><span class="n">additive</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line"><span class="n">position</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">CAAnimationGroup</span> <span class="o">*</span><span class="n">group</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CAAnimationGroup</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="n">group</span><span class="p">.</span><span class="n">animations</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span> <span class="n">zPosition</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">position</span> <span class="p">];</span>
</span><span class="line"><span class="n">group</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span>
</span><span class="line"><span class="n">group</span><span class="p">.</span><span class="n">beginTime</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">card</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addAnimation:</span><span class="n">group</span> <span class="nl">forKey:</span><span class="s">@&quot;shuffle&quot;</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">card</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">zPosition</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们使用 <code>CAAnimationGroup</code> 得到的一个好处是可以将所有动画作为一个对象暴露出去。如果你要在应用程序中的多个地方用工厂对象创建的重用的动画的话，这将会非常有用。</p>

<p>你也可以使用动画组同时控制所有动画组成部分的时间。</p>

<h2 id="coreanimation">Core Animation 之外</h2>

<p>都现在了，你应该已经听说过 UIKit Dynamics 了，这是 iOS 7 中引入的一个物理模拟框架，它允许你使用约束和力来为 views 做动画。与 Core Animation 不同，它与你在屏幕上看到的内容交互更为间接，但是它的动态特性让你可以在事先不知道结果时创建动画。</p>

<p>Facebook 最近开源了 Paper 背后的动画引擎 <a href="https://github.com/facebook/pop">Pop</a>。从概念上讲，它介于 Core Animation 和 UIKit Dynamics 之间。它完美的使用了弹簧（spring）动画，并且能够在动画运行时操控目标值，而无需替换它。Pop 也可以在 OS X 上使用，并且允许我们在每个 <code>NSObject</code> 的子类中为任意属性进行动画。</p>

<h2>扩展阅读</h2>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html">Core Animation 编程指南</a></li>
<li><a href="https://en.wikipedia.org/wiki/12_basic_principles_of_animation">动画的 12 个基本原则</a></li>
<li><a href="http://oleb.net/blog/2010/12/animating-drawing-of-cgpath-with-cashapelayer">使用 CAShapeLayer 的 CGPath 动画绘图</a></li>
<li><a href="http://ronnqvi.st/controlling-animation-timing/">控制动画时间</a></li>
<li><a href="https://github.com/facebook/pop">pop</a></li>
<li><a href="https://github.com/robb/RBBAnimation">RBBAnimation</a></li>
</ul>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义Formatters]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/16/zi-ding-yi-formatters/"/>
    <updated>2014-05-16T14:09:57+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/16/zi-ding-yi-formatters</id>
    <content type="html"><![CDATA[<p>我们希望有一种快速的一次性的解决方案，可以把数据格式化为一种易读的格式。Foundation 框架中的就有 <code>NSFormatter</code> 可以很好地胜任这个工作。另外，在 Mac 上，Appkit 已经内建了 <code>NSFormatter</code> 的支持。</p>

<h2>内建格式器</h2>

<p>Foundation 框架中的 <code>NSFormatter</code> 是一个抽象类，它有两个已经实现的子类：<code>NSNumberFormatter</code> 与 <code>NSDateFormatter</code>。现在我们先跳过这些，来实现我们自己的子类。</p>

<p>如果你想了解更多的相关知识，我推荐阅读 <a href="http://nshipster.com/nsformatter/">NSHipster</a>。</p>

<h2>介绍</h2>

<p><code>NSFormatter</code> 除了抛出错误，其它什么事也不做。我还不知道有人想要用这个，当然如果它对你有用，就去用它吧。</p>

<p>因为我们不喜欢错误，我们在此实现一个 <code>NSFormatter</code> 的子类，它可以把 <code>UIColor</code> 实例转换成可读的名字。例如，以下代码可以返回字符串“Blue”:</p>

<pre><code>KPAColorFormatter *colorFormatter = [[KPAColorFormatter alloc] init];
[colorFormatter stringForObjectValue:[UIColor blueColor]] // Blue
</code></pre>

<p><code>NSFormatter</code> 的子类化有两个方法需要实现：<code>stringForObjectValue:</code> 与 <code>getObjectValue:ForString:errorDescription:</code>。我们先开始介绍第一个方法，因为这个方法更常用。第二个方法，就我所知，经常用于 OS X 上，并且通常不是很有用，我们将稍后介绍。</p>

<h2>初始化</h2>

<p>首先，我们需要做些初始化的工作。由于没有事先定义好的字典可以把颜色映射至名字，这些工作将由我们来完成。为了简化，这些工作将在初始化方法中完成：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span><span class="p">;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nl">initWithColors:</span><span class="err">@</span><span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">]</span><span class="o">:</span> <span class="s">@&quot;Red&quot;</span><span class="p">,</span>
</span><span class="line">        <span class="p">[</span><span class="n">UIColor</span> <span class="n">blueColor</span><span class="p">]</span><span class="o">:</span> <span class="s">@&quot;Blue&quot;</span><span class="p">,</span>
</span><span class="line">        <span class="p">[</span><span class="n">UIColor</span> <span class="n">greenColor</span><span class="p">]</span><span class="o">:</span> <span class="s">@&quot;Green&quot;</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<!-- more -->
<p>这里的 colors 是一个以 <code>UIColor</code> 实例为键，英语名为值的字典。大家可以自行地去实现 <code>initWithColors:</code> 方法。当然你也可以自行实现，或者直接前往 <a href="https://github.com/klaaspieter/KPAColorFormatter">Github repo</a> 获得答案。</p>

<h2>格式化对象值</h2>

<p>由于我们这里只可以格式化 <code>UIColor</code> 实例对象，于是在方法 <code>stringForObjectValue:</code> 中的第一件事就是判断传入的参数类型是否是 <code>UIColor</code> 类。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">stringForObjectValue:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">value</span><span class="p">;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">value</span> <span class="nl">isKindOfClass:</span><span class="p">[</span><span class="n">UIColor</span> <span class="n">class</span><span class="p">]])</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// To be continued...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在判断参数合法后，我们可以实现真正的逻辑了。我们的格式器中包含一个 <code>UIColor</code> 对象为键，颜色名为值的字典。因此，我们只需要以 <code>UIColor</code> 对象为键找到对应的值：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">stringForObjectValue:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">value</span><span class="p">;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">// Previously on KPAColorFormatter</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">colors</span> <span class="nl">objectForKey:</span><span class="n">value</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>以上代码是一个尽可能简单的实现。一个更高级（有用）的格式器应该是在我们的颜色字典中没有找到匹配的颜色时，返回一个最接近的颜色。大家可以自行实现，或是你不想花费太多功夫，可以前往 <a href="https://github.com/klaaspieter/KPAColorFormatter">Github repo</a>。</p>

<h2>反向格式化</h2>

<p>我们的格式器也应该支持反向格式化，即把字符串转成实例对象。这是通过 <code>getObjectValue:forString:errorDescription:</code> 方法实现。在 OS X 上，在使用 <code>NSCell</code> 时会经常用到这个方法。</p>

<p><code>NSCell</code> 有一个 <code>objectValue</code> 属性。默认情况下，<code>NSCell</code> 会用 <code>objectValue</code> 的描述，但是它也可以选择用一个格式器。在用 <code>NSTextFieldCell</code> 时，用户可以输入值，作为程序员，我们可能期望 <code>objedctValue</code> 可以根据根据输入的字符串转成一个 <code>UIColor</code> 实例。例如，用户如果输入“Blue”，我们需要返回一个 <code>[UIColor blueColor]</code> 实例的引用。</p>

<p>实现反向格式化分为两部分：一部分为当格式器可以成功地把字符串转成 <code>UIColor</code> 实例，另一部分当其不能成功转换。第一部分代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">getObjectValue:</span><span class="p">(</span><span class="n">out</span> <span class="n">__autoreleasing</span> <span class="kt">id</span> <span class="o">*</span><span class="p">)</span><span class="nv">obj</span>
</span><span class="line">             <span class="nf">forString:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">string</span>
</span><span class="line">      <span class="nf">errorDescription:</span><span class="p">(</span><span class="n">out</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">__autoreleasing</span> <span class="o">*</span><span class="p">)</span><span class="nv">error</span><span class="p">;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">__block</span> <span class="n">UIColor</span> <span class="o">*</span><span class="n">matchingColor</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">colors</span> <span class="nl">enumerateKeysAndObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">UIColor</span> <span class="o">*</span><span class="n">color</span><span class="p">,</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">if</span><span class="p">([</span><span class="n">name</span> <span class="nl">isEqualToString:</span><span class="n">string</span><span class="p">])</span> <span class="p">{</span>
</span><span class="line">            <span class="n">matchingColor</span> <span class="o">=</span> <span class="n">color</span><span class="p">;</span>
</span><span class="line">            <span class="o">*</span><span class="n">stop</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">matchingColor</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">matchingColor</span><span class="p">;</span>
</span><span class="line">        <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span> <span class="c1">// Snip</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里可以做一些优化，但是我们先不去做这些。以上方法会遍历我们颜色字典里的每一个对象 ，当一个颜色名字找到时，则会返回其对应关联的 <code>UIColor</code> 实例对象的引用，同时返回 YES 告知调用者我们已经成功地把字符串转成了一个 <code>UIColor</code> 实例对象。</p>

<p>现在处理第二部分：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">if</span> <span class="p">(</span><span class="n">matchingColor</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// snap</span>
</span><span class="line"><span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;No known color for name: %@&quot;</span><span class="p">,</span> <span class="n">string</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里，我们如果不能找到一个匹配的颜色，我们会检测调用者是否需要错误信息，如果需要，则把错误通过引用返回。这里检查错误很重要。如果你不这样做，程序就会 crash。同时，我们也会返回 NO，告知调用者这次转换失败。</p>

<h2>本地化</h2>

<p>到现在，我们已经建立了一个完全功能的 <code>NSFormatter</code> 的子类，当然这只是对于生活在美国的英语使用者而言有用。</p>

<p>但相比全世界 71.3 亿人，那才 3.19 亿。或者说，你还有 96% 的潜在用户。当然你可以说：这些潜在用户绝大部分都不是 iPhone 或 Mac 使用者，这么做有什么意思呢？这么想你就太扫兴了。</p>

<p><code>NSNumberFormatter</code> 与 <code>NSDateFormatter</code> 都有一个 locale 属性，它是 <code>NSLocale</code> 实例对象。我们现在来扩展格式器以支持本地化，让它可以根据 local 属性来返回对应翻译的名字。</p>

<h3>翻译</h3>

<p>首先，我们需要翻译颜色名字字符串。有关 genstring 与 *.lprojs 超出了本文的范围。有<a href="http://www.getlocalization.com/library/get-localization-mac/">很多文章</a>讨论这点。好了，不需要其它工作了，快要结束了。</p>

<h3>本地化的格式化</h3>

<p>接下来是本地化功能的实现。在获取翻译的字符串后，我们需要更新 <code>stringForObejectValue:</code> 方法。以前已经使用过 <code>NSLocalizedString</code> 的人可能已经早早的把每一个字符串都用 <code>NSLocalizedString</code> 替换了。但是我们不会这么做。</p>

<p>我们现在处理的是一个动态的 local，而 <code>NSLocalizedString</code> 只会查找当前默认的语言的翻译。在99%的情况下，这种默认的行为是你所想要的，但是我们会用格式化器的 locale 属性来动态查询语言。</p>

<p>以下是 <code>stringForObjectValue:</code> 的新的实现：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">stringForObjectValue:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">value</span><span class="p">;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">// Previously on... don&#39;t you hate these? I just watched that 20 seconds ago!</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSString</span> <span class="o">*</span><span class="n">languageCode</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">locale</span> <span class="nl">objectForKey:</span><span class="n">NSLocaleLanguageCode</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSURL</span> <span class="o">*</span><span class="n">bundleURL</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSBundle</span> <span class="nl">bundleForClass:</span><span class="n">self</span><span class="p">.</span><span class="n">class</span><span class="p">]</span> <span class="nl">URLForResource:</span><span class="n">languageCode</span>
</span><span class="line">                                                              <span class="nl">withExtension:</span><span class="s">@&quot;lproj&quot;</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSBundle</span> <span class="o">*</span><span class="n">languageBundle</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSBundle</span> <span class="nl">bundleWithURL:</span><span class="n">bundleURL</span><span class="p">];</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">languageBundle</span> <span class="nl">localizedStringForKey:</span><span class="n">name</span> <span class="nl">value:</span><span class="n">name</span> <span class="nl">table:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面的代码还有可以重构改进的地方，但因为把代码都放在同一个地方可以方便阅读，所以请大家多多包涵了。</p>

<p>首先，我们通过 locale 属性查找相应的语言，之后通过 NSBundle 找到对应的语言代码。最后，我们会让 bundle 对英语名称进行翻译。如果找不到对应的翻译，则会返回 name: 方法的参数（即英语名称）。如上即是 <code>NSLocalizedString</code> 的具体实现。</p>

<h3>本地化的反向格式化</h3>

<p>同样，我们也可以把颜色名称转成 <code>UIColor</code> 实例对象，当然，我认为这样做是不值得的。我们当前的实现适用于99%的情况。另外1%的情况是在 Mac 的 <code>NSCell</code> 上使用，而且你允许用户输入一个你试图解析的颜色的名字，这所需要做的要比简单的 子类化 NSFormatter 复杂很多。或许，你不应该允许你的用户通过文本输入颜色值。<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSColorPanel_Class/">NSColorPanel</a> 在这里是一个更好的解决方案。</p>

<h2>属性化字符串</h2>

<p>到目前为止，我们的格式器都按我们预期的工作。接下来让我们做一个完全没用的功能，只是示范一下我们可以这么做，你懂的。</p>

<p>格式器同时支持属性化字符串。要不要支持它取决于你特定的应用与其用户界面。因此，你最好把这个功能做成可配置。</p>

<p>以下代码就是将文本颜色设置为当前正在格式化的颜色：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSAttributedString</span> <span class="o">*</span><span class="p">)</span><span class="nf">attributedStringForObjectValue:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">value</span>
</span><span class="line">                                 <span class="nf">withDefaultAttributes:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">defaultAttributes</span><span class="p">;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">stringForObjectValue:</span><span class="n">value</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span>  <span class="p">(</span><span class="o">!</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableDictionary</span> <span class="nl">dictionaryWithDictionary:</span><span class="n">defaultAttributes</span><span class="p">];</span>
</span><span class="line">    <span class="n">attributes</span><span class="p">[</span><span class="n">NSForegroundColorAttributeName</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[[</span><span class="n">NSAttributedString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithString:</span><span class="n">string</span> <span class="nl">attributes:</span><span class="n">attributes</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>首先，我们如之前一样处理字符串，然后检查格式化是否成功。然后我们把默认的属性值与前面设置的颜色属性结合后，最终返回属性化字符串。很容易，是吗？</p>

<h2>便捷</h2>

<p>因为初始化内建的格式器<a href="https://twitter.com/ID_AA_Carmack/status/28939697453">太慢了</a>，所以通常需要对外给你的格式器提供一个便利的类方法。这个格式器应该用默认值与当前的本地化环境。以下是格式器的实现：</p>

<pre><code>+ (NSString *)localizedStringFromColor:(UIColor *)color;
{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        KPAColorFormatterReusableInstance = [[KPAColorFormatter alloc] init];
    });

    return [KPAColorFormatterReusableInstance stringForObjectValue:color];
}
</code></pre>

<p>除非你的格式器像 <code>NSNumberFormatter</code> 与 <code>NSDateFormatter</code> 一样做一些疯狂的事情 ，你可能不需要因为性能问题这么做。但是这样做也可以让使用格式器简单许多。</p>

<h2>总结</h2>

<p>我们的颜色格式器现在可以把一个 <code>UIColor</code> 实例格式成一个可读的名字或是反过来也行。当然还有放多有关 <code>NSFormatter</code> 的事情没有涉及。特别是在 Mac 上，因为它跟 <code>NSCell</code> 相关，你可以用更多高级的特性。例如当用户在编辑的时，你可以对字符串做一些检测。</p>

<p>我们的格式器还可以做更多自定义的事情。例如，在没查找到一个你需要的颜色名字时，我们可以返回给你最相近的颜色名字。有时，你可能需要我们的格式器有一个 Boolean 属性来控制该功能。或许我们的属性化字符串的格式化不是你想要的，并且应该支持更多自定义操作。</p>

<p>就此，我们完成了一个非常可靠的格式器。所有的代码（伴有 OS X 示例）都放在了 <a href="https://github.com/klaaspieter/KPAColorFormatter">Github</a> 上， 并且你也可以在 <a href="http://cocoapods.org/">CocoaPods</a> 上看到。如果你应用需要此功能，可以将 &#8220;KPAColorFormatter&#8221; 放在你的 Podfile 中，开始使用它吧。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[消息传递机制]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/14/xiao-xi-chuan-di-ji-zhi/"/>
    <updated>2014-05-14T21:31:58+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/14/xiao-xi-chuan-di-ji-zhi</id>
    <content type="html"><![CDATA[<p>每个应用或多或少都由一些需要相互传递消息的对象结合起来以完成任务。在这篇文章里，我们将介绍所有可用的消息传递机制，并通过例子来介绍怎样在苹果的框架里使用。我们还会选择一些最佳范例来介绍什么时候该用什么机制。</p>

<p>虽然这一期的主题是关于 Foundation 框架的，但是我们会超出 Foundation 的消息传递机制 (KVO 和 通知) 来讲一讲 delegation，block 和 target-action 几种机制。</p>

<p>当然，有些情况下该使用什么机制没有唯一的答案，所以应该按照自己的喜好去试试。另外大多数情况下该使用什么机制应该是很清楚的。</p>

<p>本文中，我们会常常提及“接收者”和“发送者”。它们在消息传递中的意思可以通过以下的例子解释：一个 table view 是发送者，它的 delegate 就是接收者。Core Data managed object context 是它所发出的 notification 的发送者，获取 notification 的就是接收者。一个滑块 (slider) 是 action 消息的发送者，而实现这个 action （方法）的是它的接收者。任何修改一个支持 KVO 的对象的对象是发送者，这个 KVO 对象的观察者就是接收者。明白精髓了吗？</p>

<h2>几种消息传递机制</h2>

<p>首先我们来看看每种机制的具体特点。在这个基础上，下一节我们会画一个流程图来帮我们在具体情况下正确选择应该使用的机制。最后，我们会介绍一些苹果框架里的例子并且解释为什么在那些用例中会选择这样的机制。</p>

<h3 id="kvo">KVO</h3>

<p>KVO 是提供对象属性被改变时的通知的机制。KVO 的实现在 Foundation 中，很多基于 Foundation 的框架都依赖它。想要了解更多有关 KVO 的最佳实践，请阅读本期 Daniel 写的 <a href="http://objccn.io/issue-7-3">KVO 和 KVC 文章</a>。</p>

<p>如果只对某个对象的值的改变感兴趣的话，就可以使用 KVO 消息传递。不过有一些前提：第一，接收者（接收对象改变的通知的对象）需要知道发送者 （值会改变的对象）；第二，接收者需要知道发送者的生命周期，因为它需要在发送者被销毁前注销观察者身份。如果这两个要去符合的话，这个消息传递机制可以一对多（多个观察者可以注册观察同一个对象的变化）</p>

<p>If you plan to use KVO on Core Data objects, you have to know that things work a bit differently here. This has to do with Core Data&#8217;s faulting mechanism. Once a managed object turns into a fault, it will fire the observers on its properties although their values haven&#8217;t changed.</p>

<p>如果要在 Core Data 上使用 KVO 的话，方法会有些许差别。这和 Core Data 的 faulting 机制有关。一旦一个 managed object 被 faulting 处理的话，即使它的属性没有被改变，它还是会触发相应的观察者。</p>

<blockquote>
  <span class="secondary radius label">编者注</span> 把属性值先取入缓存中，在对象需要的时候再进行一次访问，这在 Core Data 中是默认行为，这种技术称为 Faulting。这么做可以避免降低内存开销，但是如果你确定将访问结果对象的具体属性值时，可以禁用 Faults 以提高获取性能。关于这个技术更多的情况，请移步<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdFaultingUniquing.html">官方文档</a>
</blockquote>

<h3>通知</h3>
<!-- more -->
<p>要在代码中的两个不相关的模块中传递消息时，通知机制是非常好的工具。通知机制广播消息，当消息内容丰富而且无需指望接收者一定要关注的话这一招特别有用。</p>

<p>通知可以用来发送任意消息，甚至可以包含一个 <code>userInfo</code> 字典。你也可以继承 <code>NSNotification</code> 写一个自己的通知类来自定义行为。通知的独特之处在于，发送者和接收者不需要相互知道对方，所以通知可以被用来在不同的相隔很远的模块之间传递消息。这就意味着这种消息传递是单向的，我们不能回复一个通知。</p>

<h3 id="delegation">委托 (Delegation)</h3>

<p>Delegation 在苹果的框架中广泛存在。它让我们能自定义对象的行为，并收到一些触发的事件。要使用 delegation 模式的话，发送者需要知道接收者，但是反过来没有要求。因为发送者只需要知道接收者符合一定的协议，所以它们两者结合的很松。</p>

<p>因为 delegate 协议可以定义任何的方法，我们可以照着自己的需求来传递消息。可以用方法参数来传递消息内容，delegate 可以通过返回值的形式来给发送者作出回应。如果只要在相对接近的两个模块间传递消息，delgation 是很灵活很直接的消息传递机制。</p>

<p>过度使用 delegation 也会带来风险。如果两个对象结合得很紧密，任何其中一个对象都不能单独运转，那么就不需要用 delegate 协议了。这些情况下，对象已经知道各自的类型，可以直接交流。两个比较新的例子是 <code>UICollectionViewLayout</code> 和 <code>NSURLSessionConfiguration</code>。</p>

<p><a name="blocks"> </a>  </p>

<h3 id="block">Block</h3>

<p>Block 是最近才加入 Objective-C 的，首次出现在 OS X 10.6 和 iOS 4 平台上。Block 通常可以完全替代 delegation 消息传递机制的角色。不过这两种机制都有它们自己的独特需求和优势。</p>

<p>一个不使用 block 的理由通常是 block 会存在导致 retain 环 (<a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/memorymgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-1000810">retain cycles</a>) 的风险。如果发送者需要 retain block 但又不能确保引用在什么时候被赋值为 <code>nil</code>， 那么所有在 block 内对 <code>self</code> 的引用就会发生潜在的 retain 环。</p>

<p>假设我们要实现一个用 block 回调而不是 delegate 机制的 table view 里的选择方法，如下所示：</p>

<pre><code>self.myTableView.selectionHandler = ^void(NSIndexPath *selectedIndexPath) {
    // 处理选择
};
</code></pre>

<p>这儿的问题是，<code>self</code> 会 retain table view，table view 为了让 block 之后可以使用而又需要 retain 这个 block。然而 table view 不能把这个引用设为 nil，因为它不知道什么时候不需要这个 block 了。如果我们不能保证打破 retain 环并且我们需要 retain 发送者，那么 block 就不是一个的好选择。</p>

<p><code>NSOperation</code> 是使用 block 的一个好范例。因为它在一定的地方打破了 retain 环，解决了上述的问题。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">self</span><span class="p">.</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="n">MyOperation</span> <span class="o">*</span><span class="n">operation</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyOperation</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="n">operation</span><span class="p">.</span><span class="n">completionBlock</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="n">finishedOperation</span><span class="p">];</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">queue</span> <span class="nl">addOperation:</span><span class="n">operation</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>一眼看来好像上面的代码有一个 retain 环：<code>self</code> retain 了 queue，queue retain 了 operation， operation retain 了 completionBlock， 而 completionBlock retain 了 <code>self</code>。然而，把 operation 加入 queue 中会使 operation 在某个时间被执行，然后被从 queue 中移除。（如果没被执行，问题就大了。）一旦 queue 把 operation 移除，retain 环就被打破了。</p>

<p>另一个例子是：我们在写一个视频编码器的类，在类里面我们会调用一个 <code>encodeWithCompletionHandler:</code> 的方法。为了不出问题，我们需要保证编码器对象在某个时间点会释放对 block 的引用。其代码如下所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">Encoder</span> <span class="p">()</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">completionHandler</span><span class="p">)();</span>
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">Encoder</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">encodeWithCompletionHandler:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">handler</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">completionHandler</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
</span><span class="line">    <span class="c1">// 进行异步处理...</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">// 这个方法会在完成后被调用一次</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">finishedEncoding</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">completionHandler</span><span class="p">();</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">completionHandler</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span> <span class="c1">// &amp;lt;- 不要忘了这个!</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>一旦任务完成，completion block 调用过了以后，我们就应该把它设为 <code>nil</code>。</p>

<p>如果一个被调用的方法需要发送一个一次性的消息作为回复，那么使用 block 是很好的选择， 因为这样做我们可以打破潜在的 retain 环。另外，如果将处理的消息和对消息的调用放在一起可以增强可读性的话，我们也很难拒绝使用 block 来进行处理。在用例之中，使用 block 来做完成的回调，错误的回调，或者类似的事情，是很常见的情况。</p>

<h3 id="targetaction">Target-Action</h3>

<p>Target-Action 是回应 UI 事件时典型的消息传递方式。iOS 上的 <code>UIControl</code> 和 Mac 上的 <code>NSControl</code>/<code>NSCell</code> 都支持这个机制。Target-Action 在消息的发送者和接收者之间建立了一个松散的关系。消息的接收者不知道发送者，甚至消息的发送者也不知道消息的接收者会是什么。如果 target 是 <code>nil</code>，action 会在<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/Devpedia-CocoaApp/Responder.html">响应链 (responder chain)</a> 中被传递下去，直到找到一个响应它的对象。在 iOS 中，每个控件甚至可以和多个 target-action 关联。</p>

<p>基于 target-action 传递机制的一个局限是，发送的消息不能携带自定义的信息。在 Mac 平台上 action 方法的第一个参数永远接收者。iOS 中，可以选择性的把发送者和触发 action 的事件作为参数。除此之外就没有别的控制 action 消息内容的方法了。</p>

<h2>做出正确的选择</h2>

<p>基于上述对不同消息传递机制的特点，我们画了一个流程图来帮助我们在不同情境下做出不同的选择。一句忠告：流程图的建议不代表最终答案。有些时候别的选择依然能达到应有的效果。只不过大多数情况下这张图能引导你做出正确的决定。</p>

<p><img src="http://img.objccn.io/issue-7/communication-patterns-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="688" /></p>

<p>图中有些细节值得深究：</p>

<p>有个框中说到： <em>发送者支持 KVO</em>。这不仅仅是说发送者会在值改变的时候发送 KVO 通知，而且说明观察者需要知道发送者的生命周期。如果发送者被存在一个 weak 属性中，那么发送者有可能会自己变成 nil，那时观察者会导致内存泄露。</p>

<p>一个在最后一行的框里说，<em>消息直接响应方法调用</em>。也就是说方法调用的接收者需要给调用者一个消息作为方法调用的直接反馈。这也就是说处理消息的代码和调用方法的代码必须在同一个地方。</p>

<p>最后在右下角的地方，一个选择分支这样说：<em>发送者能确保释放对 block 的引用吗？</em>这涉及到了我们<a href="#block">之前</a>讨论 block 的 API 存在潜在的 retain 环的问题。如果发送者不能保证在某个时间点会释放对 block 的引用，那么你会惹上 retain 环的麻烦。</p>

<h2 id="framework">Framework 示例</h2>

<p>本节我们通过一些苹果框架里的例子来验证流程图的选择是否有道理，同时解释为什么苹果会选择用这些机制。</p>

<h3 id="kvo">KVO</h3>

<p><code>NSOperationQueue</code> 用了 KVO 观察队列中的 operation 状态属性的改变情况 (<code>isFinished</code>，<code>isExecuting</code>，<code>isCancelled</code>)。当状态改变的时候，队列会收到 KVO 通知。为什么 operation 队列要用 KVO 呢？</p>

<p>消息的接收者（operation 队列）知道消息的发送者（operation），并 retain 它并控制后者的生命周期。另外，在这种情况下只需要单向的消息传递机制。当然如果考虑到 oepration 队列只关心那些改变 operation 的值的改变情况的话，就还不足以说服大家使用 KVO 了。但我们可以这么理解：被传递的消息可以被当成值的改变来处理。因为 state 属性在 operation 队列以外也是有用的，所以这里适合用 KVO。</p>

<p><img src="http://img.objccn.io/issue-7/kvo-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="678" /></p>

<p>当然 KVO 不是唯一的选择。我们也可以将 operation 队列作为 operation 的 delegate 来使用，operation 会调用类似 <code>operationDidFinish:</code> 或者 <code>operationDidBeginExecuting:</code> 等方法把它的 state 传递给 queue。这样就不太方便了，因为 operation 要保存 state 属性，以便于调用这些 delegate 方法。另外，由于 queue 不能主动获取 state 信息，所以 queue 也必须保存所有 operation 的 state。</p>

<h3 id="notifications">Notifications</h3>

<p>Core Data 使用 notification 传递事件（例如一个 managed object context 中的改变————<code>NSManagedObjectContextObjectsDidChangeNotification</code>）</p>

<p>发生改变时触发的 notification 是由 managed object contexts 发出的，所以我们不能假定消息的接收者知道消息的发送者。因为消息的源头不是一个 UI 事件，很多接收者可能在关注着此消息，并且消息传递是单向的，所以 notification 是唯一可行的选择。</p>

<p><img src="http://img.objccn.io/issue-7/notification-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="687" /></p>

<h3 id="delegation">Delegation</h3>

<p>Table view 的 delegate 有多重功能，它可以从管理 accessory view，直到追踪在屏幕上显示的 cell。例如我们可以看看 <code>tableView:didSelectRowAtIndexPath:</code> 方法。为什么用 delegate 实现而不是 target-action 机制？</p>

<p>正如我们在上述流程图中看到的，用 target-action 时，不能传递自定义的数据。而选中 table view 的某个 cell 时，collection view 不仅需要告诉我们一个 cell 被选中了，也要通过 index path 告诉我们哪个 cell 被选中了。如果我们照着这个思路，流程图会引导我们使用 delegation 机制。</p>

<p><img src="http://img.objccn.io/issue-7/delegation-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="687" /></p>

<p>如果不在消息传递中包含选中 cell 的 index path，而是让选中项改变时我们像 table view 主动询问并获取选中 cell 的相关信息，会怎样呢？这会非常不方便，因为我们必须记住当前选中项的数据，这样才能在多选择中知道哪些 cell 是被新选中的。</p>

<p>同理，我们可以想象通过观察 table view 选中项的 index path 属性，当该值发生改变的时候，获得一个选中项改变的通知。不过我们会遇到上述相似问题：不做记录的话我们就不能分辨哪一个 cell 被选择或取消选择了。</p>

<h3 id="block">Block</h3>

<p>我们用 <code>-[NSURLSession dataTaskWithURL:completionHandler:]</code> 来作为一个 block API 的介绍。那么从 URL 加载部分返回给调用者是怎么传递消息的呢？首先，作为 API 的调用者，我们知道消息的发送者，但是我们并没有 retain 它。另外，这是个单向的消息传递————它直接调用 <code>dataTaskWithURL:</code> 的方法。如果我们对照流程图，会发现这属于 block 消息传递机制。</p>

<p><img src="http://img.objccn.io/issue-7/block-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="688" /></p>

<p>有其他的选项吗？当然，苹果自己的 <code>NSURLConnection</code> 就是最好的例子。<code>NSURLConnection</code>在 block 问世之前就存在了，所以它并没有用 block 来实现消息传递，而是使用 delegation 来完成。当 block 出现以后，苹果就在 OS X 10.7 和 iOS 5 平台上的 <code>NSURLConnection</code> 中加了 <code>sendAsynchronousRequest:queue:completionHandler:</code>，所以我们不再在简单的任务中使用 delegate 了。</p>

<p>因为 <code>NSURLSession</code> 是个最近在 OS X 10.9 和 iOS 7 才出现的 API，所以它们使用 block 来实现消息传递机制（<code>NSURLSession</code> 有一个 delegate，但是是用于其他目的）。</p>

<h3 id="targetaction">Target-Action</h3>

<p>一个明显的 target-action 用例是按钮。按钮在不被按下的时候不需要发送任何的信息。为了这个目的，target-action 是 UI 中消息传递的最佳选择。</p>

<p><img src="http://img.objccn.io/issue-7/target-action-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="678" /></p>

<p>如果 target 是明确指定的，那么 action 消息会发送给指定的对象。如果 target 是 <code>nil</code>， action 消息会一直在响应链中被传递下去，直到找到一个能处理它的对象。在这种情况下，我们有一个完全解耦的消息传递机制：发送者不需要知道接收者，反之亦然。</p>

<p>Target-action 机制非常适合响应 UI 的事件。没有其他的消息传递机制能够提供相同的功能。虽然 notification 在发送者和接收者的松散关系上最接近它，但是 target-action 可以用于响应链——只有一个对象获得 action 并响应，action 在响应链中传递，直到能遇到响应这个 action 的对象。</p>

<h2>总结</h2>

<p>一开始接触这么多的消息传递机制的时候，我们可能有些无所适从，觉得所有的机制都可以被选用。不过一旦我们仔细分析每个机制的时候，它们各自都有特殊的要求和能力。</p>

<p>文中的选择流程图是帮助你清楚认识这些机制的好的开始，当然它不是所有问题的答案。如果你觉得这和你自己选择机制的方式相似或是有任何缺漏，欢迎来信指正。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语言标签]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/14/yu-yan-biao-qian/"/>
    <updated>2014-05-14T21:13:29+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/14/yu-yan-biao-qian</id>
    <content type="html"><![CDATA[<p>当我们处理自然语言（相对于程序语言而言）的时候会遇到一项挑战，即涵义模棱两可。程序语言是被设计成为有且只有一个可能解释的语言，而人类语言可能由于模糊性和不确定性衍生出很多问题。这是由于有时候你并不想确切地告诉别人你对某事物的想法。在社交场合这完全没有问题，但是当你试图使用计算机来处理人类语言的话，就会非常痛苦。</p>

<p>词法标识（token）就是一个简单的例子。程序语言的词法分析对于标识表示什么，它是什么类型（语句分隔符，标识符，保留关键字等等）是什么有着明确的规则。而自然语言则远不能如此清晰可辩。<em>can’t</em> 是一个还是两个标识？并且根据你做出的判断，<em>cannot</em> 或者 <em>can not</em> 这两个应该是相同意思的词又各是几个标识呢？很多复合词都可以写成一个词（比如：<em>bookshelf</em>），或者两个词（比如：<em>lawn mower</em>），甚至还可以用连字符来连接（比如：<em>life-cycle</em>）。有些字符 （比如说连字符或者右肩单撇号），可以有很多种解释，而如何选择正确字符往往取决于上下文语言环境（撇号在一个单词的最后是表示所有格符号还是后单引号？）</p>

<p>句子的情况同样不怎么好：如果简单认为句号是用来结束一个句子的话，在我们使用缩写或是序数的时候就悲剧了。虽然通常情况下，我们是可以解决这个问题的，但是对有些句子而言，除非将整个段落彻底分析，否则无法真正确定这些句子的意思。我们人类甚至也无法有意识地考虑这些问题。</p>

<p>不过我们希望能够处理人类语言，因为在跟软件交流的时候，使用人类语言对用户更加友好。我们更愿意直接告诉计算机要做什么，让计算机为我们分析报纸文章，并对我们感兴趣的新闻做个总结，而不是通过敲击键盘或者点击小小的按钮（或者在小小的虚拟键盘上打字）来让计算机为我们做这些事。其中有些还在我们的能力范围之外（至少在苹果为我们提供与 Siri 交互的  API 之前）。但是有些已经成为可能，那就是 <code>NSLinguisticTagger</code>。</p>

<p><code>NSLinguisticTagger</code> 是 Foundation 框架中命名极为不当的类之一，这是因为它远远不止是一个小小的词性 tagger，而是集词法分析，分词器，命名实体识别及词性标注为一体的类。换句话说，它几乎可以满足你处理某些计算机语言处理的全部要求。</p>

<p>为了展示 <code>NSLinguisticTagger</code> 类的用法，我们会开发一个灵活的工具用来搜索。我们有一个充满了文本（比如新闻，电邮，或者其他的任意文本）的集合，然后我们输入一个单词，这个单词将返回所有包含这个单词的句子。我们会忽略功能词（比如 <em>the</em>，<em>of</em> 或者 <em>and</em>），因为它们在这个语言环境中太过于常见，没有什么用处。我们目前要实现的是第一步：从一个单独文件中提取相关单词。由此可以迅速地扩展到提供完整功能。</p>

<p><a href="https://github.com/objcio/issue-7-linguistic-tagging">GitHub</a> 上有源代码和样本文本。这是《卫报》上一篇关于中英贸易的文章。当用软件分析这份文本时，你会发现，它并不是总是运行良好，不过，出现运行故障完全正常：人类语言和任何正式语言都不同，人类语言凌乱复杂，无法简单划归到整齐划一的规则系统。很多理论问题（哪怕就像词性一样基础的问题）在某种程度上是无法解决的，这是由于我们仍然对如何才能最好地描述语言还所知甚少。比如说，词的分类是以拉丁语为依据的，但这并不意味着就必定适合英语。它们充其量只是大概近似而已。不过从很多实际的目的来看，这样就已经足够了，不需要让人怎么担心了。</p>
<!-- more -->
<h2 id="tagschemes">标签体系 (Tag Schemes)</h2>

<p>注释和标记文本的核心方法就是标签体系的核心方法。以下是几个可用的标签体系：</p>

<ul>
<li><code>NSLinguisticTagSchemeTokenType</code></li>
<li><code>NSLinguisticTagSchemeLexicalClass</code></li>
<li><code>NSLinguisticTagSchemeNameType</code></li>
<li><code>NSLinguisticTagSchemeNameTypeOrLexicalClass</code></li>
<li><code>NSLinguisticTagSchemeLemma</code></li>
<li><code>NSLinguisticTagSchemeLanguage</code></li>
<li><code>NSLinguisticTagSchemeScript</code></li>
</ul>

<p><code>NSLinguisticTagger</code> 实例扫描文本中的所有条目，并调用一个包含被请求的标签体系值的 block。最基础的是 <code>NSLinguisticTagSchemeTokenType</code>：词，标点，空格，或是“其他”。我们可以使用这个来识别哪些是真正的词，那么我们在应用程序中就可以简单地忽略其他那些不是有效词的语素。<code>NSLinguisticTagSchemeLexicalClass</code> 和词性有关，是一组非常基础的标签（就严格意义上的语言分析而言，这组标签还远远不够精细），我们可以使用这组标签来分辨我们想要的实词（名词，动词，形容词，副词）和我们想忽略的虚词（连词，介词，冠词等等）。在 <code>NSLinguisticTagger</code> 类的<a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/NSLinguisticTagger_Class/Reference/Reference.html">文档</a>中写明了全套可能值。</p>

<p><code>NSLinguisticTagSchemeNameType</code> 是指命名实体识别：我们可以知道一个词是不是表示人物，地点或者组织。同样的，这相对于自然语言的处理而言是相当基本，但却非常有用的，比如说你想搜索一个特定的人物或者地点。还有一种潜在的应用是“给我一份文本中所提到的所有政治家的名录”，你可以浏览这份文本中的人名，然后查阅数据库（比如维基）来核对他们是否确实是政治家。这也可以跟 lexical 类相结合，因为这往往包含一个分类叫做“名字”。</p>

<p><code>NSLinguisticTagSchemeLemma</code> 是词汇的标准形式，或者说是其基本形式。对英语而言，这不是什么大问题，不过对于其它语言而言却重要得多。原型基本上就是你在词典中查的到的那个形式。比如说，<em>tables</em> 是一个复数名词，它的基本形式是单数的 <em>table</em>。同样的，动词 <em>running</em> 是由 <em>run</em> 变形而来的不定式。如果你想要以同样的方式处理各种词类的变形，使用原形就非常有用，事实上这也是我们要为我们的示例应用程序所做的 (因为这可以有助于保持索引不过于庞大)。</p>

<p><code>NSLinguisticTagSchemeLanguage</code> 和我们所使用的语言相关。如果你使用iOS（截至iOS7），目前只能处理英语。使用OS X（截至10.9 / Mavericks）你可以稍微多几种语言可以选择。<code>+[NSLinguisticTagger availableTagSchemesForLanguage:]</code> 方法为我们列举了对于给定语言的所有可用体系。对于在 iOS 中对应语言数量限制的原因很可能是资源文件要占用大量空间。在笔记本或者台式电脑上不是什么大问题，但是在手机或者平板上的话就不太妙了。</p>

<p><code>NSLinguisticTagSchemeScript</code> 是书写体系，比如拉丁字母 (Latin)，西里尔字母 (Cyrillic) 等等。对于英语，我们将使用拉丁字母。如果你知道你将处理哪种语言，使用 <code>setOrthography</code> 方法可以改善标签的结果，特别对相对较短的字符而言更是如此。</p>

<h2>标签选项</h2>

<p>目前我们已经知道 <code>NSLinguisticTagger</code> 可以为我们识别什么了，我们需要告诉它我们想要什么，以及我们想如何获得。这里有几个可以定义 tagger 行为的选项，它们都是 <code>NSUInteger</code> 类型的，并且可以使用位运算 OR 组合使用。</p>

<p>第一个选项是“省略单词”，除非你只想看标点或者其它非词类，否则这个选项毫无意义。比较有用的是下面的三个选项：“省略标点（omit punctuation）”，“省略空格（omit whitespace）”以及“省略其他（omit other）”。除非你想要对文本做全面语言分析，否则你基本上只会对单词感兴趣，而对其中的逗号句号则兴趣不大。有了这些选项，就可以轻轻松松让 tagger 对单词作出限制，再也不用挂虑在心。最后一个选项是“连接名字（join names）”，因为名字有时不仅仅是一个标识。这个选项会将它们结合在一起，作为一个独立的语言单位来处理。这个选项可能不会总是用得上，但是确实非常有用。举个例子，在样本文本中，字符串“Owen Patterson”被识别为一个名称，并且作为一个独立的语言单位被返回。</p>

<h2>处理架构</h2>

<p>程序会给一定数量的文本在独立文件中建立索引（我们假设是使用UTF-8编码）。我们将使用一个 <code>FileProcessor</code> 类来处理一个单独文件，将文件内容分为一个一个单词，再把这些单词传递给另一类来进行处理。后一个类将实现 <code>WordReceiver</code> 接口，其中包括一个方法：</p>

<pre><code>-(void)receiveWord:(NSDictionary*)word
</code></pre>

<p>我们不是使用 <code>NSString</code> 来表示单词，而是使用字典，这是因为一个单词会有很多属性，包括实际标识，词性或名称类型，原型，所在句子的数目，句子中的位置等。为了建立索引，我们还想储存文件名。调用 <code>FileProcessor</code> 的这个方法：</p>

<pre><code>- (BOOL)processFile:(NSString*)filename
</code></pre>

<p>将触发分析，如果一切进行顺利的话，返回 <code>YES</code>，在出现错误的时候返回 <code>NO</code>。它首先由文件创建一个 <code>NSString</code>，然后将其传递给一个 <code>NSLinguisticTagger</code> 实例来处理。</p>

<p><code>NSLinguisticTagger</code> 主要做的是的在一个 <code>NSString</code> 中进行扫描并对寻找到的每一个元素调用 block。为了稍作简化，我们首先将文本分解为一个个的句子，然后分别扫描每一个句子。这样比较容易追踪句子的 ID。至于标签，我们会处理大量的 <code>NSRange</code>，它们可以被用来界定源文件中文本的注解。我们从在第一个句子范围内创建一个搜索范围开始，并使用其在最大程度上获得初始语句的标签。</p>

<pre><code>NSRange currentSentence = [tagger sentenceRangeForRange:NSMakeRange(0, 1)];
</code></pre>

<p>一旦句子处理结束，就检查是否成功完成全部的文本，或者是否还有更多的句子等待处理：</p>

<pre><code>if (currentSentence.location + currentSentence.length == [fileContent length]) {
    currentSentence.location = NSNotFound;
} else {
    NSRange nextSentence = NSMakeRange(currentSentence.location + currentSentence.length + 1, 1);
    currentSentence = [tagger sentenceRangeForRange:nextSentence];
}
</code></pre>

<p>如果已经到了文本的末尾，我们将使用 <code>NSNotFound</code> 来对 <code>while</code> 循环发出终止信号。如果我们使用一个超出文本之外的范围，<code>NSLinguisticTagger</code> 将抛出一个异常并且直接崩溃。</p>

<p>句子处理循环中的主要方法调用如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">while</span> <span class="p">(</span><span class="n">currentSentence</span><span class="p">.</span><span class="n">location</span> <span class="o">!=</span> <span class="n">NSNotFound</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">__block</span> <span class="n">NSUInteger</span> <span class="n">tokenPosition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">tagger</span> <span class="nl">enumerateTagsInRange:</span><span class="n">currentSentence</span>
</span><span class="line">                          <span class="nl">scheme:</span><span class="n">NSLinguisticTagSchemeNameTypeOrLexicalClass</span>
</span><span class="line">                         <span class="nl">options:</span><span class="n">options</span>
</span><span class="line">                      <span class="nl">usingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">tag</span><span class="p">,</span> <span class="n">NSRange</span> <span class="n">tokenRange</span><span class="p">,</span> <span class="n">NSRange</span> <span class="n">sentenceRange</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">NSString</span> <span class="o">*</span><span class="n">token</span> <span class="o">=</span> <span class="p">[</span><span class="n">fileContent</span> <span class="nl">substringWithRange:</span><span class="n">tokenRange</span><span class="p">];</span>
</span><span class="line">        <span class="n">NSString</span> <span class="o">*</span><span class="n">lemma</span> <span class="o">=</span> <span class="p">[</span><span class="n">tagger</span> <span class="nl">tagAtIndex:</span><span class="n">tokenRange</span><span class="p">.</span><span class="n">location</span>
</span><span class="line">                                      <span class="nl">scheme:</span><span class="n">NSLinguisticTagSchemeLemma</span>
</span><span class="line">                                  <span class="nl">tokenRange:</span> <span class="nb">NULL</span>
</span><span class="line">                               <span class="nl">sentenceRange:</span><span class="nb">NULL</span><span class="p">];</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">lemma</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">lemma</span> <span class="o">=</span> <span class="n">token</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">delegate</span> <span class="nl">receiveWord:</span><span class="err">@</span><span class="p">{</span>
</span><span class="line">            <span class="s">@&quot;token&quot;</span><span class="o">:</span> <span class="n">token</span><span class="p">,</span>
</span><span class="line">            <span class="s">@&quot;postag&quot;</span><span class="o">:</span> <span class="n">tag</span><span class="p">,</span>
</span><span class="line">            <span class="s">@&quot;lemma&quot;</span><span class="o">:</span> <span class="n">lemma</span><span class="p">,</span>
</span><span class="line">            <span class="s">@&quot;position&quot;</span><span class="o">:</span> <span class="err">@</span><span class="p">(</span><span class="n">tokenPosition</span><span class="p">),</span>
</span><span class="line">            <span class="s">@&quot;sentence&quot;</span><span class="o">:</span> <span class="err">@</span><span class="p">(</span><span class="n">sentenceCounter</span><span class="p">),</span>
</span><span class="line">            <span class="s">@&quot;filename&quot;</span><span class="o">:</span> <span class="n">filename</span>
</span><span class="line">        <span class="p">}];</span>
</span><span class="line">        <span class="n">tokenPosition</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们让 tagger 处理 <code>NSLinguisticTagSchemeNameTypeOrLexicalClass</code>，指定一组选项（连接名字，省略标点和空格）。然后我们获取这个标签，以及搜索到的每一项条目的范围，并进一步检索信息。标识（token）是字符串一部分，仅仅由字符范围来描述。lemma 是基本形式，如果不可能用的这个值会是 <code>nil</code>，所以我们需要做检查，并使用标识字符串作为候补值。一旦收集到这个信息，我们就可以将其打包到一个字典中，然后发送给 delegate 进行处理。</p>

<p>在我们的示例应用中，我们仅仅输出了我们接收到的单词，但是我们在这里基本上可以做任何我们想做的一切。为了实现搜索，我们可以过滤掉除了名词，动词，形容词，副词和名字以外的所有词，并且在索引数据库中储存这些单词的位置。使用原形，而不使用标识值，可以使我们合并各种词的变形 (<em>pig</em> 和 <em>pigs</em>)，这可以保持索引不过于庞大，并且与仅只匹配实际标识词相比，也可以检索出更相关的词。请记住，你可能还要将所有查询按照原形变化进行归类，否则，搜索 <em>pigs</em> 的话将不会返回任何结果。</p>

<p>为了更加真实，我在样本文本头部信息中加进了一些基本 HTML 标签，比如确定标题，署名，日期。在通过 tagger 运行的时候出现一个问题，即 <code>NSLinguisticTagger</code> 是不知道关于 HTML 的东西的，并试图将这些 HTML 标记当做文本来处理。下面是最前面的三个检索词。</p>

<pre><code>{
    filename = "/Users/oliver/tmp/guardian-article.txt";
    lemma = "&lt;";
    position = 0;
    postag = Particle;
    sentence = 0;
    token = "&lt;";
}
{
    filename = "/Users/oliver/tmp/guardian-article.txt";
    lemma = h1;
    position = 1;
    postag = Verb;
    sentence = 0;
    token = h1;
}
{
    filename = "/Users/oliver/tmp/guardian-article.txt";
    lemma = "&gt;";
    position = 2;
    postag = Adjective;
    sentence = 0;
    token = "&gt;";
}
</code></pre>

<p>不仅仅是标签被分成了几个部分，被当做词来处理，而且还得到了奇怪和完全错误的标签。所以，如果你在处理包含标记的文件，最好先将其过滤出来。或许，你想要识别出标签，并返回覆盖标签区域的 <code>NSRange</code>，而不是像我们之前处理示例应用一样将整个文本分成一个个句子。或者说，如果存在内嵌标签（比如加粗，斜体，超链接），将标签全部剔除出来会更好些。</p>

<h2>结果</h2>

<p>就算是用 tagger 来处理通用语言，其表现也出人意料的优秀。如果你仅仅处理某一个领域（比如技术文本）的话，你可以做出一些在处理不受限制的文本时无法做到的假设。但是苹果的 tagger 必须在无法预知会遇到什么的情况下也能工作，鉴于如此，它偶尔也会出错，不过相对来说是非常少的。很显然，很多名称无法识别，比如说 <em>Chengdu</em> 这样的地名。但另一方面，文本中大多数人名的处理都是非常不错的。由于某些原因，日期（<em>Wednesday 4 December 2013 10.35 GMT</em>）被当做了人名来处理，可能是来源于鲁宾逊•克鲁索的命名习惯吧。环境大臣 <em>Owen Patterson</em> 可以被识别出来，但是，一般被认为更加重要的首相 <em>David Cameron</em> 却没有被识别出来，尽管 <em>David</em> 是个更为常见的名字。</p>

<p>这是概率 tagger 的问题：有时候很难理解为什么某些词以特定的方式被加上标签。也没有什么像钩子一样的东西可以挂靠 tagger，可以让你提供比如说已知的地点，人物或者组织的名称列表。你只能用默认设置进行处理。因此，最好使用大量数据来测试那些带有 tagger 的应用程序，通过观察结果，你可以大概知道哪些可以正常运行，哪些会遇到问题。</p>

<h2>概率</h2>

<p>有很多种方法来实现词性标签：两个主要的途径，一个是规则性的，一个是随机性。两种途径都有一套相当庞大的规则来告诉你，形容词的后面是名词，而不是冠词，或者有一个概率矩阵告诉你某一个特定的标签会出现在一个特定的语言环境中的可能性有多大。你也可以使用基于概率性的模型，同时添加一些规则来修正反复出现的典型错误，这就是所谓的混合 tagger。由于为不同语言开发规则集比自动学习随机语言模型的成本要高得多，所以我猜测 <code>NSLinguisticTagger</code> 应该是基于完全的随机模型。这个实现细节也可以从下面的方法中窥探一二：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">possibleTagsAtIndex:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">charIndex</span>
</span><span class="line">                          <span class="nf">scheme:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">tagScheme</span>
</span><span class="line">                      <span class="nf">tokenRange:</span><span class="p">(</span><span class="n">NSRangePointer</span><span class="p">)</span><span class="nv">tokenRange</span>
</span><span class="line">                   <span class="nf">sentenceRange:</span><span class="p">(</span><span class="n">NSRangePointer</span><span class="p">)</span><span class="nv">sentenceRange</span>
</span><span class="line">                          <span class="nf">scores:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">**</span><span class="p">)</span><span class="nv">scores</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这说明了一个事实，那就是有时候（其实是大多数时候）会出现多个可能的标签值，tagger 必须判断哪个可能是错误的。使用这个方法，你可以获得一份选项列表和概率得分。得分最高的词则被 tagger 选中，但是如果你想要创建一套基于规则的后处理来改善 tagger 工作，你依然可以访问得分第二的词或者其他候选项。</p>

<p>对于这个方法要提高警惕，其中有个 bug，实际上它并没有返回任何的分数。不过在 OS X 10.9 / Mavericks 中这个 bug 已被修复。所以，如果你需要支持 OS X 10.9 / Mavericks 之前的版本，会提示你无法使用这个方法。顺带一提，在 iOS 7 中这个方法可以良好运行。</p>

<p>下面是几个 <em>When is the next train…:</em> 的输出案例：</p>

<table><thead><tr><th style="text-align: left;padding-right:1em;">When</th><th style="text-align: left;padding-right:1em;">is</th><th style="text-align: left;padding-right:1em;">the</th><th style="text-align: left;padding-right:1em;">next</th><th style="text-align: left;padding-right:1em;">train</th></tr></thead><tbody><tr><td style="text-align: left;padding-right:1em;">Pronoun, 0.9995162</td><td style="text-align: left;padding-right:1em;">Verb, 1</td><td style="text-align: left;padding-right:1em;">Determiner, 0.9999986</td><td style="text-align: left;padding-right:1em;">Adjective, 0.9292629</td><td style="text-align: left;padding-right:1em;">Noun, 0.8741992</td>  
</tr><tr><td style="text-align: left;padding-right:1em;">Conjunction, 0.0004337671</td><td style="text-align: left;padding-right:1em;" /><td style="text-align: left;padding-right:1em;">Adverb, 1.344403e-06</td><td style="text-align: left;padding-right:1em;">Adverb, 0.0636334</td><td style="text-align: left;padding-right:1em;">Verb, 0.1258008</td>  
</tr><tr><td style="text-align: left;padding-right:1em;">Adverb, 4.170838e-05</td><td style="text-align: left;padding-right:1em;" /><td style="text-align: left;padding-right:1em;" /><td style="text-align: left;padding-right:1em;">Preposition, 0.007003677</td><td style="text-align: left;padding-right:1em;">  
</td></tr><tr><td style="text-align: left;padding-right:1em;">Noun, 8.341675e-06</td><td style="text-align: left;padding-right:1em;" /><td style="text-align: left;padding-right:1em;" /><td style="text-align: left;padding-right:1em;">Noun, 0.0001000525</td><td style="text-align: left;padding-right:1em;">  
</td></tr></tbody></table>

<p>正如你所见，在这个例子中到现在为止，正确的 tag 拥有最高的概率。对于大多数应用程序而言，你可以保持程序简单，并认可 tagger 所提供的标签，而不对概率进行深究。不过你得承认 tagger 偶然也是会出错的，而你也可以访问到这些识别结果，并做出相应处理。 当然，如果你不亲自检查的话，你就不会知道 tagger 什么时候会出错。然而，其中一个线索是概率差：如果概率非常接近（和上面的例子不同），说不定就表示可能出错了。</p>

<h2>结论</h2>

<p>处理自然语言是很困难的，苹果给我们提供了一个非常好的工具，这个工具可以简便地支持绝大多数使用情况。当然，它也不是完美无缺的，即使最先进的语言处理工具也不是完美无缺的。iOS 目前只支持英语，不过随着技术改善，以及如果有足够大的内存来储存（毫无疑问会很大的）语言模型的话，这将有所改变。在此之前，我们会受到一些限制。不过还是有很多方法可以给应用程序添加语言支持。在文本编辑器中突出动词，理解用户键入的内容，或者处理外部数据文件等工作还是很简单的，<code>NSLinguisticTagger</code> 可以帮助你做到这一点。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[View-Layer协作]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/14/view-layerxie-zuo/"/>
    <updated>2014-05-14T11:30:43+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/14/view-layerxie-zuo</id>
    <content type="html"><![CDATA[<p>在 iOS 中，所有的 view 都是由一个底层的 layer 来驱动的。view 和它的 layer 之间有着紧密的联系，view 其实直接从 layer 对象中获取了绝大多数它所需要的数据。在 iOS 中也有一些单独的 layer，比如 <code>AVCaptureVideoPreviewLayer</code> 和 <code>CAShapeLayer</code>，它们不需要附加到 view 上就可以在屏幕上显示内容。两种情况下其实都是 layer 在起决定作用。当然了，附加到 view 上的 layer 和单独的 layer 在行为上还是稍有不同的。</p>

<p>基本上你改变一个单独的 layer 的任何属性的时候，都会触发一个从旧的值过渡到新值的简单动画（这就是所谓的可动画 <code>animatable</code>）。然而，如果你改变的是 view 中 layer 的同一个属性，它只会从这一帧直接跳变到下一帧。尽管两种情况中都有 layer，但是当 layer 附加在 view 上时，它的默认的隐式动画的 layer 行为就不起作用了。</p>

<blockquote>
  <p>animatable；几乎所有的层的属性都是隐性可动画的。你可以在文档中看到它们的简介是以 &#8216;animatable&#8217; 结尾的。这不仅包括了比如位置，尺寸，颜色或者透明度这样的绝大多数的数值属性，甚至也囊括了像 isHidden 和 doubleSided 这样的布尔值。 像 paths 这样的属性也是 animatable 的，但是它不支持隐式动画。</p>
</blockquote>

<p>在 Core Animation 编程指南的 “How to Animate Layer-Backed Views” 中，对<em>为什么</em>会这样做出了一个解释：</p>

<blockquote>
  <p>UIView 默认情况下禁止了 layer 动画，但是在 animation block 中又重新启用了它们</p>
</blockquote>

<p>这正是我们所看到的行为；当一个属性在动画 block 之外被改变时，没有动画，但是当属性在动画 block 内被改变时，就带上了动画。对于这是<em>如何</em>发生的这一问题的答案十分简单和优雅，它优美地阐明和揭示了 view 和 layer 之间是如何协同工作和被精心设计的。</p>

<p>无论何时一个可动画的 layer 属性改变时，layer 都会寻找并运行合适的 &#8216;action&#8217; 来实行这个改变。在 Core Animation 的专业术语中就把这样的动画统称为动作 (action，或者 <code>CAAction</code>)。</p>

<blockquote>
  <p>CAAction：技术上来说，这是一个接口，并可以用来做各种事情。但是实际中，某种程度上你可以只把它理解为用来处理动画。</p>
</blockquote>

<p>layer 将像文档中所写的的那样去寻找动作，整个过程分为五个步骤。第一步中的在 view 和 layer 中交互的部分是最有意思的：</p>

<p>layer 通过向它的 delegate 发送 <code>actionForLayer:forKey:</code> 消息来询问提供一个对应属性变化的 action。delegate 可以通过返回以下三者之一来进行响应：</p>
<!-- more -->
<ol>
<li>它可以返回一个动作对象，这种情况下 layer 将使用这个动作。  </li>
<li>它可以返回一个 <code>nil</code>， 这样 layer 就会到其他地方继续寻找。  </li>
<li>它可以返回一个 <code>NSNull</code> 对象，告诉 layer 这里不需要执行一个动作，搜索也会就此停止。</li>
</ol>

<p>而让这一切变得有趣的是，当 layer 在背后支持一个 view 的时候，view 就是它的 delegate；</p>

<blockquote>
  <p>在 iOS 中，如果 layer 与一个 UIView 对象关联时，这个属性<code>必须</code>被设置为持有这个 layer 的那个 view。</p>
</blockquote>

<p>理解这些之后，前一分钟解释起来还复杂无比的现象瞬间就易如反掌了：属性改变时 layer 会向 view 请求一个动作，而一般情况下 view 将返回一个 <code>NSNull</code>，只有当属性改变发生在动画 block 中时，view 才会返回实际的动作。哈，但是请别轻信我的这些话，你可以非常容易地验证到底是不是这样。只要对一个一般来说可以动画的 layer 属性向 view 询问动作就可以了，比如对于 &#8216;position&#8217;：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;outside animation block: %@&quot;</span><span class="p">,</span>
</span><span class="line">      <span class="p">[</span><span class="n">myView</span> <span class="nl">actionForLayer:</span><span class="n">myView</span><span class="p">.</span><span class="n">layer</span> <span class="nl">forKey:</span><span class="s">@&quot;position&quot;</span><span class="p">]);</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">UIView</span> <span class="nl">animateWithDuration:</span><span class="mf">0.3</span> <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;inside animation block: %@&quot;</span><span class="p">,</span>
</span><span class="line">          <span class="p">[</span><span class="n">myView</span> <span class="nl">actionForLayer:</span><span class="n">myView</span><span class="p">.</span><span class="n">layer</span> <span class="nl">forKey:</span><span class="s">@&quot;position&quot;</span><span class="p">]);</span>
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>运行上面的代码，可以看到在 block 外 view 返回的是 NSNull 对象，而在 block 中时返回的是一个 CABasicAnimation。很优雅，对吧？值得注意的是打印出的 NSNull 是带着一对尖括号的 (&#8221;<code>&lt;null&gt;</code>&#8221;)，这和其他对象一样，而打印 nil 的时候我们得到的是普通括号(<code>(null)</code>)： </p>

<pre><code>outside animation block: &lt;null&gt;
inside animation block: &lt;CABasicAnimation: 0x8c2ff10&gt;
</code></pre>

<p>对于 view 中的 layer 来说，对动作的搜索只会到第一步为止（至少我没有见过 view 返回一个 <code>nil</code> 然后导致继续搜索动作的情况）。对于单独的 layer 来说，剩余的四个步骤可以在 <a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CALayer_class/Introduction/Introduction.html#//apple_ref/occ/instm/CALayer/actionForKey:">CALayer 的 <code>actionForKey:</code> 文档</a>中找到。</p>

<h1 id="uikit">从 UIKit 中学习</h1>

<p>我很确定我们都会同意 UIView 动画是一组非常优秀的 API，它简洁明确。实际上，它使用了 Core Animation 来执行动画，这给了我们一个绝佳的机会来深入研究 UIKit 是如何使用 Core Animation 的。在这里甚至还有很多非常棒的实践和技巧可以让我们借鉴。:)</p>

<p>当属性在动画 block 中改变时，view 将向 layer 返回一个基本的动画，然后动画通过通常的 <code>addAnimation:forKey:</code> 方法被添加到 layer 中，就像显式地添加动画那样。再一次，别直接信我，让我们实践检验一下。</p>

<p>归功于 UIView 的 <code>+layerClass</code> 类方法，view 和 layer 之间的交互很容易被观测到。通过这个方法我们可以在为 view 创建 layer 时为其指定要使用的类。通过子类一个 UIView，以及用这个方法返回一个自定义的 layer 类，我们就可以重写 layer 子类中的 <code>addAnimation:forKey:</code> 并输出一些东西来验证它是否确实被调用。唯一要记住的是我们需要调用 super 方法，不然的话我们就把要观测的行为完全改变了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">DRInspectionLayer</span> : <span class="nc">CALayer</span>
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">DRInspectionLayer</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addAnimation:</span><span class="p">(</span><span class="n">CAAnimation</span> <span class="o">*</span><span class="p">)</span><span class="nv">anim</span> <span class="nf">forKey:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;adding animation: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">anim</span> <span class="n">debugDescription</span><span class="p">]);</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="nl">addAnimation:</span><span class="n">anim</span> <span class="nl">forKey:</span><span class="n">key</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">@interface</span> <span class="nc">DRInspectionView</span> : <span class="nc">UIView</span>
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">DRInspectionView</span>
</span><span class="line"><span class="k">+</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">layerClass</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">DRInspectionLayer</span> <span class="n">class</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>通过输出动画的 debug 信息，我们不仅可以验证它确实如预期一样被调用了，还可以看到动画是如何组织构建的：</p>

<pre><code>&lt;CABasicAnimation:0x8c73680; 
    delegate = &lt;UIViewAnimationState: 0x8e91fa0&gt;;
    fillMode = both; 
    timingFunction = easeInEaseOut; 
    duration = 0.3; 
    fromValue = NSPoint: {5, 5}; 
    keyPath = position
&gt;
</code></pre>

<p>当动画刚被添加到 layer 时，属性的新值还没有被改变。在构建动画时，只有 <code>fromValue</code> (也就是当前值) 被显式地指定了。<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html">CABasicAnimation 的文档</a>向我们简单介绍了这么做对于动画的插值来说的的行为应该是：</p>

<blockquote>
  <p>只有 <code>fromValue</code> 不是 <code>nil</code> 时，在 <code>fromValue</code> 和属性当前显示层的值之间进行插值。</p>
</blockquote>

<p>这也是我在处理显式动画时选择的做法，将一个属性改变为新的值，然后将动画对象添加到 layer 上：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">fadeIn</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="nl">animationWithKeyPath:</span><span class="s">@&quot;opacity&quot;</span><span class="p">];</span>
</span><span class="line"><span class="n">fadeIn</span><span class="p">.</span><span class="n">duration</span>  <span class="o">=</span> <span class="mf">0.75</span><span class="p">;</span>
</span><span class="line"><span class="n">fadeIn</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">myLayer</span><span class="p">.</span><span class="n">opacity</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span> <span class="c1">// 更改 model 的值 ...</span>
</span><span class="line"><span class="c1">// ... 然后添加动画对象</span>
</span><span class="line"><span class="p">[</span><span class="n">myLayer</span> <span class="nl">addAnimation:</span><span class="n">fadeIn</span> <span class="nl">forKey:</span><span class="s">@&quot;fade in slowly&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这很简洁，你也不需要在动画被移除的时候做什么额外操作。如果动画是在一段延迟后才开始的话，你可以使用 backward 填充模式 (或者 &#8216;both&#8217; 填充模式)，就像 UIKit 所创建的动画那样。</p>

<p>可能你看见上面输出中的动画的 delegate 了，想知道这个类是用来做什么的吗？我们可以来看看 <a href="https://github.com/rpetrich/iphoneheaders/blob/master/UIKit/UIViewAnimationState.h">dump 出来的头文件</a>，它主要用来维护动画的一些状态 (持续时间，延时，重复次数等等)。它还负责对一个栈做 push 和 pop，这是为了在多个动画 block 嵌套时能够获取正确的动画状态。这些都是些实现细节，除非你想要写一套自己的基于 block 的动画 API，否则可能你不会用到它们 (实际上这是一个很有趣的点子)。</p>

<p>然后真正<em>有意思</em>的是这个 delegate 实现了 <code>animationDidStart:</code> 和 <code>animationDidStop:finished:</code>，并将信息传给了它自己的 delegate。</p>

<blockquote>
  <p><span class="secondary radius label">编者注</span> 这里不太容易理解，加以说明：从上面的头文件中可以看出，作为 CAAnimation 的 delegate 的私有类 <code>UIViewAnimationState</code> 中还有一个 <code>_delegate</code> 成员，并且 <code>animationDidStart:</code> 和 <code>animationDidStop:finished:</code> 也是典型的 delegate 的实现方法。</p>
</blockquote>

<p>通过打印这个 delegate 的 delegate，我们可以发现它也是一个私有类：UIViewAnimationBlockDelegate。同样进行 <a href="https://github.com/EthanArbuckle/IOS-7-Headers/blob/master/Frameworks/UIKit.framework/UIViewAnimationBlockDelegate.h">class dump 得到它的头文件</a>，这是一个很小的类，只负责一件事情：响应动画的 delegate 回调并且执行相应的 block。如果我们使用自己的 Core Animation 代码，并且选择 block 而不是 delegate 做回调的话，添加这个是很容易的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">DRAnimationBlockDelegate</span> : <span class="nc">NSObject</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">copy</span><span class="p">)</span> <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">start</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">copy</span><span class="p">)</span> <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">stop</span><span class="p">)(</span><span class="kt">BOOL</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="k">+</span><span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">animationDelegateWithBeginning:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="nv">beginning</span>
</span><span class="line">                                   <span class="nf">completion:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">))</span><span class="nv">completion</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">DRAnimationBlockDelegate</span>
</span><span class="line">
</span><span class="line"><span class="k">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">animationDelegateWithBeginning:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="nv">beginning</span>
</span><span class="line">                                    <span class="nf">completion:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">BOOL</span><span class="p">))</span><span class="nv">completion</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">DRAnimationBlockDelegate</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">DRAnimationBlockDelegate</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line">    <span class="n">result</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">beginning</span><span class="p">;</span>
</span><span class="line">    <span class="n">result</span><span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">completion</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animationDidStart:</span><span class="p">(</span><span class="n">CAAnimation</span> <span class="o">*</span><span class="p">)</span><span class="nv">anim</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animationDidStop:</span><span class="p">(</span><span class="n">CAAnimation</span> <span class="o">*</span><span class="p">)</span><span class="nv">anim</span> <span class="nf">finished:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">flag</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">stop</span><span class="p">(</span><span class="n">flag</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>虽然是我个人的喜好，但是我觉得像这样的基于 block 的回调风格可能会比实现一个 delegate 回调更适合你的代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">fadeIn</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">[</span><span class="n">DRAnimationBlockDelegate</span> <span class="nl">animationDelegateWithBeginning:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;beginning to fade in&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span> <span class="nl">completion:</span><span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;did fade %@&quot;</span><span class="p">,</span> <span class="n">finished</span> <span class="o">?</span> <span class="s">@&quot;to the end&quot;</span> <span class="o">:</span> <span class="s">@&quot;but was cancelled&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h1 id="blockapis">自定义基于 block 的动画 APIs</h1>

<p>一旦你知道了 <code>actionForKey:</code> 的机理之后，UIView 就远没有它一开始看起来那么神秘了。实际上我们完全可以按照我们的需求量身定制地写出一套自己的基于 block 的动画 APIs。我所设计的动画将通过在 block 中用一个很激进的时间曲线来做动画，以吸引用户对该 view 的注意，之后做一个缓慢的动画回到原始状态。你可以把它看作一种类似 pop (请不要和 Facebook 最新的 Pop 框架弄混了)的行为。与一般使用 <code>UIViewAnimationOptionAutoreverse</code> 的动画 block 不同，因为动画设计和概念上的需要，我自己实现了将 model 值改变回原始值的过程。自定义的动画 API 的使用方法就像这样：</p>

<pre><code>[UIView DR_popAnimationWithDuration:0.7
                             animations:^{
                                 myView.transform = CGAffineTransformMakeRotation(M_PI_2);
                                }];
</code></pre>

<p>当我们完成后，效果是这个样子的 (对四个不同的 view 为位置，尺寸，颜色和旋转进行动画)：</p>

<p><img alt="The custom block animation API, used to animate the position, size, color, and rotation of four different views" src="http://img.objccn.io/issue-12/2014-05-01-view-layer-synergy-custom-block-animations.gif" width="238" /></p>

<p>要开始实现它，我们首先要做的是当一个 layer 属性变化时获取 delegate 的回调。因为我们无法事先预测 layer 要改变什么，所以我选择在一个 UIView 的 category 中 swizzle <code>actionForLayer:forKey:</code> 方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">UIView</span> <span class="nl">(DR_CustomBlockAnimations)</span>
</span><span class="line">
</span><span class="line"><span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">load</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">SEL</span> <span class="n">originalSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">actionForLayer:forKey:</span><span class="p">);</span>
</span><span class="line">    <span class="kt">SEL</span> <span class="n">extendedSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">DR_actionForLayer:forKey:</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">Method</span> <span class="n">originalMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">originalSelector</span><span class="p">);</span>
</span><span class="line">    <span class="n">Method</span> <span class="n">extendedMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">extendedSelector</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSAssert</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">,</span> <span class="s">@&quot;original method should exist&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="n">NSAssert</span><span class="p">(</span><span class="n">extendedMethod</span><span class="p">,</span> <span class="s">@&quot;exchanged method should exist&quot;</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">class_addMethod</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">originalSelector</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">extendedMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">extendedMethod</span><span class="p">)))</span> <span class="p">{</span>
</span><span class="line">        <span class="n">class_replaceMethod</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">extendedSelector</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">));</span>
</span><span class="line">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">        <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">,</span> <span class="n">extendedMethod</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>为了保证我们不破坏其他依赖于 <code>actionForLayer:forKey:</code> 回调的代码，我们使用一个静态变量来判断现在是不是处于我们自己定义的上下文中。对于这个例子来说一个简单的 <code>BOOL</code> 其实就够了，但是如果我们之后要写更多内容的话，上下文的话就要灵活得多了：</p>

<pre><code>static void *DR_currentAnimationContext = NULL;
static void *DR_popAnimationContext     = &amp;DR_popAnimationContext;

- (id&lt;CAAction&gt;)DR_actionForLayer:(CALayer *)layer forKey:(NSString *)event
{
    if (DR_currentAnimationContext == DR_popAnimationContext) {
        // 这里写我们自定义的代码...
    }

    // 调用原始方法
    return [self DR_actionForLayer:layer forKey:event]; // 没错，你没看错。因为它们已经被交换了
}
</code></pre>

<p>在我们的实现中，我们要确保在执行动画 block 之前设置动画的上下文，并且在执行后恢复上下文：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="o">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">DR_popAnimationWithDuration:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="n">duration</span>
</span><span class="line">                          <span class="nl">animations:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="n">animations</span>
</span><span class="line"> <span class="p">{</span>
</span><span class="line">     <span class="n">DR_currentAnimationContext</span> <span class="o">=</span> <span class="n">DR_popAnimationContext</span><span class="p">;</span>
</span><span class="line">     <span class="c1">// 执行动画 (它将触发交换后的 delegate 方法)</span>
</span><span class="line">     <span class="n">animations</span><span class="p">();</span>
</span><span class="line">     <span class="cm">/* 一会儿再添加 */</span>
</span><span class="line">     <span class="n">DR_currentAnimationContext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果我们想要做的不过是添加一个从旧的值向新的值过度的动画的话，我们可以直接在 delegate 的回调中来做。然而因为我们想要更精确地控制动画，我们需要用一个帧动画来实现。帧动画需要所有的值都是已知的，而对我们的情况来说，新的值还没有被设定，因此我们也就无从知晓。</p>

<p>有意思的是，iOS 添加的一个基于 block 的动画 API 也遇到了同样的问题。使用和上面一样的观察手段，我们就能知道它是如何绕开这个麻烦的。对于每个关键帧，在属性变化时，view 返回 <code>nil</code>，但是却存储下需要的状态。这样就能在所有关键帧 block 执行后创建一个 <code>CAKeyframeAnimationz</code> 对象。</p>

<p>受到这种方法的启发，我们可以创建一个小的类来存储我们创建动画时所需要的信息：什么 layer 被更改了，什么 key path 的值被改变了，以及原来的值是什么：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="k">@interface</span> <span class="nc">DRSavedPopAnimationState</span> : <span class="nc">NSObject</span>
</span><span class="line">
</span><span class="line"> <span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">)</span> <span class="n">CALayer</span>  <span class="o">*</span><span class="n">layer</span><span class="p">;</span>
</span><span class="line"> <span class="k">@property</span> <span class="p">(</span><span class="n">copy</span><span class="p">)</span>   <span class="n">NSString</span> <span class="o">*</span><span class="n">keyPath</span><span class="p">;</span>
</span><span class="line"> <span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">)</span> <span class="kt">id</span>        <span class="n">oldValue</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"> <span class="o">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nl">savedStateWithLayer:</span><span class="p">(</span><span class="n">CALayer</span> <span class="o">*</span><span class="p">)</span><span class="n">layer</span>
</span><span class="line">                             <span class="nl">keyPath:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">keyPath</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"> <span class="k">@end</span>
</span><span class="line">
</span><span class="line"> <span class="k">@implementation</span> <span class="nc">DRSavedPopAnimationState</span>
</span><span class="line">
</span><span class="line"> <span class="o">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nl">savedStateWithLayer:</span><span class="p">(</span><span class="n">CALayer</span> <span class="o">*</span><span class="p">)</span><span class="n">layer</span>
</span><span class="line">                             <span class="nl">keyPath:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">keyPath</span>
</span><span class="line"> <span class="p">{</span>
</span><span class="line">     <span class="n">DRSavedPopAnimationState</span> <span class="o">*</span><span class="n">savedState</span> <span class="o">=</span> <span class="p">[</span><span class="n">DRSavedPopAnimationState</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line">     <span class="n">savedState</span><span class="p">.</span><span class="n">layer</span>    <span class="o">=</span> <span class="n">layer</span><span class="p">;</span>
</span><span class="line">     <span class="n">savedState</span><span class="p">.</span><span class="n">keyPath</span>  <span class="o">=</span> <span class="n">keyPath</span><span class="p">;</span>
</span><span class="line">     <span class="n">savedState</span><span class="p">.</span><span class="n">oldValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">layer</span> <span class="nl">valueForKeyPath:</span><span class="n">keyPath</span><span class="p">];</span>
</span><span class="line">     <span class="k">return</span> <span class="n">savedState</span><span class="p">;</span>
</span><span class="line"> <span class="p">}</span>
</span><span class="line">
</span><span class="line"> <span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>接下来，在我们的交换后的 delegate 回调中，我们简单地将被变更的属性的状态存入一个静态可变数组中：</p>

<pre><code> if (DR_currentAnimationContext == DR_popAnimationContext) {
       [[UIView DR_savedPopAnimationStates] addObject:[DRSavedPopAnimationState savedStateWithLayer:layer
                                                                                 keyPath:event]];

       // 没有隐式的动画 (稍后添加)
       return (id&lt;CAAction&gt;)[NSNull null];
   }
</code></pre>

<p>在动画 block 执行完毕后，所有的属性都被变更了，它们的状态也被保存了。现在，创建关键帧动画：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"> <span class="o">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">DR_popAnimationWithDuration:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="n">duration</span>
</span><span class="line">                          <span class="nl">animations:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="n">animations</span>
</span><span class="line"> <span class="p">{</span>
</span><span class="line">     <span class="n">DR_currentAnimationContext</span> <span class="o">=</span> <span class="n">DR_popAnimationContext</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">     <span class="c1">// 执行动画 (它将触发交换后的 delegate 方法)</span>
</span><span class="line">     <span class="n">animations</span><span class="p">();</span>
</span><span class="line">
</span><span class="line">     <span class="p">[[</span><span class="n">self</span> <span class="n">DR_savedPopAnimationStates</span><span class="p">]</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">         <span class="n">DRSavedPopAnimationState</span> <span class="o">*</span><span class="n">savedState</span>   <span class="o">=</span> <span class="p">(</span><span class="n">DRSavedPopAnimationState</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span><span class="p">;</span>
</span><span class="line">         <span class="n">CALayer</span> <span class="o">*</span><span class="n">layer</span>    <span class="o">=</span> <span class="n">savedState</span><span class="p">.</span><span class="n">layer</span><span class="p">;</span>
</span><span class="line">         <span class="n">NSString</span> <span class="o">*</span><span class="n">keyPath</span> <span class="o">=</span> <span class="n">savedState</span><span class="p">.</span><span class="n">keyPath</span><span class="p">;</span>
</span><span class="line">         <span class="kt">id</span> <span class="n">oldValue</span>       <span class="o">=</span> <span class="n">savedState</span><span class="p">.</span><span class="n">oldValue</span><span class="p">;</span>
</span><span class="line">         <span class="kt">id</span> <span class="n">newValue</span>       <span class="o">=</span> <span class="p">[</span><span class="n">layer</span> <span class="nl">valueForKeyPath:</span><span class="n">keyPath</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">         <span class="n">CAKeyframeAnimation</span> <span class="o">*</span><span class="n">anim</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAKeyframeAnimation</span> <span class="nl">animationWithKeyPath:</span><span class="n">keyPath</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">         <span class="n">CGFloat</span> <span class="n">easing</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span>
</span><span class="line">         <span class="n">CAMediaTimingFunction</span> <span class="o">*</span><span class="n">easeIn</span>  <span class="o">=</span> <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nl">functionWithControlPoints:</span><span class="mf">1.0</span> <span class="o">:</span><span class="mf">0.0</span> <span class="o">:</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">easing</span><span class="p">)</span> <span class="o">:</span><span class="mf">1.0</span><span class="p">];</span>
</span><span class="line">         <span class="n">CAMediaTimingFunction</span> <span class="o">*</span><span class="n">easeOut</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nl">functionWithControlPoints:</span><span class="n">easing</span> <span class="o">:</span><span class="mf">0.0</span> <span class="o">:</span><span class="mf">0.0</span> <span class="o">:</span><span class="mf">1.0</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">         <span class="n">anim</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span><span class="p">;</span>
</span><span class="line">         <span class="n">anim</span><span class="p">.</span><span class="n">keyTimes</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="err">@</span><span class="mi">0</span><span class="p">,</span> <span class="err">@</span><span class="p">(</span><span class="mf">0.35</span><span class="p">),</span> <span class="err">@</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">         <span class="n">anim</span><span class="p">.</span><span class="n">values</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="n">oldValue</span><span class="p">,</span> <span class="n">newValue</span><span class="p">,</span> <span class="n">oldValue</span><span class="p">];</span>
</span><span class="line">         <span class="n">anim</span><span class="p">.</span><span class="n">timingFunctions</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="n">easeIn</span><span class="p">,</span> <span class="n">easeOut</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">         <span class="c1">// 不带动画地返回原来的值</span>
</span><span class="line">         <span class="p">[</span><span class="n">CATransaction</span> <span class="n">begin</span><span class="p">];</span>
</span><span class="line">         <span class="p">[</span><span class="n">CATransaction</span> <span class="nl">setDisableActions:</span><span class="n">YES</span><span class="p">];</span>
</span><span class="line">         <span class="p">[</span><span class="n">layer</span> <span class="nl">setValue:</span><span class="n">oldValue</span> <span class="nl">forKeyPath:</span><span class="n">keyPath</span><span class="p">];</span>
</span><span class="line">         <span class="p">[</span><span class="n">CATransaction</span> <span class="n">commit</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">         <span class="c1">// 添加 &quot;pop&quot; 动画</span>
</span><span class="line">         <span class="p">[</span><span class="n">layer</span> <span class="nl">addAnimation:</span><span class="n">anim</span> <span class="nl">forKey:</span><span class="n">keyPath</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">     <span class="p">}];</span>
</span><span class="line">
</span><span class="line">     <span class="c1">// 扫除工作 (移除所有存储的状态)</span>
</span><span class="line">     <span class="p">[[</span><span class="n">self</span> <span class="n">DR_savedPopAnimationStates</span><span class="p">]</span> <span class="n">removeAllObjects</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">     <span class="n">DR_currentAnimationContext</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line"> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意老的 model 值被射到了 layer 上，所以在当动画结束和移除后，model 的值和 presentation 的值是相符合的。</p>

<p>创建像这样的你自己的 API 不会对没种情况都很适合，但是如果你需要在你的应用中的很多地方都做同样的动画的话，这可以帮助你写出整洁的代码，并减少重复。就算你之后从来不会使用这种方法，实际做一遍也能帮助你搞懂 UIView block 动画的 APIs，特别是你已经在 Core Animation 的舒适区的时候，这非常有助于你的提高。</p>

<h1>其他的动画灵感</h1>

<p>UIImageView 动画是一个完全不同的更高层次的动画 API 的实现方式，我会把它留给你来探索。表面上，它只不过是重新组装了一个传统的动画 API。你所要做的事情就是指定一个图片数组和一段时间，然后告诉 image view 开始动画。在抽象背后，其实是一个添加在 image view 的 layer 上的 contents 属性的离散的关键帧动画：</p>

<pre><code>&lt;CAKeyframeAnimation:0x8e5b020; 
    removedOnCompletion = 0; 
    delegate = &lt;_UIImageViewExtendedStorage: 0x8e49230&gt;; 
    duration = 2.5; 
    repeatCount = 2.14748e+09; 
    calculationMode = discrete; 
    values = (
        "&lt;CGImage 0x8d6ce80&gt;",
        "&lt;CGImage 0x8d6d2d0&gt;",
        "&lt;CGImage 0x8d5cd30&gt;"
    ); 
    keyPath = contents
&gt;
</code></pre>

<p>动画 APIs 可以以很多不同形式出现，而对于你自己写的动画 API 来说，也是这样的。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CollectionView布局动画]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/13/collectionviewbu-ju-dong-hua/"/>
    <updated>2014-05-13T16:33:11+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/13/collectionviewbu-ju-dong-hua</id>
    <content type="html"><![CDATA[<p><code>UICollectionView</code> 和相关类的设置非常灵活和强大。但是灵活性一旦增强，某种程度上也增加了其复杂性： <code>UICollectionView</code> 比老式的 <code>UITableView</code> 更有深度，适用性也更强。</p>

<p>Collection View 深入太多了，事实上，<a href="http://oleb.net">Ole Begeman</a> 和 <a href="https://twitter.com/ashfurrow">Ash Furrow</a> 之前曾在 objc.io 上发表过 <a href="http://objccn.io/issue-3-3/">自定义 Collection View 布局</a> 和 <a href="http://objccn.io/issue-5-2/">UICollectionView + UIKit 力学</a>，但是我依然有一些他们没有提及的内容可以写。在这篇文章中，我假设你已经非常熟悉 <code>UICollectionView</code> 的基本布局，并且至少阅读了苹果精彩的<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012334">编程指南</a>以及 Ole 之前的<a href="http://objccn.io/issue-3-3/">文章</a>。</p>

<p>本文的第一部分将集中讨论并举例说明如何用不同的类和方法来共同帮助实现一些常见的 <code>UICollectionView</code> 动画。在第二部分，我们将看一下带有 collection views 的 view controller 转场动画以及在 <code>useLayoutToLayoutNavigationTransitions</code> 可用时使用其进行转场，如果不可用时，我们会实现一个自定义转场动画。</p>

<p>你可以在 GitHub 中找到本文提到的两个示例工程:</p>

<ul>
<li><a href="https://github.com/objcio/issue-12-CollectionViewAnimations">布局动画</a></li>
<li><a href="https://github.com/objcio/issue-12-CustomCollectionViewTransition">自定义 collection view 转场动画</a></li>
</ul>

<h2 id="collectionview">Collection View 布局动画</h2>

<p>标准 <code>UICollectionViewFlowLayout</code> 除了动画是非常容易自定义的，苹果选择了一种安全的途径去实现一个简单的淡入淡出动画作为所有布局的默认动画。如果你想实现自定义动画，最好的办法是子类化 <code>UICollectionViewFlowLayout</code> 并且在适当的地方实现你的动画。让我们通过一些例子来了解 <code>UICollectionViewFlowLayout</code> 子类中的一些方法如何协助完成自定义动画。</p>

<h3>插入删除元素</h3>
<!-- more -->
<p>一般来说，我们对布局属性从初始状态到结束状态进行线性插值来计算 collection view 的动画参数。然而，新插入或者删除的元素并没有最初或最终状态来进行插值。要计算这样的 cells 的动画，collection view 将通过  <code>initialLayoutAttributesForAppearingItemAtIndexPath:</code> 以及 <code>finalLayoutAttributesForAppearingItemAtIndexPath:</code> 方法来询问其布局对象，以获取最初的和最后的属性。苹果默认的实现中，对于特定的某个 indexPath，返回的是它的通常的位置，但 <code>alpha</code> 值为 0.0，这就产生了一个淡入或淡出动画。如果你想要更漂亮的效果，比如你的新的 cells 从屏幕底部发射并且旋转飞到对应位置，你可以如下实现这样的布局子类：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">UICollectionViewLayoutAttributes</span><span class="o">*</span><span class="p">)</span><span class="nf">initialLayoutAttributesForAppearingItemAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">itemIndexPath</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">UICollectionViewLayoutAttributes</span> <span class="o">*</span><span class="n">attr</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">layoutAttributesForItemAtIndexPath:</span><span class="n">itemIndexPath</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">attr</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformRotate</span><span class="p">(</span><span class="n">CGAffineTransformMakeScale</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">),</span> <span class="n">M_PI</span><span class="p">);</span>
</span><span class="line">    <span class="n">attr</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">CGRectGetMidX</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">bounds</span><span class="p">),</span> <span class="n">CGRectGetMaxY</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">bounds</span><span class="p">));</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">attr</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>结果如下：</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-collectionview-animations-1-insertion.gif" alt="Insertion and Deletion" /></p>

<p>对应的 <code>finalLayoutAttributesForAppearingItemAtIndexPath:</code> 方法中，除了设定了不同的 transform 以外，其他都很相似。</p>

<h3>响应设备旋转</h3>

<p>设备方向变化通常会导致 collection view 的 bounds 变化。如果通过 <code>shouldInvalidateLayoutForBoundsChange:</code> 判定为布局需要被无效化并重新计算的时候，布局对象会被询问以提供新的布局。<code>UICollectionViewFlowLayout</code> 的默认实现正确地处理了这个情况，但是如果你子类化 <code>UICollectionViewLayout</code> 的话，你需要在边界变化时返回 <code>YES</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">shouldInvalidateLayoutForBoundsChange:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">newBounds</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">CGRect</span> <span class="n">oldBounds</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CGSizeEqualToSize</span><span class="p">(</span><span class="n">oldBounds</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">newBounds</span><span class="p">.</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在 bounds 变化的动画中，collection view 表现得像当前显示的元素被移除然后又在新的 bounds 中被被重新插入，这会对每个 IndexPath 产生一系列的 <code>finalLayoutAttributesForAppearingItemAtIndexPath:</code> 和 <code>initialLayoutAttributesForAppearingItemAtIndexPath:</code> 的调用。</p>

<p>如果你在插入和删除的时候加入了非常炫的动画，现在你应该看看为何苹果明智的使用简单的淡入淡出动画作为默认效果：</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-collectionview-animations-2-wrong-rotation.gif" alt="设备旋转的错误反应" /></p>

<p>啊哦&#8230;</p>

<p>为了防止这种不想要的动画，初始化位置 -&gt; 删除动画 -&gt; 插入动画 -&gt; 最终位置的顺序必须完全匹配 collection view 的每一项，以便最终呈现出一个平滑动画。换句话说，<code>finalLayoutAttributesForAppearingItemAtIndexPath:</code> 以及 <code>initialLayoutAttributesForAppearingItemAtIndexPath:</code> 应该针对元素到底是真的在显示或者消失，还是 collection view 正在经历的边界改变动画的不同情况，做出不同反应，并返回不同的布局属性。</p>

<p>幸运的是，collection view 会告知布局对象哪一种动画将被执行。它分别通过调用 <code>prepareForAnimatedBoundsChange:</code> 和 <code>prepareForCollectionViewUpdates:</code> 来对应 bounds 变化以及元素更新。出于本实例的说明目的，我们可以使用 <code>prepareForCollectionViewUpdates:</code> 来跟踪更新对象：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">prepareForCollectionViewUpdates:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">updateItems</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="nl">prepareForCollectionViewUpdates:</span><span class="n">updateItems</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">indexPaths</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">UICollectionViewUpdateItem</span> <span class="o">*</span><span class="n">updateItem</span> <span class="k">in</span> <span class="n">updateItems</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">switch</span> <span class="p">(</span><span class="n">updateItem</span><span class="p">.</span><span class="n">updateAction</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">case</span> <span class="nl">UICollectionUpdateActionInsert:</span>
</span><span class="line">                <span class="p">[</span><span class="n">indexPaths</span> <span class="nl">addObject:</span><span class="n">updateItem</span><span class="p">.</span><span class="n">indexPathAfterUpdate</span><span class="p">];</span>
</span><span class="line">                <span class="k">break</span><span class="p">;</span>
</span><span class="line">            <span class="k">case</span> <span class="nl">UICollectionUpdateActionDelete:</span>
</span><span class="line">                <span class="p">[</span><span class="n">indexPaths</span> <span class="nl">addObject:</span><span class="n">updateItem</span><span class="p">.</span><span class="n">indexPathBeforeUpdate</span><span class="p">];</span>
</span><span class="line">                <span class="k">break</span><span class="p">;</span>
</span><span class="line">            <span class="k">case</span> <span class="nl">UICollectionUpdateActionMove:</span>
</span><span class="line">                <span class="p">[</span><span class="n">indexPaths</span> <span class="nl">addObject:</span><span class="n">updateItem</span><span class="p">.</span><span class="n">indexPathBeforeUpdate</span><span class="p">];</span>
</span><span class="line">                <span class="p">[</span><span class="n">indexPaths</span> <span class="nl">addObject:</span><span class="n">updateItem</span><span class="p">.</span><span class="n">indexPathAfterUpdate</span><span class="p">];</span>
</span><span class="line">                <span class="k">break</span><span class="p">;</span>
</span><span class="line">            <span class="k">default</span><span class="o">:</span>
</span><span class="line">                <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;unhandled case: %@&quot;</span><span class="p">,</span> <span class="n">updateItem</span><span class="p">);</span>
</span><span class="line">                <span class="k">break</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">indexPathsToAnimate</span> <span class="o">=</span> <span class="n">indexPaths</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>以及修改我们元素的插入动画，让元素只在其正在被插入 collection view 时进行发射：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">UICollectionViewLayoutAttributes</span><span class="o">*</span><span class="p">)</span><span class="nf">initialLayoutAttributesForAppearingItemAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">itemIndexPath</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">UICollectionViewLayoutAttributes</span> <span class="o">*</span><span class="n">attr</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">layoutAttributesForItemAtIndexPath:</span><span class="n">itemIndexPath</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">_indexPathsToAnimate</span> <span class="nl">containsObject:</span><span class="n">itemIndexPath</span><span class="p">])</span> <span class="p">{</span>
</span><span class="line">        <span class="n">attr</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformRotate</span><span class="p">(</span><span class="n">CGAffineTransformMakeScale</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">),</span> <span class="n">M_PI</span><span class="p">);</span>
</span><span class="line">        <span class="n">attr</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">CGRectGetMidX</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">bounds</span><span class="p">),</span> <span class="n">CGRectGetMaxY</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">bounds</span><span class="p">));</span>
</span><span class="line">        <span class="p">[</span><span class="n">_indexPathsToAnimate</span> <span class="nl">removeObject:</span><span class="n">itemIndexPath</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">attr</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果这个元素没有正在被插入，那么将通过 <code>layoutAttributesForItemAtIndexPath</code> 来返回一个普通的属性，以此取消特殊的外观动画。结合 <code>finalLayoutAttributesForAppearingItemAtIndexPath:</code> 中相应的逻辑，最终将会使元素能够在 bounds 变化时，从初始位置到最终位置以很流畅的动画形式实现，从而建立一个简单但很酷的动画效果：</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-collectionview-animations-3-correct-rotation.gif" alt="Wrong reaction to device rotation" /></p>

<h3>交互式布局动画</h3>

<p>Collection views 让用户通过手势实现与布局交互这件事变得很容易。如苹果<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/IncorporatingGestureSupport/IncorporatingGestureSupport.html#//apple_ref/doc/uid/TP40012334-CH4-SW1">建议</a>的那样，为 collection view 布局添加交互的途径一般会遵循以下步骤：</p>

<ol>
<li>创建手势识别  </li>
<li>将手势识别添加给 collection view  </li>
<li>通过手势来驱动布局动画</li>
</ol>

<p>让我们来看看我们如何可以建立一些用户可缩放捏合的元素，以及一旦用户释放他们的捏合手势元素返回到原始大小。</p>

<p>我们的处理方式可能会是这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handlePinch:</span><span class="p">(</span><span class="n">UIPinchGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">sender</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">sender</span> <span class="n">numberOfTouches</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">sender</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateBegan</span> <span class="o">||</span>
</span><span class="line">        <span class="n">sender</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateChanged</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="c1">// 获取捏合的点</span>
</span><span class="line">        <span class="n">CGPoint</span> <span class="n">p1</span> <span class="o">=</span> <span class="p">[</span><span class="n">sender</span> <span class="nl">locationOfTouch:</span><span class="mi">0</span> <span class="nl">inView:</span><span class="p">[</span><span class="n">self</span> <span class="n">collectionView</span><span class="p">]];</span>
</span><span class="line">        <span class="n">CGPoint</span> <span class="n">p2</span> <span class="o">=</span> <span class="p">[</span><span class="n">sender</span> <span class="nl">locationOfTouch:</span><span class="mi">1</span> <span class="nl">inView:</span><span class="p">[</span><span class="n">self</span> <span class="n">collectionView</span><span class="p">]];</span>
</span><span class="line">
</span><span class="line">        <span class="c1">// 计算扩展距离</span>
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">xd</span> <span class="o">=</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">yd</span> <span class="o">=</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">xd</span><span class="o">*</span><span class="n">xd</span> <span class="o">+</span> <span class="n">yd</span><span class="o">*</span><span class="n">yd</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">        <span class="c1">// 更新自定义布局参数以及无效化</span>
</span><span class="line">        <span class="n">FJAnimatedFlowLayout</span><span class="o">*</span> <span class="n">layout</span> <span class="o">=</span> <span class="p">(</span><span class="n">FJAnimatedFlowLayout</span><span class="o">*</span><span class="p">)[[</span><span class="n">self</span> <span class="n">collectionView</span><span class="p">]</span> <span class="n">collectionViewLayout</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">        <span class="n">NSIndexPath</span> <span class="o">*</span><span class="n">pinchedItem</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span> <span class="nl">indexPathForItemAtPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">),</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">))];</span>
</span><span class="line">        <span class="p">[</span><span class="n">layout</span> <span class="nl">resizeItemAtIndexPath:</span><span class="n">pinchedItem</span> <span class="nl">withPinchDistance:</span><span class="n">distance</span><span class="p">];</span>
</span><span class="line">        <span class="p">[</span><span class="n">layout</span> <span class="n">invalidateLayout</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sender</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateCancelled</span> <span class="o">||</span>
</span><span class="line">             <span class="n">sender</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateEnded</span><span class="p">){</span>
</span><span class="line">        <span class="n">FJAnimatedFlowLayout</span><span class="o">*</span> <span class="n">layout</span> <span class="o">=</span> <span class="p">(</span><span class="n">FJAnimatedFlowLayout</span><span class="o">*</span><span class="p">)[[</span><span class="n">self</span> <span class="n">collectionView</span><span class="p">]</span> <span class="n">collectionViewLayout</span><span class="p">];</span>
</span><span class="line">        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span>
</span><span class="line">         <span class="nl">performBatchUpdates:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">            <span class="p">[</span><span class="n">layout</span> <span class="n">resetPinchedItem</span><span class="p">];</span>
</span><span class="line">         <span class="p">}</span>
</span><span class="line">         <span class="nl">completion:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这个捏合操作需要计算捏合距离并找出被捏合的元素，并且在用户捏合的时候通知布局以实现自身更新。当捏合手势结束的时候，布局会做一个批量更新动画返回原始尺寸。</p>

<p>另一方面，我们的布局始终在跟踪捏合的元素以及期望尺寸，并在需要的时候提供正确的属性：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span><span class="o">*</span><span class="p">)</span><span class="nf">layoutAttributesForElementsInRect:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">rect</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSArray</span> <span class="o">*</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nl">layoutAttributesForElementsInRect:</span><span class="n">rect</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">_pinchedItem</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">UICollectionViewLayoutAttributes</span> <span class="o">*</span><span class="n">attr</span> <span class="o">=</span> <span class="p">[[</span><span class="n">attrs</span> <span class="nl">filteredArrayUsingPredicate:</span><span class="p">[</span><span class="n">NSPredicate</span> <span class="nl">predicateWithFormat:</span><span class="s">@&quot;indexPath == %@&quot;</span><span class="p">,</span> <span class="n">_pinchedItem</span><span class="p">]]</span> <span class="n">firstObject</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">        <span class="n">attr</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">_pinchedItemSize</span><span class="p">;</span>
</span><span class="line">        <span class="n">attr</span><span class="p">.</span><span class="n">zIndex</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">attrs</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3>小结</h3>

<p>我们通过一些例子来说明了如何在 collection view 布局中创建自定义动画。虽然 <code>UICollectionViewFlowLayout</code> 并不直接允许定制动画，但是苹果工程师提供了清晰的架构让你可以子类化并实现各种自定义行为。从本质来说，在你的 <code>UICollectionViewLayout</code> 子类中正确地响应以下信号，并对那些要求返回 <code>UICollectionViewLayoutAttributes</code> 的方法返回合适的属性，那么实现自定义布局和动画的唯一约束就是你的想象力：</p>

<ul>
<li><code>prepareLayout</code></li>
<li><code>prepareForCollectionViewUpdates:</code></li>
<li><code>finalizeCollectionViewUpdates</code></li>
<li><code>prepareForAnimatedBoundsChange:</code></li>
<li><code>finalizeAnimatedBoundsChange</code></li>
<li><code>shouldInvalidateLayoutForBoundsChange:</code></li>
</ul>

<p>更引人入胜的动画可以结合像在 objc.io <a href="http://objccn.io/issue-5-2/">话题 #5</a> 中 UIKit 力学这样的技术来实现。</p>

<h2 id="collectionviewsviewcontroller">带有 Collection views 的 View controller 转场</h2>

<p>就如 <a href="https://twitter.com/chriseidhof">Chris</a> 之前在 objc.io 的<a href="http://objccn.io/issue-5-3/">文章</a>中所说的那样，iOS 7 中的一个重大更新是自定义 view controller 转场动画。与自定义转场动画相呼应，苹果也在 <code>UICollectionViewController</code> 添加了 <code>useLayoutToLayoutNavigationTransitions</code> 标记来在可复用的单个 collection view 间启用导航转场。苹果自己的照片和日历应用就是这类转场动画的非常好的代表作。</p>

<h3 id="uicollectionviewcontroller">UICollectionViewController 实例之间的转场动画</h3>

<p>让我们来看看我们如何能够利用上一节相同的示例项目达到类似的效果：</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-collectionview-animations-4-layout2layout.gif" alt="Layout to Layout Navigation Transitions" /></p>

<p>为了使布局到布局的转场动画工作，navigation controller 的 root view controller 必须是一个 <code>useLayoutToLayoutNavigationTransitions</code> 设置为 <code>NO</code> 的 collection view controller。当另一个 <code>useLayoutToLayoutNavigationTransitions</code> 设置为 <code>YES</code> 的 <code>UICollectionViewController</code> 实例被 push 到根视图控制器之上时，navigation controller 会用布局转场动画来代替标准的 push 转场动画。这里要注意一个重要的细节，根视图控制器的 collection view 实例被回收用于在导航栈上 push 进来的 collection 控制器中，如果你试图在 <code>viewDidLoad</code> 之类的方法中中设置 collection view 属性， 它们将不会有任何反应，你也不会收到任何警告。</p>

<p>这个行为可能最常见的陷阱是期望回收的 collection view 根据顶层的 collection 视图控制器来更新数据源和委托。它当然不会这样：根 collection 视图控制器会保持数据源和委托，除非我们做点什么。</p>

<p>解决此问题的方法是实现 navigation controller 的委托方法，并根据导航堆栈顶部的当前视图控制器的需要正确设置 collection view 的数据源和委托。在我们简单的例子中，这可以通过以下方式实现：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">navigationController:</span><span class="p">(</span><span class="n">UINavigationController</span> <span class="o">*</span><span class="p">)</span><span class="nv">navigationController</span> <span class="nf">didShowViewController:</span><span class="p">(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">viewController</span> <span class="nf">animated:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">viewController</span> <span class="nl">isKindOfClass:</span><span class="p">[</span><span class="n">FJDetailViewController</span> <span class="n">class</span><span class="p">]])</span> <span class="p">{</span>
</span><span class="line">        <span class="n">FJDetailViewController</span> <span class="o">*</span><span class="n">dvc</span> <span class="o">=</span> <span class="p">(</span><span class="n">FJDetailViewController</span><span class="o">*</span><span class="p">)</span><span class="n">viewController</span><span class="p">;</span>
</span><span class="line">        <span class="n">dvc</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="n">dvc</span><span class="p">;</span>
</span><span class="line">        <span class="n">dvc</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">dvc</span><span class="p">;</span>
</span><span class="line">        <span class="p">[</span><span class="n">dvc</span><span class="p">.</span><span class="n">collectionView</span> <span class="nl">scrollToItemAtIndexPath:</span><span class="p">[</span><span class="n">NSIndexPath</span> <span class="nl">indexPathForItem:</span><span class="n">_selectedItem</span> <span class="nl">inSection:</span><span class="mi">0</span><span class="p">]</span> <span class="nl">atScrollPosition:</span><span class="n">UICollectionViewScrollPositionCenteredVertically</span> <span class="nl">animated:</span><span class="n">NO</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">viewController</span> <span class="o">==</span> <span class="n">self</span><span class="p">){</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>objc</p>

<p>当详细页面的 collection view 被推入导航栈时，我们重新设置 collection view 的数据源到详细视图控制器，确保只有被选择的 cell 颜色显示在详细页面的 collection view 中。如果我们不打算这样做，布局依然可以正确过渡，但是collection 将显示所有的 cells。在实际应用中，detail 的数据源通常负责在转场动画过程中显示更详细的数据。</p>

<h3 id="collectionview">用于常规转换的 Collection View 布局动画</h3>

<p>使用了 <code>useLayoutToLayoutNavigationTransitions</code> 的布局和布局间导航转换是很有用的，但却局限于仅在 两个 view controller 都是 <code>UICollectionViewController</code> 的实例，并且转场的必须发生在顶级 collection views 之间。为了达到在任意视图控制器的任意 collection view 之间都能实现相似的过渡，我们需要自定义一个 view collection 的转场动画。</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-collectionview-animations-5-custom-transitions.gif" alt="Custom Collection View Transition" /></p>

<p>针对此类自定义过渡的动画控制器，需要遵循以下步骤进行设计：</p>

<ol>
<li>对初始的 collection view 中的所有可见元素制作截图  </li>
<li>将截图添加到转场上下文的 container view 中  </li>
<li>运用目标 collection view 的布局计算最终位置  </li>
<li>制作动画使快照到正确的位置  </li>
<li>当目标 collection view 可见时删除截图</li>
</ol>

<p>一个这样的动画设计有两重缺陷：它只能对初始的 collection view 的可见元素制作动画，因为<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/uiview_class/UIView/UIView.html#//apple_ref/doc/uid/TP40006816-CH3-SW198">快照 APIs </a> 只能工作于屏幕上可见的 view，另外，依赖于可见的元素数量，可能会有很多的 views 需要进行正确的跟踪并为其制作动画。但另一方面，这种设计又具有一个明显的优势，那就是它可以为所有类型的 <code>UICollectionViewLayout</code> 组合所使用。这样一个系统的实现就留给读者们去进行练习吧。</p>

<p>在附带的演示项目中我们用另一种途径进行了实现，它依赖于一些 <code>UICollectionViewFlowLayout</code> 的巧合。</p>

<p>基本的想法是，因为源 collection view 和目标 collection view 都拥有有效的 flow layouts，因此源 layout 的布局属性正好可以用作目标 collection view 的布局中的初始布局属性，以此驱动转场动画。一旦正确建立，就算对于那些一开始在屏幕上不可见的元素，collection view 的机制都将为我们追踪它们并进行动画。下面是我们的动画控制器中的 <code>animateTransition:</code> 的核心代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGRect</span> <span class="n">initialRect</span> <span class="o">=</span> <span class="p">[</span><span class="n">inView</span><span class="p">.</span><span class="n">window</span> <span class="nl">convertRect:</span><span class="n">_fromCollectionView</span><span class="p">.</span><span class="n">frame</span> <span class="nl">fromView:</span><span class="n">_fromCollectionView</span><span class="p">.</span><span class="n">superview</span><span class="p">];</span>
</span><span class="line"><span class="n">CGRect</span> <span class="n">finalRect</span>   <span class="o">=</span> <span class="p">[</span><span class="n">transitionContext</span> <span class="nl">finalFrameForViewController:</span><span class="n">toVC</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">UICollectionViewFlowLayout</span> <span class="o">*</span><span class="n">toLayout</span> <span class="o">=</span> <span class="p">(</span><span class="n">UICollectionViewFlowLayout</span><span class="o">*</span><span class="p">)</span> <span class="n">_toCollectionView</span><span class="p">.</span><span class="n">collectionViewLayout</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">UICollectionViewFlowLayout</span> <span class="o">*</span><span class="n">currentLayout</span> <span class="o">=</span> <span class="p">(</span><span class="n">UICollectionViewFlowLayout</span><span class="o">*</span><span class="p">)</span> <span class="n">_fromCollectionView</span><span class="p">.</span><span class="n">collectionViewLayout</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//制作原来布局的拷贝</span>
</span><span class="line"><span class="n">UICollectionViewFlowLayout</span> <span class="o">*</span><span class="n">currentLayoutCopy</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UICollectionViewFlowLayout</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">currentLayoutCopy</span><span class="p">.</span><span class="n">itemSize</span> <span class="o">=</span> <span class="n">currentLayout</span><span class="p">.</span><span class="n">itemSize</span><span class="p">;</span>
</span><span class="line"><span class="n">currentLayoutCopy</span><span class="p">.</span><span class="n">sectionInset</span> <span class="o">=</span> <span class="n">currentLayout</span><span class="p">.</span><span class="n">sectionInset</span><span class="p">;</span>
</span><span class="line"><span class="n">currentLayoutCopy</span><span class="p">.</span><span class="n">minimumLineSpacing</span> <span class="o">=</span> <span class="n">currentLayout</span><span class="p">.</span><span class="n">minimumLineSpacing</span><span class="p">;</span>
</span><span class="line"><span class="n">currentLayoutCopy</span><span class="p">.</span><span class="n">minimumInteritemSpacing</span> <span class="o">=</span> <span class="n">currentLayout</span><span class="p">.</span><span class="n">minimumInteritemSpacing</span><span class="p">;</span>
</span><span class="line"><span class="n">currentLayoutCopy</span><span class="p">.</span><span class="n">scrollDirection</span> <span class="o">=</span> <span class="n">currentLayout</span><span class="p">.</span><span class="n">scrollDirection</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//将拷贝赋值给源 collection view</span>
</span><span class="line"><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">fromCollectionView</span> <span class="nl">setCollectionViewLayout:</span><span class="n">currentLayoutCopy</span> <span class="nl">animated:</span><span class="n">NO</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">UIEdgeInsets</span> <span class="n">contentInset</span> <span class="o">=</span> <span class="n">_toCollectionView</span><span class="p">.</span><span class="n">contentInset</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">CGFloat</span> <span class="n">oldBottomInset</span> <span class="o">=</span> <span class="n">contentInset</span><span class="p">.</span><span class="n">bottom</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//强制在目标 collection view 中设定一个很大的 bottom inset</span>
</span><span class="line"><span class="n">contentInset</span><span class="p">.</span><span class="n">bottom</span> <span class="o">=</span> <span class="n">CGRectGetHeight</span><span class="p">(</span><span class="n">finalRect</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">toLayout</span><span class="p">.</span><span class="n">itemSize</span><span class="p">.</span><span class="n">height</span><span class="o">+</span><span class="n">toLayout</span><span class="p">.</span><span class="n">sectionInset</span><span class="p">.</span><span class="n">bottom</span><span class="o">+</span><span class="n">toLayout</span><span class="p">.</span><span class="n">sectionInset</span><span class="p">.</span><span class="n">top</span><span class="p">);</span>
</span><span class="line"><span class="n">self</span><span class="p">.</span><span class="n">toCollectionView</span><span class="p">.</span><span class="n">contentInset</span> <span class="o">=</span> <span class="n">contentInset</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//将源布局设置给目标 collection view</span>
</span><span class="line"><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">toCollectionView</span> <span class="nl">setCollectionViewLayout:</span><span class="n">currentLayout</span> <span class="nl">animated:</span><span class="n">NO</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">toView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">initialRect</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">inView</span> <span class="nl">insertSubview:</span><span class="n">toView</span> <span class="nl">aboveSubview:</span><span class="n">fromView</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">UIView</span>
</span><span class="line"> <span class="nl">animateWithDuration:</span><span class="p">[</span><span class="n">self</span> <span class="nl">transitionDuration:</span><span class="n">transitionContext</span><span class="p">]</span>
</span><span class="line"> <span class="nl">delay:</span><span class="mi">0</span>
</span><span class="line"> <span class="nl">options:</span><span class="n">UIViewAnimationOptionBeginFromCurrentState</span>
</span><span class="line"> <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">   <span class="c1">//使用最终 frame 制作动画</span>
</span><span class="line">     <span class="n">toView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">finalRect</span><span class="p">;</span>
</span><span class="line">     <span class="c1">//在 performUpdates 中设定最终的布局</span>
</span><span class="line">     <span class="p">[</span><span class="n">_toCollectionView</span>
</span><span class="line">      <span class="nl">performBatchUpdates:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">          <span class="p">[</span><span class="n">_toCollectionView</span> <span class="nl">setCollectionViewLayout:</span><span class="n">toLayout</span> <span class="nl">animated:</span><span class="n">NO</span><span class="p">];</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">      <span class="nl">completion:</span><span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">          <span class="n">_toCollectionView</span><span class="p">.</span><span class="n">contentInset</span> <span class="o">=</span> <span class="n">UIEdgeInsetsMake</span><span class="p">(</span><span class="n">contentInset</span><span class="p">.</span><span class="n">top</span><span class="p">,</span>
</span><span class="line">                                                            <span class="n">contentInset</span><span class="p">.</span><span class="n">left</span><span class="p">,</span>
</span><span class="line">                                                            <span class="n">oldBottomInset</span><span class="p">,</span>
</span><span class="line">                                                            <span class="n">contentInset</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
</span><span class="line">      <span class="p">}];</span>
</span><span class="line">
</span><span class="line"> <span class="p">}</span> <span class="nl">completion:</span><span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">     <span class="p">[</span><span class="n">transitionContext</span> <span class="nl">completeTransition:</span><span class="n">YES</span><span class="p">];</span>
</span><span class="line"> <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>首先，动画控制器确保目标 collection view 以与原来的 collection view 完全相同的框架和布局作为开始。接着，它将源 collection view 的布局设定给目标 collection view，以确保其不会失效。与此同时，该布局已经复制到另一个新的布局对象中，而这个布局对象则是为防止在导航回原始视图控制器时出现奇怪的布局 bug。我们还会强制在目标 collection view 的底部设定一个很大的 content inset，来确保布局在动画的初始位置时保持在一行上。观察日志的话，你会发现由于元素的尺寸加上 inset 的尺寸会比 collection view 的非滚动维度要大，因此 collection view 会在控制台警告。在这样的情况下，collection view 的行为是没有定义的，我们也只是使用这样一个不稳定的状态来作为我们转换动画的初始状态。最后，复杂的动画 block 将展现它的魅力，首先将目标 collection view 的框架设定到最终位置，然后在 <code>performBatchUpdates:completion:</code> 的 update block 中执行一个无动画的布局来改变至最终布局，紧随其后便是在 completion block 中将 content insets 重置为原始值。</p>

<h3>小结</h3>

<p>我们讨论了两种可以在 collection view 之间实现布局转场的途径。一种使用了内置的 <code>useLayoutToLayoutNavigationTransitions</code>，看起来令人印象深刻并且极其容易实现，缺点就是可以使用的范围较为局限。由于 <code>useLayoutToLayoutNavigationTransitions</code> 在一些案例中不能使用，想驱动自定义的过渡动画的话，就需要一个自定义的 animator。这篇文章中，我们看到了如何实现这样一个 animator，然而，由于你的应用程序大概肯定会需要在两个和本例完全不同的 view 结构中实现完全不同的动画，所以正如此例中做的那样，不要吝于尝试不同的方法来探究其是否能够工作。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义ViewController动画]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/13/zi-ding-yi-viewcontrollerdong-hua/"/>
    <updated>2014-05-13T15:45:26+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/13/zi-ding-yi-viewcontrollerdong-hua</id>
    <content type="html"><![CDATA[<p>在<a href="http://objccn.io/issue-5/">话题 #5</a> 中，<a href="http://twitter.com/chriseidhof">Chris Eidhof</a> 向我们介绍了 iOS7 引入的新特性自定义 <a href="http://objccn.io/issue-5-3">View Controller 转场</a>. 他给出了一个 <a href="http://objccn.io/issue-5-3/#conclusion">结论</a>：</p>

<blockquote>
  <p>我们在本文只探讨了在 navigation controller 中的两个 view controller 之间的转场动画，但是这些做法在 tab bar controller 或者<strong>任何你自己定义的 view controller 容器</strong>中<strong>也是通用的</strong>… </p>
</blockquote>

<p>尽管从技术角度来讲，使用 iOS 7 的 API，你可以对自定义容器中的 view controllers 做自定义转场，但是这不是能直接使用的，实现这种效果非常不容易。</p>

<p>请注意我正在讨论的自定义视图控制器容器 (custom container view controllers) 都是 <code>UIViewController</code> 的直接子类，而不是 <code>UITabBarController</code> 或者 <code>UINavigationController</code> 的子类。</p>

<p>对于你自定义的继承于 <code>UIViewController</code> 的容器子类，并没有现成可用的 API 允许一个任意的<em>动画控制器 (animation controller)</em> 将一个子视图控制器自动转场到另外一个，不管是可交互式的转场还是不可交互式的转场。 我甚至都觉着苹果根本就不想支持这种方式。苹果支持下面的这几种转场方式:</p>

<ul>
<li>Navigation controller 推入和推出页面</li>
<li>Tab bar controller 选择的改变</li>
<li>Modal 页面的展示和消失</li>
</ul>

<p>在本文中，我将向你展示如何自定义视图控制器容器，并且使其支持第三方的动画控制器。</p>

<p>如果你需要复习一下 iOS 5 引入的视图控制器容器，请阅读<a href="http://objccn.io/issue-1/">话题＃1</a> 中 <a href="https://twitter.com/rickigregersen">Ricky Gregersen</a> 写的文章 “<a href="http://objccn.io/issue-1-4/">View Controller 容器</a>”。</p>

<h2>预热准备</h2>

<p>看到这里，你可能对上文我们说到的一些问题犯嘀咕，让我来告诉你答案吧:</p>

<p><em>为什么我们不直接继承 <code>UINavigationController</code> 或 <code>UITabBarController</code>，并且使用它们提供的功能的？</em></p>
<!-- more -->
<p>有些时候这是你不想要的。可能你想要一个非常特殊的外观或者行为，和这些类能够提供给你的差别非常大，因此你必须使用一些黑客式的手段去达到你想要的结果，同时还要担心系统框架的版本更新后这些黑客式的手段是否还仍然有效。或者，你就是想完全控制你的视图控制器容器，避免不得不支持一些特定的功能。</p>

<p><em>好吧, 那么为什么不使用  <pre><code>transitionFromViewController:toViewController:duration:options:animations:completion:</code></pre> 去实现呢？</em></p>

<p>这又是一个好问题，你可能想用这种方式去实现，但是或许你对代码的整洁性比较在意，想把这种转场相关的代码封装在内部。那么为什么不使用一个既存的、被良好验证的设计模式呢？这种设计模式可以非常方便的支持第三方的转场动画。</p>

<h2 id="api">介绍相关的API</h2>

<p>在我们开始写代码之前，让我们先花一分钟的时间来简单看一下我们需要的组件吧。</p>

<p>iOS 7 自定义视图控制器转场的 API 基本上都是以协议的方式提供的，这也使其可以非常灵活的使用，因为你可以很简单地将它们插入到你的类中。最主要的五个组件如下:</p>

<ol>
<li><strong>动画控制器 (Animation Controllers)</strong> 遵从 <code>UIViewControllerAnimatedTransitioning</code> 协议，并且负责实际执行动画。  </li>
<li><strong>交互控制器 (Interaction Controllers)</strong> 通过遵从 <code>UIViewControllerInteractiveTransitioning</code> 协议来控制可交互式的转场。  </li>
<li><strong>转场代理 (Transitioning Delegates)</strong> 根据不同的转场类型方便的提供需要的动画控制器和交互控制器。  </li>
<li><strong>转场上下文 (Transitioning Contexts)</strong> 定义了转场时需要的元数据，比如在转场过程中所参与的视图控制器和视图的相关属性。 转场上下文对象遵从 <code>UIViewControllerContextTransitioning</code> 协议，<em>并且这是由系统负责生成和提供的</em>。2.  </li>
<li><strong>转场协调器(Transition Coordinators)</strong> 可以在运行转场动画时，并行的运行其他动画。 转场协调器遵从 <code>UIViewControllerTransitionCoordinator</code> 协议。</li>
</ol>

<p>正如你从其他的阅读材料中得知的那样，转场有不可交互式和可交互式两种方式。在本文中，我们将集中精力于不可交互的转场。这种转场是最简单的转场，也是我们学习的一个好的开始。这意味着我们需要处理上面提到的<em>动画控制器 (animation controllers)</em>，<em>转场代理 (transitioning delegates)</em> 和<em>转场上下文 (transitioning contexts)</em>。</p>

<p>闲话少说，让我们开始动手吧…</p>

<h2>示例工程</h2>

<p>通过三个阶段，我们将要实现一个简单自定义的视图控制器容器，它可以对子视图控制器提供自定义的转场动画的支持。</p>

<p>你可以在<a href="https://github.com/objcio/issue-12-custom-container-transitions">这里</a>找到这三个阶段的 Xcode 工程的源代码。</p>

<h3 id="1">阶段 1: 基础</h3>

<p>我们应用中的核心类是 <code>ContainerViewController</code>，它持有一个<code>UIViewController</code>实例的数组，每个实例是一个普通的 <code>ChildViewController</code>。容器视图控制器设置了一个带有可点击图标，并代表每个子视图控制器的私有的子视图：</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-custom-container-view-controller-transitions-stage-1.gif" alt="Stage 1: no animation" /></p>

<p>我们通过点击图标在不同的子视图控制器之间切换。在这一阶段，子视图控制器之间切换时是没有转场动画的。</p>

<p>你可以在这里查看<a href="https://github.com/objcio/issue-12-custom-container-transitions/tree/stage-1">阶段－1</a>的源代码。</p>

<h3 id="2">阶段 2: 转场动画</h3>

<p>当我们添加转场动画时，我们想要使用一个遵从 <code>UIViewControllerAnimatedTransitioning</code> 协议的<em>动画控制器(animation controllers)</em>。这个协议声明了 3 个方法，前面的 2 个方法是必须实现的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nf">transitionDuration:</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">UIViewControllerContextTransitioning</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">transitionContext</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animateTransition:</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">UIViewControllerContextTransitioning</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">transitionContext</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animationEnded:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">transitionCompleted</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>通过这些方法，我们可以获得我们所需的所有东西。当我们的视图控制器容器准备执行动画时，我们可以从动画控制器中获取动画的持续时间，并让其去执行真正的动画。当动画执行完毕后，如果动画控制器实现了可选的 <code>animationEnded:</code> 方法，我们可以调用动画控制器中的 <code>animationEnded:</code> 方法。</p>

<p>但是，首先我们必须把一件事情搞清楚。正如你在上面的方法签名中看到的那样，上面两个必须实现的方法需要一个<em>转场上下文</em>参数，这是一个遵从 <code>UIViewControllerContextTransitioning</code> 协议的对象。通常情况下，当我们使用系统内建的类时，系统框架为我们创建了<em>转场上下文</em>对象，并把它传递给动画控制器。但是在我们这种情况下，我们需要自定义转场动画，所以我们需要承担系统框架的责任，<em>自己</em>去创建这个<em>转场上下文</em>对象。</p>

<p>这就是大量使用协议的方便之处。我们可以不用必须复写一个私有类，而复写私有类这种方法是明显不可行的。我们可以定义自己的类，并使其遵从文档中相应的协议就可以了。</p>

<p>尽管在 <code>UIViewControllerContextTransitioning</code> 协议中声明了<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIViewControllerContextTransitioning_protocol/Reference/Reference.html">很多方法</a>，而且它们都是必须要实现 (required) 的，但是我们现在可以暂时忽略它们中的一些方法，因为我们现在仅仅支持不可交互式的转场。</p>

<p>同 UIKit 类似，我们定义了一个私有类 <code>NSObject &lt;UIViewControllerContextTransitioning&gt;</code>。在我们的特定例子中，这个私有类是 <code>PrivateTransitionContext</code>，它的初始化方法如下实现：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithFromViewController:</span><span class="p">(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">fromViewController</span> <span class="nf">toViewController:</span><span class="p">(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">toViewController</span> <span class="nf">goingRight:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">goingRight</span> <span class="p">{</span>
</span><span class="line">    <span class="n">NSAssert</span> <span class="p">([</span><span class="n">fromViewController</span> <span class="n">isViewLoaded</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">superview</span><span class="p">,</span> <span class="s">@&quot;The fromViewController view must reside in the container view upon initializing the transition context.&quot;</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">((</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">]))</span> <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">presentationStyle</span> <span class="o">=</span> <span class="n">UIModalPresentationCustom</span><span class="p">;</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">containerView</span> <span class="o">=</span> <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">superview</span><span class="p">;</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">viewControllers</span> <span class="o">=</span> <span class="err">@</span><span class="p">{</span>
</span><span class="line">            <span class="nl">UITransitionContextFromViewControllerKey:</span><span class="n">fromViewController</span><span class="p">,</span>
</span><span class="line">            <span class="nl">UITransitionContextToViewControllerKey:</span><span class="n">toViewController</span><span class="p">,</span>
</span><span class="line">        <span class="p">};</span>
</span><span class="line">
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">travelDistance</span> <span class="o">=</span> <span class="p">(</span><span class="n">goingRight</span> <span class="o">?</span> <span class="o">-</span><span class="n">self</span><span class="p">.</span><span class="n">containerView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">:</span> <span class="n">self</span><span class="p">.</span><span class="n">containerView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">);</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">disappearingFromRect</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">appearingToRect</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">containerView</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">disappearingToRect</span> <span class="o">=</span> <span class="n">CGRectOffset</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">containerView</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">travelDistance</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">appearingFromRect</span> <span class="o">=</span> <span class="n">CGRectOffset</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">containerView</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="o">-</span><span class="n">travelDistance</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们把视图的出现和消失时的状态记录了下来，比如初始状态和最终状态的 frame。</p>

<p>请注意一点，我们的初始化方法需要我们提供我们是在向右切换还是向左切换。在我们的 <code>ContainerViewController</code> 中，按钮是一个接一个水平排列的，转场上下文通过设置每个的 frame 来记录它们之间的位置关系。动画控制器或者说 <em>animator</em>，在生成动画时可以使用这些 frame。</p>

<p>我们也可以通过另外的方式去获取这些信息，但是那样的话，就会使 animator 和 <code>ContainerViewController</code> 及其视图控制器耦合在一起了，这是不好的，我们并不想这样。animator 应该只关心它自己以及传递给它的上下文，因为这样，在理想情况下，animator 可以在不同的上下文中得到复用。</p>

<p>在下一步实现我们自己的动画控制器时，我们应该时刻记住这一点，现在让我们来实现转场上下文吧。</p>

<p>你可能记得我们在 <a href="http://objccn.io/issue-5/">issue #5</a> 中的<a href="http://objccn.io/issue-5-3/">View Controller 转场</a>已经做过相同的事情了，为什么我们不使用它呢？事实上，由于使用了非常灵活的协议，我们可以直接把那个工程中的动画控制器，也就是 <code>Animator</code> 类直接拿过来使用，不需要任何修改。</p>

<p>使用 <code>Animator</code> 类的实例来做转场动画的核心代码如下所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">fromViewController</span> <span class="nl">willMoveToParentViewController:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">self</span> <span class="nl">addChildViewController:</span><span class="n">toViewController</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">Animator</span> <span class="o">*</span><span class="n">animator</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Animator</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">NSUInteger</span> <span class="n">fromIndex</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">viewControllers</span> <span class="nl">indexOfObject:</span><span class="n">fromViewController</span><span class="p">];</span>
</span><span class="line"><span class="n">NSUInteger</span> <span class="n">toIndex</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">viewControllers</span> <span class="nl">indexOfObject:</span><span class="n">toViewController</span><span class="p">];</span>
</span><span class="line"><span class="n">PrivateTransitionContext</span> <span class="o">*</span><span class="n">transitionContext</span> <span class="o">=</span> <span class="p">[[</span><span class="n">PrivateTransitionContext</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFromViewController:</span><span class="n">fromViewController</span> <span class="nl">toViewController:</span><span class="n">toViewController</span> <span class="nl">goingRight:</span><span class="n">toIndex</span> <span class="o">&gt;</span> <span class="n">fromIndex</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">transitionContext</span><span class="p">.</span><span class="n">animated</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line"><span class="n">transitionContext</span><span class="p">.</span><span class="n">interactive</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class="line"><span class="n">transitionContext</span><span class="p">.</span><span class="n">completionBlock</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">didComplete</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span> <span class="n">removeFromSuperview</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">fromViewController</span> <span class="n">removeFromParentViewController</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">toViewController</span> <span class="nl">didMoveToParentViewController:</span><span class="n">self</span><span class="p">];</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">animator</span> <span class="nl">animateTransition:</span><span class="n">transitionContext</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这其中的大部分是在对视图控制器容器的操作，计算出我们是在向左切换还是向右切换。做动画的部分基本上只有 3 行代码：1) 创建 animator，2) 创建转场上下文，和 3) 触发动画执行。</p>

<p>有了上面的代码，转场效果看起来如下图所示:</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-custom-container-view-controller-transitions-stage-2.gif" alt="Stage 2: third-party animation" /></p>

<p>非常酷，我们甚至没有写一行动画相关的代码。</p>

<p>你可以在 <a href="https://github.com/objcio/issue-12-custom-container-transitions/tree/stage-2">阶段-2</a> 标签下看到这部分代码的变化。在<a href="https://github.com/objcio/issue-12-custom-container-transitions/compare/stage-1...stage-2">与 阶段－1 的对比</a>这里你可以看到 阶段-2 和 阶段-1 相对比的完整的代码改变。</p>

<h3 id="3">阶段 3: 封装</h3>

<p>我想我们最后要做的一件事情是封装 <code>ContainerViewController</code> ，使其能够：</p>

<ol>
<li>提供默认的转场动画。  </li>
<li>提供替换默认动画控制器的代理。</li>
</ol>

<p>这意味着我们需要把对 <code>Animator</code> 类的依赖移除，同时需要创建一个代理协议。</p>

<p>我们如下定义这个协议:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@protocol</span> <span class="nc">ContainerViewControllerDelegate</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">@optional</span>
</span><span class="line"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">containerViewController:</span><span class="p">(</span><span class="n">ContainerViewController</span> <span class="o">*</span><span class="p">)</span><span class="n">containerViewController</span> <span class="nl">didSelectViewController:</span><span class="p">(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="n">viewController</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span> <span class="o">&lt;</span><span class="n">UIViewControllerAnimatedTransitioning</span><span class="o">&gt;</span><span class="p">)</span><span class="nf">containerViewController:</span><span class="p">(</span><span class="n">ContainerViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">containerViewController</span> <span class="nf">animationControllerForTransitionFromViewController:</span><span class="p">(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">fromViewController</span> <span class="nf">toViewController:</span><span class="p">(</span><span class="n">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">toViewController</span><span class="p">;</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>containerViewController:didSelectViewController:</code> 方法使 <code>ContainerViewController</code> 可以很更容易的集成于功能齐全的应用中。 </p>

<p><code>containerViewController:animationControllerForTransitionFromViewController:toViewController:</code> 方法挺有趣的，当然，你可以把它和下面的 UIKit 中的视图控制器容器的代理协议做对比：</p>

<ul>
<li><code>tabBarController:animationControllerForTransitionFromViewController:toViewController:</code> (<code>UITabBarControllerDelegate</code>)</li>
<li><code>navigationController:animationControllerForOperation:fromViewController:toViewController:</code> (<code>UINavigationControllerDelegate</code>)</li>
</ul>

<p>所有的这些方法都返回一个 <code>id&lt;UIViewControllerAnimatedTransitioning&gt;</code> 对象。</p>

<p>与之前一直使用一个 <code>Animator</code> 对象不同, 我们现在可以从我们的代理那里获取一个动画控制器：</p>

<pre><code>id&lt;UIViewControllerAnimatedTransitioning&gt;animator = nil;
if ([self.delegate respondsToSelector:@selector (containerViewController:animationControllerForTransitionFromViewController:toViewController:)]) {
    animator = [self.delegate containerViewController:self animationControllerForTransitionFromViewController:fromViewController toViewController:toViewController];
}
animator = (animator ?: [[PrivateAnimatedTransition alloc] init]);
</code></pre>

<p>如果我们有代理并且它返回了一个 animator，那么我们就使用这个 animator。否则，我们使用内部私有类 <code>PrivateAnimatedTransition</code> 创建一个默认的 animator。接下来我们将实现 <code>PrivateAnimatedTransition</code> 类。</p>

<p>尽管默认的动画和 <code>Animator</code> 有一些不同，但是代码看起来惊人的相似。下面是完整的代码实现:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">PrivateAnimatedTransition</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="n">CGFloat</span> <span class="k">const</span> <span class="n">kChildViewPadding</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
</span><span class="line"><span class="k">static</span> <span class="n">CGFloat</span> <span class="k">const</span> <span class="n">kDamping</span> <span class="o">=</span> <span class="mf">0.75f</span><span class="p">;</span>
</span><span class="line"><span class="k">static</span> <span class="n">CGFloat</span> <span class="k">const</span> <span class="n">kInitialSpringVelocity</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nf">transitionDuration:</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">UIViewControllerContextTransitioning</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">transitionContext</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animateTransition:</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">UIViewControllerContextTransitioning</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">transitionContext</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">    <span class="n">UIViewController</span><span class="o">*</span> <span class="n">toViewController</span> <span class="o">=</span> <span class="p">[</span><span class="n">transitionContext</span> <span class="nl">viewControllerForKey:</span><span class="n">UITransitionContextToViewControllerKey</span><span class="p">];</span>
</span><span class="line">    <span class="n">UIViewController</span><span class="o">*</span> <span class="n">fromViewController</span> <span class="o">=</span> <span class="p">[</span><span class="n">transitionContext</span> <span class="nl">viewControllerForKey:</span><span class="n">UITransitionContextFromViewControllerKey</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// When sliding the views horizontally, in and out, figure out whether we are going left or right.</span>
</span><span class="line">    <span class="kt">BOOL</span> <span class="n">goingRight</span> <span class="o">=</span> <span class="p">([</span><span class="n">transitionContext</span> <span class="nl">initialFrameForViewController:</span><span class="n">toViewController</span><span class="p">].</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="p">[</span><span class="n">transitionContext</span> <span class="nl">finalFrameForViewController:</span><span class="n">toViewController</span><span class="p">].</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">CGFloat</span> <span class="n">travelDistance</span> <span class="o">=</span> <span class="p">[</span><span class="n">transitionContext</span> <span class="n">containerView</span><span class="p">].</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">+</span> <span class="n">kChildViewPadding</span><span class="p">;</span>
</span><span class="line">    <span class="n">CGAffineTransform</span> <span class="n">travel</span> <span class="o">=</span> <span class="n">CGAffineTransformMakeTranslation</span> <span class="p">(</span><span class="n">goingRight</span> <span class="o">?</span> <span class="n">travelDistance</span> <span class="o">:</span> <span class="o">-</span><span class="n">travelDistance</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="p">[[</span><span class="n">transitionContext</span> <span class="n">containerView</span><span class="p">]</span> <span class="nl">addSubview:</span><span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class="line">    <span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformInvert</span> <span class="p">(</span><span class="n">travel</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">UIView</span> <span class="nl">animateWithDuration:</span><span class="p">[</span><span class="n">self</span> <span class="nl">transitionDuration:</span><span class="n">transitionContext</span><span class="p">]</span> <span class="nl">delay:</span><span class="mi">0</span> <span class="nl">usingSpringWithDamping:</span><span class="n">kDamping</span> <span class="nl">initialSpringVelocity:</span><span class="n">kInitialSpringVelocity</span> <span class="nl">options:</span><span class="mh">0x00</span> <span class="nl">animations:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">        <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">travel</span><span class="p">;</span>
</span><span class="line">        <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">        <span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformIdentity</span><span class="p">;</span>
</span><span class="line">        <span class="n">toViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span> <span class="nl">completion:</span><span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">fromViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformIdentity</span><span class="p">;</span>
</span><span class="line">        <span class="p">[</span><span class="n">transitionContext</span> <span class="nl">completeTransition:</span><span class="o">!</span><span class="p">[</span><span class="n">transitionContext</span> <span class="n">transitionWasCancelled</span><span class="p">]];</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>p</p>

<p>需要注意的一点是，上面的代码没有通过设置视图的 frame 来反应它们之间的位置关系，但是代码仍然可以正常工作，只不过转场总是在同一个方向上。因此，这个类也可以被其他的代码库使用。</p>

<p>转场动画现在看起来如下所示:</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-custom-container-view-controller-transitions-stage-3.gif" alt="Stage 3: third-party animation" /></p>

<p>在 <a href="https://github.com/objcio/issue-12-custom-container-transitions/tree/stage-3">阶段-3</a> 的代码中，app delegate 中设置代理的部分被<a href="https://github.com/objcio/issue-12-custom-container-transitions/blob/stage-3/Container%20Transitions/AppDelegate.m#L41">注释掉了</a>，这样就可以看到默认的动画效果了。你可以将其设置回再使用 <code>Animator</code> 类。你可能想查看<a href="https://github.com/objcio/issue-12-custom-container-transitions/compare/stage-2...stage-3">同 阶段－2 相比所有的修改</a>。</p>

<p>我们现在有一个自包含的提供了默认转场动画的 <code>ContainerViewController</code> 类，这个默认的转场动画可以被开发者自己定义的iOS 7 自定义动画控制器 (<code>UIViewControllerAnimatedTransitioning</code>) 的对象代替，甚至都可以不用关心我们的源代码就可以方便的替换。</p>

<h2>结论</h2>

<p>在本文中我们通过使用 iOS 7 提供的自定义视图控制器转场的新特性，使我们自定义的视图控制器容器成为了 UIKit 的一等公民。</p>

<p>这意味着你可以把自定义的非交互式的转场动画应用到自定义的视图控制器容器中。你可以看到我们把 7 个话题之前使用的转场类直接拿过来使用，而且没有做任何修改。</p>

<blockquote>
  <p><span class="secondary radius label">译者注</span> 即 <a href="http://objccn.io/issue-5/">issue #5</a> 中的 <a href="http://objccn.io/issue-5-3/">View Controller 转场</a>中的 <code>Animator</code> 类。</p>
</blockquote>

<p>如果你想让自己的容器视图控制器作为一个类库或者框架，或者仅仅想使你的代码得到更好的复用，这将是非常完美的。</p>

<p>我们现在仅仅支持非交互式的转场，下一步就是对交互式的转场也提供支持。</p>

<p>我把它留给你当作一个练习。这有一些复杂，因为我们基本上是要模仿系统的行为，而这真的全是猜测性的工作。</p>

<h2>扩展资料</h2>

<ul>
<li>2014 年的 iOS 7 Tech Talks 视频: <a href="https://developer.apple.com/tech-talks/videos/index.php?id=3#3">“Architecting Modern Apps, Part 1”</a> (07:23-31:27)</li>
<li>全部代码都放在 <a href="https://github.com/objcio/issue-12-custom-container-transitions">GitHub</a></li>
</ul>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Layer中动画概述]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/11/layerzhong-dong-hua-gai-shu/"/>
    <updated>2014-05-11T00:08:11+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/11/layerzhong-dong-hua-gai-shu</id>
    <content type="html"><![CDATA[<p>默认情况下，<code>CALayer</code> 及其子类的绝大部分标准属性都可以执行动画，无论是添加一个 <code>CAAnimation</code> 到 Layer（显式动画），亦或是为属性指定一个动作然后修改它（隐式动画）。</p>

<p>但有时候我们希望能同时为好几个属性添加动画，使它们看起来像是一个动画一样；或者，我们需要执行的动画不能通过使用标准 Layer 属性动画来实现。</p>

<p>在本文中，我们将讨论如何子类化 <code>CALayer</code> 并添加我们自己的属性，以便比较容易地创建那些如果以其他方式实现起来会很麻烦的动画效果。</p>

<p>一般说来，我们希望添加到 <code>CALayer</code> 的子类上的可动画属性有三种类型：</p>

<ul>
<li>能间接动画 Layer （或其子类）的一个或多个标准属性的属性。</li>
<li>能触发 Layer 背后的图像（即 <code>contents</code> 属性）重绘的属性。</li>
<li>不涉及 Layer 重绘或对任何已有属性执行动画的属性。</li>
</ul>

<h2>间接属性动画</h2>

<p>能间接修改其它标准 Layer 属性的自定义属性是这些选项中最简单的。它们仅仅只是自定义 setter 方法。然后将它们的输入转换为适用于创建动画的一个或多个不同的值。</p>

<p>如果被我们设置的属性已经预设好标准动画，那我们完全不需要编写任何实际的动画代码，因为我们修改这些属性后，它们就会继承任何被配置在当前 <code>CATransaction</code> 上的动画设置，并且自动执行动画。</p>

<p>换句话说，即使 <code>CALayer</code> 不知道如何对我们自定义的属性进行动画，它依然能对因自定义属性被改变而引起的其它可见副作用进行动画，而这恰好就是我们所需要的。</p>

<p>为了演示这种方法，让我们来创建一个简单的模拟时钟，之后我们可以使用被声明为 <code>NSDate</code> 类型 <code>time</code> 属性来设置它的时间。我会将从创建一个静态的时钟面盘开始。这个时钟包含三个 <code>CAShapeLayer</code> 实例 —— 一个用于时钟面盘的圆形 Layer 和两个用于时针和分针的长方形 Sublayer。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">ClockFace</span>: <span class="nc">CAShapeLayer</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSDate</span> <span class="o">*</span><span class="n">time</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line"><span class="k">@interface</span> <span class="nc">ClockFace</span> <span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="c1">// 私有属性</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">CAShapeLayer</span> <span class="o">*</span><span class="n">hourHand</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">CAShapeLayer</span> <span class="o">*</span><span class="n">minuteHand</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">ClockFace</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">((</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">]))</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBezierPath</span> <span class="nl">bezierPathWithOvalInRect:</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">].</span><span class="n">CGPath</span><span class="p">;</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">fillColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">whiteColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">strokeColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">blackColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">lineWidth</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">hourHand</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAShapeLayer</span> <span class="n">layer</span><span class="p">];</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">hourHand</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBezierPath</span> <span class="nl">bezierPathWithRect:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">70</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">70</span><span class="p">)].</span><span class="n">CGPath</span><span class="p">;</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">hourHand</span><span class="p">.</span><span class="n">fillColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">blackColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">hourHand</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span><span class="line">        <span class="p">[</span><span class="n">self</span> <span class="nl">addSublayer:</span><span class="n">self</span><span class="p">.</span><span class="n">hourHand</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">minuteHand</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAShapeLayer</span> <span class="n">layer</span><span class="p">];</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">minuteHand</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBezierPath</span> <span class="nl">bezierPathWithRect:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">90</span><span class="p">)].</span><span class="n">CGPath</span><span class="p">;</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">minuteHand</span><span class="p">.</span><span class="n">fillColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">blackColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">minuteHand</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span><span class="line">        <span class="p">[</span><span class="n">self</span> <span class="nl">addSublayer:</span><span class="n">self</span><span class="p">.</span><span class="n">minuteHand</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<!-- more -->
<p>同时我们要设置一个包含 <code>UIDatePicker</code> 的基本的 View Controller，这样我们就能测试我们的 Layer （日期选择器在 Storyboard 里设置）了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">ViewController</span> <span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="n">UIDatePicker</span> <span class="o">*</span><span class="n">datePicker</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">ClockFace</span> <span class="o">*</span><span class="n">clockFace</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">ViewController</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 添加时钟面板 Layer</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">clockFace</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ClockFace</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">clockFace</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">self</span><span class="p">.</span><span class="n">clockFace</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 设置默认时间</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">clockFace</span><span class="p">.</span><span class="n">time</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDate</span> <span class="n">date</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">setTime</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">clockFace</span><span class="p">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">datePicker</span><span class="p">.</span><span class="n">date</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在我们只需要实现 <code>time</code> 属性的 setter 方法。这个方法使用 <code>NSCalendar</code> 将时间变为小时和分钟，之后我们将它们转换为角坐标。然后我们就可以使用这些角度去生成两个 <code>CGAffineTransform</code> 以旋转时针和分针。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setTime:</span><span class="p">(</span><span class="n">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="nv">time</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSCalendar</span> <span class="o">*</span><span class="n">calendar</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSCalendar</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithCalendarIdentifier:</span><span class="n">NSGregorianCalendar</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSDateComponents</span> <span class="o">*</span><span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">calendar</span> <span class="nl">components:</span><span class="n">NSHourCalendarUnit</span> <span class="o">|</span> <span class="n">NSMinuteCalendarUnit</span> <span class="nl">fromDate:</span><span class="n">time</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">hourHand</span><span class="p">.</span><span class="n">affineTransform</span> <span class="o">=</span> <span class="n">CGAffineTransformMakeRotation</span><span class="p">(</span><span class="n">components</span><span class="p">.</span><span class="n">hour</span> <span class="o">/</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">M_PI</span><span class="p">);</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">minuteHand</span><span class="p">.</span><span class="n">affineTransform</span> <span class="o">=</span> <span class="n">CGAffineTransformMakeRotation</span><span class="p">(</span><span class="n">components</span><span class="p">.</span><span class="n">minute</span> <span class="o">/</span> <span class="mf">60.0</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">M_PI</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>结果看起来像这样：</p>

<p><img src="http://img.objccn.io/issue-12/clock.gif" width="320px" /></p>

<p>你可以 <a href="https://github.com/objcio/issue-12-custom-layer-property-animations">从 GitHub 上</a> 下载这个项目看看。</p>

<p>如你所见，我们实在没有做什么太费脑筋的事情；我们并没有创建一个新的可动画属性，而只是在单个方法里设置了几个标准可动画 Layer 属性而已。然而，如果我们想创建的动画并不能映射到任何已有的 Layer 属性上时，该怎么办呢？</p>

<h2 id="layer">动画 Layer 内容</h2>

<p>假设不使用几个分离的 Layer 来实现我们的时钟面板，那我们可以改用 Core Graphics 来绘制时钟。（这通常会降低性能，但我们可以假想我们所要实现的效果需要许多复杂的绘图操作，而它们很难用常规的 Layer 属性和 transform 来复制。）我们要怎么做呢？</p>

<p>与 <code>NSManagedObject</code> 很类似， <code>CALayer</code> 具有为任何被声明的属性生成 dynamic 的 setter 和 getter 的能力。在我们当前的实现中，我们让编译器去 synthesize 了 <code>time</code> 属性的 ivar 和 getter 方法，而我们自己实现了 setter 方法。但让我们来改变一下：丢弃我们的 setter 并将属性标记为 <code>@dynamic</code> 。同时我们也丢弃分离的时针和分针 Layer ，因为我们将自己去绘制它们。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">ClockFace</span> <span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">ClockFace</span>
</span><span class="line">
</span><span class="line"><span class="k">@dynamic</span> <span class="n">time</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">((</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">]))</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在我们开始之前，需要先做一个小调整：因为不幸的是，<code>CALayer</code> 不知道如何对 <code>NSDate</code> 属性进行插值（interpolate）（例如，虽然它可以处理数字类型和其它例如 <code>CGColor</code> 和 <code>CGAffineTransform</code> 这样的类型，但它不能自动生成不同的 <code>NSDate</code> 实例之间的中间值）。我们可以保留我们的自定义 setter 方法并用它设置另一个等价于 <code>NSTimeInterval</code> 的动态属性（这是一个数字值，可以被插值），但为了保持例子的简单性，我们会用一个浮点值替换 <code>NSDate</code> 属性来表征时钟的小时。我们还更新了用户界面，现在使用一个简单的 <code>UITextField</code> 来设置浮点值，而不再使用日期选择器：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">ViewController</span> <span class="p">()</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">UITextFieldDelegate</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="n">UITextField</span> <span class="o">*</span><span class="n">textField</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">ClockFace</span> <span class="o">*</span><span class="n">clockFace</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">ViewController</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 添加时钟面板 Layer</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">clockFace</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ClockFace</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">clockFace</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">self</span><span class="p">.</span><span class="n">clockFace</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">textFieldShouldReturn:</span><span class="p">(</span><span class="n">UITextField</span> <span class="o">*</span><span class="p">)</span><span class="nv">textField</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">textField</span> <span class="n">resignFirstResponder</span><span class="p">];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">textFieldDidEndEditing:</span><span class="p">(</span><span class="n">UITextField</span> <span class="o">*</span><span class="p">)</span><span class="nv">textField</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">clockFace</span><span class="p">.</span><span class="n">time</span> <span class="o">=</span> <span class="p">[</span><span class="n">textField</span><span class="p">.</span><span class="n">text</span> <span class="n">floatValue</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在，既然我们已经移除了自定义的 setter 方法，那我们要如何才能知晓 <code>time</code> 属性的改变呢？我们需要一个无论何时 <code>time</code> 属性改变时都能自动通知 <code>CALayer</code> 的方式，这样它才好重绘它的内容。我们通过覆写 <code>+needsDisplayForKey:</code> 方法即可做到这一点，如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">needsDisplayForKey:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="s">@&quot;time&quot;</span> <span class="nl">isEqualToString:</span><span class="n">key</span><span class="p">])</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">super</span> <span class="nl">needsDisplayForKey:</span><span class="n">key</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这就告诉了 Layer ，无论何时 <code>time</code> 属性被修改，它都需要调用 <code>-display</code> 方法。现在我们就覆写 <code>-display</code> 方法，添加一个 <code>NSLog</code> 语句打印出 <code>time</code> 的值：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">display</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;time: %f&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">time</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果我们设置 <code>time</code> 属性为 1.5 ，我们就会看到 <code>-display</code> 被调用，打印出新值：</p>

<pre><code>2014-04-28 22:37:04.253 ClockFace[49145:60b] time: 1.500000
</code></pre>

<p>但这还不是我们真正想要的；我们希望 <code>time</code> 属性能在旧值和新值之间在几帧之内做一个平滑的过渡动画。为了实现这一点，我们需要为 <code>time</code> 属性指定一个动画（或“动作（action）”），而通过覆写 <code>-actionForKey:</code> 方法就能做到：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">CAAction</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;)</span><span class="nf">actionForKey:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">key</span> <span class="nl">isEqualToString:</span><span class="s">@&quot;time&quot;</span><span class="p">])</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="nl">animationWithKeyPath:</span><span class="n">key</span><span class="p">];</span>
</span><span class="line">        <span class="n">animation</span><span class="p">.</span><span class="n">timingFunction</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nl">functionWithName:</span><span class="n">kCAMediaTimingFunctionLinear</span><span class="p">];</span>
</span><span class="line">        <span class="n">animation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">time</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="n">animation</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">super</span> <span class="nl">actionForKey:</span><span class="n">key</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在，如果我们再次设置 <code>time</code> 属性，我们就会看到 <code>-display</code> 被多次调用。调用的次数大约为每秒 60 次，至于动画的长度，默认为 0.25 秒，大约是 15 帧：</p>

<pre><code>2014-04-28 22:37:04.253 ClockFace[49145:60b] time: 1.500000
2014-04-28 22:37:04.255 ClockFace[49145:60b] time: 1.500000
2014-04-28 22:37:04.351 ClockFace[49145:60b] time: 1.500000
2014-04-28 22:37:04.370 ClockFace[49145:60b] time: 1.500000
2014-04-28 22:37:04.388 ClockFace[49145:60b] time: 1.500000
2014-04-28 22:37:04.407 ClockFace[49145:60b] time: 1.500000
2014-04-28 22:37:04.425 ClockFace[49145:60b] time: 1.500000
2014-04-28 22:37:04.443 ClockFace[49145:60b] time: 1.500000
2014-04-28 22:37:04.461 ClockFace[49145:60b] time: 1.500000
2014-04-28 22:37:04.479 ClockFace[49145:60b] time: 1.500000
2014-04-28 22:37:04.497 ClockFace[49145:60b] time: 1.500000
2014-04-28 22:37:04.515 ClockFace[49145:60b] time: 1.500000
2014-04-28 22:37:04.755 ClockFace[49145:60b] time: 1.500000
</code></pre>

<p>由于某些原因，当我们在每个中间点打印 <code>time</code> 值时，我们一直看到的是最终值。为何不能得到插值呢？因为我们查看的是错误的 <code>time</code> 属性。</p>

<p>当你设置某个 <code>CALayer</code> 的某个属性，你实际设置的是 <em>model</em> Layer 的值 —— 这里的 <em>model</em> Layer 表示正在进行的动画结束时， Layer 所达到的最终状态。如果你取 <em>model</em> Layer 的值，它就总是给你它被设置到的最终值。</p>

<p>但连接到 <em>model</em> Layer 的是所谓的 <em>presentation</em> Layer ——它是 <em>model</em> Layer 的一个拷贝，但它的值所表示的是 <em>当前的</em>，中间动画状态。如果我们修改 <code>-display</code> 方法去打印 Layer 的 <code>presentationLayer</code> 的 <code>time</code> 属性，那我们就会看到我们所期望的插值。（同时我们也使用 <code>presentationLayer</code> 的 <code>time</code> 属性来获取动画的开始值，替代 <code>self.time</code> ）：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">CAAction</span><span class="o">&gt;</span><span class="p">)</span><span class="nf">actionForKey:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">key</span> <span class="nl">isEqualToString:</span><span class="s">@&quot;time&quot;</span><span class="p">])</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="nl">animationWithKeyPath:</span><span class="n">key</span><span class="p">];</span>
</span><span class="line">        <span class="n">animation</span><span class="p">.</span><span class="n">timingFunction</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nl">functionWithName:</span><span class="n">kCAMediaTimingFunctionLinear</span><span class="p">];</span>
</span><span class="line">        <span class="n">animation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="p">([[</span><span class="n">self</span> <span class="n">presentationLayer</span><span class="p">]</span> <span class="n">time</span><span class="p">]);</span>
</span><span class="line">        <span class="k">return</span> <span class="n">animation</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">super</span> <span class="nl">actionForKey:</span><span class="n">key</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">display</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;time: %f&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="n">self</span> <span class="n">presentationLayer</span><span class="p">]</span> <span class="n">time</span><span class="p">]);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>下面是打印出的值：</p>

<pre><code>2014-04-28 22:43:31.200 ClockFace[49176:60b] time: 0.000000
2014-04-28 22:43:31.203 ClockFace[49176:60b] time: 0.002894
2014-04-28 22:43:31.263 ClockFace[49176:60b] time: 0.363371
2014-04-28 22:43:31.300 ClockFace[49176:60b] time: 0.586421
2014-04-28 22:43:31.318 ClockFace[49176:60b] time: 0.695179
2014-04-28 22:43:31.336 ClockFace[49176:60b] time: 0.803713
2014-04-28 22:43:31.354 ClockFace[49176:60b] time: 0.912598
2014-04-28 22:43:31.372 ClockFace[49176:60b] time: 1.021573
2014-04-28 22:43:31.391 ClockFace[49176:60b] time: 1.134173
2014-04-28 22:43:31.409 ClockFace[49176:60b] time: 1.242892
2014-04-28 22:43:31.427 ClockFace[49176:60b] time: 1.352016
2014-04-28 22:43:31.446 ClockFace[49176:60b] time: 1.460729
2014-04-28 22:43:31.464 ClockFace[49176:60b] time: 1.500000
2014-04-28 22:43:31.636 ClockFace[49176:60b] time: 1.500000
</code></pre>

<p>所以现在我们所要做就是画出时钟。我们将使用普通的 Core Graphics 函数以绘制到一个 Graphics Context 上来做到这一点，然后将产生出图像设置为我们 Layer 的 <code>contents</code>。下面是更新后的 <code>-display</code> 方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">display</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">// 获取时间插值</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">time</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">presentationLayer</span> <span class="n">time</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 创建绘制上下文</span>
</span><span class="line">    <span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">NO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">    <span class="n">CGContextRef</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 绘制时钟面板</span>
</span><span class="line">    <span class="n">CGContextSetLineWidth</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span><span class="line">    <span class="n">CGContextStrokeEllipseInRect</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">CGRectInset</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 绘制时针</span>
</span><span class="line">    <span class="n">CGFloat</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">time</span> <span class="o">/</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">M_PI</span><span class="p">;</span>
</span><span class="line">    <span class="n">CGPoint</span> <span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span><span class="line">    <span class="n">CGContextSetLineWidth</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span><span class="line">    <span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class="line">    <span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="mi">80</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="mi">80</span><span class="p">);</span>
</span><span class="line">    <span class="n">CGContextStrokePath</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 绘制分针</span>
</span><span class="line">    <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">floor</span><span class="p">(</span><span class="n">time</span><span class="p">))</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">M_PI</span><span class="p">;</span>
</span><span class="line">    <span class="n">CGContextSetLineWidth</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span><span class="line">    <span class="n">CGContextMoveToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class="line">    <span class="n">CGContextAddLineToPoint</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="mi">90</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="mi">90</span><span class="p">);</span>
</span><span class="line">    <span class="n">CGContextStrokePath</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="c1">//set backing image 设置 contents </span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">().</span><span class="n">CGImage</span><span class="p">;</span>
</span><span class="line">    <span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>结果看起来如下：</p>

<p><img src="http://img.objccn.io/issue-12/clock2.gif" width="320px" /></p>

<p>如你所见，不同于第一个时钟动画，随着时针的变化，分针实际上对每一个小时都会转上满满一圈（就像一个真正的时钟那样），而不仅仅只是通过最短的路径移动到它的最终位置；因为我们正在动画的是 <code>time</code> 值本身而不仅仅是时针或分针的位置，所以上下文信息被保留了。</p>

<p>通过这样的方式绘制一个时钟并不是很理想，因为 Core Graphics 函数没有硬件加速，可能会引起动画帧数的下降。另一种能每秒重绘 <code>contents</code> 图像 60 次的方式是用一个数组存储一些预先绘制好的图像，然后基于合适的插值简单的选择对应的图像即可。实现代码大概如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">const</span> <span class="n">NSInteger</span> <span class="n">hoursOnAClockFace</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">display</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">// 获取时间插值 </span>
</span><span class="line">    <span class="kt">float</span> <span class="n">time</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">presentationLayer</span> <span class="n">time</span><span class="p">]</span> <span class="o">/</span> <span class="n">hoursOnAClockFace</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">// 从之前定义好的图像数组里获取图像帧</span>
</span><span class="line">    <span class="n">NSInteger</span> <span class="n">numberOfFrames</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">frames</span> <span class="n">count</span><span class="p">];</span>
</span><span class="line">    <span class="n">NSInteger</span> <span class="n">index</span> <span class="o">=</span> <span class="n">round</span><span class="p">(</span><span class="n">time</span> <span class="o">*</span> <span class="n">numberOfFrames</span><span class="p">)</span> <span class="o">%</span> <span class="n">numberOfFrames</span><span class="p">;</span>
</span><span class="line">    <span class="n">UIImage</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">frames</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">frame</span><span class="p">.</span><span class="n">CGImage</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>通过避免在每一帧里都用昂贵的软件绘制，我们能改善动画的性能，但代价是我们需要在内存里存储所有预先绘制的动画帧图像，对于一个复杂的动画来说，这可能造成惊人的内存浪费。</p>

<p>但这提出了一个有趣的可能性。如果我们完全不在 <code>-display</code> 里更新 <code>contents</code> 图像会发生什么？我们做一些其它的事情怎样？</p>

<h2>非可视属性的动画</h2>

<p>在 <code>-display</code> 里更新其它 Layer 属性就是不必要的，因为我们可以很简单地直接对任何这样的属性做动画，如同我们在第一个时钟面板例子里所做的那样。但如果我们设置一些其它的东西，比如某些完全和 Layer 不相关的东西，会怎样呢？</p>

<p>下面的代码使用一个 <code>CALayer</code> 结合 <code>AVAudioPlayer</code> 来创建一个可动画的音量控制器。通过把音量绑定到 dynamic 的 Layer 属性上，我们可以使用 Core Animation 的属性插值来平滑的在两个不同的音量之间渐变，以同样的方式我们可以动画 Layer 上的任何自定义属性：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">AudioLayer</span> : <span class="nc">CALayer</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithAudioFileURL:</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">URL</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="kt">float</span> <span class="n">volume</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">play</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">stop</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isPlaying</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">@interface</span> <span class="nc">AudioLayer</span> <span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">AVAudioPlayer</span> <span class="o">*</span><span class="n">player</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">AudioLayer</span>
</span><span class="line">
</span><span class="line"><span class="k">@dynamic</span> <span class="n">volume</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithAudioFileURL:</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">URL</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">((</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">init</span><span class="p">]))</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">volume</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">player</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AVAudioPlayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithContentsOfURL:</span><span class="n">URL</span> <span class="nl">error:</span><span class="nb">NULL</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">play</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">player</span> <span class="n">play</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">stop</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">player</span> <span class="n">stop</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isPlaying</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">player</span><span class="p">.</span><span class="n">playing</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">needsDisplayForKey:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="s">@&quot;volume&quot;</span> <span class="nl">isEqualToString:</span><span class="n">key</span><span class="p">])</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">super</span> <span class="nl">needsDisplayForKey:</span><span class="n">key</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">CAAction</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;)</span><span class="nf">actionForKey:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">key</span> <span class="nl">isEqualToString:</span><span class="s">@&quot;volume&quot;</span><span class="p">])</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">CABasicAnimation</span> <span class="o">*</span><span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="nl">animationWithKeyPath:</span><span class="n">key</span><span class="p">];</span>
</span><span class="line">        <span class="n">animation</span><span class="p">.</span><span class="n">timingFunction</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAMediaTimingFunction</span> <span class="nl">functionWithName:</span><span class="n">kCAMediaTimingFunctionLinear</span><span class="p">];</span>
</span><span class="line">        <span class="n">animation</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="err">@</span><span class="p">([[</span><span class="n">self</span> <span class="n">presentationLayer</span><span class="p">]</span> <span class="n">volume</span><span class="p">]);</span>
</span><span class="line">        <span class="k">return</span> <span class="n">animation</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">super</span> <span class="nl">actionForKey:</span><span class="n">key</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">display</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">// 设置音量值为合适的音量插值</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">player</span><span class="p">.</span><span class="n">volume</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">presentationLayer</span> <span class="n">volume</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们可以通过使用一个简单的有着播放、停止、音量增大以及音量减小按钮的 View Controller 来做测试：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">ViewController</span> <span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">AudioLayer</span> <span class="o">*</span><span class="n">audioLayer</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">ViewController</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">NSURL</span> <span class="o">*</span><span class="n">musicURL</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nl">fileURLWithPath:</span><span class="p">[[</span><span class="n">NSBundle</span> <span class="n">mainBundle</span><span class="p">]</span> <span class="nl">pathForResource:</span><span class="s">@&quot;music&quot;</span> <span class="nl">ofType:</span><span class="s">@&quot;caf&quot;</span><span class="p">]];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">audioLayer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AudioLayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithAudioFileURL:</span><span class="n">musicURL</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">self</span><span class="p">.</span><span class="n">audioLayer</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">playPauseMusic:</span><span class="p">(</span><span class="n">UIButton</span> <span class="o">*</span><span class="p">)</span><span class="nv">sender</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">audioLayer</span> <span class="n">isPlaying</span><span class="p">])</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">audioLayer</span> <span class="n">stop</span><span class="p">];</span>
</span><span class="line">        <span class="p">[</span><span class="n">sender</span> <span class="nl">setTitle:</span><span class="s">@&quot;Play Music&quot;</span> <span class="nl">forState:</span><span class="n">UIControlStateNormal</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">else</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">audioLayer</span> <span class="n">play</span><span class="p">];</span>
</span><span class="line">        <span class="p">[</span><span class="n">sender</span> <span class="nl">setTitle:</span><span class="s">@&quot;Pause Music&quot;</span> <span class="nl">forState:</span><span class="n">UIControlStateNormal</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">fadeIn</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">audioLayer</span><span class="p">.</span><span class="n">volume</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">fadeOut</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">audioLayer</span><span class="p">.</span><span class="n">volume</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意：尽管我们的 Layer 没有可见的外观，但它依然需要被添加到屏幕上的视图层级里，以便动画能正常工作。</p>

<h2>结论</h2>

<p><code>CALayer</code> 的 dynamic 属性提供了一中简单的机制来实现任何形式的动画 —— 不仅仅只是内建的那些。而通过覆写 <code>-display</code>  方法，我们可以使用这些属性去控制任何我们想控制的东西，甚至是音量值这样的东西。</p>

<p>通过使用这些属性，我们不仅仅避免了重复造轮子，同时还确保了我们的自定义动画能与标准动画的时机和控制函数协同工作，以此就能非常容易地与其它动画属性同步。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
]]></content>
  </entry>
  
</feed>
