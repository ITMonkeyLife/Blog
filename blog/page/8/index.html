
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>IT Monkey Life</title>
	<meta name="author" content="Rick">

	
	<meta name="description" content="CocoaPods 是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具。利用 CocoaPods，可以定义自己的依赖关系 (称作 pods)，并且随着时间的变化，以及在整个开发环境中对第三方库的版本管理非常方便。 CocoaPods 背后的理念主要体现在两个方面。首先， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/Blog/atom.xml" rel="alternate" title="IT Monkey Life" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/Blog/favicon.png" rel="shortcut icon">
	<link href="/Blog/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/Blog/">IT Monkey Life</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/Blog/">Blog</a></li>
	<li><a href="/Blog/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/Blog/">Blog</a></li>
	<li><a href="/Blog/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:ITMonkeyLife.github.io/Blog">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
		<a class="rss" href="/Blog/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:ITMonkeyLife.github.io/Blog">
	</form>
</nav>


</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/Blog/blog/2014/04/21/shen-ru-li-jie-cocoapods/">
		
			深入理解CocoaPods</a>
	</h2>
	<div class="entry-content">
		<p>CocoaPods 是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具。利用 CocoaPods，可以定义自己的依赖关系 (称作 <code>pods</code>)，并且随着时间的变化，以及在整个开发环境中对第三方库的版本管理非常方便。</p>

<p>CocoaPods 背后的理念主要体现在两个方面。首先，在工程中引入第三方代码会涉及到许多内容。针对 Objective-C 初级开发者来说，工程文件的配置会让人很沮丧。在配置 build phases 和 linker flags 过程中，会引起许多人为因素的错误。CocoaPods 简化了这一切，它能够自动配置编译选项。</p>

<p>其次，通过 CocoaPods，可以很方便的查找到新的第三方库。当然，这并不是说你可以简单的将别人提供的库拿来拼凑成一个应用程序。它的真正作用是让你能够找到真正好用的库，以此来缩短我们的开发周期和提升软件的质量。</p>

<p>本文中，我们将通过分析 <code>pod 安装 (</code>pod install<code>)</code> 的过程，一步一步揭示 CocoaPods 背后的技术。</p>

<h2>核心组件</h2>

<p>CocoaPods是用 Ruby 写的，并由若干个 Ruby 包 (gems) 构成的。在解析整合过程中，最重要的几个 gems 分别是： <a href="https://github.com/CocoaPods/CocoaPods/">CocoaPods/CocoaPods</a>, <a href="https://github.com/CocoaPods/Core">CocoaPods/Core</a>, 和 <a href="https://github.com/CocoaPods/Xcodeproj">CocoaPods/Xcodeproj</a> (是的，CocoaPods 是一个依赖管理工具 &#8211; 利用依赖管理进行构建的！)。</p>

<blockquote>
	<p><span class="secondary radius label">编者注</span> CocoaPods 是一个 objc 的依赖管理工具，而其本身是利用 ruby 的依赖管理 gem 进行构建的</p>
</blockquote>
<hr />

<h3 id="cocoapodscocoapod">CocoaPods/CocoaPod</h3>

<p>这是是一个面向用户的组件，每当执行一个 <code>pod</code> 命令时，这个组件都将被激活。该组件包括了所有使用 CocoaPods 涉及到的功能，并且还能通过调用所有其它的 gems 来执行任务。</p>

<h3 id="cocoapodscore">CocoaPods/Core</h3>

<p>Core 组件提供支持与 CocoaPods 相关文件的处理，文件主要是 Podfile 和 podspecs。</p>

<h5 id="podfile">Podfile</h5>

<p>Podfile 是一个文件，用于定义项目锁需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 <a href="http://guides.cocoapods.org/syntax/podfile.html">Podfile 指南</a>。</p>

<h4 id="podspec">Podspec</h4>

<p><code>.podspec</code> 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。</p>

<h3 id="cocoapodsxcodeproj">CocoaPods/Xcodeproj</h3>

		
		<a href="/Blog/blog/2014/04/21/shen-ru-li-jie-cocoapods/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




</div>
	<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
	
	<div class="comments"><a href="/Blog/blog/2014/04/21/shen-ru-li-jie-cocoapods/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/Blog/blog/2014/04/21/macke-zhi-xing-wen-jian/">
		
			Mac可执行文件</a>
	</h2>
	<div class="entry-content">
		<p>我们用 Xcode 构建一个程序的过程中，会把源文件 (<code>.m</code> 和 <code>.h</code>) 文件转换为一个可执行文件。这个可执行文件中包含的字节码会将被 CPU (iOS 设备中的 ARM 处理器或 Mac 上的 Intel 处理器) 执行。</p>

<p>本文将介绍一下上面的过程中编译器都做了些什么，同时深入看看可执行文件内部是怎样的。实际上里面的东西要比我们第一眼看到的多得多。</p>

<p>这里我们把 Xcode 放一边，将使用命令行工具 (command-line tools)。当我们用 Xcode 构建一个程序时，Xcode 只是简单的调用了一系列的工具而已。Florian 对工具调用是如何工作的做了更详细的讨论。本文我们就直接调用这些工具，并看看它们都做了些什么。</p>

<p>真心希望本文能帮助你更好的理解 iOS 或 OS X 中的一个可执行文件 (也叫做 <em>Mach-O executable</em>) 是如何执行，以及怎样组装起来的。</p>

<h2 id="xcrun">xcrun</h2>

<p>先来看一些基础性的东西：这里会大量使用一个名为 <code>xcrun</code> 的命令行工具。看起来可能会有点奇怪，不过它非常的出色。这个小工具用来调用别的一些工具。原先，我们在终端执行如下命令：</p>

<pre><code>% clang -v
</code></pre>

<p>现在我们用下面的命令代替：</p>

<pre><code>% xcrun clang -v
</code></pre>

<p>在这里 <code>xcrun</code> 做的是定位到 <code>clang</code>，并执行它，附带输入 <code>clang</code> 后面的参数。</p>

<p>我们为什么要这样做呢？看起来没有什么意义。不过 <code>xcode</code> 允许我们: (1) 使用多个版本的 Xcode，以及使用某个特定 Xcode 版本中的工具。(2) 针对某个特定的 SDK (software development kit) 使用不同的工具。如果你有 Xcode 4.5 和 Xcode 5，通过 <code>xcode-select</code> 和 <code>xcrun</code> 可以选择使用 Xcode 5 中 iOS SDK 的工具，或者 Xcode 4.5 中的 OS X 工具。在许多其它平台中，这是不可能做到的。查阅 <code>xcrun</code> 和 <code>xcode-select</code> 的主页内容可以了解到详细内容。不用安装 <em>Command Line Tools</em>，就能使用命令行中的开发者工具。</p>

<h2 id="idehelloworld">不使用 IDE 的 Hello World</h2>

<p>回到终端 (Terminal)，创建一个包含一个 C 文件的文件夹：</p>

<pre><code>% mkdir ~/Desktop/objcio-command-line
% cd !$
% touch helloworld.c
</code></pre>

<p>接着使用你喜欢的文本编辑器来编辑这个文件 &#8211; 例如 TextEdit.app：</p>

<pre><code>% open -e helloworld.c
</code></pre>

<p>输入如下代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>保存并返回到终端，然后运行如下命令：</p>

<pre><code>% xcrun clang helloworld.c
% ./a.out
</code></pre>

		
		<a href="/Blog/blog/2014/04/21/macke-zhi-xing-wen-jian/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




</div>
	<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
	
	<div class="comments"><a href="/Blog/blog/2014/04/21/macke-zhi-xing-wen-jian/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/Blog/blog/2014/04/21/http/">
		
			Http,Tcp,IP协议</a>
	</h2>
	<div class="entry-content">
		<p>当 app 和服务器进行通信的时候，大多数情况下，都是采用 HTTP 协议。HTTP 最初是为 web 浏览器而定制的，如果在浏览器里输入 <a href="http://www.objc.io">http://www.objc.io</a> ，浏览器会通过 HTTP 协议和 www.objc.io 所对应的服务器进行通信。</p>

<p>HTTP是运行在应用层上的应用协议，而不同的层级上都有相应的协议在运行。层级的堆栈关系一般可以这么描述：</p>

<pre><code>Application Layer -- e.g. HTTP
----
Transport Layer -- e.g. TCP
----
Internet Layer -- e.g. IP
----
Link Layer -- e.g. IEEE 802.2
</code></pre>

<p>所谓的 <a href="https://en.wikipedia.org/wiki/OSI_model">OSI（Open Systems Interconnection，开放式系统互联）</a>模型定义了七层结构。本文会关注应用层 (application layer)、传输层 (transport layer) 和网络层 (internet layer)，它们分别代表了典型的 HTTP 的应用的 HTTP，TCP 以及 IP。在 IP 之下的是数据连接和物理层级，比如像 Ethernet 的实现之类的东西（Ethernet 拥有一个数据连接部分以及一个物理部分）。</p>

<p>如上文所述，我们只关注应用层，传输层和互联网层的部分，更确切的说，着重探讨一种特殊的混合模式：基于 IP 的 TCP，以及基于 TCP 实现的 HTTP。这就是我们每天使用的 app 的基本网络配置。</p>

<p>通过本文，希望大家能够对HTTP工作原理有一个细致的了解，知道一些常见的 HTTP 问题的产生原因，从而能在实践中尽量避免这些问题的发生。</p>

<p>其实在互联网上传递数据的方式并不只 HTTP 一种。HTTP 之所以被广泛使用的原因是其非常稳定、易用，即便是防火墙一般也是允许 HTTP 协议穿透的。</p>

<p>接下来我们从最低的一层谈起，说说 IP 网络协议。</p>

<h2 id="ipipinternetproctocol">IP网络协议 (IP-Internet Proctocol)</h2>

<p>TCP/IP 中的 IP 是<a href="https://en.wikipedia.org/wiki/Internet_Protocol">网络协议 (Internet Protocol)</a> 的缩写。从字面意思便知，它是互联网众多协议的基础。</p>

<p>IP 实现了<a href="https://en.wikipedia.org/wiki/Packet_switching">分组交换网络</a>。在协议下，机器被叫做 <em>主机 (host)</em>，IP 协议明确了 host 之间的资料包（数据包）的传输方式。</p>

<p>所谓数据包是指一段二进制数据，其中包含了发送源主机和目标主机的信息。IP 网络负责源主机与目标主机之间的数据包传输。IP 协议的特点是 <em>best effort</em>（尽力服务，其目标是提供有效服务并尽力传输）。这意味着，在传输过程中，数据包可能会丢失，也有可能被重复传送导致目标主机收到多个同样的数据包。</p>

<p>IP 网络中的主机都配有自己的地址，被称为 <em>IP 地址</em>。每个数据包中都包含了源主机和目标主机的 IP 地址。IP 协议负责路径计算，即 IP 数据包在网络中的传输传输时，数据包所经过的每一个主机节点都会读取数据包中的目标主机地址信息，以便选择朝什么地方传送数据包。</p>

<p>今天，绝大多数的数据包仍旧是 IPv4（Internet Protocol version 4 网际协议版本 4）的，每一个 IPv4 地址是长度为 32 位。常见采用 <a href="https://en.wikipedia.org/wiki/Dotted_decimal">dotted-decimal</a>（点分十进制）表示法，具体形式如：198.51.100.42。</p>

<p>新的 IPv6 标准也正在逐渐推广中。它有更大的地址空间：长度为 128 位，这使得数据包在网络中传输时的寻址更容易一些。另外，由于有更多的地址可以分配，诸如<a href="https://en.wikipedia.org/wiki/Network_address_translation">网络地址转换</a>等问题也迎刃而解。IPv6 的表示形式为：八组十六进制数以冒号分割，比如：2001:0db8:85a3:0042:1000:8a2e:0370:7334。</p>

<h2 id="iphearder">IP Hearder</h2>

		
		<a href="/Blog/blog/2014/04/21/http/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




</div>
	<div class="tags">


	<a class='category' href='/Blog/blog/categories/http/'>Http</a>


</div>
	
	<div class="comments"><a href="/Blog/blog/2014/04/21/http/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/Blog/blog/2014/04/15/foundationji-chu-ji-he-lei/">
		
			Foundation基础集合类</a>
	</h2>
	<div class="entry-content">
		<h2 id="nsarraynssetnsorderedsetnsdictionary">NSArray, NSSet, NSOrderedSet 和 NSDictionary</h2>

<p>基础集合类是每一个 Mac/iOS 应用的基本组成部分。在本文中，我们将对”老类” (<code>NSArray</code>, <code>NSSet</code>)和”新类” (<code>NSMapTable</code>, <code>NSHashTable</code>, <code>NSPointerArray</code>) 进行一个深入的研究，探索每一个的效率细节，并讨论其使用场景。</p>

<p>作者提示：本文包含一些参照结果，但它们并不意味着绝对精确，也没有进行均差分析及多次的测试。这些结果的目的是给出运行时统计，来帮助我们认识到通常来说用什么会更快。所有的测试基于 iPhone 5s，使用 Xcode 5.1b1 和 iOS 7.1b1 的 64 位程序。编译选项设置为 -Ofast 的发布构建。Vectorize loops 和 unroll loops (默认设置) 均设置为关闭。</p>

<h2 id="o">大 O 符号，算法复杂度计量</h2>

<p>首先，我们需要一些理论知识。效率通常用<a href="https://en.wikipedia.org/wiki/Big_O_notation">大 O 符号</a>描述。它定义了一个函数的<em>极限特征</em>，通常被用于描绘其算法效率。O 定义了函数增长率的上限。不同量级的差异非常巨大，可以看看通常使用的 O 符号的量级以及它们所对应需要的操作数的关系。</p>

<p><img src="http://img.objccn.io/issue-7/big-o-notation.png" alt="" /></p>

<p>例如，如果用算法复杂度为 O(n^2)的算法对一个有 50 个元素的数组排序，需要 2,500 步的操作。而且，还有内部的系统开销和方法调用 — 所以是 250 0个操作的时间常量。 O(1)是理想的复杂度，代表着恒定的时间。<a href="http://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms">好的排序算法通常需要 O(n*log n) 的时间</a>。</p>

<h3>可变性</h3>

<p>大多数的集合类存在两个版本:可变和不可变(默认)。这和其他大多数的框架有非常大的不同，一开始会让人觉得有一点奇怪。然而其他的框架现在也应用了这一特性：就在几个月前，<a href="http://blogs.msdn.com/b/dotnet/archive/2013/09/25/immutable-collections-ready-for-prime-time.aspx">.NET公布了作为官方扩展的不可变集合</a>。</p>

<p>最大的好处是什么？<strong>线程安全</strong>。不可变的集合完全是线程安全的，可以同时在多个线程中迭代，避免各种转变时出现异常的风险。你的 API <em>绝不</em>应该暴露一个可变的集合。</p>

<p>当然从不可变到可变然后再回来是会有一定代价的 — 对象必须被拷贝两次，所有集合内的对象将被 retain/release。有时在内部使用一个可变的集合，而在访问时返回一个不可变的对象副本会更高效。</p>

<p>与其他框架不同的是，苹果没有提供一个线程安全的可变集合，<code>NSCache</code> 是例外，但它真的算不上是集合类，因为它不是一个通用的容器。大多数时候，你不会需要在集合层级的同步特性。想象一段代码，作用是检查字典中一个 key 是否存在，并根据检查结果决定设置一个新的 key 或者返回某些值 — 你通常需要把多个操作归类，这时线程安全的可变集合并不能对你有所帮助。</p>

<p>其实也有<em>一些</em>同步的，线程安全的可以使用的可变集合案例，它们往往只需要用几行代码，通过子类和组合的方法建立，比如这个 <a href="https://gist.github.com/steipete/7746843"><code>NSDictionary</code></a> 或这个 <a href="https://github.com/Cue/TheKitchenSync/blob/master/Classes/Collections/CueSyncArray.mm"><code>NSArray</code></a>。</p>

<p>需要注意的是，一些较新的集合类，如 <code>NSHashTable</code>，<code>NSMapTable</code> 和 <code>NSPointerArray</code> 默认就是可变的，它们并没有对应的不可变的类。它们用于类的内部使用，你基本应该不会能找到需要它们的不可变版本的应用场景。</p>

<h2 id="nsarray">NSArray</h2>

<p><code>NSArray</code> 作为一个存储对象的有序集合，可能是被使用最多的集合类。这也是为什么它有自己的比原来的 <code>[NSArray arrayWithObjects:..., nil]</code> 简短得多的快速语法糖符号 <code>@[...]</code>。
<code>NSArray</code> 实现了 <code>objectAtIndexedSubscript:</code>，因为我们可以使用类 C 的语法 <code>array[0]</code> 来代替原来的 <code>[array objectAtIndex:0]</code>。</p>

<h3>性能特征</h3>

		
		<a href="/Blog/blog/2014/04/15/foundationji-chu-ji-he-lei/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




</div>
	<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
	
	<div class="comments"><a href="/Blog/blog/2014/04/15/foundationji-chu-ji-he-lei/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/Blog/blog/2014/04/15/wo-bu-hui-xie-shi/">
		
			我不会写诗</a>
	</h2>
	<div class="entry-content">
		<p>
好想在此写诗一回，<br />
但我始终不敢下笔，<br />
或许是诗不若景美，<br />
或许是诗不及影魅，<br />
抑或是我的诗，<br />
比此刻风景甚悲，<br />
忘记了天空的深邃，<br />
忘记了风的轻微，<br />
愿一只纸鸳的甜蜜，<br />
放飞漫天的心醉。<br />
好想在此放声歌唱，<br />
歌唱那满地的青黄，<br />
那白衣的姑娘，<br />
那微微的碎影，<br />
折射出太阳的方向，<br />
也许那甜蜜的不是淡淡阳光，<br />
而是那挂着笑容的脸庞，<br />
和那美好的希望。</p>
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>


<div class="meta">
	<div class="date">




</div>
	<div class="tags">


	<a class='category' href='/Blog/blog/categories/shi-ge/'>诗歌</a>


</div>
	
	<div class="comments"><a href="/Blog/blog/2014/04/15/wo-bu-hui-xie-shi/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/Blog/blog/2014/04/14/ioskai-fa-zhe-de-an-zhuo-chu-bu-kui-tan/">
		
			iOS开发者的安卓初步窥探</a>
	</h2>
	<div class="entry-content">
		<p>随着移动软件工业的发展，一个移动产品只局限于 iOS 系统变得越来越不切实际。 Android 目前占有近 80% 的智能手机份额[^1]，它能给一个产品带来的潜在用户量实在不能再被忽略了。</p>

<p>在本文中，我会在 iOS 的开发范围内介绍 Android 开发的核心内容。 Android 和 iOS 处理类似的问题集，但在大部分问题上，它们都有不同的解决方式。通过本文，我会使用一个配套项目（在 <a href="https://github.com/objcio/issue-11-android-101">GitHub</a> 上）来说明如何在两个平台上开发以完成相同的任务。</p>

<p>除了 iOS 开发的相关知识，我假设你在 Java 上也有一定经验，能够安装和使用<a href="http://developer.android.com/tools/index.html">ADT（Android Development Tools）</a>。此外，如果你最近才开始 Android 开发，读一遍 Google 编写的关于<a href="http://developer.android.com/training/basics/firstapp/index.html">创建你的第一个应用</a>的教程会很有帮助。</p>

<h3 id="ui">UI设计概要</h3>

<p>本文不会深入到介绍 iOS 和 Android 在用户体验和设计模式上的不同。然而，了解一些当今 Android 上使用的关键 UI 范式，比如 Action Bar、Overflow Menu、Back Button、Share Action 等，还是会很有好处的。如果你正在认真考虑 Android 开发，我推荐你从 Google Play Store 买个 <a href="https://play.google.com/store/devices/details?id=nexus_5_white_16gb">Nexus 5</a>，将它作为你的主要设备，用满一周，强迫自己最大程度的去体验这个操作系统。一个开发者若不清楚要为之开发的操作系的关键使用模式，就那是对产品的不负责任。</p>

<h2>语言应用结构</h2>

<h3 id="java">Java</h3>

<p>Objective-C 和 Java 之间有很多不同，虽然若能将 Objective-C 的方式带入 Java 可能会很有诱惑力，但这样做很可能导致代码库与驱动它的主要框架产生冲突。总之，有一些需要提防地陷阱：</p>

<ul>
<li>类前缀就留在 Objective-C 里不要带过来了。Java 有实在的命名空间和包管理，所以不再需要类前缀。</li>
<li>实例变量的前缀是 <code>m</code>，不是 <code>_</code>。尽可能多的在代码里使用JavaDoc来写方法和类描述，它能让你和其他人更舒服些。</li>
<li>Null 检查！Objective-C能妥善处理向nil发送消息，但Java不行。</li>
<li>向属性说再见。如果你想要 setter 和 getter，你只能实际地创建一个 getVariableName()方法，并显式的调用它。使用 <code>this.object</code> <strong>不会</strong>调用你自定义地getter，你必须使用 <code>this.getObjct</code>。</li>
<li>同样的，给方法名加上 <code>get</code> 和 <code>set</code> 前缀来更好的识别 getter 和 setter 。Java 方法通常写为动作和查询，例如 <code>getCell()</code>，而不是 <code>cellForRowAtIndexPath:</code>。</li>
</ul>

<h3>项目结构</h3>

		
		<a href="/Blog/blog/2014/04/14/ioskai-fa-zhe-de-an-zhuo-chu-bu-kui-tan/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




</div>
	<div class="tags">


	<a class='category' href='/Blog/blog/categories/android/'>Android</a>


</div>
	
	<div class="comments"><a href="/Blog/blog/2014/04/14/ioskai-fa-zhe-de-an-zhuo-chu-bu-kui-tan/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/Blog/blog/2014/04/10/ti-gao-xcodebian-yi-qi-xiao-lu/">
		
			提高Xcode编译器效率</a>
	</h2>
	<div class="entry-content">
		<h2>编译器做些什么？</h2>

<p>本文主要探讨一下编译器主要做些什么，以及如何有效的利用编译器。</p>

<p>简单的说，编译器有两个职责：把 Objective-C 代码转化成低级代码，以及对代码做分析，确保代码中没有任何明显的错误。</p>

<p>现在，Xcode 的默认编译器是 clang。本文中我们提到的编译器都表示 clang。clang 的功能是首先对 Objective-C 代码做分析检查，然后将其转换为低级的类汇编代码：LLVM Intermediate Representation(LLVM 中间表达码)。接着 LLVM 会执行相关指令将 LLVM IR 编译成目标平台上的本地字节码，这个过程的完成方式可以是即时编译 (Just-in-time)，或在编译的时候完成。</p>

<p>LLVM 指令的一个好处就是可以在支持 LLVM 的任意平台上生成和运行 LLVM 指令。例如，你写的一个 iOS app, 它可以自动的运行在两个完全不同的架构(Inter 和 ARM)上，LLVM 会根据不同的平台将 IR 码转换为对应的本地字节码。</p>

<p>LLVM 的优点主要得益于它的三层式架构 &#8211; 第一层支持多种语言作为输入(例如 C, ObjectiveC, C++ 和 Haskell)，第二层是一个共享式的优化器(对 LLVM IR 做优化处理)，第三层是许多不同的目标平台(例如 Intel, ARM 和 PowerPC)。在这三层式的架构中，如果你想要添加一门语言到 LLVM 中，那么可以把重要精力集中到第一层上，如果想要增加另外一个目标平台，那么你没必要过多的考虑输入语言。在书 <em>The Architecture of Open Source Applications</em> 中 LLVM 的创建者 (Chris Lattner) 写了一章很棒的内容：关于 <a href="http://www.aosabook.org/en/llvm.html">LLVM 架构</a>。</p>

<p>在编译一个源文件时，编译器的处理过程分为几个阶段。要想查看编译 <em>hello.m</em> 源文件需要几个不同的阶段，我们可以让通过 clang 命令观察：</p>

<pre><code>% clang -ccc-print-phases hello.m

0: input, "hello.m", objective-c
1: preprocessor, {0}, objective-c-cpp-output
2: compiler, {1}, assembler
3: assembler, {2}, object
4: linker, {3}, image
5: bind-arch, "x86_64", {4}, image
</code></pre>

<p>本文我们将重点关注第一阶段和第二阶段。在文章 <a href="http://objccn.io/issue-6-3/">Mach-O Executables</a> 中，Daniel 会对第三阶段和第四阶段进行阐述。</p>

<h3>预处理</h3>

<p>每当编源译文件的时候，编译器首先做的是一些预处理工作。比如预处理器会处理源文件中的宏定义，将代码中的宏用其对应定义的具体内容进行替换。</p>

<p>例如，如果在源文件中出现下述代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &lt;Foundation/Foundation.h&gt;;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>预处理器对这行代码的处理是用 Foundation.h 文件中的内容去替换这行代码，如果 Foundation.h 中也使用了类似的宏引入，则会按照同样的处理方式用各个宏对应的真正代码进行逐级替代。</p>

<p>这也就是为什么人们主张头文件最好尽量少的去引入其他的类或库，因为引入的东西越多，编译器需要做的处理就越多。例如，在头文件中用：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@class</span> <span class="nc">MyClass</span>;
</span></code></pre></td></tr></table></div></figure></notextile></div>

		
		<a href="/Blog/blog/2014/04/10/ti-gao-xcodebian-yi-qi-xiao-lu/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




</div>
	<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
	
	<div class="comments"><a href="/Blog/blog/2014/04/10/ti-gao-xcodebian-yi-qi-xiao-lu/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/Blog/blog/2014/04/10/xcodebian-yi-ni-suo-bu-zhi-dao-de-xi-jie/">
		
			Xcode编译你所不知道的细节</a>
	</h2>
	<div class="entry-content">
		<p>近些日子我们被宠坏了 &#8211; 我们只需要单击 Xcode 中的一个按钮（这个按钮看起来有点像是在播放一些音乐的动作），过几秒钟之后，我们的程序就会运行起来了，直到遇到一些错误，这非常的神奇。</p>

<p>在本文中，我们将从更高级别的角度来解读 Build 过程，并探索一下在 Xcode 界面中暴露出的 project setting 信息与 Build 过程有什么关系。为了更加深入的探索 Build 过程中，每一步实际执行的工作，我都会在本文中引入一些别的文章。</p>

<h2 id="build">解密 Build 日志</h2>

<p>为了了解 Xcode build 过程的内部工作原理，我们首先把突破口瞄准完整的 log 文件上。打开 Log Navigator ，从列表中选择一个 Build ，Xcode 会将 log 文件很完美的展现出来。</p>

<p><img src="http://img.objccn.io/issue-6/build-log.png" alt="Xcode build log navigator" /></p>

<p>默认情况下，上面的 Xcode 界面中隐藏了大量的信息，我们通过选择任务，然后点击右边的展开按钮，就能看到每个任务的详细信息。另外一种可选的方案就是选中列表中的一个或者多个任务，然后选择组合键 Cmd-C，这将会把所有的纯文本信息拷贝至粘贴板。最后，我们还可以选择 Editor 菜单中的 &#8220;Copy transcript for shown results&#8221;，以此将所有的 log 信息拷贝到粘贴板中。</p>

<p>本文给出的示例中，log 信息将近有 10,000 行（其实大多数的 log 信息是编译 OpenSSL 时生成的，并不是我们自己所写的代码生成的）。下面我们就开始吧！</p>

<p>注意观察输出的 log 信息，首先会发现 log 信息被分为不同的几大块，它们与我们工程中的targets相互对应着：</p>

<pre><code>Build target Pods-SSZipArchive
...
Build target Makefile-openssl
...
Build target Pods-AFNetworking
...
Build target crypto
...
Build target Pods
...
Build target ssl
...
Build target objcio
</code></pre>

<p>本文涉及到的工程有几个依赖项：其中 AFNetworking 和 SSZipArchive 包含在 Pods 中，而 OpenSSL 则以子工程的形式包含在工程中。</p>

<p>针对工程中的每个 target，Xcode 都会执行一系列的操作，将相关的源码，根据所选定的平台，转换为机器可读的二进制文件。下面我们详细的了解一下第一个 target：SSZipArchive。</p>

<p>在针对这个 target 输出的 log 信息中，我们可以看到每个任务被执行的详细情况。例如第一个任务是处理一个预编译头文件（为了增强 log 信息的可读性，我省略了许多细节）：</p>
<pre><code>(1) ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7 objective-c com.apple.compilers.llvm.clang.1_0.compiler
(2) cd /.../Dev/objcio/Pods
	setenv LANG en_US.US-ASCII
	setenv PATH "..."
(3) /.../Xcode.app/.../clang 
(4) -x objective-c-header 
(5) -arch armv7 
... configuration and warning flags ...
(6) -DDEBUG=1 -DCOCOAPODS=1 
... include paths and more ...
(7) -c 
(8) /.../Pods-SSZipArchive-prefix.pch 
(9) -o /.../Pods-SSZipArchive-prefix.pch.pch
</code></pre>

		
		<a href="/Blog/blog/2014/04/10/xcodebian-yi-ni-suo-bu-zhi-dao-de-xi-jie/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




</div>
	<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
	
	<div class="comments"><a href="/Blog/blog/2014/04/10/xcodebian-yi-ni-suo-bu-zhi-dao-de-xi-jie/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/Blog/blog/2014/04/10/dang-wo-zhen-zheng-kai-shi-ai-zi-ji/">
		
			当我真正开始爱自己</a>
	</h2>
	<div class="entry-content">
		<p><img src="http://ww1.sinaimg.cn/large/626e5d69gw1efahu2mtk8j20e60aadh6.jpg" alt="" /></p>
<p>当我真正开始爱自己，</p>

<p>我才认识到，所有的痛苦和情感的折磨，</p>

<p>都只是提醒我：活着，不要违背自己的本心。</p>

<p>今天我明白了，这叫做</p>

<p>『真实』。</p>

<p>当我真正开始爱自己，</p>

<p>我才懂得，把自己的愿望强加于人，</p>

<p>是多么的无礼，就算我知道，时机并不成熟，</p>

<p>那人也还没有做好准备，</p>

<p>就算那个人就是我自己，</p>

<p>今天我明白了，这叫做</p>

<p>『尊重』。</p>


		
		<a href="/Blog/blog/2014/04/10/dang-wo-zhen-zheng-kai-shi-ai-zi-ji/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




</div>
	<div class="tags">


	<a class='category' href='/Blog/blog/categories/shi-ge/'>诗歌</a>


</div>
	
	<div class="comments"><a href="/Blog/blog/2014/04/10/dang-wo-zhen-zheng-kai-shi-ai-zi-ji/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/Blog/blog/2014/04/10/uikit-dynamicsji-yu-wu-li-yin-qing-xin-te-xing/">
		
			UIKit-Dynamics基于物理引擎新特性</a>
	</h2>
	<div class="entry-content">
		<p>UIKit Dynamics 是 iOS 7 中基于物理动画引擎的一个新功能&#8211;它被特别设计使其能很好地与 collection views 配合工作，而后者是在 iOS 6 中才被引入的新特性。接下来，我们要好好看看如何将这两个特性结合在一起。 </p>

<p>这篇文章将讨论两个结合使用 UIkit Dynamics 和 collection view 的例子。第一个例子展示了如何去实现像 iOS 7 里信息 app 中的消息泡泡的弹簧动效，然后再进一步结合平铺机制来实现布局的可伸缩性。第二个例子展现了如何用 UIKit Dynamics 来模拟<a href="http://zh.wikipedia.org/wiki/牛顿摆">牛顿摆</a>，这个例子中物体可以一个个地加入到 collection view 中，并和其他物体发生相互作用。</p>

<p>在我们开始之前，我假定你们对 <code>UICollectionView</code> 是如何工作是有基本的了解——查看<a href="http://www.objccn.io/issue-3-3/">这篇 objc.io 文章</a>会有你想要的所有细节。我也假定你已经理解了 <code>UIKit Dynamics</code> 的工作原理&#8211;阅读这篇<a href="http://www.teehanlax.com/blog/introduction-to-uikit-dynamics/">博客</a>，可以了解更多 UIKit Dynamics 的知识。</p>

<blockquote>
  <p><span class="secondary radius label">编者注</span> 如果您阅读本篇文章感觉有点吃力的话，可以先来看看 <a href="http://im.onevcat.com">@onevcat</a> 的<a href="http://onevcat.com/2012/06/introducing-collection-views/">《UICollectionView 入门》</a> 和<a href="http://onevcat.com/2013/06/uikit-dynamics-started/">《UIKit Dynamics 入门》</a>这两篇入门文章，帮助您快速补充相关知识。</p>
</blockquote>

<p>文章中的两个例子项目都已经在 GitHub 中:</p>

<ul>
<li><a href="https://github.com/objcio/issue-5-springy-collection-view">ASHSpringyCollectionView</a>（基于 <a href="https://github.com/TeehanLax/UICollectionView-Spring-Demo">UICollectionView Spring Demo</a>）</li>
<li><a href="https://github.com/objcio/issue-5-newtonian-collection-view">Newtownian UICollectionView</a></li>
</ul>

<h2 id="uidynamicanimator">关于 UIDynamicAnimator</h2>

<p>支持 <code>UICollectionView</code> 实现 UIKit Dynamics 的最关键部分就是 <code>UIDynamicAnimator</code>。要实现这样的 UIKit Dynamics 的效果，我们需要自己自定义一个继承于 <code>UICollectionViewFlowLayout</code> 的子类，并且在这个子类对象里面持有一个 UIDynamicAnimator 的对象。</p>

<p>当我们创建自定义的 dynamic animator 时，我们不会使用常用的初始化方法 <code>-initWithReferenceView:</code> ，因为我们不需要把这个 dynamic animator 关联一个 view ，而是给它关联一个 collection view layout。所以我们使用 <code>-initWithCollectionViewLayout:</code> 这个初始化方法，并把 collection view layout 作为参数传入。这很关键，当的 animator 的 behavior item 的属性应该被更新的时候，它必须能够确保 collection view 的 layout 失效。换句话说，dynamic animator 将会经常使旧的 layout 失效。</p>

<p>我们很快就能看到这些事情是怎么连接起来的，但是在概念上理解 collection view 如何与 dynamic animator 相互作用是很重要的。</p>

<p>Collection view layout 将会为 collection view 中的每个 <code>UICollectionViewLayoutAttributes</code> 添加 behavior（稍后我们会讨论平铺它们）。在将这些 behaviors 添加到 dynamic animator 之后，UIKit 将会向 collection view layout 询问 atrribute 的状态。我们此时可以直接将由 dynamic animator 所提供的 items 返回，而不需要自己做任何计算。Animator 将在模拟时禁用 layout。这会导致 UIKit 再次查询 layout，这个过程会一直持续到模拟满足设定条件而结束。</p>

<p>所以重申一下，layout 创建了 dynamic animator，并且为其中每个 item 的 layout attribute 添加对应的 behaviors。当 collection view 需要 layout 信息时，由 dynamic animator 来提供需要的信息。</p>

<h2 id="uicollectionviewflowlayout">继承 UICollectionViewFlowLayout</h2>

<p>我们将要创建一个简单的例子来展示如何使用一个带 UIkit Dynamic 的 collection view layout。当然，我们需要做的第一件事就是，创建一个数据源去驱动我们的 collection view。我知道以你的能力完全可以独立实现一个数据源，但是为了完整性，我还是提供了一个给你:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">ASHCollectionViewController</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="n">NSString</span> <span class="o">*</span> <span class="n">CellIdentifier</span> <span class="o">=</span> <span class="s">@&quot;CellIdentifier&quot;</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span> <span class="nl">registerClass:</span><span class="p">[</span><span class="n">UICollectionViewCell</span> <span class="n">class</span><span class="p">]</span>
</span><span class="line">            <span class="nl">forCellWithReuseIdentifier:</span><span class="n">CellIdentifier</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="n">UIStatusBarStyle</span><span class="p">)</span><span class="nf">preferredStatusBarStyle</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">UIStatusBarStyleLightContent</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="nl">viewDidAppear:</span><span class="n">animated</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionViewLayout</span> <span class="n">invalidateLayout</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="cp">#pragma mark - UICollectionView Methods</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="n">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span>
</span><span class="line">    <span class="nf">numberOfItemsInSection:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">section</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">120</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="n">UICollectionViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="n">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span>
</span><span class="line">                 <span class="nf">cellForItemAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">UICollectionViewCell</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">collectionView</span>
</span><span class="line">        <span class="nl">dequeueReusableCellWithReuseIdentifier:</span><span class="n">CellIdentifier</span>
</span><span class="line">                                  <span class="nl">forIndexPath:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">cell</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">orangeColor</span><span class="p">];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">cell</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

		
		<a href="/Blog/blog/2014/04/10/uikit-dynamicsji-yu-wu-li-yin-qing-xin-te-xing/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




</div>
	<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
	
	<div class="comments"><a href="/Blog/blog/2014/04/10/uikit-dynamicsji-yu-wu-li-yin-qing-xin-te-xing/#disqus_thread">Comments</a></div>
	
</div>
</article>

<nav id="pagenavi">
    
        
            <a href="/Blog/blog/page/7/" class="prev">Prev</a>
        
    
    
        <a href="/Blog/blog/page/9/" class="next">Next</a>
    
    <div class="center"><a href="/Blog/blog/archives">Blog Archives</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2016

    Rick

</footer>
	<script src="/Blog/javascripts/slash.js"></script>
<script src="/Blog/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'ITMonkeyLife';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-52658428-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>
