
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>IT Monkey Life</title>
	<meta name="author" content="Rick">

	
	<meta name="description" content="Apr 10th, 2014 iOS Comments 提高Xcode编译器效率 编译器做些什么？ 本文主要探讨一下编译器主要做些什么，以及如何有效的利用编译器。 简单的说，编译器有两个职责：把 Objective-C 代码转化成低级代码，以及对代码做分析，确保代码中没有任何明显的错误。 现在， &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/Blog/atom.xml" rel="alternate" title="IT Monkey Life" type="application/atom+xml">
	
	<link rel="canonical" href="http://ITMonkeyLife.github.io/Blog/blog/page/3/">
	<link href="/Blog/favicon.png" rel="shortcut icon">
	<link href="/Blog/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/Blog/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	
	<script src="/Blog/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("382542165@qq.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>

<nav id="main-nav">
<section class="aboutme">
  <p class = "subtitle">
    心无所恃，随遇而安
  </p>
</section>

<ul class="main">
    <li><a href="/Blog/">我的Blog</a></li>
    <li><a href="/Blog/about/">关于我</a></li>
    <li><a href="/Blog/blog/archives">全部文章</a></li>
</ul></nav>
<nav id="sub-nav">
	<div class="social">
    	
			<a class="sina" href="http://weibo.com/1651400041" title="Sina">Sina</a>
		
		
			<a class="email" href="mailto:382542165@qq.com" title="Email">Email</a>
		
		
		
		
		
		
		
		
		
		
		
		
			<a class="douban" href="https://www.douban.com/people/47445127" title="Douban">Douban</a>
		
		
		
    	
    	
			<a class="rss" href="/Blog/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-10T11:21:11+08:00" data-updated="true" itemprop="datePublished">Apr 10<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/10/ti-gao-xcodebian-yi-qi-xiao-lu/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/10/ti-gao-xcodebian-yi-qi-xiao-lu/" itemprop="url">提高Xcode编译器效率</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>编译器做些什么？</h2>

<p>本文主要探讨一下编译器主要做些什么，以及如何有效的利用编译器。</p>

<p>简单的说，编译器有两个职责：把 Objective-C 代码转化成低级代码，以及对代码做分析，确保代码中没有任何明显的错误。</p>

<p>现在，Xcode 的默认编译器是 clang。本文中我们提到的编译器都表示 clang。clang 的功能是首先对 Objective-C 代码做分析检查，然后将其转换为低级的类汇编代码：LLVM Intermediate Representation(LLVM 中间表达码)。接着 LLVM 会执行相关指令将 LLVM IR 编译成目标平台上的本地字节码，这个过程的完成方式可以是即时编译 (Just-in-time)，或在编译的时候完成。</p>

<p>LLVM 指令的一个好处就是可以在支持 LLVM 的任意平台上生成和运行 LLVM 指令。例如，你写的一个 iOS app, 它可以自动的运行在两个完全不同的架构(Inter 和 ARM)上，LLVM 会根据不同的平台将 IR 码转换为对应的本地字节码。</p>

<p>LLVM 的优点主要得益于它的三层式架构 &#8211; 第一层支持多种语言作为输入(例如 C, ObjectiveC, C++ 和 Haskell)，第二层是一个共享式的优化器(对 LLVM IR 做优化处理)，第三层是许多不同的目标平台(例如 Intel, ARM 和 PowerPC)。在这三层式的架构中，如果你想要添加一门语言到 LLVM 中，那么可以把重要精力集中到第一层上，如果想要增加另外一个目标平台，那么你没必要过多的考虑输入语言。在书 <em>The Architecture of Open Source Applications</em> 中 LLVM 的创建者 (Chris Lattner) 写了一章很棒的内容：关于 <a href="http://www.aosabook.org/en/llvm.html">LLVM 架构</a>。</p>

<p>在编译一个源文件时，编译器的处理过程分为几个阶段。要想查看编译 <em>hello.m</em> 源文件需要几个不同的阶段，我们可以让通过 clang 命令观察：</p>

<pre><code>% clang -ccc-print-phases hello.m

0: input, "hello.m", objective-c
1: preprocessor, {0}, objective-c-cpp-output
2: compiler, {1}, assembler
3: assembler, {2}, object
4: linker, {3}, image
5: bind-arch, "x86_64", {4}, image
</code></pre>

<p>本文我们将重点关注第一阶段和第二阶段。在文章 <a href="http://objccn.io/issue-6-3/">Mach-O Executables</a> 中，Daniel 会对第三阶段和第四阶段进行阐述。</p>

<h3>预处理</h3>

<p>每当编源译文件的时候，编译器首先做的是一些预处理工作。比如预处理器会处理源文件中的宏定义，将代码中的宏用其对应定义的具体内容进行替换。</p>

<p>例如，如果在源文件中出现下述代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &lt;Foundation/Foundation.h&gt;;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>预处理器对这行代码的处理是用 Foundation.h 文件中的内容去替换这行代码，如果 Foundation.h 中也使用了类似的宏引入，则会按照同样的处理方式用各个宏对应的真正代码进行逐级替代。</p>

<p>这也就是为什么人们主张头文件最好尽量少的去引入其他的类或库，因为引入的东西越多，编译器需要做的处理就越多。例如，在头文件中用：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@class</span> <span class="nc">MyClass</span>;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>代替：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &quot;MyClass.h&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这么写是告诉编译器 MyClass 是一个类，并且在 .m 实现文件中可以通过 import <code>MyClass.h</code> 的方式来使用它。</p>

<p>假设我们写了一个简单的 C 程序 <code>hello.c</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hello world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后给上面的代码执行以下预处理命令，看看是什么效果：</p>

<pre><code>clang -E hello.c | less
</code></pre>

<p>接下来看看处理后的代码，一共是 401 行。如果将如下一行代码添加到上面代码的顶部：：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>再执行一下上面的预处理命令，处理后的文件代码行数暴增至 89,839 行。这个数字比某些操作系统的总代码行数还要多。</p>

<p>幸好，目前的情况已经改善许多了：引入了<a href="http://clang.llvm.org/docs/Modules.html">模块 - modules</a>功能，这使预处理变得更加的高级。</p>

<h4>自定义宏</h4>

<p>我们来看看另外一种情形定义或者使用自定义宏，比如定义了如下宏：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#define MY_CONSTANT 4</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>那么，凡是在此行宏定义作用域内，输入了 <code>MY_CONSTANT</code>，在预处理过程中 <code>MY_CONSTANT</code> 都会被替换成 <code>4</code>。我们定义的宏也是可以携带参数的， 比如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#define MY_MACRO(x) x</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>鉴于本文的内容所限，就不对强大的预处理做更多、更全面的展开讨论了。但是还是要强调一点，建议大家不要在需要预处理的代码中加入内联代码逻辑。</p>

<p>例如，下面这段代码，这样用没什么问题：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define MAX(a,b) a &gt; b ? a : b</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;largest: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAX</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>但是如果换成这么写：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define MAX(a,b) a &gt; b ? a : b</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;largest: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAX</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;i: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>用clang的max.c编译一下，结果是：</p>

<pre><code>largest: 201
i: 202
</code></pre>

<p>用 <code>clang -E max.c</code> 进行宏展开的预处理结果是如下所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;largest: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="o">?</span> <span class="n">i</span><span class="o">++</span> <span class="o">:</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;i: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>本例是典型的宏使用不当，而且通常这类问题非常隐蔽且难以 debug 。针对本例这类情况，最好使用 <code>static inline</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">MyConstant</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">   <span class="k">return</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">?</span> <span class="n">l</span> <span class="o">:</span> <span class="n">r</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">MyConstant</span><span class="p">;</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;largest: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;i: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样改过之后，就可以输出正常的结果 (<code>i:201</code>)。因为这里定义的代码是内联的 (inlined)，所以它的效率和宏变量差不多，但是可靠性比宏定义要好许多。再者，还可以设置断点、类型检查以及避免异常行为。</p>

<p>基本上，宏的最佳使用场景是日志输出，可以使用 <code>__FILE__</code> 和 <code>__LINE__</code> 和 assert 宏。</p>

<h3>词法解析标记</h3>

<p>预处理完成以后，每一个 <code>.m</code> 源文件里都有一堆的声明和定义。这些代码文本都会从 string 转化成特殊的标记流。</p>

<p>例如，下面是一段简单的 Objective-C hello word 程序：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;hello, %@&quot;</span><span class="p">,</span> <span class="s">@&quot;world&quot;</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>利用 clang 命令 <code>clang -Xclang -dump-tokens hello.m</code> 来将上面代码的标记流导出：</p>

<pre><code>int 'int'        [StartOfLine]  Loc=&lt;hello.m:4:1&gt;
identifier 'main'        [LeadingSpace] Loc=&lt;hello.m:4:5&gt;
l_paren '('             Loc=&lt;hello.m:4:9&gt;
r_paren ')'             Loc=&lt;hello.m:4:10&gt;
l_brace '{'      [LeadingSpace] Loc=&lt;hello.m:4:12&gt;
identifier 'NSLog'       [StartOfLine] [LeadingSpace]   Loc=&lt;hello.m:5:3&gt;
l_paren '('             Loc=&lt;hello.m:5:8&gt;
at '@'          Loc=&lt;hello.m:5:9&gt;
string_literal '"hello, %@"'            Loc=&lt;hello.m:5:10&gt;
comma ','               Loc=&lt;hello.m:5:21&gt;
at '@'   [LeadingSpace] Loc=&lt;hello.m:5:23&gt;
string_literal '"world"'                Loc=&lt;hello.m:5:24&gt;
r_paren ')'             Loc=&lt;hello.m:5:31&gt;
semi ';'                Loc=&lt;hello.m:5:32&gt;
return 'return'  [StartOfLine] [LeadingSpace]   Loc=&lt;hello.m:6:3&gt;
numeric_constant '0'     [LeadingSpace] Loc=&lt;hello.m:6:10&gt;
semi ';'                Loc=&lt;hello.m:6:11&gt;
r_brace '}'      [StartOfLine]  Loc=&lt;hello.m:7:1&gt;
eof ''          Loc=&lt;hello.m:7:2&gt;
</code></pre>

<p>仔细观察可以发现，每一个标记都包含了对应的源码内容和其在源码中的位置。注意这里的位置是宏展开之前的位置，这样一来，如果编译过程中遇到什么问题，clang 能够在源码中指出出错的具体位置。</p>

<h3>解析</h3>

<p>接下来要说的东西比较有意思：之前生成的标记流将会被解析成一棵抽象语法树 (abstract syntax tree &#8211; AST)。由于 Objective-C 是一门复杂的语言，因此解析的过程不简单。解析过后，源程序变成了一棵抽象语法树：一棵代表源程序的树。假设我们有一个程序 <code>hello.m</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="k">@interface</span> <span class="nc">World</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">hello</span><span class="p">;</span>
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">World</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">hello</span> <span class="p">{</span>
</span><span class="line">  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;hello, world&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">   <span class="n">World</span><span class="o">*</span> <span class="n">world</span> <span class="o">=</span> <span class="p">[</span><span class="n">World</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line">   <span class="p">[</span><span class="n">world</span> <span class="n">hello</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当我们执行 clang 命令 <code>clang -Xclang -ast-dump -fsyntax-only hello.m</code> 之后，命令行中输出的结果如下所示：：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">World</span><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">hello</span><span class="p">;</span>
</span><span class="line"><span class="k">@end</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">@implementation</span> <span class="nc">World</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">hello</span> <span class="p">(</span><span class="n">CompoundStmt</span> <span class="mh">0x10372ded0</span> <span class="o">&lt;</span><span class="n">hello</span><span class="p">.</span><span class="nl">m:</span><span class="mi">8</span><span class="o">:</span><span class="mi">15</span><span class="p">,</span> <span class="nl">line:</span><span class="mi">10</span><span class="o">:</span><span class="mi">1</span><span class="o">&gt;</span>
</span><span class="line">  <span class="p">(</span><span class="n">CallExpr</span> <span class="mh">0x10372dea0</span> <span class="o">&lt;</span><span class="nl">line:</span><span class="mi">9</span><span class="o">:</span><span class="mi">3</span><span class="p">,</span> <span class="nl">col:</span><span class="mi">24</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="kt">void</span><span class="err">&#39;</span>
</span><span class="line">    <span class="p">(</span><span class="n">ImplicitCastExpr</span> <span class="mh">0x10372de88</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">3</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">,</span> <span class="p">...)</span><span class="err">&#39;</span> <span class="o">&lt;</span><span class="n">FunctionToPointerDecay</span><span class="o">&gt;</span>
</span><span class="line">      <span class="p">(</span><span class="n">DeclRefExpr</span> <span class="mh">0x10372ddd8</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">3</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="kt">void</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">,</span> <span class="p">...)</span><span class="err">&#39;</span> <span class="n">Function</span> <span class="mh">0x1023510d0</span> <span class="err">&#39;</span><span class="n">NSLog</span><span class="sc">&#39; &#39;</span><span class="kt">void</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">,</span> <span class="p">...)</span><span class="err">&#39;</span><span class="p">))</span>
</span><span class="line">    <span class="p">(</span><span class="n">ObjCStringLiteral</span> <span class="mh">0x10372de38</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">9</span><span class="p">,</span> <span class="nl">col:</span><span class="mi">10</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="n">NSString</span> <span class="o">*</span><span class="err">&#39;</span>
</span><span class="line">      <span class="p">(</span><span class="n">StringLiteral</span> <span class="mh">0x10372de00</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">10</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="kt">char</span> <span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="err">&#39;</span> <span class="n">lvalue</span> <span class="s">&quot;hello, world&quot;</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span><span class="line"><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">(</span><span class="n">CompoundStmt</span> <span class="mh">0x10372e118</span> <span class="o">&lt;</span><span class="n">hello</span><span class="p">.</span><span class="nl">m:</span><span class="mi">13</span><span class="o">:</span><span class="mi">12</span><span class="p">,</span> <span class="nl">line:</span><span class="mi">16</span><span class="o">:</span><span class="mi">1</span><span class="o">&gt;</span>
</span><span class="line">  <span class="p">(</span><span class="n">DeclStmt</span> <span class="mh">0x10372e090</span> <span class="o">&lt;</span><span class="nl">line:</span><span class="mi">14</span><span class="o">:</span><span class="mi">4</span><span class="p">,</span> <span class="nl">col:</span><span class="mi">30</span><span class="o">&gt;</span>
</span><span class="line">    <span class="mh">0x10372dfe0</span> <span class="s">&quot;World *world =</span>
</span><span class="line">      <span class="p">(</span><span class="n">ImplicitCastExpr</span> <span class="mh">0x10372e078</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">19</span><span class="p">,</span> <span class="nl">col:</span><span class="mi">29</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="n">World</span> <span class="o">*</span><span class="err">&#39;</span> <span class="o">&lt;</span><span class="n">BitCast</span><span class="o">&gt;</span>
</span><span class="line">        <span class="p">(</span><span class="n">ObjCMessageExpr</span> <span class="mh">0x10372e048</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">19</span><span class="p">,</span> <span class="nl">col:</span><span class="mi">29</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="kt">id</span><span class="sc">&#39;:&#39;</span><span class="kt">id</span><span class="err">&#39;</span> <span class="n">selector</span><span class="o">=</span><span class="n">new</span> <span class="n">class</span><span class="o">=</span><span class="err">&#39;</span><span class="n">World</span><span class="err">&#39;</span><span class="p">))</span><span class="s">&quot;)</span>
</span><span class="line">  <span class="p">(</span><span class="n">ObjCMessageExpr</span> <span class="mh">0x10372e0e8</span> <span class="o">&lt;</span><span class="nl">line:</span><span class="mi">15</span><span class="o">:</span><span class="mi">4</span><span class="p">,</span> <span class="nl">col:</span><span class="mi">16</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="kt">void</span><span class="err">&#39;</span> <span class="n">selector</span><span class="o">=</span><span class="n">hello</span>
</span><span class="line">    <span class="p">(</span><span class="n">ImplicitCastExpr</span> <span class="mh">0x10372e0d0</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">5</span><span class="o">&gt;</span> <span class="err">&#39;</span><span class="n">World</span> <span class="o">*</span><span class="err">&#39;</span> <span class="o">&lt;</span><span class="n">LValueToRValue</span><span class="o">&gt;</span>
</span><span class="line">      <span class="p">(</span><span class="n">DeclRefExpr</span> <span class="mh">0x10372e0a8</span> <span class="o">&lt;</span><span class="nl">col:</span><span class="mi">5</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="err">&#39;</span><span class="n">World</span> <span class="o">*</span><span class="err">&#39;</span> <span class="n">lvalue</span> <span class="n">Var</span> <span class="mh">0x10372dfe0</span> <span class="err">&#39;</span><span class="n">world</span><span class="sc">&#39; &#39;</span><span class="n">World</span> <span class="o">*</span><span class="err">&#39;</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在抽象语法树中的每个节点都标注了其对应源码中的位置，同样的，如果产生了什么问题，clang 可以定位到问题所在处的源码位置。</p>

<h5>延伸阅读</h5>

<ul>
<li><a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html">clang AST 介绍</a></li>
</ul>

<h3>静态分析</h3>

<p>一旦编译器把源码生成了抽象语法树，编译器可以对这棵树做分析处理，以找出代码中的错误，比如类型检查：即检查程序中是否有类型错误。例如：如果代码中给某个对象发送了一个消息，编译器会检查这个对象是否实现了这个消息（函数、方法）。此外，clang 对整个程序还做了其它更高级的一些分析，以确保程序没有错误。</p>

<h4>类型检查</h4>

<p>每当开发人员编写代码的时候，clang 都会帮忙检查错误。其中最常见的就是检查程序是否发送正确的消息给正确的对象，是否在正确的值上调用了正确的函数。如果你给一个单纯的 <code>NSObject*</code> 对象发送了一个 <code>hello</code> 消息，那么 clang 就会报错。同样，如果你创建了 <code>NSObject</code> 的一个子类 <code>Test</code>, 如下所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">Test</span> : <span class="nc">NSObject</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后试图给这个子类中某个属性设置一个与其自身类型不相符的对象，编译器会给出一个可能使用不正确的警告。</p>

<p>一般会把类型分为两类：动态的和静态的。动态的在运行时做检查，静态的在编译时做检查。以往，编写代码时可以向任意对象发送任何消息，在运行时，才会检查对象是否能够响应这些消息。由于只是在运行时做此类检查，所以叫做动态类型。</p>

<p>至于静态类型，是在编译时做检查。当在代码中使用 ARC 时，编译器在编译期间，会做许多的类型检查：因为编译器需要知道哪个对象该如何使用。例如，如果 myObject 没有 hello 方法，那么就不能写如下这行代码了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">myObject</span> <span class="n">hello</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4>其他分析</h4>

<p>clang 在静态分析阶段，除了类型检查外，还会做许多其它一些分析。如果你把 clang 的代码仓库 clone 到本地，然后进入目录 <code>lib/StaticAnalyzer/Checkers</code>，你会看到所有静态检查内容。比如 <code>ObjCUnusedIVarsChecker.cpp</code> 是用来检查是否有定义了，但是从未使用过的变量。而 <code>ObjCSelfInitChecker.cpp</code> 则是检查在 你的初始化方法中中调用 <code>self</code> 之前，是否已经调用 <code>[self initWith...]</code> 或 <code>[super init]</code> 了。编译器还进行了一些其它的检查，例如在 <code>lib/Sema/SemaExprObjC.cpp</code> 的 2,534 行，有这样一句：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">Diag</span><span class="p">(</span><span class="n">SelLoc</span><span class="p">,</span> <span class="n">diag</span><span class="o">::</span><span class="n">warn_arc_perform_selector_leaks</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这个会生成严重错误的警告 “performSelector may cause a leak because its selector is unknown” 。</p>

<h2>代码生成</h2>

<p>clang 完成代码的标记，解析和分析后，接着就会生成 LLVM 代码。下面继续看看<code>hello.c</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hello world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>要把这段代码编译成 LLVM 字节码（绝大多数情况下是二进制码格式），我们可以执行下面的命令：</p>

<pre><code>clang -O3 -emit-LLVM hello.c -c -o hello.bc
</code></pre>

<p>接着用另一个命令来查看刚刚生成的二进制文件：</p>

<pre><code>llvm-dis &lt; hello.bc | less
</code></pre>

<p>输出如下：</p>

<pre><code>; ModuleID = '&lt;stdin&gt;'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.8.0"

@str = private unnamed_addr constant [12 x i8] c"hello world\00"

; Function Attrs: nounwind ssp uwtable
define i32 @main() #0 {
  %puts = tail call i32 @puts(i8* getelementptr inbounds ([12 x i8]* @str, i64 0, i64 0))
  ret i32 0
}

; Function Attrs: nounwind
declare i32 @puts(i8* nocapture) #1

attributes #0 = { nounwind ssp uwtable }
attributes #1 = { nounwind }
</code></pre>

<p>在上面的代码中，可以看到 <code>main</code> 函数只有两行代码：一行输出string，另一行返回 <code>0</code>。</p>

<p>再换一个程序，拿 <code>five.m</code> 为例，对其做相同的编译，然后执行 <code>LLVM-dis &lt; five.bc | less</code>:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">NSLog</span><span class="p">(</span><span class="err">@</span><span class="s">&quot;%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="err">@</span><span class="mi">5</span> <span class="n">description</span><span class="p">]);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>抛开其他的不说，单看 <code>main</code> 函数：</p>

<pre><code>define i32 @main() #0 {
  %1 = load %struct._class_t** @"\01L_OBJC_CLASSLIST_REFERENCES_$_", align 8
  %2 = load i8** @"\01L_OBJC_SELECTOR_REFERENCES_", align 8, !invariant.load !4
  %3 = bitcast %struct._class_t* %1 to i8*
  %4 = tail call %0* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to %0* (i8*, i8*, i32)*)(i8* %3, i8* %2, i32 5)
  %5 = load i8** @"\01L_OBJC_SELECTOR_REFERENCES_2", align 8, !invariant.load !4
  %6 = bitcast %0* %4 to i8*
  %7 = tail call %1* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to %1* (i8*, i8*)*)(i8* %6, i8* %5)
  tail call void (%1*, ...)* @NSLog(%1* bitcast (%struct.NSConstantString* @_unnamed_cfstring_ to %1*), %1* %7)
  ret i32 0
}
</code></pre>

<p>上面代码中最重要的是第 4 行，它创建了一个 <code>NSNumber</code> 对象。第 7 行，给这个 number 对象发送了一个  <code>description</code> 消息。第 8 行，将 <code>description</code> 消息返回的内容打印出来。</p>

<h3>优化</h3>

<p>要想了解 LLVM 的优化内容，以及 clang 能做哪些优化，我们先看一个略微复杂的 C 程序：这个函数主要是递归计算 <code>阶乘</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">   <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line">   <span class="k">else</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;factorial 10: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>先看看不做优化的编译情况，执行下面命令：</p>

<pre><code>clang -O0 -emit-llvm factorial.c  -c -o factorial.bc &amp;&amp; llvm-dis &lt; factorial.bc
</code></pre>

<p>重点看一下针对 <code>阶乘</code> 部分生成的代码：</p>

<pre><code>define i32 @factorial(i32 %x) #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  store i32 %x, i32* %2, align 4
  %3 = load i32* %2, align 4
  %4 = icmp sgt i32 %3, 1
  br i1 %4, label %5, label %11

; &lt;label&gt;:5                                       ; preds = %0
  %6 = load i32* %2, align 4
  %7 = load i32* %2, align 4
  %8 = sub nsw i32 %7, 1
  %9 = call i32 @factorial(i32 %8)
  %10 = mul nsw i32 %6, %9
  store i32 %10, i32* %1
  br label %12

; &lt;label&gt;:11                                      ; preds = %0
  store i32 1, i32* %1
  br label %12

; &lt;label&gt;:12                                      ; preds = %11, %5
  %13 = load i32* %1
  ret i32 %13
}
</code></pre>

<p>看一下 <code>%9</code> 标注的那一行，这行代码正是递归调用阶乘函数本身，实际上这样调用是非常低效的，因为每次递归调用都要重新压栈。接下来可以看一下优化后的效果，可以通过这样的方式开启优化 &#8211; 将 <code>-03</code> 标志传给 clang：</p>

<pre><code>clang -O3 -emit-llvm factorial.c  -c -o factorial.bc &amp;&amp; llvm-dis &lt; factorial.bc
</code></pre>

<p>现在 <code>阶乘</code> 计算相关代码编译后生成的代码如下：</p>

<pre><code>define i32 @factorial(i32 %x) #0 {
  %1 = icmp sgt i32 %x, 1
  br i1 %1, label %tailrecurse, label %tailrecurse._crit_edge

tailrecurse:                                      ; preds = %tailrecurse, %0
  %x.tr2 = phi i32 [ %2, %tailrecurse ], [ %x, %0 ]
  %accumulator.tr1 = phi i32 [ %3, %tailrecurse ], [ 1, %0 ]
  %2 = add nsw i32 %x.tr2, -1
  %3 = mul nsw i32 %x.tr2, %accumulator.tr1
  %4 = icmp sgt i32 %2, 1
  br i1 %4, label %tailrecurse, label %tailrecurse._crit_edge

tailrecurse._crit_edge:                           ; preds = %tailrecurse, %0
  %accumulator.tr.lcssa = phi i32 [ 1, %0 ], [ %3, %tailrecurse ]
  ret i32 %accumulator.tr.lcssa
}
</code></pre>

<p>即便我们的函数并没有按照<a href="http://en.wikipedia.org/wiki/Tail_call">尾递归</a>的方式编写，clang 仍然能对其做优化处理，让该函数编译的结果中只包含一个循环。当然 clang 能对代码进行的优化还有很多方面。可以看以下这个比较不错的 gcc 的优化例子<a href="http://ridiculousfish.com/blog/posts/will-it-optimize.html">ridiculousfish.com</a>。</p>

<p><strong>延伸阅读</strong></p>

<ul>
<li><a href="http://blog.llvm.org/search/label/optimization">LLVM blog: posts tagged &#8216;optimization&#8217;</a></li>
<li><a href="http://blog.llvm.org/2013/05/llvm-33-vectorization-improvements.html">LLVM blog: vectorization improvements</a></li>
<li><a href="http://blog.llvm.org/2011/09/greedy-register-allocation-in-llvm-30.html">LLVM blog: greedy register allocation</a></li>
<li><a href="http://polly.llvm.org/index.html">The Polly project</a></li>
</ul>

<h2>如何在实际中应用这些特性</h2>

<p>刚刚我们探讨了编译的全过程，从标记到解析，从抽象语法树到分析检查，再到汇编。读者不禁要问，为什么要关注这些？</p>

<h3 id="libclangclang">使用 libclan g或 clang 插件</h3>

<p>之所以 clang 很酷：是因为它是一个开源的项目、并且它是一个非常好的工程：几乎可以说全身是宝。使用者可以创建自己的 clang 版本，针对自己的需求对其进行改造。比如说，可以改变 clang 生成代码的方式，增加更强的类型检查，或者按照自己的定义进行代码的检查分析等等。要想达成以上的目标，有很多种方法，其中最简单的就是使用一个名为 <a href="http://clang.llvm.org/doxygen/group__CINDEX.html">libclang</a> 的C类库。libclang 提供的 API 非常简单，可以对 C 和 clang 做桥接，并可以用它对所有的源码做分析处理。不过，根据我的经验，如果使用者的需求更高，那么 libclang 就不怎么行了。针对这种情况，推荐使用 <a href="https://github.com/macmade/ClangKit">Clangkit</a>，它是基于 clang 提供的功能，用 Objective-C 进行封装的一个库。</p>

<p>最后，clang 还提供了一个直接使用 LibTooling 的 C++ 类库。这里要做的事儿比较多，而且涉及到 C++，但是它能够发挥 clang 的强大功能。用它你可以对源码做任意类型的分析，甚至重写程序。如果你想要给 clang 添加一些自定义的分析、创建自己的重构器 (refactorer)、或者需要基于现有代码做出大量修改，甚至想要基于工程生成相关图形或者文档，那么 LibTooling 是很好的选择。</p>

<h3>自定义分析器</h3>

<p>开发者可以按照 <a href="http://clang.LLVM.org/docs/LibASTMatchersTutorial.html">Tutorial for building tools using LibTooling</a> 中的说明去构造 LLVM ，clang 以及 clan g的附加工具。需要注意的是，编译代码是需要花费一些时间的，即时机器已经很快了，但是在编译期间，我还是可以吃顿饭的。</p>

<p>接下来，进入到 LLVM 目录，然后执行命令<code>cd ~/llvm/tools/clang/tools/</code>。在这个目录中，可以创建自己独立的 clang 工具。例如，我们创建一个小工具，用来检查某个库是否正确使用。首先将 <a href="https://github.com/objcio/issue6-compiler-tool">样例工程</a> 克隆到本地，然后输入 <code>make</code>。这样就会生成一个名为 <code>example</code> 的二进制文件。</p>

<p>我们的使用场景是：假如有一个 <code>Observer</code> 类, 代码如下所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">Observer</span>
</span><span class="line"><span class="k">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">observerWithTarget:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">target</span> <span class="nf">action:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">selector</span><span class="p">;</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>接下来，我们想要检查一下每当这个类被调用的时候，在 <code>target</code> 对象中是否都有对应的 <code>action</code> 方法存在。可以写个 C++ 函数来做这件事（注意，这是我第一次写 C++ 程序，可能不那么严谨）：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">virtual</span> <span class="kt">bool</span> <span class="n">VisitObjCMessageExpr</span><span class="p">(</span><span class="n">ObjCMessageExpr</span> <span class="o">*</span><span class="n">E</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">E</span><span class="o">-&gt;</span><span class="n">getReceiverKind</span><span class="p">()</span> <span class="o">==</span> <span class="n">ObjCMessageExpr</span><span class="o">::</span><span class="n">Class</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">QualType</span> <span class="n">ReceiverType</span> <span class="o">=</span> <span class="n">E</span><span class="o">-&gt;</span><span class="n">getClassReceiver</span><span class="p">();</span>
</span><span class="line">    <span class="n">Selector</span> <span class="n">Sel</span> <span class="o">=</span> <span class="n">E</span><span class="o">-&gt;</span><span class="n">getSelector</span><span class="p">();</span>
</span><span class="line">    <span class="n">string</span> <span class="n">TypeName</span> <span class="o">=</span> <span class="n">ReceiverType</span><span class="p">.</span><span class="n">getAsString</span><span class="p">();</span>
</span><span class="line">    <span class="n">string</span> <span class="n">SelName</span> <span class="o">=</span> <span class="n">Sel</span><span class="p">.</span><span class="n">getAsString</span><span class="p">();</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">TypeName</span> <span class="o">==</span> <span class="s">&quot;Observer&quot;</span> <span class="o">&amp;&amp;</span> <span class="n">SelName</span> <span class="o">==</span> <span class="s">&quot;observerWithTarget:action:&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">Expr</span> <span class="o">*</span><span class="n">Receiver</span> <span class="o">=</span> <span class="n">E</span><span class="o">-&gt;</span><span class="n">getArg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">IgnoreParenCasts</span><span class="p">();</span>
</span><span class="line">      <span class="n">ObjCSelectorExpr</span><span class="o">*</span> <span class="n">SelExpr</span> <span class="o">=</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">ObjCSelectorExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">E</span><span class="o">-&gt;</span><span class="n">getArg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">IgnoreParenCasts</span><span class="p">());</span>
</span><span class="line">      <span class="n">Selector</span> <span class="n">Sel</span> <span class="o">=</span> <span class="n">SelExpr</span><span class="o">-&gt;</span><span class="n">getSelector</span><span class="p">();</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">ObjCObjectPointerType</span> <span class="o">*</span><span class="n">OT</span> <span class="o">=</span> <span class="n">Receiver</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getAs</span><span class="o">&lt;</span><span class="n">ObjCObjectPointerType</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
</span><span class="line">        <span class="n">ObjCInterfaceDecl</span> <span class="o">*</span><span class="n">decl</span> <span class="o">=</span> <span class="n">OT</span><span class="o">-&gt;</span><span class="n">getInterfaceDecl</span><span class="p">();</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">decl</span><span class="o">-&gt;</span><span class="n">lookupInstanceMethod</span><span class="p">(</span><span class="n">Sel</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">          <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Warning: class &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">TypeName</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; does not implement selector &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Sel</span><span class="p">.</span><span class="n">getAsString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class="line">          <span class="n">SourceLocation</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">E</span><span class="o">-&gt;</span><span class="n">getExprLoc</span><span class="p">();</span>
</span><span class="line">          <span class="n">PresumedLoc</span> <span class="n">PLoc</span> <span class="o">=</span> <span class="n">astContext</span><span class="o">-&gt;</span><span class="n">getSourceManager</span><span class="p">().</span><span class="n">getPresumedLoc</span><span class="p">(</span><span class="n">Loc</span><span class="p">);</span>
</span><span class="line">          <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;in &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">PLoc</span><span class="p">.</span><span class="n">getFilename</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &lt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">PLoc</span><span class="p">.</span><span class="n">getLine</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">PLoc</span><span class="p">.</span><span class="n">getColumn</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面的这个方法首先查找消息表达式， 以 <code>Observer</code> 作为接收者， <code>observerWithTarget:action:</code> 作为 selector，然后检查 target 中是否存在相应的方法。虽然这个例子有点儿刻意，但如果你想要利用 AST 对自己的代码库做某些检查，按照上面的例子来就可以了。</p>

<h3 id="clang">clang的其他特性</h3>

<p>clang还有许多其他的用途。比如，可以写编译器插件（例如，类似上面的检查器例子）并且动态的加载到编译器中。虽然我没有亲自实验过，但是我觉得在 Xcode 中应该是可行的。再比如，也可以通过编写 clang 插件来自定义代码样式（具体可以参见 <a href="http://objccn.io/issue-6-1/">编译过程</a>）。</p>

<p>另外，如果想对现有的代码做大规模的重构， 而 Xcode 或 AppCode 本身集成的重构工具无法达你的要求，你完全可以用 clang 自己写个重构工具。听起来有点儿可怕，读读下面的文档和教程，你会发现其实没那么难。</p>

<p>最后，如果是真的有这种需求，你完全可以引导 Xcdoe 使用你自己编译的 clang 。再一次，如果你去尝试，其实这些事儿真的没想象中那么复杂，反而会发现许多个中乐趣。</p>

<h5>延伸阅读</h5>

<ul>
<li><a href="https://github.com/loarabia/Clang-tutorial">Clang Tutorial</a></li>
<li><a href="http://cocoafactory.com/blog/2012/11/23/x86-64-assembly-language-tutorial-part-1/">X86_64 Assembly Language Tutorial</a></li>
<li><a href="http://clang-analyzer.llvm.org/xcode.html">Custom clang Build with Xcode (I)</a> 和 <a href="http://stackoverflow.com/questions/3297986/using-an-external-xcode-clang-static-analyzer-binary-with-additional-checks">(II)</a></li>
<li><a href="http://kevinaboos.wordpress.com/2013/07/23/clang-tutorial-part-i-introduction/">Clang Tutorial (I)</a>, <a href="http://kevinaboos.wordpress.com/2013/07/23/clang-tutorial-part-ii-libtooling-example/">(II)</a> 和 <a href="http://kevinaboos.wordpress.com/2013/07/29/clang-tutorial-part-iii-plugin-example/">(III)</a></li>
<li><a href="http://getoffmylawnentertainment.com/blog/2011/10/01/clang-plugin-development-tutorial/">Clang Plugin Tutorial</a></li>
<li><a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">LLVM blog: What every C programmer should know (I)</a> , <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html">(II)</a> 和 <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html">(III)</a></li>
</ul>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-10T11:09:26+08:00" data-updated="true" itemprop="datePublished">Apr 10<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/10/xcodebian-yi-ni-suo-bu-zhi-dao-de-xi-jie/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/10/xcodebian-yi-ni-suo-bu-zhi-dao-de-xi-jie/" itemprop="url">Xcode编译你所不知道的细节</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>近些日子我们被宠坏了 &#8211; 我们只需要单击 Xcode 中的一个按钮（这个按钮看起来有点像是在播放一些音乐的动作），过几秒钟之后，我们的程序就会运行起来了，直到遇到一些错误，这非常的神奇。</p>

<p>在本文中，我们将从更高级别的角度来解读 Build 过程，并探索一下在 Xcode 界面中暴露出的 project setting 信息与 Build 过程有什么关系。为了更加深入的探索 Build 过程中，每一步实际执行的工作，我都会在本文中引入一些别的文章。</p>

<h2 id="build">解密 Build 日志</h2>

<p>为了了解 Xcode build 过程的内部工作原理，我们首先把突破口瞄准完整的 log 文件上。打开 Log Navigator ，从列表中选择一个 Build ，Xcode 会将 log 文件很完美的展现出来。</p>

<p><img src="http://img.objccn.io/issue-6/build-log.png" alt="Xcode build log navigator" /></p>

<p>默认情况下，上面的 Xcode 界面中隐藏了大量的信息，我们通过选择任务，然后点击右边的展开按钮，就能看到每个任务的详细信息。另外一种可选的方案就是选中列表中的一个或者多个任务，然后选择组合键 Cmd-C，这将会把所有的纯文本信息拷贝至粘贴板。最后，我们还可以选择 Editor 菜单中的 &#8220;Copy transcript for shown results&#8221;，以此将所有的 log 信息拷贝到粘贴板中。</p>

<p>本文给出的示例中，log 信息将近有 10,000 行（其实大多数的 log 信息是编译 OpenSSL 时生成的，并不是我们自己所写的代码生成的）。下面我们就开始吧！</p>

<p>注意观察输出的 log 信息，首先会发现 log 信息被分为不同的几大块，它们与我们工程中的targets相互对应着：</p>

<pre><code>Build target Pods-SSZipArchive
...
Build target Makefile-openssl
...
Build target Pods-AFNetworking
...
Build target crypto
...
Build target Pods
...
Build target ssl
...
Build target objcio
</code></pre>

<p>本文涉及到的工程有几个依赖项：其中 AFNetworking 和 SSZipArchive 包含在 Pods 中，而 OpenSSL 则以子工程的形式包含在工程中。</p>

<p>针对工程中的每个 target，Xcode 都会执行一系列的操作，将相关的源码，根据所选定的平台，转换为机器可读的二进制文件。下面我们详细的了解一下第一个 target：SSZipArchive。</p>

<p>在针对这个 target 输出的 log 信息中，我们可以看到每个任务被执行的详细情况。例如第一个任务是处理一个预编译头文件（为了增强 log 信息的可读性，我省略了许多细节）：</p>
<pre><code>(1) ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7 objective-c com.apple.compilers.llvm.clang.1_0.compiler
(2) cd /.../Dev/objcio/Pods
	setenv LANG en_US.US-ASCII
	setenv PATH "..."
(3) /.../Xcode.app/.../clang 
(4) -x objective-c-header 
(5) -arch armv7 
... configuration and warning flags ...
(6) -DDEBUG=1 -DCOCOAPODS=1 
... include paths and more ...
(7) -c 
(8) /.../Pods-SSZipArchive-prefix.pch 
(9) -o /.../Pods-SSZipArchive-prefix.pch.pch
</code></pre>

<p>在 build 处理过程中，每个任务都会出现类似上面的这些 log 信息，我们就通过上面的 log 信息进一步了解详情。</p>

<ol>
<li>类似上面的每个 log 信息块都会利用一行 log 信息来描述相关的任务作为起点。  </li>
<li>接着输出带缩进的3行 log 信息，列出了该任务执行的语句。此处，工作目录发生了改变，并对PANG和PATH环境变量进行设置。  </li>
<li>这里是发生奇迹的地方。为了处理一个<code>.pch</code>文件，调用了 clang，并附带了许多可选项。下面跟着输出的 log 信息显示了显示了完整的调用过程，以及所有的参数。我们看看其中的几个参数&#8230;  </li>
<li><code>-x</code> 标示符用来指定所使用的语言，此处是 <code>objective-c-header</code>。  </li>
<li>目标架构指定为 <code>armv7</code>。  </li>
<li>暗示 <code>#defines</code> 的内容已经被添加了。  </li>
<li><code>-c</code> 标示符用来告诉 clang 具体该如何做。<code>-c</code> 表示：运行预处理器、词法分析器、类型检查、LLVM 的生成和优化，以及 target 指定汇编代码的生成阶段，最后，运行汇编器以产出一个<code>.o</code>的目标文件。  </li>
<li>输入文件。  </li>
<li>输出文件。</li>
</ol>

<p>虽然有大量的 log 信息，不过我不会对每个任务做详细的介绍。我们的重点是让你全面的了解在整个 build 过程中，哪些工具会被调用，以及背后会使用到了哪些参数。</p>

<p>针对这个 target ，虽然只有一个 <code>.pch</code> 文件，但实际上这里对 <code>objective-c-header</code> 文件的处理有两个任务。通过观察具体输出的 log 信息，我们可以知道详情：</p>

<pre><code>ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7 objective-c ...
ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7s objective-c ...
</code></pre>

<p>从上面的 log 信息中，可以明显的看出 target 针对两种架构做了 build &#8211; armv7 和 armv7s &#8211; 因此 clang 对文件做了两次处理，每次针对一种架构。</p>

<p>在处理预编译头文件之后，可以看到针对 SSZipArchive target 有另外的几个任务类型。</p>

<pre><code>CompileC ...
Libtool ...
CreateUniversalBinary ...
</code></pre>

<p>顾名思义：<code>CompileC</code> 用来编译 <code>.m</code> 和 <code>.c</code> 文件，<code>Libtool</code> 用来从目标文件中构建 library，而 <code>CreateUniversalBinary</code> 则将上一阶段产生的两个 <code>.a</code> 文件（每个文件对应一种架构）合并为一个通用的二进制文件，这样就能同时在 armv7 和 armv7s 上面运行。</p>

<p>接着，在工程中其它一些依赖项也会发生于此类似的步骤。AFNetworking 被编译之后，会与 SSZipArchive 进行链接，以当做 pod library。OpenSSL 编译之后，会接着处理 crypto 和 ssl target。</p>

<p>当所有的依赖项都 build 完成之后，就轮到我们程序的 target 了。Build 该 target 时，输出的 log 信息会包含一些非常有价值，并且之前没有出现过的内容：</p>

<pre><code>PhaseScriptExecution ...
DataModelVersionCompile ...
Ld ...
GenerateDSYMFile ...
CopyStringsFile ...
CpResource ...
CopyPNGFile ...
CompileAssetCatalog ...
ProcessInfoPlistFile ...
ProcessProductPackaging /.../some-hash.mobileprovision ...
ProcessProductPackaging objcio/objcio.entitlements ...
CodeSign ...
</code></pre>

<p>在上面的任务列表中，根据名称不能区分的唯一任务可能就是 <code>Ld</code>，<code>Ld</code> 是一个 linker 工具的名称，与 <code>libtool</code> 非常相似。实际上，<code>libtool</code>也是简单的调用 <code>ld</code> 和 <code>lipo</code>。&#8217;ld&#8217;被用来构建可执行文件，而<code>libtool</code>则用来构建 library 文件。阅读<a href="http://www.objccn.io/issue-6-3">Daniel</a> 和 <a href="http://www.objccn.io/issue-6-2">Chris</a>两篇文章，可以了解到更多关于编译和链接的工作原理。</p>

<p>上面每一个步骤，实际上都会调用相关的命令行工具来做实际的工作，这跟之前我们看到的的 <code>ProcessPCH</code> 类似。至此，我将不会继续介绍这些 log 信息了，我将带领大家从另外一个不同的角度来继续探索这些任务：Xcode 是如何知道哪些任务需要被执行？</p>

<h2 id="build">Build过程的控制</h2>

<p>当你选择 Xcode 5 中的一个工程时，会在 project editor 顶部显示出 6 个 tabs：General, Capabilities, Info, Build Settings, Build Phases 以及 Build Rules。</p>

<p><img src="http://img.objccn.io/issue-6/project-editor-tabs.png" alt="Xcode project editor tabs" /></p>

<p>对于我们理解 build 过程来说，其中最后 3 项与 build 过程紧密相连。</p>

<h3 id="buildphases">Build Phases</h3>

<p>Build Phases 代表着将代码转变为可执行文件的最高级别规则。里面描述了 build 过程中必须执行的不同类型规则。</p>

<p><img src="http://img.objccn.io/issue-6/build-phases.png" alt="Xcode build phases" /></p>

<p>首先是 target 依赖项的构建。这里会告诉 build 系统，build 当前的 target 之前，必须先对这里的依赖性进行 build。实际上这并不属于真正的 build phase，在这里，Xcode 只不过将其与 build phase 显示到一块罢了。</p>

<p>接着在 build phase中是一个 CocoaPods 相关的脚本 <em>script execution</em> &#8211; 更多 CocoaPods 相关信息和 它的 build 过程可以查看<a href="http://www.objc.io/issue-6-4">Michele的文章</a> &#8211; 接着在 <code>Compile Sources</code> section 中规定了所有必须参与编译的文件。需要留意的是，这里并没有指明这些文件是<em>如何</em>被编译处理的。关于处理这些文件的更多内容，我们将在研究 build rules 和 build settings 时学习到。此处列出的所有文件将根据相关的 rules 和 settings 被处理。</p>

<p>当编译结束之后，接下来就是将编译所生成的目标文件链接到一块。注意观察，Xcode 中的 build phase 之后是：&#8221;Link Binary with Libraries.&#8221; 这里面列出了所有的静态库和动态库，这些库会参与上面编译阶段生成的目标文件进行链接。静态库和动态库的处理过程有非常大的区别，相关内容请参考 Daniel的文章 <a href="http://www.objccn.io/issue-6-3">Mach-O 可执行文件</a>。</p>

<p>当链接完成之后，build phase 中最后需要处理的就是将静态资源（例如图片和字体）拷贝到 app bundle 中。需要注意的是，如果图片资源是PNG格式，那么不仅仅对其进行拷贝，还会做一些优化（如果 build settings 中的 PNG 优化是打开的话）。</p>

<p>虽然静态资源的拷贝是 build phase 中的最后一步，但 build 还没有完成。例如，还没有进行 code signing （这并不是 build phase 考虑的范畴），code signing 属于 build 步骤中的最后一步 &#8220;Packaging&#8221;。</p>

<h3 id="buildphases">定制Build Phases</h3>

<p>至此，如果不考虑默认设置的话，你已经可以完全掌握了上面介绍的 build phases。例如，你可以在 build phases 中添加运行自定义脚本，就像<a href="http://www.objccn.io/issue-6-4/">CocoaPods</a>使用的一样，来做额外的工作。当然也可以添加一些资源的拷贝任务，当你需要将某些确定的资源拷贝到指定的 target 目录中，这非常有用。</p>

<p>另外定制 build phases 有一个非常好用的功能：添加带有水印（包括版本号和 commit hash）的 app icon &#8211; 只需要在 build phase 中添加一个 &#8220;Run Script&#8221;，并用下面的命令来获取版本号和 commit hash：</p>

<pre><code>version=`/usr/libexec/PlistBuddy -c "Print CFBundleVersion" "${INFOPLIST_FILE}"`
commit=`git rev-parse --short HEAD`
</code></pre>

<p>然后使用 ImageMagick 来修改 app icon。这里有一个<a href="https://github.com/krzysztofzablocki/IconOverlaying">完整的示例</a>，可以参考。</p>

<p>如果你希望自己或者别人编写的代码看起来比较简洁点，可以添加一个 &#8220;Run Script&#8221;：如果一个源文件超过指定行数，就发出警告。如下代码所示，设置的行数为 200。</p>

<pre><code>find "${SRCROOT}" \( -name "*.h" -or -name "*.m" \) -print0 | xargs -0 wc -l | awk '$1 &gt; 200 &amp;&amp; $2 != "total" { print $2 ":1: warning: file more than 200 lines" }'
</code></pre>

<h3 id="buildrules">Build Rules</h3>

<p>Build rules 指定了不同的文件类型该如何编译。一般来说，开发者并不需要修改这里面的内容。如果你需要对特定类型的文件添加处理方法，那么可以在此处添加一条新的规则。</p>

<p>一条 build rule 指定了其应用于哪种类型文件，该类型文件是如何被处理的，以及输出的内容该如何处置。比方说，我们创建了一条预处理规则，该规则将 Objective-C 的实现文件当做输入，解析文件中的注释内容，最后再输出一个 <code>.m</code> 文件，文件中包含了生成的代码。由于我们不能将 <code>.m</code> 文件既当做输入又当做输出，所以我使用了 <code>.mal</code> 后缀，定制的 build rule 如下所示：</p>

<p><img src="http://img.objccn.io/issue-6/custom-build-rule.png" alt="Custom build rule" /></p>

<p>上面的规则应用于所有后缀为 <code>*.mal</code> 的文件，这些文件会被自定义的脚本处理（调用我们的预处理器，并附带上输入和输出参数）。最后，该规则告诉 build system 在哪里可以找到此规则的输出文件。</p>

<p>在脚本中，我使用了少量的变量来指定正确的路径和文件名。在苹果的 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html#//apple_ref/doc/uid/TP40003931-CH3-SW105">Build Setting Reference</a> 文档中可以找到所有可用的变量。build 过程中，要想观察所有已存在的环境变量，你可以在 build phase 中添加一个 &#8220;Run Script&#8221;，并勾选上 &#8220;Show environment variables in build log&#8221;。</p>

<h3 id="buildsettings">Build Settings</h3>

<p>至此，我们已经了解到在 build phases 中是如何定义 build 处理的过程，以及 build rules 是如何指定哪些文件类型在编译阶段需要被预处理。在 build settings 中，我们可以配置每个任务（之前在 build log 输出中看到的任务）的详细内容。</p>

<p>你会发现 build 过程的每一个阶段，都有许多选项：从编译、链接一直到 code signing 和 packaging。注意，settings 是如何被分割为不同的部分 &#8211; 其实这大部分会与 build phases 有关联，有时候也会指定编译的文件类型。</p>

<p>这些选项基本都有很好的文档介绍，你可以在右边面板中的 quick help inspector 或者 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html#//apple_ref/doc/uid/TP40003931-CH3-SW105">Build Setting Reference</a> 中查看到。</p>

<h2>工程文件</h2>

<p>上面我们介绍的所有内容都被保存在工程文件（<code>.pbxproj</code>）中，除了其它一些工程相关信息（例如 file groups），我们很少会深入该文件内部，除非在代码 merge 时发生冲突，或许会进去看看。</p>

<p>建议你用文本编辑器打开一个工程文件，从头到尾看一遍里面的内容。它的可读性非常高，里面的许多内容一看就知道什么意思了，不会存在太大的问题。通过阅读并完全理解工程文件，这对于合并工程文件的冲突非常有帮助。</p>

<p>首先，我们来看看文件中叫做 <code>rootObject</code> 的条目。在我的工程中，如下所示：</p>

<pre><code>rootObject = 1793817C17A9421F0078255E /* Project object */;
</code></pre>

<p>根据这个 ID（<code>1793817C17A9421F0078255E</code>），我们可以找到 main 工程的定义：</p>

<pre><code>/* Begin PBXProject section */
    1793817C17A9421F0078255E /* Project object */ = {
        isa = PBXProject;
...
</code></pre>

<p>在这部分中有一些 keys，顺从这些 key，我们可以了解到更多关于这个工程文件的组成。例如，<code>mainGroup</code> 指向了 root file group。如果你按照这个思路，你可以快速了解到在 <code>.pbxproj</code> 文件中工程的结构。下面我要来介绍一些与 build 过程相关的内容。其中 <code>target</code> key 指向了 build target 的定义：</p>

<pre><code>targets = (
    1793818317A9421F0078255E /* objcio */,
    170E83CE17ABF256006E716E /* objcio Tests */,
);
</code></pre>

<p>根据第一个内容，我们找到一个 target 的定义：</p>

<pre><code>1793818317A9421F0078255E /* objcio */ = {
    isa = PBXNativeTarget;
    buildConfigurationList = 179381B617A9421F0078255E /* Build configuration list for PBXNativeTarget "objcio" */;
    buildPhases = (
        F3EB8576A1C24900A8F9CBB6 /* Check Pods Manifest.lock */,
        1793818017A9421F0078255E /* Sources */,
        1793818117A9421F0078255E /* Frameworks */,
        1793818217A9421F0078255E /* Resources */,
        FF25BB7F4B7D4F87AC7A4265 /* Copy Pods Resources */,
    );
    buildRules = (
    );
    dependencies = (
        1769BED917CA8239008B6F5D /* PBXTargetDependency */,
        1769BED717CA8236008B6F5D /* PBXTargetDependency */,
    );
    name = objcio;
    productName = objcio;
    productReference = 1793818417A9421F0078255E /* objcio.app */;
    productType = "com.apple.product-type.application";
};
</code></pre>

<p>其中 <code>buildConfigurationList</code> 指向了可用的配置项，一般是 <code>Debug</code> 和 <code>Release</code>。根据 debug 对应的 id，我们可以找到 build setting tab 中所有选项存储的位置：</p>

<pre><code>179381B717A9421F0078255E /* Debug */ = {
    isa = XCBuildConfiguration;
    baseConfigurationReference = 05D234D6F5E146E9937E8997 /* Pods.xcconfig */;
    buildSettings = {
        ALWAYS_SEARCH_USER_PATHS = YES;
        ASSETCATALOG_COMPILER_LAUNCHIMAGE_NAME = LaunchImage;
        CODE_SIGN_ENTITLEMENTS = objcio/objcio.entitlements;
...
</code></pre>

<p><code>buildPhases</code> 属性则简单的列出了在 Xcode 中定义的所有 build phases。这非常容易识别出来（Xcode 中的参数使用了它们原本真正的名字，并以 C 风格进行注释）。<code>buildRules</code> 属性是空的：因为在该工程中，我没有自定义 build rules。<code>dependencies</code> 列出了在 Xcode build phase tab 中列出的 target 依赖项。</p>

<p>没那么吓人，不是吗？工程中剩下的内容就留给你去当做练习来了解吧。只需要顺着对象的 ID 走，即可，一旦你找到了敲门，理解了Xcode中工程设置的不同 section ，那么对于 merge 工程文件的冲突时，将变得非常简单。甚至可以在 GitHub 中就能阅读工程文件，而不用将工程文件 clone 到本地，并用 Xcode 打开。</p>

<h2>小结</h2>

<p>当今的软件是都用其它复杂的一些软件和资源开发出来的，例如 library 和 build 工具等。反过来，这些工具是构建于底层架构的，这犹如剥洋葱一样，一层包着一层。虽然这样一层一层的，给人感觉太复杂，但是你完全可以去深入了解它们，这非常有助于你对软件的深入理解，实际上当你了解之后，这并没有想象中的那么神奇，只不过它是一层一层堆砌起来的，每一层都是基于下一层构建起来的。</p>

<p>本文所探索 build system 的内部机制犹如剥掉洋葱的一层。其实当我们点击 Xcode 中的运行按钮时，我们并没必要理解这个动作涉及到的所有内容。我们只是深入理解某一层，然后找到一个有组织的、并且可控的调用其它工具的顺序，如果我们愿意的话，可以做进一步的探索。我建议你阅读本期中的其它文章，以进一步了解这个洋葱的下一层内容！</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-10T09:42:56+08:00" data-updated="true" itemprop="datePublished">Apr 10<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/shi-ge/'>诗歌</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/10/dang-wo-zhen-zheng-kai-shi-ai-zi-ji/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/10/dang-wo-zhen-zheng-kai-shi-ai-zi-ji/" itemprop="url">当我真正开始爱自己</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><img src="http://ww1.sinaimg.cn/large/626e5d69gw1efahu2mtk8j20e60aadh6.jpg" alt="" /></p>
<p>当我真正开始爱自己，</p>

<p>我才认识到，所有的痛苦和情感的折磨，</p>

<p>都只是提醒我：活着，不要违背自己的本心。</p>

<p>今天我明白了，这叫做</p>

<p>『真实』。</p>

<p>当我真正开始爱自己，</p>

<p>我才懂得，把自己的愿望强加于人，</p>

<p>是多么的无礼，就算我知道，时机并不成熟，</p>

<p>那人也还没有做好准备，</p>

<p>就算那个人就是我自己，</p>

<p>今天我明白了，这叫做</p>

<p>『尊重』。</p>

<p>当我开始爱自己，</p>

<p>我不再渴求不同的人生，</p>

<p>我知道任何发生在我身边的事情，</p>

<p>都是对我成长的邀请。</p>

<p>如今，我称之为</p>

<p>『成熟』。</p>

<p>当我开始真正爱自己，</p>

<p>我才明白，我其实一直都在正确的时间，</p>

<p>正确的地方，发生的一切都恰如其分。</p>

<p>由此我得以平静。</p>

<p>今天我明白了，这叫做</p>

<p>『自信』。</p>

<p>当我开始真正爱自己，</p>

<p>我不再牺牲自己的自由时间，</p>

<p>不再去勾画什么宏伟的明天。</p>

<p>今天我只做有趣和快乐的事，</p>

<p>做自己热爱，让心欢喜的事，</p>

<p>用我的方式，以我的韵律。</p>

<p>今天我明白了，这叫做</p>

<p>『单纯』。</p>

<p>当我开始真正爱自己，</p>

<p>我开始远离一切不健康的东西。</p>

<p>不论是饮食和人物，还是事情和环境，</p>

<p>我远离一切让我远离本真的东西。</p>

<p>从前我把这叫做“追求健康的自私自利”，</p>

<p>但今天我明白了，这是</p>

<p>『自爱』。</p>

<p>当我开始真正爱自己，</p>

<p>我不再总想着要永远正确，不犯错误。</p>

<p>我今天明白了，这叫做</p>

<p>『谦逊』。</p>

<p>我当开始真正爱自己，</p>

<p>我不再继续沉溺于过去，</p>

<p>也不再为明天而忧虑，</p>

<p>现在我只活在一切正在发生的当下，</p>

<p>今天，我活在此时此地，</p>

<p>如此日复一日。这就叫</p>

<p>『完美』。</p>

<p>当我开始真正爱自己，</p>

<p>我明白，我的思虑让我变得贫乏和病态，</p>

<p>但当我唤起了心灵的力量，</p>

<p>理智就变成了一个重要的伙伴，</p>

<p>这种组合我称之为，</p>

<p>『心的智慧』。</p>

<p>我们无须再害怕自己和他人的分歧，矛盾和问题，因为即使星星有时也会碰在一起，形成新的世界，今天我明白，这就是</p>

<p>『生命』！</p>
<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-10T09:09:08+08:00" data-updated="true" itemprop="datePublished">Apr 10<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/10/uikit-dynamicsji-yu-wu-li-yin-qing-xin-te-xing/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/10/uikit-dynamicsji-yu-wu-li-yin-qing-xin-te-xing/" itemprop="url">UIKit-Dynamics基于物理引擎新特性</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>UIKit Dynamics 是 iOS 7 中基于物理动画引擎的一个新功能&#8211;它被特别设计使其能很好地与 collection views 配合工作，而后者是在 iOS 6 中才被引入的新特性。接下来，我们要好好看看如何将这两个特性结合在一起。 </p>

<p>这篇文章将讨论两个结合使用 UIkit Dynamics 和 collection view 的例子。第一个例子展示了如何去实现像 iOS 7 里信息 app 中的消息泡泡的弹簧动效，然后再进一步结合平铺机制来实现布局的可伸缩性。第二个例子展现了如何用 UIKit Dynamics 来模拟<a href="http://zh.wikipedia.org/wiki/牛顿摆">牛顿摆</a>，这个例子中物体可以一个个地加入到 collection view 中，并和其他物体发生相互作用。</p>

<p>在我们开始之前，我假定你们对 <code>UICollectionView</code> 是如何工作是有基本的了解——查看<a href="http://www.objccn.io/issue-3-3/">这篇 objc.io 文章</a>会有你想要的所有细节。我也假定你已经理解了 <code>UIKit Dynamics</code> 的工作原理&#8211;阅读这篇<a href="http://www.teehanlax.com/blog/introduction-to-uikit-dynamics/">博客</a>，可以了解更多 UIKit Dynamics 的知识。</p>

<blockquote>
  <p><span class="secondary radius label">编者注</span> 如果您阅读本篇文章感觉有点吃力的话，可以先来看看 <a href="http://im.onevcat.com">@onevcat</a> 的<a href="http://onevcat.com/2012/06/introducing-collection-views/">《UICollectionView 入门》</a> 和<a href="http://onevcat.com/2013/06/uikit-dynamics-started/">《UIKit Dynamics 入门》</a>这两篇入门文章，帮助您快速补充相关知识。</p>
</blockquote>

<p>文章中的两个例子项目都已经在 GitHub 中:</p>

<ul>
<li><a href="https://github.com/objcio/issue-5-springy-collection-view">ASHSpringyCollectionView</a>（基于 <a href="https://github.com/TeehanLax/UICollectionView-Spring-Demo">UICollectionView Spring Demo</a>）</li>
<li><a href="https://github.com/objcio/issue-5-newtonian-collection-view">Newtownian UICollectionView</a></li>
</ul>

<h2 id="uidynamicanimator">关于 UIDynamicAnimator</h2>

<p>支持 <code>UICollectionView</code> 实现 UIKit Dynamics 的最关键部分就是 <code>UIDynamicAnimator</code>。要实现这样的 UIKit Dynamics 的效果，我们需要自己自定义一个继承于 <code>UICollectionViewFlowLayout</code> 的子类，并且在这个子类对象里面持有一个 UIDynamicAnimator 的对象。</p>

<p>当我们创建自定义的 dynamic animator 时，我们不会使用常用的初始化方法 <code>-initWithReferenceView:</code> ，因为我们不需要把这个 dynamic animator 关联一个 view ，而是给它关联一个 collection view layout。所以我们使用 <code>-initWithCollectionViewLayout:</code> 这个初始化方法，并把 collection view layout 作为参数传入。这很关键，当的 animator 的 behavior item 的属性应该被更新的时候，它必须能够确保 collection view 的 layout 失效。换句话说，dynamic animator 将会经常使旧的 layout 失效。</p>

<p>我们很快就能看到这些事情是怎么连接起来的，但是在概念上理解 collection view 如何与 dynamic animator 相互作用是很重要的。</p>

<p>Collection view layout 将会为 collection view 中的每个 <code>UICollectionViewLayoutAttributes</code> 添加 behavior（稍后我们会讨论平铺它们）。在将这些 behaviors 添加到 dynamic animator 之后，UIKit 将会向 collection view layout 询问 atrribute 的状态。我们此时可以直接将由 dynamic animator 所提供的 items 返回，而不需要自己做任何计算。Animator 将在模拟时禁用 layout。这会导致 UIKit 再次查询 layout，这个过程会一直持续到模拟满足设定条件而结束。</p>

<p>所以重申一下，layout 创建了 dynamic animator，并且为其中每个 item 的 layout attribute 添加对应的 behaviors。当 collection view 需要 layout 信息时，由 dynamic animator 来提供需要的信息。</p>

<h2 id="uicollectionviewflowlayout">继承 UICollectionViewFlowLayout</h2>

<p>我们将要创建一个简单的例子来展示如何使用一个带 UIkit Dynamic 的 collection view layout。当然，我们需要做的第一件事就是，创建一个数据源去驱动我们的 collection view。我知道以你的能力完全可以独立实现一个数据源，但是为了完整性，我还是提供了一个给你:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">ASHCollectionViewController</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="n">NSString</span> <span class="o">*</span> <span class="n">CellIdentifier</span> <span class="o">=</span> <span class="s">@&quot;CellIdentifier&quot;</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span> <span class="nl">registerClass:</span><span class="p">[</span><span class="n">UICollectionViewCell</span> <span class="n">class</span><span class="p">]</span>
</span><span class="line">            <span class="nl">forCellWithReuseIdentifier:</span><span class="n">CellIdentifier</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="n">UIStatusBarStyle</span><span class="p">)</span><span class="nf">preferredStatusBarStyle</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">UIStatusBarStyleLightContent</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="nl">viewDidAppear:</span><span class="n">animated</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionViewLayout</span> <span class="n">invalidateLayout</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="cp">#pragma mark - UICollectionView Methods</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="n">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span>
</span><span class="line">    <span class="nf">numberOfItemsInSection:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">section</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">120</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="n">UICollectionViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nf">collectionView:</span><span class="p">(</span><span class="n">UICollectionView</span> <span class="o">*</span><span class="p">)</span><span class="nv">collectionView</span>
</span><span class="line">                 <span class="nf">cellForItemAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">UICollectionViewCell</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">collectionView</span>
</span><span class="line">        <span class="nl">dequeueReusableCellWithReuseIdentifier:</span><span class="n">CellIdentifier</span>
</span><span class="line">                                  <span class="nl">forIndexPath:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">cell</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">orangeColor</span><span class="p">];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">cell</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们注意到当 view 第一次出现的时候，这个 layout 是被无效的。这是因为没有用 Storyboard 的结果（使用或不使用 Storyboard，调用 prepareLayout 方法的时机是不同的，苹果在 WWDC 的视频中并没有告诉我们这一点）。所以，当这些视图一出现我们就需要手动使这个 collection view layout 无效。当我们用平铺（后面会详细介绍）的时候，就不需要这样。</p>

<p>现在来创建自定义的 collection view layout 吧，我们需要强引用一个 dynamic animator，并且使用它来驱动我们的 collcetion view layout 的 attribute。我们在实现文件里定义了一个私有属性：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">ASHSpringyCollectionViewFlowLayout</span> <span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">UIDynamicAnimator</span> <span class="o">*</span><span class="n">dynamicAnimator</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们将在 layout 的初始化方法中初始化我们的 dynamic animator。还要设置一些属于父类 <code>UICollectionViewFlowLayout</code> 中的属性:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">]))</span> <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">minimumInteritemSpacing</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">minimumLineSpacing</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">itemSize</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">44</span><span class="p">,</span> <span class="mi">44</span><span class="p">);</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">sectionInset</span> <span class="o">=</span> <span class="n">UIEdgeInsetsMake</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIDynamicAnimator</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithCollectionViewLayout:</span><span class="n">self</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们将实现的下一个方法是 prepareLayout。我们首先需要调用父类的方法。因为我们是继承 <code>UICollectionViewFlowLayout</code> 类，所以在调用父类的 prepareLayout 方法时，可以使 collection view layout 的各个 attribute 都放置在合适的位置。我们可以依靠父类的这个方法来提供一个默认的排布，并且能够使用 <code>[super layoutAttributesForElementsInRect:visibleRect];</code> 方法得到指定 rect 内的<em>所有</em> item 的 layout attributes。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">super</span> <span class="n">prepareLayout</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">CGSize</span> <span class="n">contentSize</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">contentSize</span><span class="p">;</span>
</span><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nl">layoutAttributesForElementsInRect:</span>
</span><span class="line">    <span class="n">CGRectMake</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="n">contentSize</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">contentSize</span><span class="p">.</span><span class="n">height</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这<em>真的</em>是效率低下的代码。因为我们的 collection view 中可能会有成千上万个 cell，一次性加载所有的 cell 是一个可能会产生难以置信的内存紧张的操作。我们要在一段时间内遍历所有的元素，这也成为耗时的操作。这真的是效率的双重打击！别担心——我们是负责任的开发者，所以我们会很快解决这个问题的。我们先暂时继续使用简单、粗暴的实现方式。</p>

<p>当加载完我们所有的 collection view layout attribute 之后，我们需要检查他们是否都已经被加载到我们的 animator 里了。如果一个 behavior 已经在 animator 中存在，那么我们就不能重新添加，否则就会得到一个非常难懂的运行异常提示:</p>

<pre><code>&lt;UIDynamicAnimator: 0xa5ba280&gt; (0.004987s) in 
&lt;ASHSpringyCollectionViewFlowLayout: 0xa5b9e60&gt; \{\{0, 0}, \{0, 0\}\}: 
body &lt;PKPhysicsBody&gt; type:&lt;Rectangle&gt; representedObject:
[&lt;UICollectionViewLayoutAttributes: 0xa281880&gt; 
index path: (&lt;NSIndexPath: 0xa281850&gt; {length = 2, path = 0 - 0}); 
frame = (10 10; 300 44); ] 0xa2877c0  
PO:(159.999985,32.000000) AN:(0.000000) VE:(0.000000,0.000000) AV:(0.000000) 
dy:(1) cc:(0) ar:(1) rs:(0) fr:(0.200000) re:(0.200000) de:(1.054650) gr:(0) 
without representedObject for item &lt;UICollectionViewLayoutAttributes: 0xa3833e0&gt; 
index path: (&lt;NSIndexPath: 0xa382410&gt; {length = 2, path = 0 - 0}); 
frame = (10 10; 300 44);
</code></pre>

<p>如果看到了这个错误，那么这基本表明你添加了两个 behavior 给同一个 <code>UICollectionViewLayoutAttribute</code>，这使得系统不知道该怎么处理。</p>

<p>无论如何，一旦我们已经检查好我们是否已经将 behavior 添加到 dynamic animator 之后，我们就需要遍历每个 collection view layout attribute 来创建和添加新的 dynamic animator：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span><span class="p">.</span><span class="n">behaviors</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">items</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">UIDynamicItem</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">UIAttachmentBehavior</span> <span class="o">*</span><span class="n">behaviour</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIAttachmentBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItem:</span><span class="n">obj</span>
</span><span class="line">                                                                    <span class="nl">attachedToAnchor:</span><span class="p">[</span><span class="n">obj</span> <span class="n">center</span><span class="p">]];</span>
</span><span class="line">
</span><span class="line">        <span class="n">behaviour</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span><span class="line">        <span class="n">behaviour</span><span class="p">.</span><span class="n">damping</span> <span class="o">=</span> <span class="mf">0.8f</span><span class="p">;</span>
</span><span class="line">        <span class="n">behaviour</span><span class="p">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="nl">addBehavior:</span><span class="n">behaviour</span><span class="p">];</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这段代码非常简单。我们为每个 item 创建了一个以物体的中心为附着点的 <code>UIAttachmentBehavior</code> 对象。然后又设置了我们的 attachment behavior 的 length 为 0 以便约束这个 cell 能一直以 behavior 的附着点为中心。然后又给 <code>damping</code> 和 <code>frequency</code> 这两个参数设置一个比较合适的值。</p>

<p>这就是 <code>prepareLayout</code>。我们现在需要实现 <code>layoutAttributesForElementsInRect:</code> 和 <code>layoutAttributesForItemAtIndexPath:</code> 这两个方法，UIKit 会调用它们来询问 collection view 每一个 item 的布局信息。我们写的代码会把这些查询交给专门做这些事的 dynamic animator:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">layoutAttributesForElementsInRect:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">rect</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="nl">itemsInRect:</span><span class="n">rect</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span><span class="p">(</span><span class="n">UICollectionViewLayoutAttributes</span> <span class="o">*</span><span class="p">)</span><span class="nf">layoutAttributesForItemAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="nl">layoutAttributesForCellAtIndexPath:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h1>响应滚动事件</h1>

<p>我们目前实现的代码给我们展示的只是一个在正常滑动下只有静态感觉的 <code>UICollectionView</code>，运行起来没什么特别的。看上去很好，但不是真的<em>动态</em>，不是么？</p>

<p>为了使它表现地动态点，我们需要 layout 和 dynamic animator 能够对 collection view 中滑动位置的变化做出反应。幸好这里有个非常适合这个要求的方法 <code>shouldInvalidateLayoutForBoundsChange:</code>。这个方法会在 collection view 的 bound 发生改变的时候被调用，根据最新的 <a href="http://www.objccn.io/issue-3-2/">content offset</a> 调整我们的 dynamic animator 中的 behaviors 的参数。在重新调整这些 behavior 的 item 之后，我们在这个方法中返回 NO；因为 dynamic animator 会关心 layout 的无效问题，所以在这种情况下，它不需要去主动使其无效：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">shouldInvalidateLayoutForBoundsChange:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">newBounds</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">UIScrollView</span> <span class="o">*</span><span class="n">scrollView</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">;</span>
</span><span class="line">    <span class="n">CGFloat</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">newBounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">scrollView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">CGPoint</span> <span class="n">touchLocation</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">panGestureRecognizer</span> <span class="nl">locationInView:</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span><span class="p">.</span><span class="n">behaviors</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">UIAttachmentBehavior</span> <span class="o">*</span><span class="n">springBehaviour</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">yDistanceFromTouch</span> <span class="o">=</span> <span class="n">fabsf</span><span class="p">(</span><span class="n">touchLocation</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">springBehaviour</span><span class="p">.</span><span class="n">anchorPoint</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">xDistanceFromTouch</span> <span class="o">=</span> <span class="n">fabsf</span><span class="p">(</span><span class="n">touchLocation</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">springBehaviour</span><span class="p">.</span><span class="n">anchorPoint</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">scrollResistance</span> <span class="o">=</span> <span class="p">(</span><span class="n">yDistanceFromTouch</span> <span class="o">+</span> <span class="n">xDistanceFromTouch</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1500.0f</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="n">UICollectionViewLayoutAttributes</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">springBehaviour</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">firstObject</span><span class="p">;</span>
</span><span class="line">        <span class="n">CGPoint</span> <span class="n">center</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">delta</span><span class="o">*</span><span class="n">scrollResistance</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">else</span> <span class="p">{</span>
</span><span class="line">            <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">delta</span><span class="o">*</span><span class="n">scrollResistance</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">item</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="nl">updateItemUsingCurrentState:</span><span class="n">item</span><span class="p">];</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>让我们仔细查看这个代码的细节。首先我们得到了这个 scroll view（就是我们的 collection view ），然后计算它的 content offset 中 y 的变化（在这个例子中，我们的 collection view 是垂直滑动的）。一旦我们得到这个增量，我们需要得到用户接触的位置。这是非常重要的，因为我们希望离接触位置比较近的那些物体能移动地更迅速些，而离接触位置比较远的那些物体则应该滞后些。</p>

<p>对于 dynamic animator 中的每个 behavior，我们将接触点到该 behavior 物体的 x 和 y 的距离之和除以 1500，1500 是我根据经验设的。分母越小，这个 collection view 的的交互就越有弹簧的感觉。一旦我们拿到了这个“滑动阻力”的值，我们就可以用它的增量乘上 <code>scrollResistance</code> 这个变量来指定这个 behavior 物体的中心点的 y 值。最后，我们在滑动阻力大于增量的情况下对增量和滑动阻力的结果进行了选择（这意味着物体开始往错误的方向移动了）。在本例我们用了这么大的分母，那么这种情况是不可能的，但是在一些更具弹性的 collection view layout 中还是需要注意的。</p>

<p>就是这么一回事。以我的经验，这个方法对多达几百个物体的 collection view 来说也是是适用的。超过这个数量的话，一次性加载所有物体到内存中就会变成很大的负担，并且在滑动的时候就会开始卡顿了。</p>

<p><img src="http://img.objccn.io/issue-5/springyCollectionView.gif" alt="Springy Collection View" /></p>

<h2 id="tilingdynamicbehaviors">平铺（Tiling）你的 Dynamic Behaviors 来优化性能</h2>

<p>当你的 collection view 中只有几百个 cell 的时候，他运行的很好，但当数据源超过这个范围的时候会发生什么呢？或者在运行的时你不能预测你的数据源有多大呢？我们的简单粗暴的方法就不管用了。</p>

<p>除了在 <code>prepareLayout</code> 中加载<em>所有</em>的物体，如果我们能<em>更聪明地</em>知道哪些物体会加载那该多好啊。是的，就是仅加载显示的和即将显示的物体。这正是我们要采取的办法。</p>

<p>我们需要做的第一件事就是是跟踪 dynamic animator 中的所有 behavior 物体的 index path。我在 collection view 中添加一个属性来做这件事:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSMutableSet</span> <span class="o">*</span><span class="n">visibleIndexPathsSet</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们用 set 是因为它具有常数复杂度的查找效率，并且我们<em>经常</em>地查找 <code>visibleIndexPathsSet</code> 中是否已经包含了某个 index path。</p>

<p>在我们实现全新的 <code>prepareLayout</code> 方法之前——有一个问题就是什么是<strong>平铺 behavior</strong> —— 理解平铺的意思是非常重要的。当我们平铺behavior 的时候，我们会在这些 item 离开 collection view 的可视范围的时候删除对应的 behavior，在这些 item 进入可视范围的时候又添加对应的 behavior。这是一个大麻烦：我们需要在<em>滚动中</em>创建新的 behavior。这就意味着让人觉得创建它们就好像它们本来就已经在 dynamic animator 里了一样，并且它们是在 <code>shouldInvalidateLayoutForBoundsChange:</code> 方法被修改的。</p>

<p>因为我们是在滚动中创建这些新的 behavior，所以我们需要维持现在 collection view 的一些状态。尤其我们需要跟踪最近一次我们 <code>bound</code> 变化的增量。我们会在滚动时用这个状态去创建我们的 behavior：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">latestDelta</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>添加完这个 property 后，我们将要在 <code>shouldInvalidateLayoutForBoundsChange:</code> 方法中添加下面这行代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">self</span><span class="p">.</span><span class="n">latestDelta</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这就是我们需要修改我们的方法来响应滚动事件。我们的这两个方法是为了将 collection view 中 items 的 layout 信息传给 dynamic animator，这种方式没有变化。事实上，当你的 collection view 实现了 dynamic animator 的大部分情况下，都需要实现我们上面提到的两个方法 <code>layoutAttributesForElementsInRect:</code> 和 <code>layoutAttributesForItemAtIndexPath:</code>。</p>

<p>这里最难懂的部分就是平铺机制。我们将要完全重写我们的 prepareLayout。</p>

<p>这个方法的第一步是将那些物体的 index path 已经不在屏幕上显示的 behavior 从 dynamic animator 上删除。第二步是添加那些即将显示的物体的 behavior。</p>

<p>让我们先看一下第一步。</p>

<p>像以前一样，我们要调用 <code>super prepareLayout</code>，这样我们就能依赖父类 <code>UICollectionViewFlowLayout</code> 提供的默认排布。还像以前一样，我们通过父类获取一个矩形内的所有元素的 layout attribute。不同的是我们不是获取整个 collection view 中的元素属性，而只是获取显示范围内的。</p>

<p>所以我们需要计算这个显示矩形。但是别着急！有件事要记住。我们的用户可能会非常快地滑动 collection view，导致了 dynamic animator 不能跟上，所以我们需要稍微扩大显示范围，这样就能包含到那些将要显示的物体了。否则，在滑动很快的时候就会出现频闪现象了。让我们计算一下显示范围:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGRect</span> <span class="n">originalRect</span> <span class="o">=</span> <span class="p">(</span><span class="n">CGRect</span><span class="p">){.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">,</span> <span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">};</span>
</span><span class="line"><span class="n">CGRect</span> <span class="n">visibleRect</span> <span class="o">=</span> <span class="n">CGRectInset</span><span class="p">(</span><span class="n">originalRect</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我确信在实际显示矩形上的每个方向都扩大100个像素对我的 demo 来说是可行的。仔细查看这些值是否适合你们的 collection view，尤其是当你们的 cell 很小的情况下。</p>

<p>接下来我们就需要收集在显示范围内的 collection view layout attributes。还有它们的 index paths:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">itemsInVisibleRectArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nl">layoutAttributesForElementsInRect:</span><span class="n">visibleRect</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">NSSet</span> <span class="o">*</span><span class="n">itemsIndexPathsInVisibleRectSet</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSSet</span> <span class="nl">setWithArray:</span><span class="p">[</span><span class="n">itemsInVisibleRectArray</span> <span class="nl">valueForKey:</span><span class="s">@&quot;indexPath&quot;</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意我们是在用一个 NSSet。这是因为它具有常数复杂度的查找效率，并且我们经常的查找 <code>visibleIndexPathsSet</code> 是否已经包含了某个 index path:</p>

<p>接下来我们要做的就是遍历 dynamic animator 的 behaviors，过滤掉那些已经在 <code>itemsIndexPathsInVisibleRectSet</code> 中的 item。因为我们已经过滤掉我们的 behavior，所以我们将要遍历的这些 item 都是不在显示范围里的，我们就可以将这些 item 从 animator 中删除掉（连同 <code>visibleIndexPathsSet</code> 属性中的 index path）:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSPredicate</span> <span class="o">*</span><span class="n">predicate</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSPredicate</span> <span class="nl">predicateWithBlock:</span><span class="o">^</span><span class="kt">BOOL</span><span class="p">(</span><span class="n">UIAttachmentBehavior</span> <span class="o">*</span><span class="n">behaviour</span><span class="p">,</span> <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">bindings</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">BOOL</span> <span class="n">currentlyVisible</span> <span class="o">=</span> <span class="p">[</span><span class="n">itemsIndexPathsInVisibleRectSet</span> <span class="nl">member:</span><span class="p">[[[</span><span class="n">behaviour</span> <span class="n">items</span><span class="p">]</span> <span class="n">firstObject</span><span class="p">]</span> <span class="n">indexPath</span><span class="p">]]</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="o">!</span><span class="n">currentlyVisible</span><span class="p">;</span>
</span><span class="line"><span class="p">}]</span>
</span><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">noLongerVisibleBehaviours</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span><span class="p">.</span><span class="n">behaviors</span> <span class="nl">filteredArrayUsingPredicate:</span><span class="n">predicate</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">noLongerVisibleBehaviours</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">index</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="nl">removeBehavior:</span><span class="n">obj</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">visibleIndexPathsSet</span> <span class="nl">removeObject:</span><span class="p">[[[</span><span class="n">obj</span> <span class="n">items</span><span class="p">]</span> <span class="n">firstObject</span><span class="p">]</span> <span class="n">indexPath</span><span class="p">]];</span>
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>下一步就是要得到<em>新</em>出现 item 的 <code>UICollectionViewLayoutAttributes</code> 数组——那些 item 的 index path 在 <code>itemsIndexPathsInVisibleRectSet</code> 而不在 <code>visibleIndexPathsSet</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSPredicate</span> <span class="o">*</span><span class="n">predicate</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSPredicate</span> <span class="nl">predicateWithBlock:</span><span class="o">^</span><span class="kt">BOOL</span><span class="p">(</span><span class="n">UICollectionViewLayoutAttributes</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">bindings</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">BOOL</span> <span class="n">currentlyVisible</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">visibleIndexPathsSet</span> <span class="nl">member:</span><span class="n">item</span><span class="p">.</span><span class="n">indexPath</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="o">!</span><span class="n">currentlyVisible</span><span class="p">;</span>
</span><span class="line"><span class="p">}];</span>
</span><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">newlyVisibleItems</span> <span class="o">=</span> <span class="p">[</span><span class="n">itemsInVisibleRectArray</span> <span class="nl">filteredArrayUsingPredicate:</span><span class="n">predicate</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>一旦我们有新的 layout attribute 出现，我就可以遍历他们来创建新的 behavior，并且将他们的 index path 添加到 <code>visibleIndexPathsSet</code> 中。首先，无论如何，我都需要获取到用户手指触碰的位置。如果它是 <code>CGPointZero</code> 的话，那就表示这个用户没有在滑动 collection view，这时我就<em>假定</em>我们不需要在滚动时创建新的 behavior 了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CGPoint</span> <span class="n">touchLocation</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">panGestureRecognizer</span> <span class="nl">locationInView:</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这是一个潜藏危险的假定。如果用户很快地滑动了 collection view 之后释放了他的手指呢？这个 collection view 就会一直滚动，但是我们的方法就不会在滚动时创建新的 behavior 了。但幸运的是，那也就意味这时 scroll view 滚动太快很难被注意到！好哇！但是，对于那些拥有大型 cell 的 collection view 来说，这仍然是个问题。那么在这种情况下，就需要增加你的可视范围的 bounds 来加载更多物体以解决这个问题。</p>

<p>现在我们需要枚举我们刚显示的 item，为他们创建 behavior，再将他们的 index path 添加到 <code>visibleIndexPathsSet</code>。我们还需要在滚动时做些<a href="http://www.youtube.com/watch?v=gENVB6tjq_M">数学运算</a>来创建 behavior：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">newlyVisibleItems</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">UICollectionViewLayoutAttributes</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">CGPoint</span> <span class="n">center</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class="line">    <span class="n">UIAttachmentBehavior</span> <span class="o">*</span><span class="n">springBehaviour</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIAttachmentBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItem:</span><span class="n">item</span> <span class="nl">attachedToAnchor:</span><span class="n">center</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">springBehaviour</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span><span class="line">    <span class="n">springBehaviour</span><span class="p">.</span><span class="n">damping</span> <span class="o">=</span> <span class="mf">0.8f</span><span class="p">;</span>
</span><span class="line">    <span class="n">springBehaviour</span><span class="p">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CGPointEqualToPoint</span><span class="p">(</span><span class="n">CGPointZero</span><span class="p">,</span> <span class="n">touchLocation</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">yDistanceFromTouch</span> <span class="o">=</span> <span class="n">fabsf</span><span class="p">(</span><span class="n">touchLocation</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">springBehaviour</span><span class="p">.</span><span class="n">anchorPoint</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">xDistanceFromTouch</span> <span class="o">=</span> <span class="n">fabsf</span><span class="p">(</span><span class="n">touchLocation</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">springBehaviour</span><span class="p">.</span><span class="n">anchorPoint</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span><span class="line">        <span class="n">CGFloat</span> <span class="n">scrollResistance</span> <span class="o">=</span> <span class="p">(</span><span class="n">yDistanceFromTouch</span> <span class="o">+</span> <span class="n">xDistanceFromTouch</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1500.0f</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">latestDelta</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">latestDelta</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">latestDelta</span><span class="o">*</span><span class="n">scrollResistance</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">else</span> <span class="p">{</span>
</span><span class="line">            <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">latestDelta</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">latestDelta</span><span class="o">*</span><span class="n">scrollResistance</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">item</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="nl">addBehavior:</span><span class="n">springBehaviour</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">visibleIndexPathsSet</span> <span class="nl">addObject:</span><span class="n">item</span><span class="p">.</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>大部分代码看起来还是挺熟悉的。大概有一半是来自没有实现平铺的 <code>prepareLayout</code>。另一半是来自 <code>shouldInvalidateLayoutForBoundsChange:</code> 这个方法。我们用 latestDelta 这个属性来表示 <code>bound</code> 变化的增量，适当地调整 <code>UICollectionViewLayoutAttributes</code> 使这些 cell 表现地就像被 attachment behavior “拉”着一样。</p>

<p>就这样就完成了，真的！我已经在真机上测试过显示上千个 cell 的情况了，它运行地非常完美。<a href="https://github.com/objcio/issue-5-springy-collection-view">去试试吧</a>。</p>

<h2>超越瀑布流布局</h2>

<p>一般来说，当我们使用 <code>UICollectionView</code> 的时候，继承 <code>UICollectionViewFlowLayout</code> 会比直接继承 <code>UICollectionViewLayout</code> 更容易。这是因为 <em>flow</em> layout 会为我们做很多事。然而，瀑布流布局是严格基于它们的尺寸一个接一个的展现出来。如果你有一个布局不能适应这个标准怎么办？好的，如果你已经尝试用 <code>UICollectionViewFlowLayout</code> 来适应，而且你很确定它不能很好运行，那么就应该抛弃 <code>UICollectionViewFlowLayout</code> 这个定制性比较弱的子类，而应该直接在 <code>UICollectionViewLayout</code> 这个基类上进行定制。</p>

<p>这个原则在处理 UIKit Dynamic 时也是适用的。</p>

<p>让我们先创建 <code>UICollectionViewLayout</code> 的子类。当继承 <code>UICollectionViewLayout</code> 的时候需要实现 <code>collectionViewContentSize</code> 方法，这点非常重要。否则这个 collection view 就不知道如果去显示自己，也不会有显示任何东西。因为我们想要 collection view 不能滚动，所以这里要返回 collection view 的 frame 的 size，减去它的 <code>contentInset.top</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span><span class="p">(</span><span class="n">CGSize</span><span class="p">)</span><span class="nf">collectionViewContentSize</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">contentInset</span><span class="p">.</span><span class="n">top</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在这个（有点教学式）的例子中，我们的 collection view <em>总是会以零个cell开始</em>，物体通过 <code>performBatchUpdates:</code> 这个方法添加。这就意味着我们必须使用 <code>-[UICollectionViewLayout prepareForCollectionViewUpdates:]</code> 这个方法来添加我们的 behavior（即这个 collection view 的数据源总是以零开始）。</p>

<p>除了给各个 item 添加 attachment behavior 外，我们还将保留另外两个 behavior：重力和碰撞。对于添加在这个 collection view 中的每个 item 来说，我们必须把这些 item 添加到我们的碰撞和 attachment behavior 中。最后一步就是设置这些 item 的初始位置为屏幕外的某些地方，这样就有被 attachment behavior 拉入到屏幕内的效果了:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">prepareForCollectionViewUpdates:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">updateItems</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="nl">prepareForCollectionViewUpdates:</span><span class="n">updateItems</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">updateItems</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">UICollectionViewUpdateItem</span> <span class="o">*</span><span class="n">updateItem</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">updateItem</span><span class="p">.</span><span class="n">updateAction</span> <span class="o">==</span> <span class="n">UICollectionUpdateActionInsert</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">UICollectionViewLayoutAttributes</span> <span class="o">*</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">UICollectionViewLayoutAttributes</span>
</span><span class="line">                <span class="nl">layoutAttributesForCellWithIndexPath:</span><span class="n">updateItem</span><span class="p">.</span><span class="n">indexPathAfterUpdate</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">            <span class="n">attributes</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">CGRectGetMaxX</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">frame</span><span class="p">)</span> <span class="o">+</span> <span class="n">kItemSize</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="n">kItemSize</span><span class="p">,</span> <span class="n">kItemSize</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">            <span class="n">UIAttachmentBehavior</span> <span class="o">*</span><span class="n">attachmentBehaviour</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIAttachmentBehavior</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithItem:</span><span class="n">attributes</span>
</span><span class="line">                                                                                  <span class="nl">attachedToAnchor:</span><span class="n">attachmentPoint</span><span class="p">];</span>
</span><span class="line">            <span class="n">attachmentBehaviour</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mf">300.0f</span><span class="p">;</span>
</span><span class="line">            <span class="n">attachmentBehaviour</span><span class="p">.</span><span class="n">damping</span> <span class="o">=</span> <span class="mf">0.4f</span><span class="p">;</span>
</span><span class="line">            <span class="n">attachmentBehaviour</span><span class="p">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span><span class="line">            <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dynamicAnimator</span> <span class="nl">addBehavior:</span><span class="n">attachmentBehaviour</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">            <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">gravityBehaviour</span> <span class="nl">addItem:</span><span class="n">attributes</span><span class="p">];</span>
</span><span class="line">            <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">collisionBehaviour</span> <span class="nl">addItem:</span><span class="n">attributes</span><span class="p">];</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://img.objccn.io/issue-5/newtonianCollectionView.gif" alt="Demo" /></p>

<p>删除就有点复杂了。我们希望这些物体有“掉落”的效果而不是简单的消失。这就不仅仅是从 collection view 中删除个 cell 这么简单了，因为我们希望在它离开了屏幕之前还是保留它。我已经在代码中实现了这样的效果，但是做法有点取巧。</p>

<p>基本上我们要做的是在 layout 中提供一个方法，在它删除 attachment behavior 两秒之后，将这个 cell 从 collection view 中删除。我们希望在这段时间里，这个 cell 能掉出屏幕，但是这不一定会发生。如果没有发生，也没关系。只要淡出就行了。然而，我们必须保证在这两秒内既没有新的 cell 被添加，也没有旧的 cell 被删除。（我说了有点取巧。）</p>

<p>欢迎提交 pull request。</p>

<p>这个方法是有局限性的。我将 cell 数量的上限设为 10，但是即使这样，在像 iPad2 这样比较旧的设备中，动画就会运行地很慢。当然，这个例子只是为了展示如何模拟有趣的动力学的一个方法——它并不是一个可以解决任何问题的万金油。你个人在实践中如何来进行模拟，包括性能等各个方面，都取决于你自己了。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-10T08:54:06+08:00" data-updated="true" itemprop="datePublished">Apr 10<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/10/textviewde-zhuan-you-ku-textkit/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/10/textviewde-zhuan-you-ku-textkit/" itemprop="url">TextView的专有库TextKit</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>iOS 7 的发布给开发者的案头带来了很多新工具。其中一个就是 <em>TextKit</em>。TextKit 由许多新的 UIKit 类组成，顾名思义，这些类就是用来处理文本的。在这里，我们将介绍 TextKit 的来由、它的组成，以及通过几个例子解释开发者怎样将它派上大用场。</p>

<p>但是首先我们得先阐明一个观点：TextKit 可能是近期对 UIKit <em>最重要</em>的补充了。iOS 7 的新界面用纯文本按钮替换了大量的图标和边框。总的来说，文本和文本布局在新 OS 系统的视觉效果中所占有的重要性大大提高了。iOS7 的重新设计完全是被文本驱动，这样说也许并不夸张——而文本全部是 TextKit 来处理的。</p>

<p>告诉你这个变动到底有多大吧：iOS7 之前的所有版本，（几乎）所有的文本都是 WebKit 来处理的。对：WebKit，web 浏览器引擎。所有 <code>UILabel</code>、<code>UITextField</code>，以及 <code>UITextView</code> 都在后台以某种方式使用 web views 来进行文本布局和渲染。为了新的界面风格，它们全都被重新设计以使用 TextKit。</p>

<h2 id="ios">iOS 上文本的简短历史</h2>

<p>这些新类并不是用来替换开发者以前使用的类。对 SDK 来说，TextKit 提供的是全新的功能。iOS 7 之前，TextKit 提供的功能必须都手动完成。这是现有框架缺失的功能。</p>

<p>长期以来，只有一个基本的文本布局和渲染框架：<em>CoreText</em>。同样也只有一个途径读取用户的键盘输入：<code>UITextInput</code> 协议。在 iOS6 中，为了简单地获取系统的文本选择，也只有一个选择：继承 <code>UITextView</code>。</p>

<p>（这可能就是为什么我要公开自己十年开发文本编辑器的经验的原因了）在渲染文本和读取键盘输入之间存在着巨大（跟我读：巨大）的缺口。这个缺口可能也是导致很少有富文本或者语法高亮编辑器的原因了——毫无疑问，开发一个好用的文本编辑器得耗费几个月的时间。</p>

<p>就这样——如下是 iOS 文本（不那么）简短历史的简短概要：</p>

<p><strong>iOS 2</strong>：这是第一个公开的 SDK，包括一个简单的文本显示组件（<code>UILabel</code>），一个简单的文本输入组件（<code>UITextField</code>），以及一个简单的、可滚动、可编辑的并且支持更大量文本的组件：<code>UITextView</code>。这些组件都只支持纯文本，没有文本选择支持（仅支持插入点），除了设置字体和文本颜色外几乎没有其他可定制功能。</p>

<p><strong>iOS 3</strong>：新特性有复制和粘贴，以及复制粘贴所需要的文本选择功能。数据探测器（Data Detector）为文本视图提供了一个高亮电话号码和链接的方法。然而，除了打开或关闭这些特性外，开发者基本上没有什么别的事情可以做。</p>

<p><strong>iOS 3.2</strong>：iPad 的出现带来了 CoreText，也就是前面提到的低级文本布局和渲染引擎（从Mac OS X 10.5 移植过来的），以及 <code>UITextInput</code>，就是前面也提到的键盘存取协议。Apple 将 Pages 作为移动设备上文本编辑功能的样板工程[^1]。然而，由于我前面提到的框架缺口，只有很少的应用使用它们。</p>

<p><strong>iOS 4</strong>：iOS 3.2 发布仅仅几个月后就发布了，文本方面没有一丁点新功能。<em>（个人经历：在 WWDC，我走近工程师们，告诉他们我想要一个完善的 iOS 文本布局系统。回答是：“哦…提交个请求。”不出所料…）</em></p>

<p><strong>iOS 5</strong>：文本方面没啥变化。<em>（个人经历：在 WWDC，我和工程师们谈及 iOS 上文本系统。回答是：“我们没有看到太多这方面的请求…” 靠！）</em></p>

<p><strong>iOS 6</strong>：有些动作了：属性文本编辑被加入了 <code>UITextView</code>。很不幸的是，它很难定制。默认的 UI 有粗体、斜体和下划线。用户可以设置字体大小和颜色。粗看起来相当不错，但还是没法控制布局或者提供一个便利的途径来定制文本属性。然而对于（文本编辑）开发者，有一个大的新功能：可以继承 <code>UITextView</code> 了，这样的话，除了以前版本提供的键盘输入外，开发者可以“免费”获得文本选择功能。而在这以前，开发者必须实现一个完全自定义的文本选择功能，这可能是很多非纯文本工具的开发半途而废的原因。<em>（个人经历：我，WWDC，工程师们。我想要一个 iOS 的文本系统。回答：“嗯。吖。是的。也许？看，它只是不执行…” 所以毕竟还是有希望，对吧？）</em></p>

<p><strong>iOS 7</strong>：终于来了，TextKit。</p>

<h2>功能</h2>

<p>所以我们来了。iOS7 带着 TextKit 登陆了。咱们看看它可以做什么！深入之前，我还想提一下，严格来说，这些新功能中的大部分以前都<em>可以</em>实现。如果你有大量的资源和时间来用 CoreText 构建一个文本引擎，这些都是可以实现的。但是在以前，构建一个完善的富文本编辑器可能花费你<em>几个月</em>的时间，现在却非常简单。你只需要到在 Xcode 里打开一个界面文件，然后将 <code>UITextView</code> 拖到你的试图控制器，就可以获得所有以下这些功能：</p>

<p><strong>字距调整（Kerning）</strong>：所有的字符都有一个矩形的外边框，这些边框必须彼此相邻来放置，这样的想法已经过时了。例如，现代文本布局会考虑到一个大写的“T”的“两翼”下面有一些空白，所以它会把后面的小写字母向左移让它们更靠近点。这样做的结果大大提高了文本的易读性，特别是在更长的文字中：</p>

<p><img src="http://img.objccn.io/issue-5/kerning.png" alt="Kerning: the bounding box of the letter “a” (blue rect) clearly overlap the capital “T” when kerning is enabled." title="" /></p>

<p><strong>连写</strong>：我认为这主要是个艺术功能，但当某些字符组合（如“f”后面是“l”）使用组合符号（所谓的字形(glyph)）绘制时，有些文本确实看起来更好（更美观）。</p>

<p><img src="http://img.objccn.io/issue-5/ligature.png" alt="Ligatures: the “Futura” font family contains special symbols for character combinations like “fl”." title="" /></p>

<p><strong>图像附件</strong>：现在可以向 Text View 中添加图像了。</p>

<p><strong>断字</strong>：编辑文本时没那么重要，但如果要以好看易读的方式展现文本时，这就相当重要。断字意味着在行边界处分割单词，从而为整体文本创建一个更整齐的排版和外观。<em>个人经历：</em> iOS 7 之前，开发者必须直接使用 CoreText。像这样：首先以句子为基础检测文本语言，然后获取句子中每个单词可能的断字点，然后在每一个可能的断字点上插入定制的连字占位字符。准备好之后，运行 CoreText 的布局方法并手动将连字符插入到断行。如果你想得到好的效果，之后你得检查带有连字符的文本没有超出行边界，如果超出了，在运行一次行的布局方法，这一次不要使用上次使用的断字点。使用 TextKit 的话，就非常简单了，设置 <code>hyphenationFactor</code> 属性就可以启用断字。</p>

<p><img src="http://img.objccn.io/issue-5/Screen%20Shot%202013-09-29%20at%2022.19.58.png" alt="The text in this view would have looked much more compartmentalized without hyphenation." title="" /></p>

<p><strong>可定制性</strong>：对我来说，甚至比改进过的排版还多，这是个<em>全新</em>的功能。以前开发者必须在使用现有的功能和自己全部重头写之间做出选择。现在提供了一整套类，它们有代理协议，或者可以被覆盖从而改变<em>部分</em>行为。例如，不必重写整个文本组件，你现在就可以改变指定单词的断行行为。我认为这是个胜利。</p>

<p><strong>更多的富文本属性</strong>：现在可以设置不同的下划线样式（双线、粗线、虚线、点线，或者它们的组合）。提高文本的基线非常容易，这可用来设置上标数字。开发者也不再需要自己为定制渲染的文本绘制背景颜色了（CoreText 不支持这些功能）。</p>

<p><strong>序列化</strong>：过去没有内置的方法从磁盘读取带文本属性的字符串。或者再写回磁盘。现在有了。</p>

<p><strong>文本样式</strong>：iOS 7 的界面引入了一个全局预定义的文本类型的新概念。这些文本类型分配了一个全局预定义的外观。理想情况下，这可以让整个系统的标题和连续文本具有一致的风格。通过设置应用，用户可以定义他们的阅读习惯（例如文本大小），那些使用文本样式的应用将自动拥有正确的文本大小和外观。</p>

<p><strong>文本效果</strong>：最后也是最不重要的。iOS 7 有且仅有一个文本效果：凸版。使用此效果的文本看起来像是盖在纸上面一样。内阴影，等等。<em>个人观点：真的？靠…？在一个已经完全彻底不可饶恕地枪毙了所有无用的<a href="http://en.wikipedia.org/wiki/Skeuomorph">怀旧装饰（skeuomorphism）</a>的 iOS 系统上，谁会需要这个像文本盖在纸上的效果？</em></p>

<h2>结构</h2>

<p>可能概览一个系统最好的方法是画一幅图。这是 UIKit 文本系统——TextKit 的简图：</p>

<p><img src="http://img.objccn.io/issue-5/TextKit.png" alt="The structure of all essential TextKit classes. Highlighted with a “New” badge are classes introduced in iOS 7." title="" /></p>

<p>从上图可以看出来，要让一个文本引擎工作，需要几个参与者。我们将从外到里介绍它们：</p>

<p><strong>字符串（String）</strong>：要绘制文本，那么必然在某个地方有个字符串来存储这段文本。在默认的结构中，<code>NSTextStorage</code> 保存并管理这个字符串，在这种情况中，它可以远离绘制。但并不一定非得这样。使用 TextKit 时，文本可以来自任何适合的来源。例如，对于一个代码编辑器，字符串可以是一棵包含所有显示的代码的结构信息的注释语法树（annotated syntax tree，缩写为 AST）。使用一个自定义的 <code>NSTextStorage</code> 就可以让文本在稍后动态地添加字体或颜色高亮等文本属性装饰。这是第一次，开发者可以直接为文本组件使用自己的模型。要想实现这个功能，我们需要一个特别设计的 <code>NSTextStorage</code>，即：</p>

<p><code>NSTextStorage</code>：如果你把文本系统看做一个模型-视图-控制器（MVC）架构，这个类代表的是模型。<code>NSTextStorage</code> 是一个中枢，它管理所有的文本和属性信息。系统只提供了两个存取器方法存取它们，并另外提供了两个方法来分别修改文本和属性。后面我们将进一步了解这些方法。现在重要的是你得理解 <code>NSTextStorage</code> 是从它的父类 <code>NSAttributedString</code> 继承了这些方法。这就很清楚了，<code>NSTextStorage</code>——从文本系统看来——仅仅是一个带有属性的字符串，附带一些扩展。这两者唯一的重大不同点是 <code>NSTextStorage</code> 包含了一个方法，可以把所有对其内容进行的修改以通知的形式发送出来。我们等一下会介绍这部分内容。</p>

<p><code>UITextView</code>：堆栈的另一头是实际的视图。在 TextKit 中，有两个目的：第一，它是文本系统用来绘制的视图。文本视图它自己并<em>不</em>会做任何绘制；它仅仅提供一个供其它类绘制的区域。作为视图层级机构中唯一的组件，第二个目的是处理所有的用户交互。具体来说，Text View 实现 <code>UITextInput</code> 的协议来处理键盘事件，它为用户提供了一种途径来设置一个插入点或选择文本。它并不对文本做任何实际上的改变，仅仅将这些改变请求转发给刚刚讨论的 Text Storage。</p>

<p><code>NSTextContainer</code>：每个 Text View 定义了一个文本可以绘制的区域。为此，每个 Text View 都有一个 Text Container，它精确地描述了这个可用的区域。在简单的情况下，这是一个垂直的无限大的矩形区域。文本被填充到这个区域，并且 Text View 允许用户滚动它。然而，在更高级的情况下，这个区域可能是一个无限大的矩形。例如，当渲染一本书时，每一页都有最大的高度和宽度。 Text Container 会定义这个大小，并且不接受任何超出的文本。相同情况下，一幅图像可能占据了页面的一部分，文本应该沿着它的边缘重新排版。这也是由 Text Container 来处理的，我们会在后面的例子中看到这一点。</p>

<p><code>NSLayoutManager</code>：Layout Manager 是中心组件，它把所有组件粘合在一起：</p>

<ol>
<li>这个管理器监听 Text Storage 中文本或属性改变的通知，一旦接收到通知就触发布局进程。  </li>
<li>从 Text Storage 提供的文本开始，它将所有的字符翻译为字形（Glyph）[^2]。  </li>
<li>一旦字形全部生成，这个管理器向它的 Text Containers 查询文本可用以绘制的区域。  </li>
<li>然后这些区域被行逐步填充，而行又被字形逐步填充。一旦一行填充完毕，下一行开始填充。  </li>
<li>对于每一行，布局管理器必须考虑断行行为（放不下的单词必须移到下一行）、连字符、内联的图像附件等等。  </li>
<li>当布局完成，文本的当前显示状态被设为无效，然后 Layout Manager 将前面几步排版好的文本设给 Text View。</li>
</ol>

<p><strong>CoreText</strong>：没有直接包含在 TextKit 中，CoreText 是进行实际排版的库。对于布局管理器的每一步，CoreText 被这样或那样的方式调用。它提供了从字符到字形的翻译，用它们来填充行，以及建议断字点。</p>

<h3 id="cocoa">Cocoa 文本系统</h3>

<p>创建像 TextKit 这样庞大复杂的系统肯定不是件简单快速的事情，而且肯定需要丰富的经验和知识。在 iOS 的前面 6 个主版本中，一直没有提供一个“真正的”文本组件，这也说明了这一点。Apple 把它视为一个大的新特性，当然没啥问题。但是它真的是全新的吗？</p>

<p>这里有个数字：在 <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIKit_Framework/_index.html">UIKit 的 131 个公共类</a>中，只有 9 个的名字没有使用UI作为前缀。这 9 个类使用的是旧系统的的、旧世界的（跟我读：Mac OS）前缀 NS。而且这九个类里面，有七个是用来处理文本的。巧合？好吧…</p>

<p>这是 Cocoa 文本系统的简图。不妨和上面 TextKit 的那幅图作一下对比。</p>

<p><img src="http://img.objccn.io/issue-5/CocoaTextSystem.png" alt="The structure of all essential classes of the Cocoa Text System as present on Mac OS today." title="" /></p>

<p>惊人地相似。很明显，最起码主要部分，两者是相同的。很明显——除了右边部分以及 <code>NSTextView</code> 和 <code>UITextView</code> ——主要的类全部相同。TextKit 是（起码部分是）从 Cocoa 文本系统移植到 iOS。<em>（我之前一直请求的那个，耶！）</em></p>

<p>进一步比较还是能看出一些不同的。最值得注意的有：</p>

<ul>
<li><p>在 iOS 上没有 <code>NSTypesetter</code> 和 <code>NSGlyphGenerator</code> 这两个类。在 Mac OS 上有很多方法来定制排版，在 iOS 中被极大地简化了，去掉了一些抽象概念，并将这个过程合并到 <code>NSLayoutManager</code> 中来。保留下来的是少数的代理方法，以用来更改文本布局和断行行为。</p></li>
<li><p>这些 Cocoa 的类移植到 iOS 系统后新增了几个非常便利的功能。在 Cocoa 中，必须手工地将确定的区域从 Text Container 分离出来（见上）。而 UIKit 类提供了一个简单的 <code>exclusionPaths</code> 属性就可以做到这一点。</p></li>
<li><p>有些功能未能提供，比如，内嵌表格，以及对非图像的附件的支持。</p></li>
</ul>

<p>尽管有这些区别，总的来说系统还是一样的。<code>NSTextStorage</code> 在两个系统是是一模一样的，<code>NSLayoutManager</code> 和 <code>NSTextContainer</code> 也没有太大的不同。这些变动，在没有太多去除对一些特例的支持的情况下，看来（某些情况下大大地）使文本系统的使用变得更为容易。我认为这是件好事。</p>

<p><em>事后回顾我从 Apple 工程师那里得到的关于将 Cocoa 文本系统移植到 iOS 的答案，我们可以得到一些背景信息。拖到现在并削减功能的原因很简单：性能、性能、性能。文本布局可能是极度昂贵的任务——内存方面、电量方面以及时间方面——特别是在移动设备上。Apple 必须采用更简单的解决方案，并等到处理能力能够至少部分支持一个完善的文本布局引擎。</em></p>

<h2>示例</h2>

<p>为了说明 TextKit 的能力，我创建了一个小的演示项目，你可以<a href="https://github.com/objcio/issue-5-textkit">在 GitHub 上找到它</a>。在这个演示程序中，我只完成了一些以前不容易完成的功能。我必须承认写这些代码只花了我礼拜天的一个上午的时间；如果以前要做同样的事情，我得花几天甚至几个星期。</p>

<p>TextKit 包括了超过 100 个方法，一篇文章根本没办法尽数涉及。而事实上，大多数时候，你需要的仅仅是一个正确的方法，TextKit 的使用和定制性也仍有待探索。所以我决定做四个更小的演示程序，而非一个大的演示程序来展示所有功能。每个演示程序中，我试着演示针对不同的方面和不同的类进行定制。</p>

<h3 id="1">演示程序1：配置</h3>

<p>让我们从最简单的开始：配置文本系统。正如你在上面 TextKit 简图中看到的，<code>NSTextStorage</code>、<code>NSLayoutManager</code> 和 <code>NSTextContainer</code> 之间的箭头都是有两个头的。我试图描述它们的关系是 1 对 N 的关系。就是那样：一个 Text Storage 可以拥有多个 Layout Manager，一个 Layout Manager 也可以拥有多个 Text Container。这些多重性带来了很好的特性：</p>

<ul>
<li>将多个 Layout Manager 附加到同一个 Text Storage 上，可以产生<em>相同文本的多种视觉表现</em>，而且可以把它们放到一起来显示。每一个表现都有独立的位置和大小。如果相应的 Text View 可编辑，那么在某个 Text View 上做的所有修改都会马上反映到所有 Text View 上。</li>
<li>将多个 Text Container 附加到同一个 Layout Manager 上，这样可以将<em>一个文本分布到多个视图</em>展现出来。很有用的一个例子，基于页面的布局：每个页面包含一个单独的 Text View。所有这些视图的 Text Container 都引用同一个 Layout Manager，这时这个 Layout Manager 就可以将文本分布到这些视图上来显示。</li>
</ul>

<p>在 Storyboard 或者 Interface 文件中实例化 <code>UITextView</code> 时，它会预配置一个文本系统：一个 Text Storage，引用一个 Layout Manager，而后者又引用一个 Text Container。同样地，一个文本系统栈也可以通过代码直接创建：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSTextStorage</span> <span class="o">*</span><span class="n">textStorage</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTextStorage</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">NSLayoutManager</span> <span class="o">*</span><span class="n">layoutManager</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSLayoutManager</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">textStorage</span> <span class="nl">addLayoutManager:</span> <span class="n">layoutManager</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">NSTextContainer</span> <span class="o">*</span><span class="n">textContainer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTextContainer</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">layoutManager</span> <span class="nl">addTextContainer:</span> <span class="n">textContainer</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">UITextView</span> <span class="o">*</span><span class="n">textView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UITextView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="n">someFrame</span>
</span><span class="line">                                                                     <span class="nl">textContainer:</span><span class="n">textContainer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这是最简单的方式。手工创建一个文本系统，唯一需要记住的事情是你的 View Controller 必须 retain 这个 Text Storage。在栈底的 Text View 只保留了对 Text Storage 和 Layout Manager 的弱引用。当 Text Storage 被释放时，Layout Manager 也被释放了，这样留给 Text View 的就只有一个断开的 Text Container 了。</p>

<p>这个规则有一个例外。只有从一个 interface 文件或 storyboard 实例化一个 Text View 时，Text View 确实会<em>自动</em> retain Text Storage。框架使用了一些黑魔法以确保所有的对象都被 retain，而无需手动建立一个 retain 环。</p>

<p>记住这些之后，创建一个更高级的设置也非常简单。假设在一个视图里面依旧有一个从 nib 实例化的 Text View，叫做 <code>originalTextView</code>。增加对相同文本的第二个文本视图只需要复制上面的代码，并重用 <code>originalTextView</code> 的 Text Storage：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSTextStorage</span> <span class="o">*</span><span class="n">sharedTextStorage</span> <span class="o">=</span> <span class="n">originalTextView</span><span class="p">.</span><span class="n">textStorage</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">NSLayoutManager</span> <span class="o">*</span><span class="n">otherLayoutManager</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSLayoutManager</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">sharedTextStorage</span> <span class="nl">addLayoutManager:</span> <span class="n">otherLayoutManager</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">NSTextContainer</span> <span class="o">*</span><span class="n">otherTextContainer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTextContainer</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">otherLayoutManager</span> <span class="nl">addTextContainer:</span> <span class="n">otherTextContainer</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">UITextView</span> <span class="o">*</span><span class="n">otherTextView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UITextView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="n">someFrame</span>
</span><span class="line">                                                <span class="nl">textContainer:</span><span class="n">otherTextContainer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>将第二个 Text Container 附加到 Layout Manager 也差不多。比方说我们希望上面例子中的文本填充<em>两个</em> Text View，而非一个。简单：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSTextContainer</span> <span class="o">*</span><span class="n">thirdTextContainer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTextContainer</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">otherLayoutManager</span> <span class="nl">addTextContainer:</span> <span class="n">thirdTextContainer</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">UITextView</span> <span class="o">*</span><span class="n">thirdTextView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UITextView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="n">someFrame</span>
</span><span class="line">                                                <span class="nl">textContainer:</span><span class="n">thirdTextContainer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>但有一点需要注意：由于在 otherTextView 中的 Text Container 可以无限地调整大小，<code>thirdTextView</code> 永远不会得到任何文本。因此，我们必须指定文本应该从一个视图回流到其它视图，而不应该调整大小或者滚动：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">otherTextView</span><span class="p">.</span><span class="n">scrollEnabled</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>不幸的是，看来将多个 Text Container 附加到一个 Layout Manager 会禁用编辑功能。如果必须保留编辑功能的话，那么一个 Text Container 只能附加到一个 Layout Manager 上。</p>

<p>想要一个这个配置的可运行的例子的话，请在前面提到的 <a href="https://github.com/objcio/issue-5-textkit">TextKitDemo</a> 中查看 “Configuration” 标签页。</p>

<h2 id="2">演示程序2：语法高亮</h2>

<p>如果配置 Text View 不是那么令人激动，那么这里有更有趣的：语法高亮！</p>

<p>看看 TextKit 组件的责任划分，就很清楚语法高亮应该由 Text Storage 实现。因为 <code>NSTextStorage</code> 是一个类簇[^3]，创建它的子类需要做不少工作。我的想法是建立一个复合对象：实现所有的方法，但只是将对它们的调用转发给一个实际的实例，将输入输出参数或者结果修改为希望的样子。</p>

<p><code>NSTextStorage</code> 继承自 <code>NSMutableAttributedString</code>，并且必须实现以下四个方法——两个 getter 和两个 setter：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">string</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nf">attributesAtIndex:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">location</span>
</span><span class="line">                     <span class="nf">effectiveRange:</span><span class="p">(</span><span class="n">NSRangePointer</span><span class="p">)</span><span class="nv">range</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">replaceCharactersInRange:</span><span class="p">(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">range</span> <span class="nf">withString:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">str</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAttributes:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">attrs</span> <span class="nf">range:</span><span class="p">(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">range</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>一个类簇的子类的复合对象的实现也相当简单。首先，找到一个满足所有要求的<em>最简单</em>的类。在我们的例子中，它是 <code>NSMutableAttributedString</code>，我们用它作为实现自定义存储的实现：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">TKDHighlightingTextStorage</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSMutableAttributedString</span> <span class="o">*</span><span class="n">_imp</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">init</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">_imp</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableAttributedString</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>有了这个对象，只需要一行代码就可以实现两个 getter 方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">string</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">_imp</span><span class="p">.</span><span class="n">string</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nf">attributesAtIndex:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">location</span> <span class="nf">effectiveRange:</span><span class="p">(</span><span class="n">NSRangePointer</span><span class="p">)</span><span class="nv">range</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">_imp</span> <span class="nl">attributesAtIndex:</span><span class="n">location</span> <span class="nl">effectiveRange:</span><span class="n">range</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>实现两个 setter 方法也几乎同样简单。但也有一个小麻烦：Text Storage 需要通知它的 Layout Manager 变化发生了。因此 settter 方法必须也要调用 <code>-edited:range:changeInLegth:</code> 并传给它变化的描述。听起来更糟糕，实现变成：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">replaceCharactersInRange:</span><span class="p">(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">range</span> <span class="nf">withString:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">str</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">_imp</span> <span class="nl">replaceCharactersInRange:</span><span class="n">range</span> <span class="nl">withString:</span><span class="n">str</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">edited:</span><span class="n">NSTextStorageEditedCharacters</span> <span class="nl">range:</span><span class="n">range</span>
</span><span class="line">                                      <span class="nl">changeInLength:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="n">str</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="n">range</span><span class="p">.</span><span class="n">length</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAttributes:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">attrs</span> <span class="nf">range:</span><span class="p">(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">range</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">_imp</span> <span class="nl">setAttributes:</span><span class="n">attrs</span> <span class="nl">range:</span><span class="n">range</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">edited:</span><span class="n">NSTextStorageEditedAttributes</span> <span class="nl">range:</span><span class="n">range</span> <span class="nl">changeInLength:</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>就这样，我们在文本系统栈里面有了一个 Text Storage 的全功能替换版本。在从 Interface 文件中载入时，可以像这样将它插入文本视图——但是记住从一个实例变量引用 Text Storage：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">_textStorage</span> <span class="o">=</span> <span class="p">[</span><span class="n">TKDHighlightingTextStorage</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">_textStorage</span> <span class="nl">addLayoutManager:</span> <span class="n">self</span><span class="p">.</span><span class="n">textView</span><span class="p">.</span><span class="n">layoutManager</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>到目前为止，一切都很好。我们设法插入了一个自定义的文本存储，接下来我们需要真正高亮文本的某些部分了。现在，一个简单的高亮应该就是够了：我们希望将所有 iWords 的颜色变成红色——也就是那些以小写“i”开头，后面跟着一个大写字母的单词。</p>

<p>一个方便实现高亮的办法是覆盖 <code>-processEditing</code>。每次文本存储有修改时，这个方法都自动被调用。每次编辑后，<code>NSTextStorage</code> 会用这个方法来清理字符串。例如，有些字符无法用选定的字体显示时，Text Storage 使用一个可以显示它们的字体来进行替换。</p>

<p>和其它一样，为 iWords 增加一个简单的高亮也相当简单。我们覆盖 <code>-processEditing</code>，调用父类的实现，并设置一个正则表达式来查找单词：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">processEditing</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="n">processEditing</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">static</span> <span class="n">NSRegularExpression</span> <span class="o">*</span><span class="n">iExpression</span><span class="p">;</span>
</span><span class="line">    <span class="n">NSString</span> <span class="o">*</span><span class="n">pattern</span> <span class="o">=</span> <span class="s">@&quot;i[\p{Alphabetic}&amp;amp;amp;&amp;amp;amp;\p{Uppercase}][\p{Alphabetic}]%2B&quot;</span><span class="p">;</span>
</span><span class="line">    <span class="n">iExpression</span> <span class="o">=</span> <span class="n">iExpression</span> <span class="o">?:</span> <span class="p">[</span><span class="n">NSRegularExpression</span> <span class="nl">regularExpressionWithPattern:</span><span class="n">pattern</span>
</span><span class="line">                                                                           <span class="nl">options:</span><span class="mi">0</span>
</span><span class="line">                                                                             <span class="nl">error:</span><span class="nb">NULL</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>																			
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后，首先清除之前的所有高亮：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSRange</span> <span class="n">paragaphRange</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">string</span> <span class="nl">paragraphRangeForRange:</span> <span class="n">self</span><span class="p">.</span><span class="n">editedRange</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">self</span> <span class="nl">removeAttribute:</span><span class="n">NSForegroundColorAttributeName</span> <span class="nl">range:</span><span class="n">paragaphRange</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>其次遍历所有的样式匹配项并高亮它们：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">iExpression</span> <span class="nl">enumerateMatchesInString:</span><span class="n">self</span><span class="p">.</span><span class="n">string</span>
</span><span class="line">                              <span class="nl">options:</span><span class="mi">0</span> <span class="nl">range:</span><span class="n">paragaphRange</span>
</span><span class="line">                           <span class="nl">usingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSTextCheckingResult</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">NSMatchingFlags</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">addAttribute:</span><span class="n">NSForegroundColorAttributeName</span> <span class="nl">value:</span><span class="p">[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">]</span> <span class="nl">range:</span><span class="n">result</span><span class="p">.</span><span class="n">range</span><span class="p">];</span>
</span><span class="line"><span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>就是这样。我们创建了一个支持语法高亮的动态 Text View。当用户键入时，高亮将被<em>实时</em>应用。而且这只需几行代码。酷吧？</p>

<p><img src="http://img.objccn.io/issue-5/SyntaxHighlighting.png" alt="A screenshot from the TextKitDemo project showing the text view with iWords highlighted." title="" /></p>

<p>请注意仅仅使用 <em>edited range</em> 是不够的。例如，当手动键入 iWords，只有一个单词的第三个字符被键入后，正则表达式才开始匹配。但那时 <code>editedRange</code> 仅包含第三个字符，因此所有的处理只会影响这一个字符。通过重新处理整个段落可以解决这个问题，这样既完成高亮功能，又不会太过影响性能。</p>

<p>想要一个可以运行的 Demo 的话，请在前面提到的 <a href="https://github.com/objcio/issue-5-textkit">TextKitDemo</a> 中查看“Highlighting”标签页。</p>

<h2 id="3">演示程序3：布局修改</h2>

<p>如前所述，Layout Manager 是核心的布局主力。Mac OS 上 <code>NSTypesetter</code> 的高度可定制功能被并入 iOS 上的 <code>NSLayoutManager</code>。虽然 TextKit 不具备像 Cocoa 文本系统那样的完全可定制性，但它提供很多代理方法来允许做一些调整。如前所述，TextKit 与 CoreText 更紧密地集成在一起，主要是基于性能方面的考虑。但是两个文本系统的理念在一定程度上是不一样的：</p>

<p><strong>Cocoa 文本系统</strong>：在 Mac OS上，性能不是问题，设计考量的全部是灵活性。可能是这样：“这个东西可以做这个事情。如果你想的话，你可以覆盖它。性能不是问题。你也可以提供完全由自己实现的字符到字形的转换，去做吧…”</p>

<p><strong>TextKit</strong>：性能看来真是个问题。理念（起码现在）更多的是像这样：“我们用简单但是高性能的方法实现了这个功能。这是结果，但是我们给你一个机会去更改它的一些东西。但是你只能在不太损害性能的地方进行修改。”</p>

<p>理念的东西就讲这么多，现在让我们来搞些实际的东西。例如，调整行高如何？听起来不可思议，但是在之前的 iOS 发布版上调整行高需要<a href="http://stackoverflow.com/questions/3760924/set-line-height-in-uitextview/3914228">使用黑科技或者私有 API</a>。幸运的是，现在（再一次）不用那么费脑子了。设置 Layout Manager 的代理并实现仅仅一个方法即可：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span>      <span class="nf">layoutManager:</span><span class="p">(</span><span class="n">NSLayoutManager</span> <span class="o">*</span><span class="p">)</span><span class="nv">layoutManager</span>
</span><span class="line">  <span class="nf">lineSpacingAfterGlyphAtIndex:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">glyphIndex</span>
</span><span class="line">  <span class="nf">withProposedLineFragmentRect:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">rect</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">floorf</span><span class="p">(</span><span class="n">glyphIndex</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在以上的代码中，我修改了行间距，让它与文本长度同时增长。这导致顶部的行比底部的行排列得更紧密。我承认这没什么实际的用处，但是它是可以做到的（而且肯定会有更实用的用例的）。</p>

<p>好，来一个更现实的场景。假设你的文本中有链接，你不希望这些链接被断行分割。如果可能的话，一个 URL 应该始终显示为一个整体，一个单一的文本片段。没有什么比这更简单的了。</p>

<p>首先，就像前面讨论过的那样，我们使用自定义的 Text Storage。但是，它寻找链接并将其标记，而不是检测 iWords，如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">static</span> <span class="n">NSDataDetector</span> <span class="o">*</span><span class="n">linkDetector</span><span class="p">;</span>
</span><span class="line"><span class="n">linkDetector</span> <span class="o">=</span> <span class="n">linkDetector</span> <span class="o">?:</span> <span class="p">[[</span><span class="n">NSDataDetector</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTypes:</span><span class="n">NSTextCheckingTypeLink</span> <span class="nl">error:</span><span class="nb">NULL</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">NSRange</span> <span class="n">paragaphRange</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">string</span> <span class="nl">paragraphRangeForRange:</span> <span class="n">NSMakeRange</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">location</span><span class="p">,</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">)];</span>
</span><span class="line"><span class="p">[</span><span class="n">self</span> <span class="nl">removeAttribute:</span><span class="n">NSLinkAttributeName</span> <span class="nl">range:</span><span class="n">paragaphRange</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">linkDetector</span> <span class="nl">enumerateMatchesInString:</span><span class="n">self</span><span class="p">.</span><span class="n">string</span>
</span><span class="line">                               <span class="nl">options:</span><span class="mi">0</span>
</span><span class="line">                                 <span class="nl">range:</span><span class="n">paragaphRange</span>
</span><span class="line">                            <span class="nl">usingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSTextCheckingResult</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">NSMatchingFlags</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">addAttribute:</span><span class="n">NSLinkAttributeName</span> <span class="nl">value:</span><span class="n">result</span><span class="p">.</span><span class="n">URL</span> <span class="nl">range:</span><span class="n">result</span><span class="p">.</span><span class="n">range</span><span class="p">];</span>
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>有了这个，改变断行行为就只需要实现一个 Layout Manager 的代理方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">layoutManager:</span><span class="p">(</span><span class="n">NSLayoutManager</span> <span class="o">*</span><span class="p">)</span><span class="nv">layoutManager</span> <span class="nf">shouldBreakLineByWordBeforeCharacterAtIndex:</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nv">charIndex</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSRange</span> <span class="n">range</span><span class="p">;</span>
</span><span class="line">    <span class="n">NSURL</span> <span class="o">*</span><span class="n">linkURL</span> <span class="o">=</span> <span class="p">[</span><span class="n">layoutManager</span><span class="p">.</span><span class="n">textStorage</span> <span class="nl">attribute:</span><span class="n">NSLinkAttributeName</span>
</span><span class="line">                                                  <span class="nl">atIndex:</span><span class="n">charIndex</span>
</span><span class="line">                                           <span class="nl">effectiveRange:</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">amp</span><span class="p">;</span><span class="n">range</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">linkURL</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">amp</span><span class="p">;</span> <span class="n">charIndex</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">gt</span><span class="p">;</span> <span class="n">range</span><span class="p">.</span><span class="n">location</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">amp</span><span class="p">;</span> <span class="n">charIndex</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>想要一个可运行的例子的话，请在前面提到的 <a href="https://github.com/objcio/issue-5-textkit">TextKitDemo</a> 中查看“Layout”标签页。以下是截屏：</p>

<p><img src="http://img.objccn.io/issue-5/LineBreaking.png" alt="A screenshot from the TextKitDemo project showing altered line break behavior for link URLs." title="" /></p>

<p>顺便说一句，上面截屏里面的绿色轮廓线是无法用 TextKit 实现的。在这个演示程序中，我用了个小技巧来在 Layout Manager 的子类中给文本画轮廓线。以特定的方法来扩展 TextKit 的绘制功能也不是件难事，你一定要看看！</p>

<h3 id="4">演示程序4：文本交互</h3>

<p>前面已经涉及到了 <code>NSTextStorage</code> 和 <code>NSLayoutManager</code>，最后一个演示程序将涉及 <code>NSTextContainer</code>。这个类并不复杂，而且它除了指定文本可不可以放置在某个地方外，什么都没做。</p>

<p>不要将文本放置在某些区域，这是很常见的需求，例如，在杂志应用中。对于这种情况，iOS 上的 <code>NSTextContainer</code> 提供了一个 Mac 开发者梦寐以求的属性：<code>exclusionPaths</code>，它允许开发者设置一个 <code>NSBezierPath</code> 数组来指定不可填充文本的区域。要了解这到底是什么东西，看一眼下面的截屏：</p>

<p><img src="http://img.objccn.io/issue-5/ReflowingTextAndClippy.png" alt="A screenshot from the TextKitDemo project showing text revolving around an excluded oval view" title="" /></p>

<p>正如你所看到的，所有的文本都放置在蓝色椭圆外面。在 Text View 里面实现这个行为很简单，但是有个小麻烦：Bezier Path 的坐标必须使用容器的坐标系。以下是转换方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">updateExclusionPaths</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="n">CGRect</span> <span class="n">ovalFrame</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">textView</span> <span class="nl">convertRect:</span><span class="n">self</span><span class="p">.</span><span class="n">circleView</span><span class="p">.</span><span class="n">bounds</span>
</span><span class="line">                                                      <span class="nl">fromView:</span><span class="n">self</span><span class="p">.</span><span class="n">circleView</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">ovalFrame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">-=</span> <span class="n">self</span><span class="p">.</span><span class="n">textView</span><span class="p">.</span><span class="n">textContainerInset</span><span class="p">.</span><span class="n">left</span><span class="p">;</span>
</span><span class="line">    <span class="n">ovalFrame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">-=</span> <span class="n">self</span><span class="p">.</span><span class="n">textView</span><span class="p">.</span><span class="n">textContainerInset</span><span class="p">.</span><span class="n">top</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">UIBezierPath</span> <span class="o">*</span><span class="n">ovalPath</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBezierPath</span> <span class="nl">bezierPathWithOvalInRect:</span><span class="n">ovalFrame</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">textView</span><span class="p">.</span><span class="n">textContainer</span><span class="p">.</span><span class="n">exclusionPaths</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="n">ovalPath</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在这个例子中，我使用了一个用户可移动的视图，它可以被自由移动，而文本会实时地围绕着它重新排版。我们首先将它的 bounds（<code>self.circleView.bounds</code>）转换到 Text View 的坐标系统。</p>

<p>因为没有 inset，文本会过于靠近视图边界，所以 <code>UITextView</code> 会在离边界还有几个点的距离的地方插入它的文本容器。因此，要得到以容器坐标表示的路径，必须从 origin 中减去这个插入点的坐标。</p>

<p>在此之后，只需将 Bezier Path 设置给 Text Container 即可将对应的区域排除掉。其它的过程对你来说是透明的，TextKit 会自动处理。</p>

<p>想要一个可运行的例子的话，请在前面提到的 <a href="https://github.com/objcio/issue-5-textkit">TextKitDemo</a> 中查看“Interaction”标签页。作为一个小噱头，它也包含了一个跟随当前文本选择的视图。因为，你也知道，没有一个小小的丑陋的烦人的回形针挡住你的话，那还是一个好的文本编辑器演示程序吗？</p>

<p>[^1]:   Pages 确实——据 Apple 声称——绝对没有使用私有 API。<em>咳</em> 我的理论：它要么使用了一个 TextKit 的史前版本，要么复制了 UIKit 一半的私有源程序。或者两者的混合。</p>

<p>[^2]:   <em>字形（Glyphs）</em>：如果说字符是一个字母的“语义”表达，字形则是它的可视化表达。取决于所使用的字体，字形要么是贝塞尔路径，或者位图图像，它定义了要绘制出来的形状。也请参考卓越的 Wikipedia 上关于字形的<a href="http://en.wikipedia.org/wiki/Glyph">这篇文章</a>。</p>

<p>[^3]:   在一个类簇中，只有一个抽象的父类是公共的。分配一个实例实际上就是创建其中一个私有类的对象。因此，你总是为一个抽象类创建子类，并且需要实现所有的方法。也请参考 <a href="https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html">class cluster documentation</a>。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-09T17:16:22+08:00" data-updated="true" itemprop="datePublished">Apr 9<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/09/ios7-dot-0-yin-cang-ji-qiao-he-bian-tong-zhi-dao/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/09/ios7-dot-0-yin-cang-ji-qiao-he-bian-tong-zhi-dao/" itemprop="url">iOS7.0:隐藏技巧和变通之道</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>当 iOS 7 刚发布的时候，全世界的苹果开发人员都立马尝试着去编译他们的 app，接着再花上数月的时间来修复任何出现的错误，甚至从头开始重建这个 app。这样的结果，使得人们根本无暇去探究 iOS 7 所带来的新思想。除开一些明显而细微的更新，比如说 NSArray 的 <code>firstObject</code> 方法——这个方法可追溯到 iOS 4 时代，现在被提为公有 API——还有很多隐藏的技巧等着我们去挖掘。</p>

<h2>平滑淡入淡出动画</h2>

<p>我在这里要讨论的并非新的弹性动画 API 或者 UIDynamics，而是一些更细微的东西。CALayer 增加了两个新方法：<code>allowsGroupOpacity</code> 和 <code>allowsEdgeAntialiasing</code>。现在，组不透明度（group opacity）不再是什么新鲜的东西了。iOS 会多次使用存在于 Info.plist 中的键 <code>UIViewGroupOpacity</code> 并可在应用程序范围内启用或禁用它。对于大多数 app 而言，这（译注：启用）并非所期望的，因为它会降低整体性能。在 iOS 7 中，用 SDK 7 所链接的程序，这项属性默认是启用的。当它被启用时，一些动画将会变得不流畅，它也可以在 layer 层上被控制。</p>

<p>一个有趣的细节，如果 <code>allowsGroupOpacity</code> 启用的话，<code>_UIBackdropView</code>（被用作 <code>UIToolbar</code> 或者 <code>UIPopoverView</code> 的背景视图）不能对其模糊进行动画处理，所以当你做一个 alpha 转换时，你可能会临时禁用这项属性。因为这会降低动画体验，你可以回到旧的方式然后在动画期间临时启用 <code>shouldRasterize</code>。别忘了设置适当的 <code>rasterizationScale</code>，否则在 retina 的设备上这些视图会成锯齿状（pixelerated）。</p>

<p>如果你想要复制 Safari 显示所有选项卡时的动画，那么边缘抗锯齿属性将变得非常有用。</p>

<h2>阻塞动画</h2>

<p>有一个小但是非常有用的新方法 <code>[UIView performWithoutAnimation:]</code>。它是一个简单的封装，先检查动画当前是否启用，如果是则停用动画，执行块语句，然后重新启用动画。一个需要说明的地方是，它并 <em>不会</em> 阻塞基于 CoreAnimation 的动画。因此，不用急于将你的方法调用从：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">CATransaction</span> <span class="n">begin</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">CATransaction</span> <span class="nl">setDisableActions:</span><span class="n">YES</span><span class="p">];</span>
</span><span class="line"><span class="n">view</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(...);</span>
</span><span class="line"><span class="p">[</span><span class="n">CATransaction</span> <span class="n">commit</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>替换成:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">UIView</span> <span class="nl">performWithoutAnimation:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">    <span class="n">view</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(...);</span>
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>但是，绝大多数情况下这样也能工作得很好，只要你不直接跟 CALayer 打交道。</p>

<p>iOS 7 中，我有很多代码路径（主要是 <code>UITableViewCells</code>）需要额外保护以防止意外的动画，例如，如果一个弹窗（popover）的大小调整了，与此同时其中的表视图将因为高度的变化而加载新的 cell。我通常的做法是将整个 <code>layoutSubviews</code> 的代码包扎到一个动画块中：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">layoutSubviews</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">// 否则在 iOS 7 的传统模式下弹窗动画会渗入我们的单元格</span>
</span><span class="line">    <span class="p">[</span><span class="n">UIView</span> <span class="nl">performWithoutAnimation:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">super</span> <span class="n">layoutSubviews</span><span class="p">];</span>
</span><span class="line">        <span class="n">_renderView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2>处理长的表视图</h2>

<p><code>UITableView</code> 非常快速高效，除非你开始使用 <code>tableView:heightForRowAtIndexPath:</code>，它会开始为你表中 <em>每一个</em> 元素调用此方法，即便没有可视对象——这是为了让其下层的 <code>UIScrollView</code> 能获取正确的 <code>contentSize</code>。此前有一些变通方法，但都不好用。iOS 7 中，苹果公司终于承认这一问题，并添加了  <code>tableView:estimatedHeightForRowAtIndexPath:</code>，这个方法把绝大部分计算成本推迟到实际滚动的时候。如果你完全不知道一个 cell 的大小，返回 <code>UITableViewAutomaticDimension</code> 就行了。</p>

<p>对于段头/尾（section headers/footers），现在也有类似的 API 了。</p>

<h2 id="uisearchdisplaycontroller">UISearchDisplayController</h2>

<p>苹果的 search controller 使用了新的技巧来简化移动 search bar 到 navigation bar 的过程。启用 <code>displaysSearchBarInNavigationBar</code> 就可以了（除非你还在用 scope bar，那你就太不幸了）。我倒是很喜欢这么做，但遗憾的是，iOS 7 上的 <code>UISearchDisplayController</code> 貌似被破坏得相当严重，尤其在 iPad 上。苹果公司看上去像是没时间处理这个问题，对于显示的搜索结果并不会隐藏实际的表视图。在 iOS 7 之前，这不算问题，但是现在 <code>searchResultsTableView</code> 有一个透明的背景色，使它看上去相当糟糕。作为一种变通方法，你可以设置不透明背景色或者采取一些<a href="http://petersteinberger.com/blog/2013/fixing-uisearchdisplaycontroller-on-ios-7/">更富于技巧的手段</a>来获得你期望的效果。关于这个控件我碰到过各种各样的结果，当使用 <code>displaysSearchBarInNavigationBar</code> 时甚至 <em>根本</em> 不会显示搜索表视图。</p>

<p>你的结果可能有所不同，但我依赖于一些手段（severe hacks）来让 <code>displaysSearchBarInNavigationBar</code> 工作：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">restoreOriginalTableView</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">PSPDFIsUIKitFlatMode</span><span class="p">()</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">self</span><span class="p">.</span><span class="n">originalTableView</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">originalTableView</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nf">tableView</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">originalTableView</span> <span class="o">?:</span> <span class="p">[</span><span class="n">super</span> <span class="n">tableView</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">searchDisplayController:</span><span class="p">(</span><span class="n">UISearchDisplayController</span> <span class="o">*</span><span class="p">)</span><span class="nv">controller</span>
</span><span class="line">  <span class="nf">didShowSearchResultsTableView:</span><span class="p">(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">// HACK: iOS 7 依赖于重度的变通来显示搜索表视图</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">PSPDFIsUIKitFlatMode</span><span class="p">())</span> <span class="p">{</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">originalTableView</span><span class="p">)</span> <span class="n">self</span><span class="p">.</span><span class="n">originalTableView</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">;</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="o">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">searchResultsTableView</span><span class="p">;</span>
</span><span class="line">        <span class="n">controller</span><span class="p">.</span><span class="n">searchResultsTableView</span><span class="p">.</span><span class="n">contentInset</span> <span class="o">=</span> <span class="n">UIEdgeInsetsZero</span><span class="p">;</span> <span class="c1">// 移除 64 像素的空白</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">searchDisplayController:</span><span class="p">(</span><span class="n">UISearchDisplayController</span> <span class="o">*</span><span class="p">)</span><span class="nv">controller</span>
</span><span class="line">  <span class="nf">didHideSearchResultsTableView:</span><span class="p">(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="n">restoreOriginalTableView</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>另外，别忘了在 <code>viewWillDisappear</code> 中调用 <code>restoreOriginalTableView</code>，否则程序会 crash。
记住这只是一种解决办法；可能还有不那么激进的方法，不用替换视图本身，但这个问题确实应该由苹果公司来修复。（TODO: RADAR!）</p>

<h2>分页</h2>

<p><code>UIWebView</code> 现在可以对带有 <code>paginationMode</code> 的网站进行自动分页。有一大堆与此功能相关的新属性：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">UIWebPaginationMode</span> <span class="n">paginationMode</span> <span class="n">NS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">7</span><span class="n">_0</span><span class="p">);</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">UIWebPaginationBreakingMode</span> <span class="n">paginationBreakingMode</span> <span class="n">NS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">7</span><span class="n">_0</span><span class="p">);</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">pageLength</span> <span class="n">NS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">7</span><span class="n">_0</span><span class="p">);</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">CGFloat</span> <span class="n">gapBetweenPages</span> <span class="n">NS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">7</span><span class="n">_0</span><span class="p">);</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">NSUInteger</span> <span class="n">pageCount</span> <span class="n">NS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">7</span><span class="n">_0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>目前而言，虽然这不一定对大多数网站都有用，但它肯定是生成简单的电子书阅读器或者显示文本的一种更好的方式。加点乐子的话，请尝试将它设置为 <code>UIWebPaginationModeBottomToTop</code>。</p>

<h2 id="popover">会飞的 Popover</h2>

<p>想知道为什么你的 popover 疯了一样到处乱飞？在 <code>UIPopoverControllerDelegate</code> 协议中有一个新的代理方法让你能控制它：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span>  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">popoverController:</span><span class="p">(</span><span class="n">UIPopoverController</span> <span class="o">*</span><span class="p">)</span><span class="nv">popoverController</span>
</span><span class="line">  <span class="nf">willRepositionPopoverToRect:</span><span class="p">(</span><span class="n">inout</span> <span class="n">CGRect</span> <span class="o">*</span><span class="p">)</span><span class="nv">rect</span>
</span><span class="line">                       <span class="nf">inView:</span><span class="p">(</span><span class="n">inout</span> <span class="n">UIView</span> <span class="o">**</span><span class="p">)</span><span class="nv">view</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当 popover 锚点是指向一个 <code>UIBarButtonItem</code> 时，<code>UIPopoverController</code> 会做出合适的展现，但是如果你让它在一个 view 或者 rect 中显示，你可能就需要实现此方法并正常返回。一个花费了我相当长时间来验证的问题——如果你通过改变 <code>preferredContentSize</code> 来动态调整你的 popover，那么这个方法就尤其需要实现。苹果公司现在对改变 popover 大小的请求更严格，如果没有预留足够的空间，popover 将会到处移动。</p>

<h2>键盘支持</h2>

<p>苹果公司不只为我们提供了<a href="https://developer.apple.com/library/ios/documentation/ServicesDiscovery/Conceptual/GameControllerPG/Introduction/Introduction.html">全新的 framework 用于游戏控制器</a>，它也给了我们这些键盘爱好者一些关注！你会发现新定义的公用键，比如  <code>UIKeyInputEscape</code> 或 <code>UIKeyInputUpArrow</code>，可以使用全新的 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKeyCommand_class/Reference/Reference.html#//apple_ref/occ/instp/UIKeyCommand/input"><code>UIKeyCommand</code></a> 类截查。在 iOS 7 之前，只能通过一些<a href="http://petersteinberger.com/blog/2013/adding-keyboard-shortcuts-to-uialertview/">难以言表的手段来处理键盘命令</a>，现在，就让我们操起蓝牙键盘试试看我们能用这个做什么！</p>

<p>开始之前，你需要对响应链（responder chain）有个了解。你的 <code>UIApplication</code> 继承自  <code>UIResponder</code>，<code>UIView</code> 和 <code>UIViewController</code> 也是如此。如果你曾经处理过 <code>UIMenuItem</code>  并且没有使用<a href="https://github.com/steipete/PSMenuItem">我的基于块的包装</a>的话，那么你对此已经有所了解。事件先被发送到最上层的响应者，然后一级级往下传递直到 UIApplication。为了捕获按键命令，你需要告诉系统你关心哪些按键命令（而不是全捕获）。为了完成这个，你需要重写 <code>keyCommands</code> 这个新属性：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">keyCommands</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="err">@</span><span class="p">[[</span><span class="n">UIKeyCommand</span> <span class="nl">keyCommandWithInput:</span><span class="s">@&quot;f&quot;</span>
</span><span class="line">                                 <span class="nl">modifierFlags:</span><span class="n">UIKeyModifierCommand</span>
</span><span class="line">                                        <span class="nl">action:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">searchKeyPressed:</span><span class="p">)]];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">searchKeyPressed:</span><span class="p">(</span><span class="n">UIKeyCommand</span> <span class="o">*</span><span class="p">)</span><span class="nv">keyCommand</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">// 响应事件</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><img src="http://img.objccn.io/issue-5/responder-chain.png" name="工作中的响应者链" width="472" height="548" /></p>

<p>现在可别太激动，需要注意的是，这个方法只在键盘可见时有效（比如有类似 <code>UITextView</code> 这样的对象作为第一响应者时）。对于全局热键，你仍然需要用上面提到的 hack 方法。除去那些，这个解决途径还是很优雅的。不要覆盖类似 cmd-V 这种系统的快捷键，它会被自动映射到 <code>paste:</code> 方法。</p>

<p>还有一些新的预定义的响应者行为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">increaseSize:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span> <span class="n">NS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">7</span><span class="n">_0</span><span class="p">);</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">decreaseSize:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span> <span class="n">NS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">7</span><span class="n">_0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>它们分别对应 cmd+ 和 cmd- 命令，用来放大/缩小内容。</p>

<h2>匹配键盘背景</h2>

<p>苹果公司终于公开了 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIInputView_class/Reference/Reference.html"><code>UIInputView</code></a>，其中提供了一种方式——使用 <code>UIInputViewStyleKeyboard</code> 来匹配键盘样式。这使得你能编写自定义的键盘或者适应默认样式的默认键盘的扩展（工具条）。这个类<a href="https://github.com/nst/iOS-Runtime-Headers/commits/master/Frameworks/UIKit.framework/UIInputView.h">一开始</a>就存在了，不过现在我们终于可以绕过私有API的方式来使用它了。</p>

<p>如果 <code>UIInputView</code> 是一个 <code>inputView</code> 或者 <code>inputAccessoryView</code> 的<em>根视图</em>，它将只显示一个背景，否则它将是透明的。遗憾的是，这并不能让你实现一个未填充的分离态的键盘，但它仍然比用一个简单的 UIToolbar 要好。我还没看到苹果在何处使用这个新 API，看上去 Safari 里仍然使用着 <code>UIToolbar</code>。</p>

<h2>了解你的无线电通信</h2>

<p>虽然早在 iOS 4 的时候，大部分的运营商信息已经在 CTTelephony 暴露了，但它通常只用于特定场景并非十分有用。iOS 7 中，苹果公司为其添加了一个方法，其中最有用的：<code>currentRadioAccessTechnology</code>。这个方法能告诉你手机是处于较慢的 GPRS 还是高速的 LTE 或者介于其中。目前还没有方法得到连接速度（当然手机本身也无法获取这个），但是这足以用来优化一个下载管理器，让其在 EDGE 下不用尝试 <em>同时</em> 去下载6张图片了。</p>

<p>现在还没有 <code>currentRadioAccessTechnology</code> 的相关文档，为了让它工作，会遇到一些麻烦和错误。当你想要获取当前网络信号值，你应当注册一个 <code>CTRadioAccessTechnologyDidChangeNotification</code> 通知而不是去轮询这个属性。为了确切的使 iOS 发送这些通知，你需要持有一个 <code>CTTelephonyNetworkInfo</code> 的实例，但不要在通知中创建  <code>CTTelephonyNetworkInfo</code> 的实例，否则会 crash。</p>

<p>在这个简单的例子中，因为在 block 中捕获 <code>telephonyInfo</code> 将会持有它，所以我就这么用了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CTTelephonyNetworkInfo</span> <span class="o">*</span><span class="n">telephonyInfo</span> <span class="o">=</span> <span class="p">[</span><span class="n">CTTelephonyNetworkInfo</span> <span class="n">new</span><span class="p">];</span>
</span><span class="line"><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Current Radio Access Technology: %@&quot;</span><span class="p">,</span> <span class="n">telephonyInfo</span><span class="p">.</span><span class="n">currentRadioAccessTechnology</span><span class="p">);</span>
</span><span class="line"><span class="p">[</span><span class="n">NSNotificationCenter</span><span class="p">.</span><span class="n">defaultCenter</span> <span class="nl">addObserverForName:</span><span class="n">CTRadioAccessTechnologyDidChangeNotification</span>
</span><span class="line">                                                <span class="nl">object:</span><span class="nb">nil</span>
</span><span class="line">                                                 <span class="nl">queue:</span><span class="nb">nil</span>
</span><span class="line">                                            <span class="nl">usingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span><span class="n">note</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;New Radio Access Technology: %@&quot;</span><span class="p">,</span> <span class="n">telephonyInfo</span><span class="p">.</span><span class="n">currentRadioAccessTechnology</span><span class="p">);</span>
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当手机从 Edge 环境切换到 3G，日志输出应该像这样：</p>

<pre><code>iOS7Tests[612:60b] Current Radio Access Technology: CTRadioAccessTechnologyEdge
iOS7Tests[612:1803] New Radio Access Technology: (null)
iOS7Tests[612:1803] New Radio Access Technology: CTRadioAccessTechnologyHSDPA
</code></pre>

<p>苹果导出了所有字符串符号，因此可以很简单的比较和检测当前的网络信息。</p>

<h2 id="corefoundationautorelease">Core Foundation，Autorelease 和你</h2>

<p>Core Foundation 中出现了一个新的辅助方法，它被用于私有调用已有数年时间：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CFTypeRef</span> <span class="n">CFAutorelease</span><span class="p">(</span><span class="n">CFTypeRef</span> <span class="n">CF_RELEASES_ARGUMENT</span> <span class="n">arg</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>它的确做了你所期望的事，让人费解的是苹果花了这么长时间才把它公开。ARC 下，大多数人在处理返回 Core Foundation 对象时是通过转换成对等的 NS 对象来完成的，如返回一个  <code>NSDictionary</code>，虽然它是一个 <code>CFDictionaryRef</code>，简单地使用 <code>CFBridgingRelease()</code> 就行了。这样通常没问题，除非你返回的没有可用的对等 NS 对象，如 <code>CFBagRef</code>。你要么使用 id，这样会失去类型安全性，要么你将你的方法重命名为 <code>createMethod</code> 并考虑所有的内存语义，最后使用 CFRelease。还有一些手段，比如<a href="http://favstar.fm/users/AndrePang/status/18099774996">这个</a>，使用 non-ARC-file 参数你才能编译它，但终归得使用 CFAutorelease()。另外：不要编写使用苹果公司命名空间的代码，所有这些自定义的 CF-宏将来都会被打破的。</p>

<h2>图片解压缩</h2>

<p>当通过 <code>UIImage</code> 展示一张图片时，在显示之前需要解压缩（除非图片源已经像素缓存了）。对于 JPG/PNG 文件这会占用相当可观的时间并会造成卡顿。iOS 6 以前，通常是通过创建一个位图上下文，然后在其中画图来解决。<a href="https://github.com/AFNetworking/AFNetworking/blob/09658b352a496875c91cc33dd52c3f47b9369945/AFNetworking/AFURLResponseSerialization.m#L442-518">（参见 AFNetworking 如何处理这个问题）</a>。</p>

<p>从 iOS 7 开始，你可以使用 <code>kCGImageSourceShouldCacheImmediately</code>: 强制图片在创建时直接解压缩：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">+</span> <span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nf">decompressedImageWithData:</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nv">data</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">CGImageSourceRef</span> <span class="n">source</span> <span class="o">=</span> <span class="n">CGImageSourceCreateWithData</span><span class="p">((</span><span class="n">__bridge</span> <span class="n">CFDataRef</span><span class="p">)</span><span class="n">data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">CGImageRef</span> <span class="n">cgImage</span> <span class="o">=</span> <span class="n">CGImageSourceCreateImageAtIndex</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">__bridge</span> <span class="n">CFDictionaryRef</span><span class="p">)</span><span class="err">@</span><span class="p">{(</span><span class="kt">id</span><span class="p">)</span><span class="nl">kCGImageSourceShouldCacheImmediately:</span> <span class="err">@</span><span class="n">YES</span><span class="p">});</span>
</span><span class="line">
</span><span class="line">    <span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageWithCGImage:</span><span class="n">cgImage</span><span class="p">];</span>
</span><span class="line">    <span class="n">CGImageRelease</span><span class="p">(</span><span class="n">cgImage</span><span class="p">);</span>
</span><span class="line">    <span class="n">CFRelease</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
</span><span class="line">    <span class="k">return</span> <span class="n">image</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>刚发现这一点时我很很兴奋，但不要高兴得太早。在我的测试中，开启即时缓存后性能实际上有所 <em>降低</em>。要么这个方法最终是在主线程中被调用的（好像不太可能），要么感官上的性能下降是因为其在方法 <code>copyImageBlockSetJPEG</code> 中锁住了，因为这个方法也被用在主线程显示非加密的图片时。在我的 app 中，我在主线程中加载小的预览图，在后台线程中加载大型图，使用了 <code>kCGImageSourceShouldCacheImmediately</code> 后小小的解压缩阻塞了主线程，同时在后台处理大量开销昂贵的操作。    </p>

<p><img src="http://img.objccn.io/issue-5/image-decompression.png" name="Image Decompression Stack Trace" width="662" height="1008" /></p>

<p>还有更多关于图片解压缩的却不是 iOS 7 中的新东西，像 <code>kCGImageSourceShouldCache</code>，它用来控制系统自动卸载解压缩图片数据的能力。确保你将它设置为 YES，否则所有的工作都将没有意义。有趣的是，苹果在 64-bit 运行时的系统中将 <code>kCGImageSourceShouldCache</code> 的 <em>默认值</em> 从 NO 改为了 YES。</p>

<h2>盗版检查</h2>

<p>苹果添加了一个方式，通过 NSBunble 上的新方法 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSBundle_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBundle/appStoreReceiptURL"><code>appStoreReceiptURL</code></a> 来获取和验证 Lion 系统上 App Store 的收据，现在终于也移植到了 iOS 上了。这使得你可以检查你的应用是合法购买的还是被破解了的。检查收据还有另一个重要的原因，它包含了 <em>初始购买日期</em>，这点对于把你的应用从付费模式迁移到免费+应用内付费模式很有帮助。你可以根据这个初始购买日期来决定额外内容对于你的用户是免费（因为他们已经付过费了）还是收费的。</p>

<p>收据还允许你检查应用程序是否通过批量购买计划购买以及该许可证是否仍有效，有一个名为  <code>SKReceiptPropertyIsVolumePurchase</code> 的属性标示了该值。</p>

<p>当你调用 <code>appStoreReceiptURL</code> 时，你需要特别注意，因为在 iOS 6 上，它还是一个私有 API，你应该在用户代码中先调用 <code>doesNotRecognizeSelector:</code>，在调用前检查运行（基础）版本。在开发期间，这个方法返回的 URL 不会指向一个文件。你可能需要使用 StoreKit 的 <a href="https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKReceiptRefreshRequest_ClassRef/SKReceiptRefreshRequest.html"><code>SKReceiptRefreshRequest</code></a>，这也是 iOS 7 中的新东西，用它来下载证书。使用一个至少有过一次购买的测试用户，否则它将没法工作：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="c1">// 刷新收据</span>
</span><span class="line"><span class="n">SKReceiptRefreshRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SKReceiptRefreshRequest</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">request</span> <span class="nl">setDelegate:</span><span class="n">self</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">request</span> <span class="n">start</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>验证收据需要大量的代码。你需要使用 OpenSSL 和内嵌的<a href="http://www.apple.com/certificateauthority/">苹果根证书</a>，并且你还要了解一些基本的东西像是证书、<a href="http://en.wikipedia.org/wiki/PKCS">PCKS 容器</a>以及 <a href="http://de.wikipedia.org/wiki/Abstract_Syntax_Notation_One">ASN.1</a>。这里有一些<a href="https://github.com/rmaddy/VerifyStoreReceiptiOS">样例代码</a>，但是你不应该让它这么简单——尤其是对那些有“高尚意图”的人，别只是拷贝现有的验证方法，至少做点修改或者编写你自己的，你应该不希望一个普通的补丁程序就能在数秒内瓦解你的努力吧。</p>

<p>你绝对应该读读苹果的指南——<a href="https://developer.apple.com/library/mac/releasenotes/General/ValidateAppStoreReceipt/index.html#//apple_ref/doc/uid/TP40010573-CH1-SW6">验证 Mac App 商店收据</a>，这里面的大多数都适用于 iOS。苹果在 <a href="https://developer.apple.com/wwdc/videos/">WWDC 2013 的 Session 308 “Using Receipts to Protect Your Digital Sales”</a> 中详述了通过新加入的“Grand Unified Receipt”而带来的变动。</p>

<h2 id="comicsansms">Comic Sans MS</h2>

<p>承认吧，你是怀念 Comic Sans MS 的。在 iOS 7 中，Comic Sans MS 终于回来了。iOS 6 中添加了可下载字体，但那时的字体列表很少也不见得有趣。在 iOS 7 中苹果添加了不少字体，包括 “famous”，它和 <a href="http://www.fontsquirrel.com/fonts/PT-Sans">PT Sans</a> 或 <a href="http://sixrevisions.com/graphics-design/comic-sans-the-font-everyone-loves-to-hate/">Comic Sans MS</a> 有些类似。<code>kCTFontDownloadableAttribute</code> 并没有在 iOS 6 中声明，所以 iOS 7 之前它并不真正可用，但苹果确是在 iOS 6 的时候就已经做了私有声明了。</p>

<p><img src="http://img.objccn.io/issue-5/comic-sans-ms.png" name="Who doesn't love Comic Sans MS" width="414" height="559" /></p>

<p>字体列表是<a href="http://mesu.apple.com/assets/com_apple_MobileAsset_Font/com_apple_MobileAsset_Font.xml">动态变化</a>的，以后可能就会发生变动。苹果在 <a href="http://support.apple.com/kb/HT5484">Tech Note HT5484</a> 中罗列了一些可用的字体，但这个文档已经过时了，并不能反映 iOS 7 的变化。</p>

<p>这里显示了你该如何获取一个用 <code>CTFontDescriptorRef</code> 标示的可下载的字体数组：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CFDictionary</span> <span class="o">*</span><span class="n">descriptorOptions</span> <span class="o">=</span> <span class="err">@</span><span class="p">{(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTFontDownloadableAttribute</span> <span class="o">:</span> <span class="err">@</span><span class="n">YES</span><span class="p">};</span>
</span><span class="line"><span class="n">CTFontDescriptorRef</span> <span class="n">descriptor</span> <span class="o">=</span> <span class="n">CTFontDescriptorCreateWithAttributes</span><span class="p">((</span><span class="n">CFDictionaryRef</span><span class="p">)</span><span class="n">descriptorOptions</span><span class="p">);</span>
</span><span class="line"><span class="n">CFArrayRef</span> <span class="n">fontDescriptors</span> <span class="o">=</span> <span class="n">CTFontDescriptorCreateMatchingFontDescriptors</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>系统不会检查字体是否已存在于磁盘上而将直接返回同样的列表。另外，这个方法可能会启用网络并造成阻塞，你不应该在主线程中使用它。</p>

<p>使用如下基于块的 API 来下载字体：    </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">bool</span> <span class="n">CTFontDescriptorMatchFontDescriptorsWithProgressHandler</span><span class="p">(</span>
</span><span class="line">         <span class="n">CFArrayRef</span>                          <span class="n">descriptors</span><span class="p">,</span>
</span><span class="line">         <span class="n">CFSetRef</span>                            <span class="n">mandatoryAttributes</span><span class="p">,</span>
</span><span class="line">         <span class="n">CTFontDescriptorProgressHandler</span>     <span class="n">progressBlock</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这个方法能操作网络并传递下载进度信息来调用你的 <code>progressBlock</code> 方法直到下载成功或者失败。参考苹果的 <a href="https://developer.apple.com/library/ios/samplecode/DownloadFont/Listings/DownloadFont_ViewController_m.html">DownloadFont 样例</a>看看如何使用它。    </p>

<p>有一些值得注意的地方，这里的字体只在当前程序运行时有效，下次运行将被重新载入内存。因为字体存放在共享空间中，你不能依赖于它们是否可用。很有可能但不能保证地说，系统会清理这个目录，或者你的程序被拷贝到没有这个字体的新设备中，同时你又没有网络。在 Mac 或是模拟器上，你能根据 <code>kCTFontURLAttribute</code> 获得字体的绝对路径，加载速度也会提升，但是在 iOS 上是不行的，因为这个目录在你的程序之外，你需要再次调用 <code>CTFontDescriptorMatchFontDescriptorsWithProgressHandler</code>。</p>

<p>你也可以注册新的 <code>kCTFontManagerRegisteredFontsChangedNotification</code> 通知来跟踪新字体在何时被载入到了字体注册表中。你可以在 <a href="https://developer.apple.com/wwdc/videos/">WWDC 2013 的 Session 223 “Using Fonts with TextKit”</a>中查找更多信息。</p>

<h2>这还不够?</h2>

<p>没关系，iOS 7 的新东西远不止如此！了解一下 <a href="http://nshipster.com/ios7/">NSHipster</a> 你将明白语音合成相关的东西，base64、全新的 <code>NSURLComponents</code>、<code>NSProgress</code>、条形码扫描、阅读列表以及 <code>CIDetectorEyeBlink</code>。还有很多我们没有涵盖到的，比如苹果的 <a href="https://developer.apple.com/library/ios/releasenotes/General/iOS70APIDiffs/index.html#//apple_ref/doc/uid/TP40013203">iOS 7 API 变化</a>，<a href="https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS7.html">What&#8217;s new in iOS</a>指南以及 <a href="https://developer.apple.com/library/prerelease/mac/releasenotes/Foundation/RN-Foundation/index.html#//apple_ref/doc/uid/TP30000742">Foundation Release Notes</a>（这些都是基于 OS X的，但是代码都是共享的，很多也同样适用于 iOS）。很多新方法都还没形成文档，等着你来探究和写成博客。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-09T17:04:49+08:00" data-updated="true" itemprop="datePublished">Apr 9<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/09/scrollviewde-qian-shi-jin-sheng/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/09/scrollviewde-qian-shi-jin-sheng/" itemprop="url">ScrollView的前世今生</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>可能你很难相信 <a href="http://developer.apple.com/library/ios/#documentation/uikit/reference/UIScrollView_Class/Reference/UIScrollView.html">UIScrollView</a> 和一个标准的 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/UIView/UIView.html">UIView</a> 差异并不大，scroll view 确实会多出一些方法，但这些方法只是和 UIView 的属性很好的结合到一起了。因此，在要想弄懂 UIScrollView 是怎么工作之前，你需要先了解一下 UIView，特别是视图渲染的两步过程。</p>

<h2>光栅化和组合</h2>

<p>渲染过程的第一部分是众所周知的光栅化(<code>rasterization</code>)，光栅化简单的说就是产生一组绘图指令并且生成一张图片。比如绘制一个圆角矩形、带图片、标题居中的 UIButtons。这些图片并没有被绘制到屏幕上去；取而代之的是，他们被自己的视图保持着留到下一个步骤使用。</p>

<p>一旦每个视图都产生了自己的光栅化图片，这些图片便被一个接一个的绘制，并产生一个屏幕大小的图片，这便是上文所说的组合。视图层级(view hierarchy)对于组合如何进行扮演了很重要的角色：一个视图的图片被组合在它父视图的图片上面。然后，组合好的图片被组合到父视图的父视图图片上面。视图层级最顶端是窗口(window)，它组合好的图片便是我们看到的东西了。</p>

<p>概念上，依次在每个视图上放置独立分层的图片并最终产生一个图片，单调的图像更容易被理解，特别是如果你以前使用过像 Photoshop 这样的工具。我们还有另外一篇文章详细解释了<a href="http://objccn.io/issue-3-1/">像素是如何绘制到屏幕上去的</a>。</p>

<p>现在，回想一下，每个视图都有一个 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instp/UIView/bounds">bounds</a> 和 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instp/UIView/frame">frame</a>。当布局一个界面时，我们需要处理视图的 frame。这允许我们放置并设置视图的大小。视图的 frame 和 bounds 的大小总是一样的，但是他们的 origin 有可能不同。弄懂这两个工作原理是理解 UIScrollView 的关键。</p>

<p>在光栅化步骤中，视图并不关心即将发生的组合步骤。也就是说，它并不关心自己的 frame (这是用来放置视图的图像)或自己在视图层级中的位置(这是决定组合的顺序)。这时视图只关心一件事就是绘制它自己的 content。这个绘制发生在每个视图的 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instm/UIView/drawRect:"><code>drawRect:</code></a> 方法中。</p>

<p>在 <code>drawRect:</code> 方法被调用前，会为视图创建一个空白的图片来绘制 content。这个图片的坐标系统是视图的 bounds。几乎每个视图 bounds 的 origin 都是 {0，0}。因此，当在光栅化图片左上角绘制一些东西的时候，你都会在 bounds 的 origin {x:0, y:0} 处绘制。在一个图片右下角的地方绘制东西的时候，你都会绘制在 {x:width, y:height} 处。如果你的绘制超出了视图的 bounds，那么超出的部分就不属于光栅化图片的部分了，并且会被丢弃。</p>

<p><img src="http://img.objccn.io/issue-3/SV2.png" alt="" title="" /></p>

<p>在组合的步骤中，每个视图将自己光栅化图片组合到自己父视图的光栅化图片上面。视图的 frame 决定了自己在父视图中绘制的位置，frame 的 origin 表明了视图光栅化图片左上角相对父视图光栅化图片左上角的偏移量。所以，一个 origin 为 {x:20, y:15} 的 frame 所绘制的图片左边距其父视图 20 点，上边距父视图 15 点。因为视图的 frame 和 bounds 矩形的大小总是一样的，所以光栅化图片组合的时候是像素对齐的。这确保了光栅化图片不会被拉伸或缩小。</p>

<p><img src="http://img.objccn.io/issue-3/SV1.png" alt="" title="" /></p>

<p>记住，我们才仅仅讨论了一个视图和它父视图之间的组合操作。一旦这两个视图被组合到一起，组合的结果图片将会和父视图的父视图进行组合，这是一个雪球效应。</p>

<p>考虑一下组合图片背后的公式。视图图片的左上角会根据它 frame 的 origin 进行偏移，并绘制到父视图的图片上：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CompositedPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">View</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">Superview</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">CompositedPosition</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">View</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">Superview</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>正如之前所说的，如果一个视图 bounds 的 origin 是 {0,0}。那么，我们得到这个公式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CompositedPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">View</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">CompositedPosition</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">View</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们可以通过几个不同的 frames 看一下：</p>

<p><img src="http://img.objccn.io/issue-3/SV3.png" alt="" title="" /></p>

<p>这样做是有道理的，我们改变 button 的 <code>frame.origin</code>后，它会改变自己相对紫色父视图的位置。注意，如果我们移动 button 直到它的一部分已经在紫色父视图 bounds 的外面，当光栅化图片被截去时这部分也将会通过同样的绘制方式被截去。然而，技术上讲，因为 iOS 处理组合方法的原因，你可以将一个子视图渲染在其父视图的 bounds 之外，但是光栅化期间的绘制不可能超出一个视图的 bounds。</p>

<h2 id="scrollviewcontentoffset">Scroll View的Content Offset</h2>

<p>现在我们所讲的跟 UIScrollView 有什么关系呢？一切都和它有关！考虑一种我们可以实现的滚动：我们有一个拖动时 frame 不断改变的视图。这达到了相同的效果，对吗？如果我拖动我的手指到右边，那么拖动的同时我增大视图的 <code>origin.x</code> ，瞧，这货就是 scroll view。</p>

<p>当然，在 scroll view 中有很多具有代表性的视图。为了实现这个平移功能，当用户移动手指时，你需要时刻改变每个视图的 frames。当我们提到组合一个 view 的光栅化图片到它父视图什么地方时，记住这个公式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">CompositedPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">View</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">Superview</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">CompositedPosition</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">View</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">Superview</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们减少 <code>Superview.bounds.origin</code> 的值(因为他们总是0)。但是如果他们不为0呢？我们用和前一个图例相同的 frames，但是我们改变了紫色视图 bounds 的 origin 为 {-30, -30}。得到下图：</p>

<p><img src="http://img.objccn.io/issue-3/SV4.png" alt="" title="" /></p>

<p>现在，巧妙的是通过改变这个紫色视图的 bounds，它每一个单独的子视图都被移动了。事实上，这正是 scroll view 工作的原理。当你设置它的 <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIScrollView_Class/Reference/UIScrollView.html#//apple_ref/occ/instp/UIScrollView/contentOffset">contentOffset</a> 属性时它改变 <code>scroll view.bounds</code> 的 origin。事实上，contentOffset 甚至不是实际存在的。代码看起来像这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setContentOffset:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">offset</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">CGRect</span> <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">bounds</span><span class="p">];</span>
</span><span class="line">    <span class="n">bounds</span><span class="p">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">setBounds:</span><span class="n">bounds</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意前一个图例，只要足够的改变 bounds 的 origin，button 将会超出紫色视图和 button 组合成的图片的范围。这也是当你足够的移动 scroll view 时，一个视图会消失！</p>

<h2 id="contentsize">世界之窗：Content Size</h2>

<p>现在，最难的部分已经过去了，我们再看看 UIScrollView 另一个属性：<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIScrollView_Class/Reference/UIScrollView.html#//apple_ref/occ/instp/UIScrollView/contentSize">contentSize</a>。
scroll view 的 content size 并不会改变其 bounds 的任何东西，所以这并不会影响 scroll view 如何组合自己的子视图。反而，content size 定义了可滚动区域。scroll view 的默认 content size 为 {w:0, h:0}。既然没有可滚动区域，用户是不可以滚动的，但是 scroll view 任然会显示其 bounds 范围内所有的子视图。 <br />
当 content size 设置为比 bounds 大的时候，用户就可以滚动视图了。你可以认为 scroll view 的 bounds 为可滚动区域上的一个窗口：</p>

<p><img src="http://img.objccn.io/issue-3/SV5.png" alt="" title="" /></p>

<p>当 content offset 为 {x:0, y:0} 时，可见窗口的左上角在可滚动区域的左上角处。这也是 content offset 的最小值；用户不能再往可滚动区域的左边或上边移动了。那儿没啥，别滚了！</p>

<p>content offset 的最大值是 content size 和 scroll view size 的差(不同于 content size 和scroll view的 bounds 大小)。这也在情理之中：从左上角一直滚动到右下角，用户停止时，滚动区域右下角边缘和滚动视图 bounds 的右下角边缘是齐平的。你可以像这样记下 content offset 的最大值：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">contentOffset</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">contentSize</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">contentOffset</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">contentSize</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="contentinsets">用Content Insets对窗口稍作调整</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIScrollView_Class/Reference/UIScrollView.html#//apple_ref/occ/instp/UIScrollView/contentInset">contentInset</a> 属性可以改变 content offset 的最大和最小值，这样便可以滚动出可滚动区域。它的类型为 <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIKitDataTypesReference/Reference/reference.html#//apple_ref/doc/c_ref/UIEdgeInsets">UIEdgeInsets</a>，包含四个值：{top，left，bottom，right}。当你引进一个 inset 时，你改变了 content offset 的范围。比如，设置 content inset 顶部值为 10，则允许 content offset 的 y 值达到 10。这介绍了可滚动区域周围的填充。</p>

<p><img src="http://img.objccn.io/issue-3/SV6.png" alt="" title="" /></p>

<p>这咋一看好像没什么用。实际上，为什么不仅仅增加 content size 呢？除非没办法，否则你需要避免改变scroll view 的 content size。想要知道为什么？想想一个 table view（UItableView是UIScrollView 的子类，所以它有所有相同的属性），table view 为了适应每一个cell，它的可滚动区域是通过精心计算的。当你滚动经过 table view 的第一个或最后一个 cell 的边界时，table view将 content offset 弹回并复位，所以 cells 又一次恰到好处的紧贴 scroll view 的 bounds。</p>

<p>当你想要使用 <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIRefreshControl_class/Reference/Reference.html">UIRefreshControl</a> 实现拉动刷新时发生了什么？你不能在 table view 的可滚动区域内放置 UIRefreshControl，否则，table view 将会允许用户通过 refresh control 中途停止滚动，并且将 refresh control 的顶部弹回到视图的顶部。因此，你必须将 refresh control 放在可滚动区域上方。这将允许首先将 content offset 弹回第一行，而不是 refresh control。</p>

<p>但是等等，如果你通过滚动足够多的距离初始化 pull-to-refresh 机制，因为 table view 设置了 content inset，这将允许 content offset 将 refresh control 弹回到可滚动区域。当刷新动作被初始化时，content inset 已经被校正过，所以 content offset 的最小值包含了完整的 refresh control。当刷新完成后，content inset 恢复正常，content offset 也跟着适应大小，这里并不需要为content size 做数学计算。(这里可能比较难理解，建议看看 EGOTableViewPullRefresh 这样的类库就应该明白了)</p>

<p>如何在自己的代码中使用 content inset？当键盘在屏幕上时，有一个很好的用途：你想要设置一个紧贴屏幕的用户界面。当键盘出现在屏幕上时，你损失了几百个像素的空间，键盘下面的东西全都被挡住了。</p>

<p>现在，scroll view 的 bounds 并没有改变，content size 也并没有改变(也不需要改变)。但是用户不能滚动 scroll view。考虑一下之前一个公式：content offset 的最大值是 content size 和 bounds 的差。如果他们相等，现在 content offset 的最大值是 {x:0, y:0}.</p>

<p>现在开始出绝招，将界面放入一个 scroll view。scroll view 的 content size 仍然和 scroll view 的 bounds 一样大。当键盘出现在屏幕上时，你设置 content inset 的底部等于键盘的高度。</p>

<p><img src="http://img.objccn.io/issue-3/SV7.png" alt="" title="" /></p>

<p>这允许在 content offset 的最大值下显示滚动区域外的区域。可视区域的顶部在 scroll view bounds 的外面，因此被截取了(虽然它在屏幕之外了，但这并没有什么)。</p>

<p>但愿这能让你理解一些滚动视图内部工作的原理，你对缩放感兴趣？好吧，我们今天不会谈论它，但是这儿有一个有趣的小窍门：检查 <a href="http://developer.apple.com/library/ios/#documentation/uikit/reference/UIScrollViewDelegate_Protocol/Reference/UIScrollViewDelegate.html#//apple_ref/doc/uid/TP40006923-CH3-SW7"><code>viewForZoomingInScrollView:</code></a> 方法返回视图的 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instp/UIView/transform">transform</a> 属性。你将再次发现 scroll view 只是聪明的利用了 UIView 已经存在的属性。</p>

<p>相关链接(强烈推荐)：</p>

<p><a href="http://bbs.weiphone.com/read-htm-tid-6880069.html">计算机图形渲染的流程</a></p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-09T16:40:06+08:00" data-updated="true" itemprop="datePublished">Apr 9<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/09/ioszhi-wan-zhuan-zi-fu-chuan/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/09/ioszhi-wan-zhuan-zi-fu-chuan/" itemprop="url">iOS之玩转字符串</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>在每个应用里我们都大量使用字符串。下面我们将快速看看一些常见的操作字符串的方法，过一遍常见操作的最佳实践。</p>

<h2>字符串的比较、搜索和排序</h2>

<p>排序和比较字符串比第一眼看上去要复杂得多。不只是因为字符串可以包含<strong>代理对（surrogate pairs ）</strong>(详见 <a href="http://objccn.io/issue-9-1/#peculiar-unicode-features">Ole 写的这篇关于 Unicode 的文章</a>) ，而且比较还与字符串的本地化相关。在某些极端情况下相当棘手。</p>

<p>苹果文档中 <em>String Programming Guide</em> 里有一节叫做 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html"><strong>“字符与字形集群（Characters and Grapheme Clusters）”</strong></a>，里面提到一些陷阱。例如对于排序来说，一些欧洲语言将序列“ch”当作单个字母。在一些语言里，“ä”被认为等同于 ‘a’ ，而在其它语言里它却被排在 ‘z’ 后面。</p>

<p>而 <code>NSString</code> 有一些方法来帮助我们处理这种复杂性。首先看下面的方法：</p>

<pre><code>- (NSComparisonResult)compare:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)range locale:(id)locale
</code></pre>

<p>它带给我们充分的灵活性。另外，还有很多<strong>便捷函数（convenience functions）</strong>都使用了这个方法。</p>

<p>与比较有关的可用参数如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSCaseInsensitiveSearch</span>
</span><span class="line"><span class="n">NSLiteralSearch</span>
</span><span class="line"><span class="n">NSNumericSearch</span>
</span><span class="line"><span class="n">NSDiacriticInsensitiveSearch</span>
</span><span class="line"><span class="n">NSWidthInsensitiveSearch</span>
</span><span class="line"><span class="n">NSForcedOrderingSearch</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>它们都可以用逻辑“或”运算符组合在一起。</p>

<p><code>NSCaseInsensitiveSearch</code>：“A”等同于“a”，然而在某些地方还有更复杂的情况。例如，在德国，“ß” 和 “SS”是等价的。</p>

<p><code>NSLiteralSearch</code>：Unicode 的点对点比较。它只在所有字符都用相同的方式组成的情况下才会返回相等（即 <code>NSOrderedSame</code>）。LATIN CAPITAL LETTER A 加上 COMBINING RING ABOVE 并不等同于 LATIN CAPITAL LETTER A WITH RING ABOVE.</p>

<blockquote>
  <p><span class="secondary radius label">编者注</span> 这里要解释一下，首先，每一个Unicode都是有官方名字的！LATIN CAPITAL LETTER A是一个大写“A”，COMBINING RING ABOVE是一个  ̊，LATIN CAPITAL LETTER A WITH RING ABOVE，这是Å。前两者的组合不等同于后者。</p>
</blockquote>

<p><code>NSNumericSearch</code>：它对字符串里的数字排序，所以 “Section 9” &lt; “Section 20” &lt; “Section 100.”</p>

<p><code>NSDiacriticInsensitiveSearch</code>：“A” 等同于 “Å” 等同于 “Ä.”</p>

<p><code>NSWidthInsensitiveSearch</code>：一些东亚文字（平假名和片假名）有全宽与半宽两种形式。</p>

<p>很值得一提的是<code>-localizedStandardCompare:</code>，它排序的方式和 Finder 一样。它对应的选项是 <code>NSCaseInsensitiveSearch</code>、<code>NSNumericSearch</code>、<code>NSWidthInsensitiveSearch</code> 以及 <code>NSForcedOrderingSearch</code>。如果我们要在 UI 上显示一个文件列表，用它就最合适不过了。</p>

<p>大小写不敏感的比较和音调符号不敏感的比较都是相对复杂和昂贵的操作。如果我们需要比较很多次字符串那这就会成为一个性能上的瓶颈（例如对一个大的数据集进行排序），一个常见的解决方法是同时存储原始字符串和折叠字符串。例如，我们的 <code>Contact</code> 类有一个正常的 <code>name</code> 属性，在内部它还有一个 <code>foldedName</code> 属性，它将自动在 name 变化时更新。那么我们就可以使用 <code>NSLiteralSearch</code> 来比较 name 的折叠版本。 <code>NSString</code> 有一个方法来创建折叠版本：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">stringByFoldingWithOptions:</span><span class="p">(</span><span class="n">NSStringCompareOptions</span><span class="p">)</span><span class="nv">options</span> <span class="nf">locale:</span><span class="p">(</span><span class="n">NSLocale</span> <span class="o">*</span><span class="p">)</span><span class="nv">locale</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3>搜索</h3>

<p>要在一个字符串中搜索子字符串，最灵活性的方法是:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSRange</span><span class="p">)</span><span class="nf">rangeOfString:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">aString</span> <span class="nf">options:</span><span class="p">(</span><span class="n">NSStringCompareOptions</span><span class="p">)</span><span class="nv">mask</span> <span class="nf">range:</span><span class="p">(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">searchRange</span> <span class="nf">locale:</span><span class="p">(</span><span class="n">NSLocale</span> <span class="o">*</span><span class="p">)</span><span class="nv">locale</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>同时，还有一些便捷方法，它们在最终都会调用上面这个方法，我们可以传入上面列出的参数，以及以下这些额外的参数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSBackwardsSearch</span>
</span><span class="line"><span class="n">NSAnchoredSearch</span>
</span><span class="line"><span class="n">NSRegularExpressionSearch</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>NSBackwardsSearch</code>：在字符串的末尾开始反向搜索。</p>

<p><code>NSAnchoredSearch</code>：只考虑搜索的起始点（单独使用）或终止点（当与 <code>NSBackwardsSearch</code> 结合使用时）。这个方法可以用来检查前缀或者后缀，以及<strong>大小写不敏感（case-insensitive）</strong>或者<strong>音调不敏感（diacritic-insensitive）</strong>的比较。</p>

<p><code>NSRegularExpressionSearch</code>：使用正则表达式搜索，要了解更多与使用正则表达式有关的信息，请关注 Chris 写的字符串解析这篇文章。</p>

<p>另外，还有一个方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSRange</span><span class="p">)</span><span class="nf">rangeOfCharacterFromSet:</span><span class="p">(</span><span class="n">NSCharacterSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">aSet</span> <span class="nf">options:</span><span class="p">(</span><span class="n">NSStringCompareOptions</span><span class="p">)</span><span class="nv">mask</span> <span class="nf">range:</span><span class="p">(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">aRange</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>与前面搜索字符串不同的是，它只搜索给定字符集的第一个字符。即使只搜索一个字符，但如果由于此字符是<strong>由元字符组成的序列（composed character sequence）</strong>，所以返回范围的长度也可能大于1。</p>

<h2>大写与小写</h2>

<p>一定不要使用 <code>NSString</code> 的 <code>-uppercaseString</code> 或者 <code>-lowercaseString</code> 的方法来处理 UI 显示的字符串，而应该使用 <code>-uppercaseStringWithLocale</code> 来代替， 比如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="s">@&quot;Tómas&quot;</span><span class="p">;</span>
</span><span class="line"><span class="n">cell</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="nl">uppercaseStringWithLocale:</span><span class="p">[</span><span class="n">NSLocale</span> <span class="n">currentLocale</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2>格式化字符串</h2>

<p>同 C 语言中的 <code>sprintf</code> 函数（ANSI C89 中的一个函数）类似，Objective C 中的 <code>NSString</code> 类也有如下的 3 个方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span><span class="nf">initWithFormat:</span>
</span><span class="line"><span class="k">-</span><span class="nf">initWithFormat:arguments:</span>
</span><span class="line"><span class="k">+</span><span class="nf">stringWithFormat:</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>需要注意这些格式化方法都是<em>非本地化</em>的。所以这些方法得到的字符串是不能直接拿来显示在用户界面上的。如果需要本地化，那我们需要使用下面这些方法:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span><span class="nf">initWithFormat:locale:</span>
</span><span class="line"><span class="k">-</span><span class="nf">initWithFormat:locale:arguments:</span>
</span><span class="line"><span class="k">+</span><span class="nf">localizedStringWithFormat:</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Florian 有一篇关于<a href="http://objccn.io/issue-9-3/#localized-format-strings">字符串的本地化</a>的文章更详细地讨论了这个问题。</p>

<p><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/printf.3.html">printf(3)</a> 的 man 页面有关于它如何格式化字符串的全部细节。除了以 <code>%</code> 字符开始的所谓<strong>格式转换符（conversion specification）</strong>，格式化字符串会被逐字复制：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">25812.8074434</span><span class="p">;</span>
</span><span class="line"><span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">376.730313461</span><span class="p">;</span>
</span><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%g :: %g&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">];</span>
</span><span class="line"><span class="c1">// &quot;25812.8 :: 376.73&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们格式化了两个浮点数。注意单精度浮点数 <code>float</code> 和双精度浮点数 <code>double</code> 共同了一个格式转换符。</p>

<h3>对象</h3>

<p>除了来自 <code>printf(3)</code> 的转换规范，我们还可以使用 <code>%@</code> 来输出一个对象。在<a href="#object-description">对象描述</a>那一节中有述，如果对象响应 <code>-descriptionWithLocale:</code> 方法，则调用它，否则调用 <code>-description</code>。<code>%@</code> 被结果替换。</p>

<h3>整数</h3>

<p>使用整形数字时，有些需要注意的细节。首先，有符号数（<code>d</code> 和 <code>i</code>）和无符号数（<code>o</code>、<code>u</code>、<code>x</code>和<code>X</code>）的格式转换符是不一样的，需要使用者根据具体情况来选择。</p>

<p>如果我们使用 printf 支持的类型列表之外的类型，就必须要做类型转换。<code>NSUInteger</code> 正是这样一个例子，它在 64 位和 32 位平台上是不一样的。下面的例子可以同时工作在 32 位和 64 位平台上：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">uint64_t</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2305843009213693951</span><span class="p">;</span>
</span><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;The ninth Mersenne prime is %llu&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="p">];</span>
</span><span class="line"><span class="c1">// &quot;The ninth Mersenne prime is 2305843009213693951&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<table>  
  <thead>
  <tr><th style="text-align: left">Modifier          </th><th style="text-align: left">d, i           </th><th style="text-align: left">o, u, x, X</th></tr>
  </thead>
  <tbody>
  <tr><td>hh                </td><td>signed char    </td><td>unsigned char</td></tr>
  <tr><td>h                 </td><td>short          </td><td>unsigned short</td></tr>
  <tr><td>(none)            </td><td>int            </td><td>unsigned int</td></tr>
  <tr><td>l (ell)           </td><td>long           </td><td>unsigned long</td></tr>
  <tr><td>ll (ell ell)      </td><td>long long      </td><td>unsigned long long</td></tr>
  <tr><td>j                 </td><td>intmax_t       </td><td>uintmax_t</td></tr>
  <tr><td>t                 </td><td>ptrdiff_t      </td><td /></tr>
  <tr><td>z                 </td><td>               </td><td>size_t</td></tr>
  </tbody>
</table>

<p>适用于整数的转换规则有：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="o">-</span><span class="mi">150004021</span><span class="p">;</span>
</span><span class="line"><span class="n">uint</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">150004021</span><span class="n">U</span><span class="p">;</span>
</span><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;d:%d i:%i o:%o u:%u x:%x X:%X&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">];</span>
</span><span class="line"><span class="c1">// &quot;d:-150004021 i:-150004021 o:1074160465 u:150004021 x:8f0e135 X:8F0E135&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>%d</code> 和 <code>%i</code> 具有一样的功能，它们都打印出有符号十进制数。<code>%o</code> 就较为晦涩了：它使用<a href="https://en.wikipedia.org/wiki/Octal">八进制</a>表示。<code>%u</code> 输出无符号十进制数——它是我们常用的。最后 <code>%x</code> 和 <code>%X</code> 使用十六进制表示——后者使用大写字母。</p>

<p>对于 <code>x%</code> 和 <code>X%</code>，我们可以在 <code>0x</code> 前面添加 <code>#</code> 前缀，增加可读性。</p>

<p>我们可以传入特定参数，来设置最小字段宽度和最小数字位数（默认两者都是 0），以及左/右对齐。请查看 man 页面获取详细信息。下面是一些例子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;&#39;%4d&#39; &#39;%-4d&#39; &#39;%+4d&#39; &#39;%4.3d&#39; &#39;%04d&#39;&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">];</span>
</span><span class="line"><span class="c1">// &quot;[  42] [42  ] [ +42] [ 042] [0042]&quot;</span>
</span><span class="line"><span class="n">m</span> <span class="o">=</span> <span class="o">-</span><span class="mi">42</span><span class="p">;</span>
</span><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;&#39;%4d&#39; &#39;%-4d&#39; &#39;%+4d&#39; &#39;%4.3d&#39; &#39;%04d&#39;&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">];</span>
</span><span class="line"><span class="c1">// &quot;[ -42] [-42 ] [ -42] [-042] [-042]&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>%p</code> 可用于打印出指针——它和 <code>%#x</code> 相似但可同时在 32 位和 64 位平台上正常工作。</p>

<h3>浮点数</h3>

<p>浮点数的格式转符有8个：<code>eEfFgGaA</code>。但除了 <code>%f</code> 和 <code>%g</code> 外我们很少使用其它的。对于指数部分，小写的版本使用小写 <code>e</code>，大写的版本就使用大写 <code>E</code>。</p>

<p>通常 <code>%g</code> 是浮点数的全能转换符 ，它与 <code>%f</code> 的不同在下面的例子里显示得很清楚：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">double</span> <span class="n">v</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">12345</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mf">0.12</span><span class="p">,</span> <span class="mf">0.12345678901234</span><span class="p">,</span> <span class="mf">0.0000012345678901234</span><span class="p">};</span>
</span><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%g %g %g %g %g&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]];</span>
</span><span class="line"><span class="c1">// &quot;12345 12 0.12 0.123457 1.23457e-06&quot;</span>
</span><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%f %f %f %f %f&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">]];</span>
</span><span class="line"><span class="c1">// &quot;12345.000000 12.000000 0.120000 0.123457 0.000001&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>和整数一样，我们依然可以指定最小字段宽度和最小数字数。</p>

<h3>指定位置</h3>

<p>格式化字符串允许使用参数来改变顺序：</p>

<p>[NSString stringWithFormat:@&#8221;%2$@ %1$@&#8221;, @&#8221;1st&#8221;, @&#8221;2nd&#8221;];</p>

<p>// &#8220;2nd 1st&#8221;</p>

<p>我们只需将从 1 开始的参数与一个 <code>$</code> 接在 <code>%</code> 后面。这种写法在进行本地化的时候极其常见，因为在不同语言中，各个参数所处的顺序位置可能不尽相同。</p>

<h3 id="nslog">NSLog()</h3>

<p><code>NSLog()</code> 函数与 <code>+stringWithFormat:</code> 的工作方式一样。我们可以调用：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">int</span> <span class="n">magic</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span><span class="line"><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;The answer is %d&quot;</span><span class="p">,</span> <span class="n">magic</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>下面的代码可以用同样的方式构造字符串：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">int</span> <span class="n">magic</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;The answer is %d&quot;</span><span class="p">,</span> <span class="n">magic</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>显然 <code>NSLog()</code> 会输出字符串，并且它会加上时间戳、进程名、进程 ID 以及线程 ID 作为前缀。</p>

<h3>实现能接受格式化字符串的方法</h3>

<p>有时在我们自己的类中提供一个能接受格式化字符串的方法会很方便使用。假设我们要实现的是一个 To Do 类的应用，它包含一个  <code>Item</code> 类。我们想要提供：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">itemWithTitleFormat:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">format</span><span class="p">,</span> <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如此我们就可以使用：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">Item</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="p">[</span><span class="n">Item</span> <span class="nl">itemWithFormat:</span><span class="s">@&quot;Need to buy %@ for %@&quot;</span><span class="p">,</span> <span class="n">food</span><span class="p">,</span> <span class="n">pet</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这种类型的方法接受可变数量的参数，所以被称为可变参数方法。我们必须使用一个定义在 <code>stdarg.h</code> 里的宏来使用可变参数。上面方法的实现代码可能会像下面这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">itemWithTitleFormat:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">format</span><span class="p">,</span> <span class="p">...;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">va_list</span> <span class="n">ap</span><span class="p">;</span>
</span><span class="line">    <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
</span><span class="line">    <span class="n">NSString</span> <span class="o">*</span><span class="n">title</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat:</span><span class="n">format</span> <span class="nl">locale:</span><span class="p">[</span><span class="n">NSLocale</span> <span class="n">currentLocale</span><span class="p">]</span> <span class="nl">arguments:</span><span class="n">ap</span><span class="p">];</span>
</span><span class="line">    <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nl">itemWithTitle:</span><span class="n">title</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>进一步，我们要添加 <code>NS_FORMAT_FUNCTION</code> 到方法的定义里（即头文件中），如下所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">itemWithTitleFormat:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">format</span><span class="p">,</span> <span class="p">...</span> <span class="n">NS_FORMAT_FUNCTION</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>NS_FORMAT_FUNCTION</code> 展开为一个方法 <code>__attribute__</code>，它会告诉编译器在索引 <strong>1</strong> 处的参数是一个格式化字符串，而实际参数从索引 <strong>2</strong> 开始。这将允许编译器检查格式化字符串而且会像 <code>NSLog()</code> 和 <code>-[NSString stringWithFormat:]</code> 一样输出警告信息。</p>

<h2>字符与字符串组件</h2>

<p>如有一个字符串 “bird” ，找出组成它的独立字母是很简单的。第二个字母是“i”（Unicode: LATIN SMALL LETTER I）。而对于像<a href="https://en.wikipedia.org/wiki/Åse">Åse</a>这样的字符串就没那么简单了。看起来像三个字母的组合可有多种方式，例如：</p>

<pre><code>A    LATIN CAPITAL LETTER A
 ̊    COMBINING RING ABOVE
s    LATIN SMALL LETTER S
e    LATIN SMALL LETTER E
</code></pre>

<p>或者</p>

<pre><code>Å    LATIN CAPITAL LETTER A WITH RING ABOVE
s    LATIN SMALL LETTER S
e    LATIN SMALL LETTER E
</code></pre>

<p>从 <a href="http://objccn.io/issue-9-1/#peculiar-unicode-features">Ole 写的这篇关于 Unicode 的文章</a> 里可以读到更多关于<strong>联合标记（combining marks）</strong>的信息，其他语言文字有更多复杂的<strong>代理对（complicated surrogate pairs）</strong>。</p>

<p>如果我们要在字符层面处理一个字符串，那我们就要小心翼翼。苹果的文档中 String Programming Guide 里有一节叫做 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html">“Characters and Grapheme Clusters”</a>，里面有更多关于这一点的细节。</p>

<p><code>NSString</code> 有两个方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span><span class="nf">rangeOfComposedCharacterSequencesForRange:</span>
</span><span class="line"><span class="k">-</span><span class="nf">rangeOfComposedCharacterSequenceAtIndex:</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面这两个方法在有的时候很有帮助，例如，拆分一个字符串时保证我们不会把所谓的<strong>代理对（surrogate pairs）</strong>拆散。</p>

<p>如果我们要针对字符串中的字符做文章， NSString 提供了下面这个方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span><span class="nf">enumerateSubstringsInRange:options:usingBlock:</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>options 这里传入 <code>NSStringEnumerationByComposedCharacterSequences</code> 这个参数，就可以扫描所有的字符。例如，用下面的方法，我们可将字符串 “International Business Machines” 变成 “IBM”：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">initials</span><span class="p">;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSMutableString</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableString</span> <span class="n">string</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">enumerateSubstringsInRange:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="nl">options:</span><span class="n">NSStringEnumerationByWords</span> <span class="o">|</span> <span class="n">NSStringEnumerationLocalized</span> <span class="nl">usingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">word</span><span class="p">,</span> <span class="n">NSRange</span> <span class="n">wordRange</span><span class="p">,</span> <span class="n">NSRange</span> <span class="n">enclosingWordRange</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">__block</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">firstLetter</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">          <span class="p">[</span><span class="n">self</span> <span class="nl">enumerateSubstringsInRange:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">word</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="nl">options:</span><span class="n">NSStringEnumerationByComposedCharacterSequences</span> <span class="nl">usingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">letter</span><span class="p">,</span> <span class="n">NSRange</span> <span class="n">letterRange</span><span class="p">,</span> <span class="n">NSRange</span> <span class="n">enclosingLetterRange</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop2</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">              <span class="n">firstLetter</span> <span class="o">=</span> <span class="n">letter</span><span class="p">;</span>
</span><span class="line">              <span class="o">*</span><span class="n">stop2</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line">          <span class="p">}];</span>
</span><span class="line">          <span class="k">if</span> <span class="p">(</span><span class="n">firstLetter</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">              <span class="p">[</span><span class="n">result</span> <span class="nl">appendString:</span><span class="n">firstLetter</span><span class="p">];</span>
</span><span class="line">        <span class="p">};</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如文档所示，词和句的分界可能基于地区的变化而变化。因此有 <code>NSStringEnumerationLocalized</code> 这个选项。</p>

<h2>多行文字字面量</h2>

<p>编译器的确有一个隐蔽的特性：把空格分隔开的字符串衔接到一起。这是什么意思呢？这段代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">limerick</span> <span class="o">=</span> <span class="s">@&quot;A lively young damsel named Menzies</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class="line"><span class="s">@&quot;Inquired: «Do you know what this thenzies?»</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class="line"><span class="s">@&quot;Her aunt, with a gasp,</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class="line"><span class="s">@&quot;Replied: &quot;</span><span class="n">It</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">a</span> <span class="n">wasp</span><span class="p">,</span><span class="err">\</span><span class="n">n</span><span class="s">&quot;</span>
</span><span class="line"><span class="s">@&quot;And you&#39;re holding the end where the stenzies.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>与下面这段代码是完全等价的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">limerick</span> <span class="o">=</span> <span class="s">@&quot;A lively young damsel named Menzies</span><span class="se">\n</span><span class="s">Inquired: «Do you know what this thenzies?»</span><span class="se">\n</span><span class="s">Her aunt, with a gasp,</span><span class="se">\n</span><span class="s">Replied: &quot;</span><span class="n">It</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">a</span> <span class="n">wasp</span><span class="p">,</span><span class="err">\</span><span class="n">nAnd</span> <span class="n">you</span><span class="err">&#39;</span><span class="n">re</span> <span class="n">holding</span> <span class="n">the</span> <span class="n">end</span> <span class="n">where</span> <span class="n">the</span> <span class="n">stenzies</span><span class="p">.</span><span class="err">\</span><span class="n">n</span><span class="s">&quot;;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>前者看起来更舒服，但是有一点要注意：千万不要在任意一行末尾加入逗号或者分号。</p>

<p>你也可以这样做：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSString</span> <span class="o">*</span> <span class="n">string</span> <span class="o">=</span> <span class="s">@&quot;The man &quot;</span> <span class="s">@&quot;who knows everything &quot;</span> <span class="s">@&quot;learns nothing&quot;</span> <span class="s">@&quot;.&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>编译器只是为我们提供了一个便捷的方式，将多个字符串在编译期组合在了一起。</p>

<h2>可变字符串</h2>

<p>可变字符串有两个常见的使用场景：（1）拼接字符串（2）替换子字符串</p>

<h3>拼接字符串</h3>

<p>可变字符串可以很轻易地把多个字符串按照你的需要组合起来。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">magicToken</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSMutableString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableString</span> <span class="n">string</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">usePrefix</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">string</span> <span class="nl">appendString:</span><span class="s">@&quot;&amp;gt;&amp;gt;&amp;gt;&quot;</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="p">[</span><span class="n">string</span> <span class="nl">appendFormat:</span><span class="s">@&quot;%d--%d&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">foo</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">bar</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">useSuffix</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">string</span> <span class="nl">appendString:</span><span class="s">@&quot;&amp;gt;&amp;gt;&amp;gt;&quot;</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">string</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里要注意的是，虽然原本返回值应该是一个 <code>NSString</code> 类型的对象，我们在这里只是简单地返回一个 <code>NSMutableString</code> 类型的对象。</p>

<h3>替换子字符串</h3>

<p>除了追加组合之外，<code>NSMutableString</code> 还提供了以下4个方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span><span class="nf">deleteCharactersInRange:</span>
</span><span class="line"><span class="k">-</span><span class="nf">insertString:atIndex:</span>
</span><span class="line"><span class="k">-</span><span class="nf">replaceCharactersInRange:withString:</span>
</span><span class="line"><span class="k">-</span><span class="nf">replaceOccurrencesOfString:withString:options:range:</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>NSString</code> 也有类似的方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span><span class="nf">stringByReplacingOccurrencesOfString:withString:</span>
</span><span class="line"><span class="k">-</span><span class="nf">stringByReplacingOccurrencesOfString:withString:options:range:</span>
</span><span class="line"><span class="k">-</span><span class="nf">stringByReplacingCharactersInRange:withString:</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>但是 <code>NSMutableString</code> 的那些方法不会创建新的字符串，而仅仅改变当前字符串。这样会让代码更容易阅读，有时也会提升一些性能。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSMutableString</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span> <span class="c1">// 假设我们已经有了一个名为 string 的字符串</span>
</span><span class="line"><span class="c1">// 现在要去掉它的一个前缀，做法如下:</span>
</span><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">prefix</span> <span class="o">=</span> <span class="s">@&quot;WeDon’tWantThisPrefix&quot;</span>
</span><span class="line"><span class="n">NSRange</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">string</span> <span class="nl">rangeOfString:</span><span class="n">prefix</span> <span class="nl">options:</span><span class="n">NSAnchoredSearch</span> <span class="nl">range:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">string</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="nl">locale:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">location</span> <span class="o">!=</span> <span class="n">NSNotFound</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">string</span> <span class="nl">deleteCharactersInRange:</span><span class="n">r</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2>连接组件</h2>

<p>一个看似微不足道但很常见的情况是字符串连接。比如现在有这样几个字符串：</p>

<pre><code>Hildr
Heidrun
Gerd
Guðrún
Freya
Nanna
Siv
Skaði
Gróa
</code></pre>

<p>我们想用它们来创建下面这样的一个字符串：</p>

<pre><code>Hildr, Heidrun, Gerd, Guðrún, Freya, Nanna, Siv, Skaði, Gróa
</code></pre>

<p>那么就可以这样做：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">names</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="s">&quot;Hildr&quot;</span><span class="p">,</span> <span class="s">@&quot;Heidrun&quot;</span><span class="p">,</span> <span class="s">@&quot;Gerd&quot;</span><span class="p">,</span> <span class="s">@&quot;Guðrún&quot;</span><span class="p">,</span> <span class="s">@&quot;Freya&quot;</span><span class="p">,</span> <span class="s">@&quot;Nanna&quot;</span><span class="p">,</span> <span class="s">@&quot;Siv&quot;</span><span class="p">,</span> <span class="s">@&quot;Skaði&quot;</span><span class="p">,</span> <span class="s">@&quot;Gróa&quot;</span><span class="p">];</span>
</span><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span> <span class="nl">componentsJoinedByString:</span><span class="s">@&quot;, &quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果我们将其显示给用户，我们就要使用本地化表达，确保将最后一部分替换相应语言的 “, and” ：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">NSArray</span> <span class="nl">(ObjcIO_GroupedComponents)</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">groupedComponentsWithLocale:</span><span class="p">(</span><span class="n">NSLocale</span> <span class="o">*</span><span class="p">)</span><span class="nv">locale</span><span class="p">;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="s">@&quot;&quot;</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">self</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">NSString</span> <span class="o">*</span><span class="n">joiner</span> <span class="o">=</span> <span class="n">NSLocalizedString</span><span class="p">(</span><span class="s">@&quot;joiner.2components&quot;</span><span class="p">,</span> <span class="s">@&quot;&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%@%@%@&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">joiner</span><span class="p">,</span> <span class="n">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]];</span>
</span><span class="line">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">        <span class="n">NSString</span> <span class="o">*</span><span class="n">joiner</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%@ &quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">locale</span> <span class="nl">objectForKey:</span><span class="n">NSLocaleGroupingSeparator</span><span class="p">]];</span>
</span><span class="line">        <span class="n">NSArray</span> <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">subarrayWithRange:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)];</span>
</span><span class="line">        <span class="n">NSMutableString</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableString</span> <span class="nl">stringWithString:</span><span class="p">[</span><span class="n">first</span> <span class="nl">componentsJoinedByString:</span><span class="n">joiner</span><span class="p">]];</span>
</span><span class="line">
</span><span class="line">        <span class="n">NSString</span> <span class="o">*</span><span class="n">lastJoiner</span> <span class="o">=</span> <span class="n">NSLocalizedString</span><span class="p">(</span><span class="s">@&quot;joiner.3components&quot;</span><span class="p">,</span> <span class="s">@&quot;&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="p">[</span><span class="n">result</span> <span class="nl">appendString:</span><span class="n">lastJoiner</span><span class="p">];</span>
</span><span class="line">        <span class="p">[</span><span class="n">result</span> <span class="nl">appendString:</span><span class="n">self</span><span class="p">.</span><span class="n">lastObject</span><span class="p">];</span>
</span><span class="line">        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>那么在本地化的时候，如果是英语，应该是：</p>

<pre><code>"joiner.2components" = " and ";
"joiner.3components" = ", and ";
</code></pre>

<p>如果是德语，则应该是：</p>

<pre><code>"joiner.2components" = " und ";
"joiner.3components" = " und ";
</code></pre>

<p>结合组件的逆过程可以用 <code>-componentsSeparatedByString:</code>，这个方法会将字符串变成一个数组。例如，将 “12|5|3” 变成 “12”、“5” 和 “3”。</p>

<p><a name="object-description"> </a>  </p>

<h2>对象描述</h2>

<p>在许多面向对象编程语言里，对象有一个叫做 <code>toString()</code> 或类似的方法。在 Objective C 里，这个方法是：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>以及它的兄弟方法:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">debugDescription</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>当自定义模型对象时，覆写 <code>-description</code> 方法是一个好习惯，在 UI 上显示该对象时调用的就是该方法的返回值。假定我们有一个 <code>Contact</code> 类，下面是它的 <code>-description</code> 方法的实现：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们可以像下面代码这样格式化字符串：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">label</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="n">NSLocalizedString</span><span class="p">(</span><span class="s">@&quot;%@ has been added to the group “%@”.&quot;</span><span class="p">,</span> <span class="s">@&quot;&quot;</span><span class="p">),</span> <span class="n">contact</span><span class="p">,</span> <span class="n">group</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>因为该字符串是用来做 UI 显示的，我们可能需要做本地化，那么我们就需要覆写下面这个方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">descriptionWithLocale:</span><span class="p">(</span><span class="n">NSLocale</span> <span class="o">*</span><span class="p">)</span><span class="nv">locale</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>格式转换符 <code>%@</code> 会首先调用 <code>-descriptionWithLocale</code>，如果没有返回值，再调用 <code>-description</code>。</p>

<p>在调试时，打印一个对象，我们用 <code>po</code> 这个命令（它是 print object 的缩写）：</p>

<pre><code>(lldb) po contact
</code></pre>

<p>它会调用对象的 <code>debugDescription</code> 方法。默认情况下 <code>debugDescription</code> 是直接调用 <code>description</code>。如果你希望输出不同的信息，那么就分别覆写两个方法。大多数情况下，尤其是对于非数据模型的对象，你只需要覆写 <code>-description</code> 就能满足需求了。</p>

<p>实际上对象的标准格式化输出是这样的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span><span class="p">;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;&amp;lt;%@: %p&amp;gt;&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">class</span><span class="p">,</span> <span class="n">self</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>NSObject</code> 这个类内部就是这么实现的。当你覆写该方法时，也可以像这样写。假定我们有一个 <code>DetailViewController</code>，在它的UI上要显示一个 <code>contact</code>，我们可能会这样覆写该方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span><span class="p">;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;&amp;lt;%@: %p&amp;gt; contact = %@&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">class</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">contact</span><span class="p">.</span><span class="n">debugDescription</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="nsmanagedobject"><code>NSManagedObject</code> 子类的描述</h3>

<p>我们将特别注意向 <code>NSManagedObject</code> 的子类添加 <code>-description</code>/<code>-debugDescription</code> 的情况。由于 Core Data 的<strong>惰性加载机制（faulting mechanism）</strong>允许未加载数据的对象存在，所以当我们调用 <code>-debugDescription</code> 时我们并不希望改变应用程序的状态，因此需要检查 <code>isFault</code> 这个属性。例如，我们可如下这样实现它：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">debugDescription</span><span class="p">;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSMutableString</span> <span class="o">*</span><span class="n">description</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;&amp;lt;%@: %p&amp;gt;&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">class</span><span class="p">,</span> <span class="n">self</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">self</span><span class="p">.</span><span class="n">isFault</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">description</span> <span class="nl">appendFormat:</span><span class="s">@&quot; %@ </span><span class="se">\&quot;</span><span class="s">%@</span><span class="se">\&quot;</span><span class="s"> %gL&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">metricVolume</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">description</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>再次，因为它们是模型对象，重载 <code>-description</code> 简单地返回描述实例的属性名就可以了。</p>

<h3>文件路径</h3>

<p>简单来说就是我们不应该使用 <code>NSString</code> 来描述文件路径。对于 OS X 10.7 和 iOS 5，<code>NSURL</code> 更便于使用，而且更有效率，它还能缓存文件系统的属性。</p>

<p>再者，<code>NSURL</code> 有八个方法来访问被称为 <em>resource values</em> 的东西。这些方法提供了一个稳定的接口，使我们可以用来获取和设置文件与目录的各种属性，例如本地化文件名（<code>NSURLLocalizedNameKey</code>）、文件大小（<code>NSURLFileSizeKey</code>），以及创建日期（<code>NSURLCreationDateKey</code>），等等。</p>

<p>尤其是在遍历目录内容时，使用 
<code>-[NSFileManager enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:]</code>，并传入一个<strong>关键词（keys）</strong>列表，然后用 <code>-getResourceValue:forKey:error:</code> 检索它们，能带来显著的性能提升。

<p>下面是一个简短的例子展示了如何将它们组合在一起：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line"><span class="n">NSFileManager</span> <span class="o">*</span><span class="n">fm</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSFileManager</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line"><span class="n">NSURL</span> <span class="o">*</span><span class="n">documents</span> <span class="o">=</span> <span class="p">[</span><span class="n">fm</span> <span class="nl">URLForDirectory:</span><span class="n">NSDocumentationDirectory</span> <span class="nl">inDomain:</span><span class="n">NSUserDomainMask</span> <span class="nl">appropriateForURL:</span><span class="nb">nil</span> <span class="nl">create:</span><span class="n">NO</span> <span class="nl">error:</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">error</span><span class="p">];</span>
</span><span class="line"><span class="n">NSArray</span> <span class="o">*</span><span class="n">properties</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="n">NSURLLocalizedNameKey</span><span class="p">,</span> <span class="n">NSURLCreationDateKey</span><span class="p">];</span>
</span><span class="line"><span class="n">NSDirectoryEnumerator</span> <span class="o">*</span><span class="n">dirEnumerator</span> <span class="o">=</span> <span class="p">[</span><span class="n">fm</span> <span class="nl">enumeratorAtURL:</span><span class="n">documents</span>
</span><span class="line">                                <span class="nl">includingPropertiesForKeys:</span><span class="n">properties</span>
</span><span class="line">                                                   <span class="nl">options:</span><span class="mi">0</span>
</span><span class="line">                                              <span class="nl">errorHandler:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="n">fileURL</span> <span class="k">in</span> <span class="n">dirEnumerator</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">NSString</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">    <span class="n">NSDate</span> <span class="o">*</span><span class="n">creationDate</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">fileURL</span> <span class="nl">getResourceValue:</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">name</span> <span class="nl">forKey:</span><span class="n">NSURLLocalizedNameKey</span> <span class="nl">error:</span><span class="nb">NULL</span><span class="p">]</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span>
</span><span class="line">        <span class="p">[</span><span class="n">fileURL</span> <span class="nl">getResourceValue:</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">creationDate</span> <span class="nl">forKey:</span><span class="n">NSURLCreationDateKey</span> <span class="nl">error:</span><span class="nb">NULL</span><span class="p">])</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;&#39;%@&#39; was created at %@&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">creationDate</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们把属性的键传给 <code>-enumeratorAtURL:...</code> 方法中，在遍历目录内容时，这个方法能确保用非常高效的方式获取它们。在循环中，调用 <code>-getResourceValue:...</code> 能简单地从 <code>NSURL</code> 得到已缓存的值，而不用去访问文件系统。</p>

<h2 id="unixapi">传递路径到 UNIX API</h2>

<p>因为 Unicode 非常复杂，同一个字母有多种表示方式，所以我们在传递路径给 UNIX API 时需要非常小心。在这些情况里，一定不能使用 <code>UTF8String</code>，正确的做法是使用 <code>-fileSystemRepresentation</code> 这个方法，如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSURL</span> <span class="o">*</span><span class="n">documentURL</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSFileManager</span> <span class="n">defaultManager</span><span class="p">]</span> <span class="nl">URLForDirectory:</span><span class="n">NSDocumentDirectory</span> <span class="nl">inDomain:</span><span class="n">NSUserDomainMask</span> <span class="nl">appropriateForURL:</span><span class="nb">nil</span> <span class="nl">create:</span><span class="n">NO</span> <span class="nl">error:</span><span class="nb">NULL</span><span class="p">];</span>
</span><span class="line"><span class="n">documentURL</span> <span class="o">=</span> <span class="p">[</span><span class="n">documentURL</span> <span class="nl">URLByAppendingPathComponent:</span><span class="n">name</span><span class="p">];</span>
</span><span class="line"><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">documentURL</span><span class="p">.</span><span class="n">fileSystemRepresentation</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>与 <code>NSURL</code> 类似，同样的情况也发生在 <code>NSString</code> 上。如果我们不这么做，在打开一个文件名或路径名包含合成字符的文件时我们将看到随机错误。在 OS X 上，当用户的短名刚好包含合成字符时就会显得特别糟糕，比如 <code>tómas</code>。</p>

<p>有时我们可能需要路径是一个不可变的常量，即 <code>char const *</code>，一个常见的例子就是 UNIX 的 <code>open()</code> 和 <code>close()</code> 指令。但这种需求也可能发生在使用 GCD / libdispatch 的 I/O API 上。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">dispatch_io_t</span>
</span><span class="line"><span class="nf">dispatch_io_create_with_path</span><span class="p">(</span><span class="n">dispatch_io_type_t</span> <span class="n">type</span><span class="p">,</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">,</span>
</span><span class="line">    <span class="n">dispatch_queue_t</span> <span class="n">queue</span><span class="p">,</span>
</span><span class="line">    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">cleanup_handler</span><span class="p">)(</span><span class="kt">int</span> <span class="n">error</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果我们要使用 <code>NSString</code> 来做这件事，那我们要保证像下面这样做：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="p">...</span> <span class="c1">// 假设这个字符串已经存在</span>
</span><span class="line"><span class="n">io</span> <span class="o">=</span> <span class="n">dispatch_io_create_with_path</span><span class="p">(</span><span class="n">DISPATCH_IO_STREAM</span><span class="p">,</span>
</span><span class="line">    <span class="n">path</span><span class="p">.</span><span class="n">fileSystemRepresentation</span><span class="p">,</span>
</span><span class="line">    <span class="n">O_RDONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">cleanupHandler</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>-fileSystemRepresentation</code> 所做的是它首先将这个字符串转换成文件系统的<a href="http://objccn.io/issue-9-1/#normalization-forms">规范形式</a>然后用 UTF-8 编码。</p>

<hr /><p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-09T16:33:17+08:00" data-updated="true" itemprop="datePublished">Apr 9<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/09/zheng-ji-de-tableviewdai-ma/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/09/zheng-ji-de-tableviewdai-ma/" itemprop="url">整洁的TableView代码</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Table view 是 iOS 应用程序中非常通用的组件。许多代码和 table view 都有直接或间接的关系，随便举几个例子，比如提供数据、更新 table view，控制它的行为以及响应选择事件。在这篇文章中，我们将会展示保持 table view 相关代码的整洁和良好组织的技术。</p>

<h2 id="uitableviewcontrollervsuiviewcontroller">UITableViewController vs. UIViewController</h2>

<p>Apple 提供了 <code>UITableViewController</code> 作为 table views 专属的 view controller 类。Table view controllers 实现了一些非常有用的特性，来帮你避免一遍又一遍地写那些死板的代码！但是话又说回来，table view controller 只限于管理一个全屏展示的 table view。大多数情况下，这就是你想要的，但如果不是，还有其他方法来解决这个问题，就像下面我们展示的那样。</p>

<h3 id="tableviewcontrollers">Table View Controllers 的特性</h3>

<p>Table view controllers 会在第一次显示 table view 的时候帮你加载其数据。另外，它还会帮你切换 table view 的编辑模式、响应键盘通知、以及一些小任务，比如闪现侧边的滑动提示条和清除选中时的背景色。为了让这些特性生效，当你在子类中覆写类似 <code>viewWillAppear:</code> 或者 <code>viewDidAppear:</code> 等事件方法时，需要调用 super 版本。</p>

<p>Table view controllers 相对于标准 view controllers 的一个特别的好处是它支持 Apple 实现的“下拉刷新”。目前，文档中唯一的使用 <code>UIRefreshControl</code> 的方式就是通过 table view controller ，虽然通过努力在其他地方也能让它工作（<a href="http://stackoverflow.com/questions/12805003/uirefreshcontrol-issues">见此处</a>），但很可能在下一次 iOS 更新的时候就不行了。</p>

<p>这些要素加一起，为我们提供了大部分 Apple 所定义的标准 table view 交互行为，如果你的应用恰好符合这些标准，那么直接使用 table view controllers 来避免写那些死板的代码是个很好的方法。</p>

<h3 id="tableviewcontrollers">Table View Controllers 的限制</h3>

<p>Table view controllers 的 view 属性永远都是一个 table view。如果你稍后决定在 table view 旁边显示一些东西（比如一个地图），如果不依赖于那些奇怪的 hacks，估计就没什么办法了。</p>

<p>如果你是用代码或 .xib 文件来定义的界面，那么迁移到一个标准 view controller 将会非常简单。但是如果你使用了 storyboards，那么这个过程要多包含几个步骤。除非重新创建，否则你并不能在 storyboards 中将 table view controller 改成一个标准的 view controller。这意味着你必须将所有内容拷贝到新的 view controller，然后再重新连接一遍。</p>

<p>最后，你需要把迁移后丢失的 table view controller 的特性给补回来。大多数都是 <code>viewWillAppear:</code> 或 <code>viewDidAppear:</code> 中简单的一条语句。切换编辑模式需要实现一个 action 方法，用来切换 table view 的 <code>editing</code> 属性。大多数工作来自重新创建对键盘的支持。</p>

<p>在选择条路之前，其实还有一个更轻松的选择，它可以通过分离我们需要关心的功能（关注点分离），让你获得额外的好处：</p>

<h3 id="childviewcontrollers">使用Child View Controllers</h3>

<p>和完全抛弃 table view controller 不同，你还可以将它作为 child view controller 添加到其他 view controller 中（<a href="http://objccn.io/issue-1-4">关于此话题的文章</a>）。这样，parent view controller 在管理其他的你需要的新加的界面元素的同时，table view controller 还可以继续管理它的 table view。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addPhotoDetailsTableView</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">DetailsViewController</span> <span class="o">*</span><span class="n">details</span> <span class="o">=</span> <span class="p">[[</span><span class="n">DetailsViewController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="n">details</span><span class="p">.</span><span class="n">photo</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">photo</span><span class="p">;</span>
</span><span class="line">    <span class="n">details</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span> <span class="nl">addChildViewController:</span><span class="n">details</span><span class="p">];</span>
</span><span class="line">    <span class="n">CGRect</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
</span><span class="line">    <span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">110</span><span class="p">;</span>
</span><span class="line">    <span class="n">details</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview:</span><span class="n">details</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">details</span> <span class="nl">didMoveToParentViewController:</span><span class="n">self</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果你使用这个解决方案，你就必须在 child view controller 和 parent view controller 之间建立消息传递的渠道。比如，如果用户选择了一个 table view 中的 cell，parent view controller 需要知道这个事件来推入其他 view controller。根据使用习惯，通常最清晰的方式是为这个 table view controller 定义一个 delegate protocol，然后到 parent view controller 中去实现。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@protocol</span> <span class="nc">DetailsViewControllerDelegate</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">didSelectPhotoAttributeWithKey:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span><span class="p">;</span>
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line"><span class="k">@interface</span> <span class="nc">PhotoViewController</span> <span class="p">()</span>
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">PhotoViewController</span>
</span><span class="line"><span class="c1">// ...</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">didSelectPhotoAttributeWithKey:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">DetailViewController</span> <span class="o">*</span><span class="n">controller</span> <span class="o">=</span> <span class="p">[[</span><span class="n">DetailViewController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="n">controller</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">navigationController</span> <span class="nl">pushViewController:</span><span class="n">controller</span> <span class="nl">animated:</span><span class="n">YES</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>就像你看到的那样，这种结构为 view controller 之间的消息传递带来了额外的开销，但是作为回报，代码封装和分离非常清晰，有更好的复用性。根据实际情况的不同，这既可能让事情变得更简单，也可能会更复杂，需要读者自行斟酌和决定。</p>

<h2 id="separatingconcerns">分离关注点（Separating Concerns）</h2>

<p>当处理 table views 的时候，有许多各种各样的任务，这些任务穿梭于 models，controllers 和 views 之间。为了避免让 view controllers 做所有的事，我们将尽可能地把这些任务划分到合适的地方，这样有利于阅读、维护和测试。</p>

<p>这里描述的技术是文章<a href="http://objccn.io/issue-1-1">更轻量的 View Controllers</a> 中的概念的延伸，请参考这篇文章来理解如何重构 data source 和 model 的逻辑。结合 table views，我们来具体看看如何在 view controllers 和 views 之间分离关注点。</p>

<h3 id="modelcells">搭建 Model 对象和 Cells 之间的桥梁</h3>

<p>有时我们需要将想显示的 model 层中的数据传到 view 层中去显示。由于我们同时也希望让 model 和 view 之间明确分离，所以通常把这个任务转移到 table view 的 data source 中去处理：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">UITableViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span>
</span><span class="line">         <span class="nf">cellForRowAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">PhotoCell</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">tableView</span> <span class="nl">dequeueReusableCellWithIdentifier:</span><span class="s">@&quot;PhotoCell&quot;</span><span class="p">];</span>
</span><span class="line">    <span class="n">Photo</span> <span class="o">*</span><span class="n">photo</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">itemAtIndexPath:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class="line">    <span class="n">cell</span><span class="p">.</span><span class="n">photoTitleLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">photo</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</span><span class="line">    <span class="n">NSString</span><span class="o">*</span> <span class="n">date</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dateFormatter</span> <span class="nl">stringFromDate:</span><span class="n">photo</span><span class="p">.</span><span class="n">creationDate</span><span class="p">];</span>
</span><span class="line">    <span class="n">cell</span><span class="p">.</span><span class="n">photoDateLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">date</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>但是这样的代码会让 data source 变得混乱，因为它向 data source 暴露了 cell 的设计。最好分解出来，放到 cell 类的一个 category 中。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">PhotoCell</span> <span class="nl">(ConfigureForPhoto)</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">configureForPhoto:</span><span class="p">(</span><span class="n">Photo</span> <span class="o">*</span><span class="p">)</span><span class="nv">photo</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">photoTitleLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">photo</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</span><span class="line">    <span class="n">NSString</span><span class="o">*</span> <span class="n">date</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dateFormatter</span> <span class="nl">stringFromDate:</span><span class="n">photo</span><span class="p">.</span><span class="n">creationDate</span><span class="p">];</span>
</span><span class="line">    <span class="n">self</span><span class="p">.</span><span class="n">photoDateLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">date</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>有了上述代码后，我们的 data source 方法就变得简单了。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">UITableViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span>
</span><span class="line">         <span class="nf">cellForRowAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">PhotoCell</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">tableView</span> <span class="nl">dequeueReusableCellWithIdentifier:</span><span class="n">PhotoCellIdentifier</span><span class="p">];</span>
</span><span class="line">    <span class="p">[</span><span class="n">cell</span> <span class="nl">configureForPhoto:</span><span class="p">[</span><span class="n">self</span> <span class="nl">itemAtIndexPath:</span><span class="n">indexPath</span><span class="p">]];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">cell</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在我们的示例代码中，table view 的 data source 已经<a href="http://objccn.io/issue-1-1">分解到单独的类中了</a>，它用一个设置 cell 的 block 来初始化。这时，这个 block 就变得这样简单了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">TableViewCellConfigureBlock</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">PhotoCell</span> <span class="o">*</span><span class="n">cell</span><span class="p">,</span> <span class="n">Photo</span> <span class="o">*</span><span class="n">photo</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">cell</span> <span class="nl">configureForPhoto:</span><span class="n">photo</span><span class="p">];</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="cells">让 Cells 可复用</h3>

<p>有时多种 model 对象需要用同一类型的 cell 来表示，这种情况下，我们可以进一步让 cell 可以复用。首先，我们给 cell 定义一个 protocol，需要用这个 cell 显示的对象必须遵循这个 protocol。然后简单修改 category 中的设置方法，让它可以接受遵循这个 protocol 的任何对象。这些简单的步骤让 cell 和任何特殊的 model 对象之间得以解耦，让它可适应不同的数据类型。</p>

<h3 id="cellcell">在 Cell 内部控制 Cell 的状态</h3>

<p>如果你想自定义 table views 默认的高亮或选择行为，你可以实现两个 delegate 方法，把点击的 cell 修改成我们想要的样子。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span>
</span><span class="line">        <span class="nf">didHighlightRowAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">PhotoCell</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">tableView</span> <span class="nl">cellForRowAtIndexPath:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class="line">    <span class="n">cell</span><span class="p">.</span><span class="n">photoTitleLabel</span><span class="p">.</span><span class="n">shadowColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">darkGrayColor</span><span class="p">];</span>
</span><span class="line">    <span class="n">cell</span><span class="p">.</span><span class="n">photoTitleLabel</span><span class="p">.</span><span class="n">shadowOffset</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span>
</span><span class="line">        <span class="nf">didUnhighlightRowAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">PhotoCell</span> <span class="o">*</span><span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">tableView</span> <span class="nl">cellForRowAtIndexPath:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class="line">    <span class="n">cell</span><span class="p">.</span><span class="n">photoTitleLabel</span><span class="p">.</span><span class="n">shadowColor</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然而，这两个 delegate 方法的实现又基于了 view controller 知晓 cell 实现的具体细节。如果我们想替换或重新设计 cell，我们必须改写 delegate 代码。View 的实现细节和 delegate 的实现交织在一起了。我们应该把这些细节移到 cell 自身中去。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@implementation</span> <span class="nc">PhotoCell</span>
</span><span class="line"><span class="c1">// ...</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setHighlighted:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">highlighted</span> <span class="nf">animated:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">super</span> <span class="nl">setHighlighted:</span><span class="n">highlighted</span> <span class="nl">animated:</span><span class="n">animated</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">highlighted</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">photoTitleLabel</span><span class="p">.</span><span class="n">shadowColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">darkGrayColor</span><span class="p">];</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">photoTitleLabel</span><span class="p">.</span><span class="n">shadowOffset</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">        <span class="n">self</span><span class="p">.</span><span class="n">photoTitleLabel</span><span class="p">.</span><span class="n">shadowColor</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>总的来说，我们在努力把 view 层和 controller 层的实现细节分离开。delegate 肯定得清楚一个 view 该显示什么状态，但是它不应该了解如何修改 view 结构或者给某些 subviews 设置某些属性以获得正确的状态。所有这些逻辑都应该封装到 view 内部，然后给外部提供一个简单地 API。</p>

<h3 id="cell">控制多个 Cell 类型</h3>

<p>如果一个 table view 里面有多种类型的 cell，data source 方法很快就难以控制了。在我们示例程序中，photo details table 有两种不同类型的 cell：一种用于显示几个星，另一种用来显示一个键值对。为了划分处理不同 cell 类型的代码，data source 方法简单地通过判断 cell 的类型，把任务派发给其他指定的方法。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">UITableViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span>
</span><span class="line">         <span class="nf">cellForRowAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSString</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">keys</span><span class="p">[(</span><span class="n">NSUInteger</span><span class="p">)</span> <span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">];</span>
</span><span class="line">    <span class="kt">id</span> <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">photo</span> <span class="nl">valueForKey:</span><span class="n">key</span><span class="p">];</span>
</span><span class="line">    <span class="n">UITableViewCell</span> <span class="o">*</span><span class="n">cell</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">key</span> <span class="nl">isEqual:</span><span class="n">PhotoRatingKey</span><span class="p">])</span> <span class="p">{</span>
</span><span class="line">        <span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">cellForRating:</span><span class="n">value</span> <span class="nl">indexPath:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">        <span class="n">cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">detailCellForKey:</span><span class="n">key</span> <span class="nl">value:</span><span class="n">value</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">cell</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">RatingCell</span> <span class="o">*</span><span class="p">)</span><span class="nf">cellForRating:</span><span class="p">(</span><span class="n">NSNumber</span> <span class="o">*</span><span class="p">)</span><span class="nv">rating</span>
</span><span class="line">                    <span class="nf">indexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">// ...</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">UITableViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nf">detailCellForKey:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span>
</span><span class="line">                                <span class="nf">value:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">value</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">// ...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="tableview">编辑 Table View</h3>

<p>Table view 提供了易于使用的编辑特性，允许你对 cell 进行删除或重新排序。这些事件都可以让 table view 的 data source 通过 <a href="http://developer.apple.com/library/ios/#documentation/uikit/reference/UITableViewDataSource_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UITableViewDataSource/tableView:commitEditingStyle:forRowAtIndexPath:">delegate 方法</a>得到通知。因此，通常我们能在这些 delegate 方法中看到对数据的进行修改的操作。</p>

<p>修改数据很明显是属于 model 层的任务。Model 应该为诸如删除或重新排序等操作暴露一个 API，然后我们可以在 data source 方法中调用它。这样，controller 就可以扮演 view 和 model 之间的协调者，而不需要知道 model 层的实现细节。并且还有额外的好处，model 的逻辑也变得更容易测试，因为它不再和 view controllers 的任务混杂在一起了。</p>

<h2>总结</h2>

<p>Table view controllers（以及其他的 controller 对象！）应该在 model 和 view 对象之间扮演<a href="http://developer.apple.com/library/mac/#documentation/General/Conceptual/DevPedia-CocoaCore/ControllerObject.html">协调者和调解者的角色</a>。它不应该关心明显属于 view 层或 model 层的任务。你应该始终记住这点，这样 delegate 和 data source 方法会变得更小巧，最多包含一些简单地样板代码。</p>

<p>这不仅减少了 table view controllers 那样的大小和复杂性，而且还把业务逻辑和 view 的逻辑放到了更合适的地方。Controller 层的里里外外的实现细节都被封装成了简单地 API，最终，它变得更加容易理解，也更利于团队协作。</p>

<h3>扩展阅读</h3>

<ul>
<li><a href="http://www.sebastianrehnby.com/blog/2013/01/01/skinnier-controllers-using-view-categories/">Blog: Skinnier Controllers using View Categories</a></li>
<li><a href="http://developer.apple.com/library/ios/#documentation/userexperience/conceptual/tableview_iphone/AboutTableViewsiPhone/AboutTableViewsiPhone.html">Table View Programming Guide</a></li>
<li><a href="http://developer.apple.com/library/mac/#documentation/General/Conceptual/DevPedia-CocoaCore/ControllerObject.html">Cocoa Core Competencies: Controller Object</a></li>
</ul>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-04-09T16:15:22+08:00" data-updated="true" itemprop="datePublished">Apr 9<span>th</span>, 2014</time></div>
		<div class="tags">


	<a class='category' href='/Blog/blog/categories/ios/'>iOS</a>


</div>
		
			<span class="comments"><a href="/Blog/blog/2014/04/09/bing-fa-cheng-xu-kai-fa-ce-shi/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/Blog/blog/2014/04/09/bing-fa-cheng-xu-kai-fa-ce-shi/" itemprop="url">并发程序开发测试</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>在开发高质量应用程序的过程中，测试是一个很重要的工具。在过去，当并发并不是应用程序架构中重要组成部分的时候，测试就相对简单。随着这几年的发展，使用并发设计模式已愈发重要了，想要测试好并发应用程序，已成了一个不小的挑战。</p>

<p>测试并发代码最主要的困难在于程序或信息流不是反映在调用堆栈上。函数并不会立即返回结果给调用者，而是通过回调函数，Block，通知或者一些类似的机制，这些使得测试变得更加困难。</p>

<p>然而，测试异步代码也会带来一些好处，比如可以揭露较差的程序设计，让最终的实现变得更加清晰。</p>

<h2>异步测试的问题</h2>

<p>首先，我们来看一个简单的同步单元测试例子。两个数求和的方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">+</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nf">add:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">a</span> <span class="nf">to:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">b</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>测试这个方法很简单，只需要比较该方法返回的值是否与期望的值相同，如果不相同，则测试失败。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testAddition</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">Calculator</span> <span class="nl">add:</span><span class="mi">2</span> <span class="nl">to:</span><span class="mi">2</span><span class="p">];</span>
</span><span class="line">    <span class="n">STAssertEquals</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">nil</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>接下来，我们利用 Block 将该方法改成异步返回结果。为了模拟测试失败，我们会在方法实现中故意添加一个 bug。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">+</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nf">add:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">a</span> <span class="nf">to:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">b</span> <span class="nf">block:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span><span class="nv">block</span> <span class="p">{</span>
</span><span class="line">    <span class="p">[[</span><span class="n">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">]</span> <span class="nl">addOperationWithBlock:</span><span class="o">^</span><span class="p">{</span>
</span><span class="line">        <span class="n">block</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// 带有bug的实现</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>显然这是一个人为的例子，但是它却真实的反应了在编程中可能经常遇到的问题，只不过实际过程更复杂罢了。</p>

<p>测试上面的方法最简单的做法就是把断言放到 Block 中。尽管我们的方法实现中存在 bug，但是这种测试永远不会失败的:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="c1">// 千万不要使用这些代码！</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testAdditionAsync</span> <span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">Calculator</span> <span class="nl">add:</span><span class="mi">2</span> <span class="nl">to:</span><span class="mi">2</span> <span class="nl">block:</span><span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">STAssertEquals</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">nil</span><span class="p">);</span> <span class="c1">// 永远不会被调用到</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里的断言为什么没失败呢?</p>

<h2 id="sentestingkit">关于SenTestingKit</h2>

<p>XCode4 所使用的测试框架是基于 <a href="http://www.sente.ch/software/ocunit/" title="OCUnit">OCUnit</a>。为了理解之前所提到的异步测试问题，我们需要了解一下测试包中的各个部分之间的执行顺序。下图展示了一个简化的流程。</p>

<p><img src="http://img.objccn.io/issue-2/SenTestingKit-call-stack.png" style="width:698px" alt="SenTestingKit call stack" /></p>

<p>在测试框架在主 run loop 开始运行之后，主要执行了以下几个步骤：</p>

<ol>
<li>配置一个包含所有相关测试的测试包 (比如可以在工程的 scheme 中配置)。  </li>
<li>运行测试包，内部会调用所有以 <em>test</em> 开头测试用例的方法。运行结束后会返回一个包含单个测试结果的对象。  </li>
<li>调用 <code>exit()</code> 退出测试。</li>
</ol>

<p>这其中我们最感兴趣的是单个测试是如何被调用的。在异步测试中，包含断言的 Block 会被加到主 run loop。当所有的测试执行完毕后，测试框架就会退出，而 block 却从来没有被执行，因此不会引起测试失败。</p>

<p>当然我们有很多种方发来解决这个问题。但是所有的方法都必须在主 run loop 中运行，而且在测试方法返回和比较结果之前需要处理已入队所有操作。</p>

<p><a href="https://github.com/allending/Kiwi" title="Kiwi">Kiwi</a> 使用探测轮询 (probe poller)，它可以在测试方法中被调用。 <a href="https://github.com/gabriel/gh-unit/" title="GHUnit">GHUnit</a> 编写了一个单独的测试类，它必须在测试的方法内初始化，并在结束时接收一个通知。以上两种方式都是通过编写相应的代码来确保异步测试方法在测试结束之前都不会返回。</p>

<h2 id="sentestingkit">SenTestingKit的异步扩展</h2>

<p>我们对这个问题的解决方案是对 SenTestingKit 添加一个<a href="https://github.com/nxtbgthng/SenTestingKitAsync" title="SenTestingKitAsync">扩展</a>，它在栈上使用同步执行，并把每个部分加入到主队列上。正如下图所见，在验证整个测试框架结果之前，报告异步测试成功或者失败的 Block 就被加入到队列。这种执行顺序允许我们开启一个测试并等待它的测试结果。</p>

<p><img src="http://img.objccn.io/issue-2/SenTestingKitAsync-call-stack.png" style="width:531px" alt="SenTestingKitAsync call stack" /></p>

<p>如果测试方法以 <strong>Async</strong> 结尾，框架就会认为该方法是异步测试。此外，在异步测试中，我们必须手动地报告测试成功，同时为了防止 Block 永远不会被调用，我们还需添加了一个超时方法。之前的错误的测试方法修改后如下所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testAdditionAsync</span> <span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">Calculator</span> <span class="nl">add:</span><span class="mi">2</span> <span class="nl">to:</span><span class="mi">2</span> <span class="n">block</span><span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">STAssertEquals</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">nil</span><span class="p">);</span>
</span><span class="line">        <span class="n">STSuccess</span><span class="p">();</span> <span class="c1">// 通过调用这个宏来判断是否测试成功</span>
</span><span class="line">    <span class="p">}];</span>
</span><span class="line">    <span class="n">STFailAfter</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="s">@&quot;Timeout&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2>设计异步测试</h2>

<p>就像同步测试一样，异步测试也应该比被测试的功能简单许多。复杂的测试并不会改进代码的质量，反而会给测试本身带来更多的 Bug。在以测试驱动开发的情况下，简单的测试会让我们对组件，接口以及架构的行为有更清醒的认识。</p>

<h3>示例工程</h3>

<p>为了运用到实际中，我们创建了一个示例框架：<a href="https://github.com/objcio/issue-2-async-testing" title="Pinacoteca Core: Cocoa Framework for an Imaginary Image Service">PinacotecaCore</a>，它从一个虚拟的服务器获取图像信息。框架中包含一个资源管理器，它对外提供一个可以根据图像 Id 获取图像对象的接口。该接口的工作原理是资源管理器从虚拟服务器获取图片对象的信息，并更新到数据库。</p>

<p>虽然这个示例框架只是为了演示，但在我们自己开发的许多应用中也使用了这种模式。</p>

<p><img src="http://img.objccn.io/issue-2/PinacotecaCore.png" style="width:699px" alt="PinacotecaCore architecture" /></p>

<p>从上图我们可以知道，示例框架有三个组件我们需要测试：</p>

<ol>
<li>模型层  </li>
<li>模拟服务器请求的服务器接口控制器（API Controller）  </li>
<li>管理 core data 堆栈以及连接模型层和服务接口控制器的资源管理器</li>
</ol>

<h3>模型层</h3>

<p>测试应该尽量使用同步的方式进行，而模型层就是一个很好的实例。只要不同的被托管对象上下文 (managed object contexts) 之间没有复杂的依赖关系，测试用例都应该根据上下文在主线程上设置它自己的 core data 堆栈，并在其中执行各自的操作。</p>

<p>在这个<a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCModelLayerTests.m" title="Pinacoteca Core Model Layer Tests">测试实例</a>中，我们就是在 <code>setUp</code> 方法中设置 core data 堆栈，然后检查 <code>PCImage</code> 实体的描述是否存在，如果不存在就构造一个，并更新它的值。当然这和异步测试没有关系，我们就不深入细说了。</p>

<h3>服务器接口控制器</h3>

<p>框架中的第二个组件就是服务器接口控制器。它主要处理服务器请求以及服务器 API 到模型的映射关系。让我们来看一下下面这个方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="o">-</span> <span class="p">[</span><span class="n">PCServerAPIController</span> <span class="nl">fetchImageWithId:queue:completionHandler:</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>调用它需要三个形参：一个图片对象 Id，所在的执行队列以及一个完成后的回调方法。</p>

<p>因为服务器根本不存在，一个比较好的做法就是伪造一个代理服务器，正好 <a href="https://github.com/AliSoftware/OHHTTPStubs" title="OHHTTPStubs">OHHTTPStubs</a> 可以解决这个问题。在它的最新版本中，可以在示例的请求响应中包含一个 bundle，发送给客户端。</p>

<p>为了能 stub 请求，OHHTTPStubs 需要在测试类初始化时或者 setUp 方法中进行配置。首先，我们需要加载一个包含请求响应对象（response）的 bundle：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSBundle</span> <span class="nl">bundleForClass:</span><span class="p">[</span><span class="n">self</span> <span class="n">class</span><span class="p">]]</span>
</span><span class="line">                        <span class="nl">URLForResource:</span><span class="s">@&quot;ServerAPIResponses&quot;</span>
</span><span class="line">                         <span class="nl">withExtension:</span><span class="s">@&quot;bundle&quot;</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="n">NSBundle</span> <span class="o">*</span><span class="n">bundle</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSBundle</span> <span class="n">url</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后我们从 bundle 加载 response 对象，作为请求的响应值：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">OHHTTPStubsResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">;</span>
</span><span class="line"><span class="n">response</span> <span class="o">=</span> <span class="p">[</span><span class="n">OHHTTPStubsResponse</span> <span class="nl">responseNamed:</span><span class="s">@&quot;images/123&quot;</span>
</span><span class="line">                                   <span class="nl">fromBundle:</span><span class="n">responsesBundle</span>
</span><span class="line">                                 <span class="nl">responseTime:</span><span class="mf">0.1</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="p">[</span><span class="n">OHHTTPStubs</span> <span class="nl">stubRequestsPassingTest:</span><span class="o">^</span><span class="kt">BOOL</span><span class="p">(</span><span class="n">NSURLRequest</span> <span class="o">*</span><span class="n">request</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">YES</span> <span class="cm">/* 如果所返回的request是我们所期望的，就返回YES */</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span> <span class="nl">withStubResponse:</span><span class="o">^</span><span class="n">OHHTTPStubsResponse</span> <span class="o">*</span><span class="p">(</span><span class="n">NSURLRequest</span> <span class="o">*</span><span class="n">request</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">response</span><span class="p">;</span>
</span><span class="line"><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>通过如上的设置之后，简化版的<a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCServerAPIControllerTests.m" title="Pinacoteca Core Server API Controller Tests">测试服务器接口控制器</a>如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testFetchImageAsync</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">server</span>
</span><span class="line">        <span class="nl">fetchImageWithId:</span><span class="s">@&quot;123&quot;</span>
</span><span class="line">                   <span class="nl">queue:</span><span class="p">[</span><span class="n">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">]</span>
</span><span class="line">       <span class="nl">completionHandler:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">imageData</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">          <span class="n">STAssertEqualObjects</span><span class="p">([</span><span class="n">NSOperationQueue</span> <span class="n">currentQueue</span><span class="p">],</span> <span class="n">queue</span><span class="p">,</span> <span class="nb">nil</span><span class="p">);</span>
</span><span class="line">          <span class="n">STAssertNil</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="p">[</span><span class="n">error</span> <span class="n">localizedDescription</span><span class="p">]);</span>
</span><span class="line">          <span class="n">STAssertTrue</span><span class="p">([</span><span class="n">imageData</span> <span class="nl">isKindOfClass:</span><span class="p">[</span><span class="n">NSDictionary</span> <span class="n">class</span><span class="p">]],</span> <span class="nb">nil</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">          <span class="c1">// 检查返回的字典中的值.</span>
</span><span class="line">
</span><span class="line">          <span class="n">STSuccess</span><span class="p">();</span>
</span><span class="line">       <span class="p">}];</span>
</span><span class="line">    <span class="n">STFailAfter</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="nb">nil</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3>资源管理器</h3>

<p>最后一个部分是资源管理器，它不但把服务器接口控制器和模型层联系起来, 还管理着 core data 堆栈。下面我们想测试获取一个图片对象的方法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="o">-</span><span class="p">[</span><span class="n">PCResourceManager</span> <span class="nl">imageWithId:usingManagedObjectContext:queue:updateHandler:</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>该方法根据 id 返回一个图片对象。如果图片在数据库中不存在，它会创建一个只包含 id 的新对象，然后通过服务器接口控制器获取图片对象的详细信息。</p>

<p>由于资源管理器的测试不应该依赖于服务器接口控制器，所以我们可以用 <a href="http://ocmock.org" title="OCMock">OCMock</a> 来模拟，如果要做方法的部分 stub，它是一个理想的框架。如以下的 <a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCResourceManagerTests.m" title="Pinacoteca Core Resource Manager Tests">资源管理器测试</a> :</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">OCMockObject</span> <span class="o">*</span><span class="n">mo</span><span class="p">;</span>
</span><span class="line"><span class="n">mo</span> <span class="o">=</span> <span class="p">[</span><span class="n">OCMockObject</span> <span class="nl">partialMockForObject:</span><span class="n">self</span><span class="p">.</span><span class="n">resourceManager</span><span class="p">.</span><span class="n">server</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="kt">id</span> <span class="n">exp</span> <span class="o">=</span> <span class="p">[[</span><span class="n">serverMock</span> <span class="n">expect</span><span class="p">]</span>
</span><span class="line">             <span class="nl">andCall:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">fetchImageWithId:queue:completionHandler:</span><span class="p">)</span>
</span><span class="line">            <span class="nl">onObject:</span><span class="n">self</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">exp</span> <span class="nl">fetchImageWithId:</span><span class="n">OCMOCK_ANY</span> <span class="nl">queue:</span><span class="n">OCMOCK_ANY</span> <span class="nl">completionHandler:</span><span class="n">OCMOCK_ANY</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面的代码实际上它并没有真正调用服务器接口控制器的方法，而是调用我们写在测试类中的方法。</p>

<p>用上面的做法，对资源管理的测试就变得很直观。当我们调用资源管理器获取资源时，实际上调用的是我们模拟的服务器接口控制器的方法。这样我们也能检查调用服务器接口控制器时参数是否正确。在调用了获取图像对象的方法后，资源管理器会更新模型，然后调用验证测试成功与否的宏。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testGetImageAsync</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSManagedObjectContext</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">resourceManager</span><span class="p">.</span><span class="n">mainManagedObjectContext</span><span class="p">;</span>
</span><span class="line">    <span class="n">__block</span> <span class="n">PCImage</span> <span class="o">*</span><span class="n">img</span><span class="p">;</span>
</span><span class="line">    <span class="n">img</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">resourceManager</span> <span class="nl">imageWithId:</span><span class="s">@&quot;123&quot;</span>
</span><span class="line">                  <span class="nl">usingManagedObjectContext:</span><span class="n">ctx</span>
</span><span class="line">                                      <span class="nl">queue:</span><span class="p">[</span><span class="n">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">]</span>
</span><span class="line">                              <span class="nl">updateHandler:</span><span class="o">^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                                       <span class="c1">// 检查error是否为空以及image是否已经被更新 </span>
</span><span class="line">                                       <span class="n">STSuccess</span><span class="p">();</span>
</span><span class="line">                                   <span class="p">}];</span>
</span><span class="line">    <span class="n">STAssertNotNil</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="nb">nil</span><span class="p">);</span>
</span><span class="line">    <span class="n">STFailAfter</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="s">@&quot;Timeout&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2>总结</h2>

<p>刚开始时候，使用并发设计模式测试应用程序是具有一定的挑战性，但是一旦你理解了它们的不同，并建立最佳实践，一切都会变得简单而有趣。</p>

<p>在 <a href="http://nxtbgthng.com" title="nxtbgthng">nxtbgthng</a> 项目中，我们用 <a href="https://github.com/nxtbgthng/SenTestingKitAsync" title="SenTestingKitAsync">SenTestingKitAsync</a> 框架来测试。但是像 <a href="https://github.com/allending/Kiwi" title="Kiwi">Kiwi</a> 和 <a href="https://github.com/gabriel/gh-unit/" title="GHUnit">GHUnit</a>  也都是不错的异步测试框架。建议你都可以尝试下，然后找到合适自己的测试工具并开始使用它。</p>

<hr />
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
        <a href="/Blog/blog/page/2/" class="prev">Prev</a>
    
    
        <a href="/Blog/blog/page/4/" class="next">Next</a>
    
    <div class="center"><a href="/Blog/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    Rick


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
</body>
</html>
