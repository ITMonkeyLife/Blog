
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>编写高性能的Swift代码 - IT Monkey Life</title>
	<meta name="author" content="Rick">

	
	<meta name="description" content="下面这篇文档收集了一系列编写高性能 Swift 代码的要诀和技巧。文档的目标读者是编译器和标准库开发人员。 文档中的一些技巧可以帮助提升您的 Swift 程序质量，使您的代码不容易出错且可读性更好。显式地标记最终类和类协议是两个显而易见的例子。 然而文档中还有一些技巧是不符合规矩的，扭曲的， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/Blog/atom.xml" rel="alternate" title="IT Monkey Life" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/Blog/favicon.png" rel="shortcut icon">
	<link href="/Blog/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/Blog/">IT Monkey Life</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/Blog/">Blog</a></li>
	<li><a href="/Blog/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/Blog/">Blog</a></li>
	<li><a href="/Blog/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:ITMonkeyLife.github.io/Blog">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
		<a class="rss" href="/Blog/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:ITMonkeyLife.github.io/Blog">
	</form>
</nav>


</header>
	
		
	
	<div id="content" class="inner"><article class="post">
	<h2 class="title">编写高性能的Swift代码</h2>
	<div class="entry-content"><p>
下面这篇文档收集了一系列编写高性能 Swift 代码的要诀和技巧。文档的目标读者是编译器和标准库开发人员。

文档中的一些技巧可以帮助提升您的 Swift 程序质量，使您的代码不容易出错且可读性更好。显式地标记最终类和类协议是两个显而易见的例子。 然而文档中还有一些技巧是不符合规矩的，扭曲的，仅仅解决一些比编译器或语言的特殊的临时性需求。文档中的很多建议来自于多方面的权衡，例如：运行时、字节大小、代码可读性等等。
</p>
<h2>启用优化</h2>
<p>第一个应该做的事情就是启用优化。Swift 提供了三种不同的优化级别：<br />
<ul>
<li>-Onone: 这意味着正常的开发。它执行最小优化和保存所有调试信息。</li>
<li>-O: 这意味着对于大多数生产代码。编译器执行积极地优化，可以大大改变提交代码的类型和数量。调试信息将被省略但还是会有损害的。</li>
<li>-Ounchecked: 这是一个特殊的优化模式，它意味着特定的库或应用程序，这是以安全性来交换的。编译器将删除所有溢出检查以及一些隐式类型检查。这不是在通常情况下使用的，因为它可能会导致内存安全问题和整数溢出。如果你仔细审查你的代码，那么对整数溢出和类型转换来说是安全的。</li>
<!-- more -->
</ul>
在 Xcode UI 中，可以修改的当前优化级别如下：
</p>
<h2>整个组件优化</h2>
<p>默认情况下Swift单独编译每个文件。这使得Xcode可以非常快速的并行编译多个文件。然而，分开编译每个文件可以预防某些编译器优化。Swift也可以是一个单一的编译单元一样优化这个程序。这个模式可以使用命令行flag-whole-module-optimization来激活。在这种模式下编译的程序将最有可能需要更长时间来编译，但可以运行更快。<br />
这个模式可以通过Xcode构建设置中的<code>Whole Module Optimization</code>来激活。
</p>
<h2>降低动态调度</h2>
<p>
Swift在默认下是一个类似Objective-C的非常动态的语言。与Objective-C不同的是，Swift给了程序员通过消除和减少这种特性来提供运行时性能的能力。本节提供几个可以这样操作的语言结构的示例。
</p>
<h2>动态调度</h2>
<p>
类使用动态调度的方法和默认的属性访问。因此在下面的代码中，a.aProperty、a.doSomething() 和 a.doSomethingElse() 都将通过动态调度来调用：
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">class</span> <span class="n">A</span> <span class="p">{</span>
</span><span class="line">  <span class="n">var</span> <span class="nl">aProperty:</span> <span class="p">[</span><span class="n">Int</span><span class="p">]</span>
</span><span class="line">  <span class="n">func</span> <span class="n">doSomething</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class="line">  <span class="n">dynamic</span> <span class="n">doSomethingElse</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">class</span> <span class="n">B</span> <span class="o">:</span> <span class="n">A</span> <span class="p">{</span>
</span><span class="line">  <span class="n">override</span> <span class="n">var</span> <span class="n">aProperty</span> <span class="p">{</span>
</span><span class="line">    <span class="n">get</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class="line">    <span class="n">set</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">
</span><span class="line">  <span class="n">override</span> <span class="n">func</span> <span class="n">doSomething</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">func</span> <span class="n">usingAnA</span><span class="p">(</span><span class="nl">a:</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="n">a</span><span class="p">.</span><span class="n">doSomething</span><span class="p">()</span>
</span><span class="line">  <span class="n">a</span><span class="p">.</span><span class="n">aProperty</span> <span class="o">=</span> <span class="p">...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<br />
在Swift 中，动态调度默认通过一个vtable（虚函数表）间接调用。如果使用一个dynamic关键字声明，Swift将通过调用Objective-C通知来发送调用代替。这两种情况中，这种情况会比直接的函数调用较慢，因为它防止了对间接调用本身之外的程序开销的编译器优化。在关键性能的代码出，人常常会想限制这种动态行为。
</p>
<h4>建议：当你知道声明不需要被重写时使用<code>final</code></h4>
<p>
final是一个类、方法、或一个属性声明中的一个限制，使这样的声明不会被重写。
这意味着编译器可以调用直接的函数调用来代替间接调用。例如下面的 C.array1 和 D.array1 将会被直接访问。与之相反，D.array2 将通过一个虚函数表访问。
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">final</span> <span class="n">class</span> <span class="n">C</span> <span class="p">{</span>
</span><span class="line">  <span class="c1">// No declarations in class &#39;C&#39; can be overridden.</span>
</span><span class="line">  <span class="n">var</span> <span class="nl">array1:</span> <span class="p">[</span><span class="n">Int</span><span class="p">]</span>
</span><span class="line">  <span class="n">func</span> <span class="n">doSomething</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">class</span> <span class="n">D</span> <span class="p">{</span>
</span><span class="line">  <span class="n">final</span> <span class="n">var</span> <span class="n">array1</span> <span class="p">[</span><span class="n">Int</span><span class="p">]</span> <span class="c1">// &#39;array1&#39; cannot be overridden by a computed property.</span>
</span><span class="line">  <span class="n">var</span> <span class="nl">array2:</span> <span class="p">[</span><span class="n">Int</span><span class="p">]</span>      <span class="c1">// &#39;array2&#39; *can* be overridden by a computed property.</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">func</span> <span class="n">usingC</span><span class="p">(</span><span class="nl">c:</span> <span class="n">C</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">   <span class="n">c</span><span class="p">.</span><span class="n">array1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">...</span> <span class="c1">// Can directly access C.array without going through dynamic dispatch.</span>
</span><span class="line">   <span class="n">c</span><span class="p">.</span><span class="n">doSomething</span><span class="p">()</span> <span class="o">=</span> <span class="p">...</span> <span class="c1">// Can directly call C.doSomething without going through virtual dispatch.</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">func</span> <span class="n">usingD</span><span class="p">(</span><span class="nl">d:</span> <span class="n">D</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">   <span class="n">d</span><span class="p">.</span><span class="n">array1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">...</span> <span class="c1">// Can directly access D.array1 without going through dynamic dispatch.</span>
</span><span class="line">   <span class="n">d</span><span class="p">.</span><span class="n">array2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">...</span> <span class="c1">// Will access D.array2 through dynamic dispatch.</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
</p>

<h4>当声明的不用被文件外部被访问的时候，使用<code>private</code></h4>
<p>将<code>private</code>关键字用在声明上，会限制对其进行了声明的文件的可见性。这会让编辑器有能力甄别出所有其他潜在的覆盖声明。如此，由于没有了任何这样的声明，使得编译器可以自动的推断出<code>final</code>关键字，并对此去掉对方法的间接调用和属性的访问。例如在如下的e.doSomething() 和 f.myPrivateVar 中，就将可以被直接访问，假定在同一个文件中，E,F 并没有任何覆盖的声明：<br />
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">private</span> <span class="n">class</span> <span class="n">E</span> <span class="p">{</span>
</span><span class="line">  <span class="n">func</span> <span class="n">doSomething</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">class</span> <span class="n">F</span> <span class="p">{</span>
</span><span class="line">  <span class="n">private</span> <span class="n">var</span> <span class="n">myPrivateVar</span> <span class="o">:</span> <span class="n">Int</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">func</span> <span class="n">usingE</span><span class="p">(</span><span class="nl">e:</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="n">e</span><span class="p">.</span><span class="n">doSomething</span><span class="p">()</span> <span class="c1">// There is no sub class in the file that declares this class.</span>
</span><span class="line">                  <span class="c1">// The compiler can remove virtual calls to doSomething()</span>
</span><span class="line">                  <span class="c1">// and directly call A’s doSomething method.</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">func</span> <span class="n">usingF</span><span class="p">(</span><span class="nl">f:</span> <span class="n">F</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class="line">  <span class="k">return</span> <span class="n">f</span><span class="p">.</span><span class="n">myPrivateVar</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
</p>
<h2>高效的使用容器类型</h2>
<p>通用的容器 Array 和 Dictionary 是有 Swift 标准库提供的一个重要的功能特性。本节将介绍如何用一种高性能的方式使用这些类型。
</p>
<h4>建议在数组中使用值类型</h4>
<p>
在Swift中，类型可以分成两种不同的类型:值类型（结构体，枚举，元组）和引用类型（类）。一个关键的区分是 NSArray 不能含有值类型。因此当使用值类型时，优化器就不需要去处理对 NSArray 的支持，从而可以在数组上省去大部分消耗。<br />
此外，相比引用类型，如果值类型递归地含有引用类型，那么值类型仅仅需要引用计数器。而如果使用没有引用类型的值类型，就可以避免额外的开销，从而释放数组内的流量。<br />
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="c1">// Don&#39;t use a class here.</span>
</span><span class="line"><span class="k">struct</span> <span class="n">PhonebookEntry</span> <span class="p">{</span>
</span><span class="line">  <span class="n">var</span> <span class="n">name</span> <span class="o">:</span> <span class="n">String</span>
</span><span class="line">  <span class="n">var</span> <span class="n">number</span> <span class="o">:</span> <span class="p">[</span><span class="n">Int</span><span class="p">]</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">var</span> <span class="n">a</span> <span class="o">:</span> <span class="p">[</span><span class="n">PhonebookEntry</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
记住要在使用大值类型和使用引用类型之间做好权衡。在某些情况下，拷贝和移动大值类型数据的消耗要大于移除桥接和持有/释放的消耗。
</p>
<h4>建议当 <code>NSArray</code> 桥接不必要时，使用<code> ContiguousArray </code>存储引用类型。</h4>
<p>
如果你需要一个引用类型的数组，而且数组不需要桥接到 NSArray 时，使用 ContiguousArray 替代 Array：
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">class</span> <span class="n">C</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class="line"><span class="n">var</span> <span class="nl">a:</span> <span class="n">ContiguousArray</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="n">C</span><span class="p">(...),</span> <span class="n">C</span><span class="p">(...),</span> <span class="p">...,</span> <span class="n">C</span><span class="p">(...)]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
</p>
<h4>建议使用适当的改变而不是对象分配。</h4>
<p>
在 Swift 中所有的标准库容器都使用 COW(copy-on-write) 执行拷贝代替即时拷贝。在很多情况下，这可以让编译器通过持有容器而不是深度拷贝，从而省掉不必要的拷贝。如果容器的引用计数大于 1 并容器时被改变时，就会拷贝底层容器。例如：在下面这种情况：当 d 被分配给 c 时不拷贝，但是当 d 经历了结构性的改变追加 2，那么 d 将会被拷贝，然后 2 被追加到 d：
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">var</span> <span class="nl">c:</span> <span class="p">[</span><span class="n">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">...</span> <span class="p">]</span>
</span><span class="line"><span class="n">var</span> <span class="n">d</span> <span class="o">=</span> <span class="n">c</span>        <span class="c1">// No copy will occur here.</span>
</span><span class="line"><span class="n">d</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>      <span class="c1">// A copy *does* occur here.</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
如果用户不小心时，有时 COW 会引起额外的拷贝。例如，在函数中，试图通过对象分配执行修改。在 Swift 中，所有的参数传递时都会被拷贝一份，例如，参数在调用点之前持有一份，然后在调用的函数结束时释放。也就是说，像下面这样的函数：
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="n">append_one</span><span class="p">(</span><span class="nl">a:</span> <span class="p">[</span><span class="n">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">Int</span><span class="p">]</span> <span class="p">{</span>
</span><span class="line">  <span class="n">a</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class="line">  <span class="k">return</span> <span class="n">a</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">var</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span><span class="line"><span class="n">a</span> <span class="o">=</span> <span class="n">append_one</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
尽管由于分配，a 的版本没有任何改变 ，在 append_one后也没有使用 ， 但 a 也许会被拷贝。这可以通过使用 inout 参数来避免这个问题：
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">func</span> <span class="nf">append_one_in_place</span><span class="p">(</span><span class="n">inout</span> <span class="nl">a:</span> <span class="p">[</span><span class="n">Int</span><span class="p">])</span> <span class="p">{</span>
</span><span class="line">  <span class="n">a</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">var</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span><span class="line"><span class="n">append_one_in_place</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<h2>未检查操作</h2>
<p>Swift 通过在执行普通计算时检查溢出的方法解决了整数溢出的 bug。这些检查在已确定没有内存安全问题会发生的高效的代码中，是不合适的。
</p>
<h4>建议当你确切的知道不会发生溢出时使用不检查整型计算</h4>
<p>
在对性能要求高的代码中，如果你知道你的代码是安全的，那么你可以忽略溢出检查。
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">a</span> <span class="o">:</span> <span class="p">[</span><span class="n">Int</span><span class="p">]</span>
</span><span class="line"><span class="n">b</span> <span class="o">:</span> <span class="p">[</span><span class="n">Int</span><span class="p">]</span>
</span><span class="line"><span class="n">c</span> <span class="o">:</span> <span class="p">[</span><span class="n">Int</span><span class="p">]</span>
</span><span class="line">
</span><span class="line"><span class="c1">// Precondition: for all a[i], b[i]: a[i] + b[i] does not overflow!</span>
</span><span class="line"><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span> <span class="p">...</span> <span class="n">n</span> <span class="p">{</span>
</span><span class="line">  <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
</p>
<h4>泛型</h4>
<p>
Swift 通过泛型类型的使用，提供了一个非常强大的抽象机制 。Swift 编译器发出一个可以对任何 T 执行 MySwiftFunc<t> 的具体的代码块。生成的代码需要一个函数指针表和一个包含 T 的盒子作为额外的参数。MySwiftFunc<int>和 MySwiftFunc<string> 之间的不同的行为通过传递不同的函数指针表和通过盒子提供的抽象大小来说明。一个泛型的例子:
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">class</span> <span class="n">MySwiftFunc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">MySwiftFunc</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span> <span class="n">X</span>    <span class="c1">// Will emit code that works with Int...</span>
</span><span class="line"><span class="n">MySwiftFunc</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">Y</span> <span class="c1">// ... as well as String.</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
当优化器启用时，Swift 编译器寻找这段代码的调用，并试着确认在调用中具体使用的类型（例如：非泛型类型）。如果泛型函数的定义对优化器来说是可见的，并知道具体类型，Swift 编译器将生成一个有特殊类型的特殊泛型函数。那么调用这个特殊函数的这个过程就可以避免关联泛型的消耗。一些泛型的例子：
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">class</span> <span class="n">MyStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class="line">  <span class="n">func</span> <span class="n">push</span><span class="p">(</span><span class="nl">element:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class="line">  <span class="n">func</span> <span class="n">pop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">T</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">func</span> <span class="n">myAlgorithm</span><span class="p">(</span><span class="nl">a:</span> <span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="nl">length:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">// The compiler can specialize code of MyStack[Int]</span>
</span><span class="line"><span class="n">var</span> <span class="nl">stackOfInts:</span> <span class="n">MyStack</span><span class="p">[</span><span class="n">Int</span><span class="p">]</span>
</span><span class="line"><span class="c1">// Use stack of ints.</span>
</span><span class="line"><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="p">...</span> <span class="p">{</span>
</span><span class="line">  <span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(...)</span>
</span><span class="line">  <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">(...)</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">var</span> <span class="nl">arrayOfInts:</span> <span class="p">[</span><span class="n">Int</span><span class="p">]</span>
</span><span class="line"><span class="c1">// The compiler can emit a specialized version of &#39;myAlgorithm&#39; targeted for</span>
</span><span class="line"><span class="c1">// [Int]&#39; types.</span>
</span><span class="line"><span class="n">myAlgorithm</span><span class="p">(</span><span class="n">arrayOfInts</span><span class="p">,</span> <span class="n">arrayOfInts</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4>建议将泛型的声明放在使用它的文件中</h4>
<p>只有在泛型声明在当前模块可见的情况下优化器才能执行特殊化。这只有在使用泛型的代码和声明泛型的代码在同一个文件中才能发生。注意标准库是一个例外。在标准库中声明的泛型对所有模块可见并可以进行特殊化。
</p>
<h4>建议允许编译器进行特殊化</h4>
<p>只有当调用位置和被调函数位于同一个编译单元的时候编译器才能对泛型代码进行特殊化。我们可以使用一个技巧让编译器对被调函数进行优化，这个技巧就是在被调函数所在的编译单元中执行类型检查。执行类型检查的代码会重新分发这个调用到泛型函数&#8212;可是这一次它携带了类型信息。在下面的代码中，我们在函数 play_a_game 中插入了类型检查，使得代码的速度提高了几百倍。<br />
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="c1">//Framework.swift:</span>
</span><span class="line">
</span><span class="line"><span class="n">protocol</span> <span class="n">Pingable</span> <span class="p">{</span> <span class="n">func</span> <span class="n">ping</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Self</span> <span class="p">}</span>
</span><span class="line"><span class="n">protocol</span> <span class="n">Playable</span> <span class="p">{</span> <span class="n">func</span> <span class="n">play</span><span class="p">()</span> <span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">extension</span> <span class="n">Int</span> <span class="o">:</span> <span class="n">Pingable</span> <span class="p">{</span>
</span><span class="line">  <span class="n">func</span> <span class="n">ping</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">self</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">class</span> <span class="n">Game</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">:</span> <span class="n">Pingable</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">Playable</span> <span class="p">{</span>
</span><span class="line">  <span class="n">var</span> <span class="n">t</span> <span class="o">:</span> <span class="n">T</span>
</span><span class="line">
</span><span class="line">  <span class="n">init</span> <span class="p">(</span><span class="n">_</span> <span class="n">v</span> <span class="o">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span><span class="n">t</span> <span class="o">=</span> <span class="n">v</span><span class="p">}</span>
</span><span class="line">
</span><span class="line">  <span class="n">func</span> <span class="n">play</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.</span><span class="mf">.100</span><span class="n">_000_000</span> <span class="p">{</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">ping</span><span class="p">()</span> <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">func</span> <span class="n">play_a_game</span><span class="p">(</span><span class="n">game</span> <span class="o">:</span> <span class="n">Playable</span> <span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="c1">// This check allows the optimizer to specialize the</span>
</span><span class="line">  <span class="c1">// generic call &#39;play&#39;</span>
</span><span class="line">  <span class="k">if</span> <span class="n">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">game</span> <span class="n">as</span><span class="o">?</span> <span class="n">Game</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class="line">    <span class="n">z</span><span class="p">.</span><span class="n">play</span><span class="p">()</span>
</span><span class="line">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">    <span class="n">game</span><span class="p">.</span><span class="n">play</span><span class="p">()</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">/// -------------- &gt;8</span>
</span><span class="line">
</span><span class="line"><span class="c1">// Application.swift:</span>
</span><span class="line">
</span><span class="line"><span class="n">play_a_game</span><span class="p">(</span><span class="n">Game</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
</p>
<h4>数值大的值对象的开销</h4>
<p>
在Swift语言中，值类型保存它们数据独有的一份拷贝。使用值类型有很多优点，比如值类型具有独立的状态。当我们拷贝值类型时（相当于复制，初始化参数传递等操作），程序会创建值类型的一个拷贝。对于大的值类型，这种拷贝时很耗费时间的，可能会影响到程序的性能。

让我们看一下下面这段代码。这段代码使用值类型的节点定义了一个树，树的节点包含了协议类型的其他节点，计算机图形场景经常由可以使用值类型表示的实体以及形态变化，因此这个例子很有实践意义。
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">protocol</span> <span class="n">P</span> <span class="p">{}</span>
</span><span class="line"><span class="k">struct</span> <span class="n">Node</span> <span class="o">:</span> <span class="n">P</span> <span class="p">{</span>
</span><span class="line">  <span class="n">var</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">:</span> <span class="n">P</span><span class="o">?</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">Tree</span> <span class="p">{</span>
</span><span class="line">  <span class="n">var</span> <span class="n">node</span> <span class="o">:</span> <span class="n">P</span><span class="o">?</span>
</span><span class="line">  <span class="n">init</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
当树进行拷贝时（参数传递，初始化或者赋值）整个树都需要被复制.这是一项花销很大的操作，需要很多的 malloc/free 调用以及以及大量的引用计数操作

然而，我们并不关系值是否被拷贝，只要在这些值还在内存中存在就可以。
</p>
<h4>对大的值类型使用 COW（copy-on-write，写时复制和数组有点类似）</h4>
<p>
减少复制大的值类型数据开销的办法时采用写时复制行为（当对象改变时才进行实际的复制工作）。最简单的实现写时复制的方案时使用已经存在的写时复制的数据结构，比如数组。Swift 的数据是值类型，但是当数组作为参数被传递时并不每次都进行复制，因为它具有写时复制的特性。

在我们的 Tree 的例子中我们通过将 tree 的内容包装成一个数组来减少复制的代价。这个简单的改变对我们 tree 数据结构的性能影响时巨大的，作为参数传递数组的代价从 O(n) 变为 O(1)。
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">struct</span> <span class="n">tree</span> <span class="o">:</span> <span class="n">P</span> <span class="p">{</span>
</span><span class="line">  <span class="n">var</span> <span class="n">node</span> <span class="o">:</span> <span class="p">[</span><span class="n">P</span><span class="o">?</span><span class="p">]</span>
</span><span class="line">  <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">    <span class="n">node</span> <span class="o">=</span> <span class="p">[</span> <span class="n">thing</span> <span class="p">]</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
但是使用数组实现 COW 机制有两个明显的不足，第一个问题是数组暴露的诸如 append 以及 count 之类的方法在值包装的上下文中没有任何作用，这些方法使得引用类型的封装变得棘手。也许我们可以通过创建一个封装的结构体并隐藏这些不用的 API 来解决这个问题，但是却无法解决第二个问题。第二个问题就是数组内部存在保证程序安全性的代码以及和 OC 交互的代码。Swift 要检查给出的下表是否搂在数组的边界内，当保存值的时候需要检查是否需要扩充存储空间。这些运行时检查会降低速度。

一个替代的方案是实现一个专门的使用 COW 机制的数据结构代替采用数组作为值的封装。构建这样一个数据结构的示例如下所示：
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">final</span> <span class="n">class</span> <span class="n">Ref</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class="line">  <span class="n">var</span> <span class="n">val</span> <span class="o">:</span> <span class="n">T</span>
</span><span class="line">  <span class="n">init</span><span class="p">(</span><span class="n">_</span> <span class="n">v</span> <span class="o">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span><span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class="line">    <span class="n">var</span> <span class="n">ref</span> <span class="o">:</span> <span class="n">Ref</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span><span class="line">    <span class="n">init</span><span class="p">(</span><span class="n">_</span> <span class="n">x</span> <span class="o">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">Ref</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">var</span> <span class="nl">value:</span> <span class="n">T</span> <span class="p">{</span>
</span><span class="line">        <span class="n">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ref</span><span class="p">.</span><span class="n">val</span> <span class="p">}</span>
</span><span class="line">        <span class="n">set</span> <span class="p">{</span>
</span><span class="line">          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isUniquelyReferencedNonObjC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">            <span class="n">ref</span> <span class="o">=</span> <span class="n">Ref</span><span class="p">(</span><span class="n">newValue</span><span class="p">)</span>
</span><span class="line">            <span class="k">return</span>
</span><span class="line">          <span class="p">}</span>
</span><span class="line">          <span class="n">ref</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">newValue</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
类型 Box 可以代替上个例子中的数组
</p>
<h4>不安全的代码</h4>
Swift语言的类都是采用引用计数进行内存管理的。Swift编译器会在每次对象被访问的时候插入增加引用计数的代码。例如，考虑一个遍历使用类实现的一个链表的例子。遍历链表是通过移动引用到链表的下一个节点来完成的：<code>elem = elem.next</code>，每次移动这个引用，Swift 都要增加 next 对象的引用计数并减少前一个对象的引用计数，这种引用计数代价昂贵但是只要使用 Swift 类就无法避免
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">final</span> <span class="n">class</span> <span class="n">Node</span> <span class="p">{</span>
</span><span class="line"> <span class="n">var</span> <span class="nl">next:</span> <span class="n">Node</span><span class="o">?</span>
</span><span class="line"> <span class="n">var</span> <span class="nl">data:</span> <span class="n">Int</span>
</span><span class="line"> <span class="p">...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4>使用未托管的引用避免引用计数的负荷</h4>
<p>
在效率至上的代码中你可以选择使用未托管的引用。Unmanaged<t>结构体允许开发者对特别的引用关闭引用计数
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">var</span> <span class="n">Ref</span> <span class="o">:</span> <span class="n">Unmanaged</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Unmanaged</span><span class="p">.</span><span class="n">passUnretained</span><span class="p">(</span><span class="n">Head</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="k">while</span> <span class="n">let</span> <span class="n">Next</span> <span class="o">=</span> <span class="n">Ref</span><span class="p">.</span><span class="n">takeUnretainedValue</span><span class="p">().</span><span class="n">next</span> <span class="p">{</span>
</span><span class="line">  <span class="p">...</span>
</span><span class="line">  <span class="n">Ref</span> <span class="o">=</span> <span class="n">Unmanaged</span><span class="p">.</span><span class="n">passUnretained</span><span class="p">(</span><span class="n">Next</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2>协议</h2>
<h4>建议将只有类实现的协议标记为类协议</h4>
<p>Swift 可以指定协议只能由类实现。标记协议只能由类实现的一个好处是编译器可以基于这一点对程序进行优化。例如，ARC 内存管理系统能够容易的持有（增加该对象的引用计数）如果它知道它正在处理一个类对象。如果编译器不知道这一点，它就必须假设结构体也可以实现协议，那么它就必须准备好持有或者释放不同的数据结构，而这代价将会十分昂贵。<br />
如果限制只能由类实现某协议那么就标记该协议为类协议以获得更好的性能
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">protocol</span> <span class="n">Pingable</span> <span class="o">:</span> <span class="n">class</span> <span class="p">{</span> <span class="n">func</span> <span class="n">ping</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
</p>

<ul>
<li>虚函数:虚拟方法表或者<code>vtable</code>是被一个实例引用的一种包含类型方法地址的类型约束表。进行动态分发时，首先从对象中查找这张表然后查找表中的方法</li>
<li>编译器对很多方法进行优化:这是因为编译器并不知道那个具体的方法要被调用</li>
<li>直接访问：例如，直接加载一个类的字段或者直接调用一个方法</li>
<li>拷贝:在特定情况下优化器能够通过内联和 ARC 优化技术移除 retain，release 因为没有引起复制</li>
</ul>
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog">http://ITMonkeyLife.github.io/Blog</a></p>
</t></p></string></int></t></p></p>
</div>


<div class="meta">
	<div class="date">




</div>
	<div class="tags">


	<a class='category' href='/Blog/blog/categories/swift/'>Swift</a>


</div>
	
	<div class="comments"><a href="#disqus_thread">Comments</a></div>
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
		
		
		
		<a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
		
		
	</div>
	
</div>



<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2016

    Rick

</footer>
	<script src="/Blog/javascripts/slash.js"></script>
<script src="/Blog/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'ITMonkeyLife';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://ITMonkeyLife.github.io/Blog/blog/2015/12/16/bian-xie-gao-zhi-liang-de-swiftdai-ma/';
        var disqus_url = 'http://ITMonkeyLife.github.io/Blog/blog/2015/12/16/bian-xie-gao-zhi-liang-de-swiftdai-ma/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-52658428-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>
