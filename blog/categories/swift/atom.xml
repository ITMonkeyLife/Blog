<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | IT Monkey Life]]></title>
  <link href="http://ITMonkeyLife.github.io/Blog/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://ITMonkeyLife.github.io/Blog/"/>
  <updated>2015-12-10T15:45:59+08:00</updated>
  <id>http://ITMonkeyLife.github.io/Blog/</id>
  <author>
    <name><![CDATA[Rick]]></name>
    <email><![CDATA[382542165@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift的强大之处]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-qiang-da-zhi-chu/"/>
    <updated>2014-09-18T13:38:34+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-qiang-da-zhi-chu</id>
    <content type="html"><![CDATA[<p>在写任何东西之前我需要承认我是带有偏见的：我爱 Swift。我认为这是从我开始接触 Cocoa 生态系统以来这个平台上发生的最好的事情。我想通过分享我在 Swift，Objective-C 和 Haskell 上的经验让大家知道我为何这样认为。写这篇文章并不是为了介绍一些最好的实践 (写这些的时候 Swift 还太年轻，还没最好实践被总结出来)，而是举几个关于 Swift 强大之处的例子。</p>

<p>给大家一些我的个人背景：在成为全职 iOS/Mac 工程师之前我花了几年的时间做 Haskell (包括一些其他函数式编程语言) 开发。我仍然认为 Haskell 是我所有使用过的语言中最棒的之一。然而我转战到了 Objective-C，是因为我相信 iOS 是最令人激动的平台。刚开始接触 Objective-C 的时候我有些许沮丧，但我慢慢地学会了欣赏它。</p>

<p>当苹果在 WWDC 发布 Swift 的时候我非常的激动。我已经很久没有对新技术的发布感的如此兴奋了。在看过文档之后我意识到 Swift 使我们能够将现有的函数式编程知识和 Cocoa API 无缝地整合到一起。我觉得这两者的组合非常独特：没有任何其他的语言将它们融合地如此完美。就拿 Haskell 来说，想要用它来使用 Objective-C API 相当的困难。同样，想用 Objective-C 去做函数式编程也是十分困难的。</p>

<p>在 Utrecht 大学期间我学会了函数式编程。因为是在很学术的环境下学习所以并没有觉得很多复杂的术语 (moands，applicative functors 以及很多其他的东西) 有多么难懂。我觉得对很多想学习函数式编程的人来说这些名称是一个很大的阻碍。</p>

<p>不仅仅名称很不同，风格也不一样。作为 Objective-C 程序员，我们很习惯于面向对象编程。而且因为大多数语言不是面对对象编程就是与之类似，我们可以看懂很多不同语言的代码。阅读函数式编程语言的时候则大不相同 -- 如果你没有习惯的话看起来简直莫名其妙。</p>

<p>那么，为什么你要使用函数式编程呢？它很奇怪，很多人都不习惯而且学习它要花费大量的时间。并且对于大多数问题面向对象编程都能解决，所以没有必要去学习任何新的东西对吧？</p>

<p>对于我来说，函数式编程只是工具箱中的一件工具。它是一个改变了我对编程的理解的强大工具。在解决问题的时候它非常强大。对于大多数问题面向对象编程都很棒，但是对于其他一些问题应用函数式编程会给你带来巨大的时间/精力的节省。</p>

<p>开始学习函数式编程或许有些痛苦。第一，你必须放手一些老的模式。而因为我们很多人常年用面对对象的方式去思考，做到这一点是很困难的。在函数式编程当中你想的是不变的数据结构以及那些转换它们的函数。在面对对象编程当中你考虑的是互相发送信息的对象。如果你没有马上理解函数式编程，这是一个好的信号。你的大脑很可能已经完全适应了用面对对象的方法来解决问题。</p>

<h2>例子</h2>
<!-- more-->
<p>我最喜欢的 Swift 功能之一是对 optionals 的使用。Optionals 让我们能够应对有可能存在也有可能不存在的值。在 Objective-C 里我们必须在文档中清晰地说明 nil 是否是允许的。Optionals 让我们将这份责任交给了类型系统。如果你有一个可选值，你就知道它可以是 nil。如果它不是可选值，你知道它不可能是 nil。</p>

<p>举个例子，看看下面一小段 Objective-C 代码</p>

<p><code>objc
- (NSAttributedString *)attributedString:(NSString *)input 
{
    return [[NSAttributedString alloc] initWithString:input];
}
</code></p>

<p>看上去没有什么问题，但是如果 <code>input</code> 是 nil, 它就会崩溃。这种问题你只能在运行的时候才能发现。取决于你如何使用它，你可能很快能发现问题，但是你也有可能在发布应用之后才发现，导致用户正在使用的应用崩溃。</p>

<p>用相同的 Swift 的 API 来做对比。</p>

<p><code>objc
extension NSAttributedString {  
    init(string str: String)
}
</code></p>

<p>看起来像对Objective-C的直接翻译，但是 Swift 不允许 <code>nil</code> 被传入。如果要达到这个目的，API 需要变成这个样子：</p>

<p><code>objc
extension NSAttributedString {  
    init(string str: String?)
}
</code></p>

<p>注意新加上的问号。这意味着你可以使用一个值或者是 nil。类非常的精确：只需要看一眼我们就知道什么值是允许的。使用 optionals 一段时间之后你会发现你只需要阅读类型而不用再去看文档了。如果犯了一个错误，你会得到一个编译时警告而不是一个运行时错误。</p>

<h2>建议</h2>

<p>如果可能的话避免使用 optionals。Optionals 对于使用你 API 的人们来说是一个多余的负担。话虽如此，还是有很多地方可以很好使用它们。如果你有一个函数会因为一个明显的原因失败你可以返回一个 optional。举例来说，比如将一个  #00ff00 字符串转换成颜色。如果你的参数不符合正确的格式，你应该返回一个 <code>nil</code> 。</p>

<p><code>objc
func parseColorFromHexString(input: String) -&gt; UIColor? {  
    // ...
}
</code></p>

<p>如果你需要阐明错误信息，你可以使用 <code>Either</code> 或者 <code>Result</code> 类型 (不在标准库里面)。当失败的原因很重要的时候，这种做法会非常有用。<a href="http://nomothetis.svbtle.com/error-handling-in-swift">“Error Handling in Swift”</a> 一文中有个很好的例子。</p>

<h2 id="enums">Enums</h2>

<p>Enums 是一个随 Swift 推出的新东西，它和我们在 Objective-C 中见过的东西都大不相同。在 Objective-C 里面我们有一个东西叫做 enums, 但是它们差不多就是升级版的整数。</p>

<p>我们来看看布尔类型。一个布尔值是两种可能性 -- true 或者 false -- 中的一个。很重要的一点是没有办法再添加另外一个值 -- 布尔类型是<strong>封闭的</strong>。布尔类型的封闭性的好处是每当使用布尔值的时候我们只需要考虑 true 或者 false 这两种情况。</p>

<p>在这一点上面 optionals 是一样的。总共只有两种情况：<code>nil</code> 或者有值。在 Swift 里面布尔和 optional 都可以被定义为 enums。但有一个不同点：在 optional enum 中有一种可能性有一个相关值。我们来看看它们不同的定义：</p>

<p>```objc
enum Boolean {<br />
    case False
    case True
}</p>

<p>enum Optional<a> {<br />
    case Nil
    case Some(A)
}
```</a></p>

<p>它们非常的相似。如果你把它们的名称改成一样的话，那么唯一的区别就是括号里的相关值。如果你给 optional 中的 <code>Nil</code>  情况也加上一个值，你就会得到一个 <code>Either</code> 类型：</p>

<p><code>objc
enum Either&lt;A,B&gt; {  
    case Left&lt;A&gt;
    case Right&lt;B&gt;
}
</code></p>

<p>在函数式编程当中，在你想表示两件事情之间的选择时候你会经常用到 <code>Either</code> 类型。举个例子：如果你有一个函数返回一个整数或者一个错误，你就可以用 <code>Either&lt;Int, NSError&gt;</code>。如果你想在一个字典中储存布尔值或者字符串，你就可以使用 <code>Either&lt;Bool,String&gt;</code> 作为键。</p>

<blockquote>
  <p>理论旁白：有些时候 enums 被称为 <strong>sum 类型</strong>，因为它们是几个不同类型的总和。在 <code>Either</code> 类型的例子中，它们表达的是 <code>A</code> 类型和 <code>B</code> 类型的和。Structs 和 tuples 被称为 <strong>product 类型</strong>，因为它们代表几个不同类型的乘积。参见<a href="http://en.wikipedia.org/wiki/Algebraic_data_type">“algebraic data types.”</a></p>
</blockquote>

<p>理解什么时候使用 enums 什么时候使用其他的数据类型 (比如 <a href="http://objccn.io/issue-16-2">class 或者 structs</a>)会有一些难度。当你有一个固定数量的值的集合的时候，enum 是最有用的。比如说，如果我们设计一个 Github API 的 wrapper，我们可以用 enum 来表示端点。比如有一个不需要任何参数的 <code>/zen</code> 的 API 端点。再比如为了获取用户的资料我们需要提供用户名。最后我们显示用户的仓库时，我们需要提供用户名以及一个值去说明是否从小到大地排列结果。</p>

<p><code>objc
enum Github {  
    case Zen
    case UserProfile(String)
    case Repositories(username: String, sortAscending: Bool)
}
</code></p>

<p>定义 API 端点是很好的使用 enum 的场景。API 的端点是有限的，所以我们可以为每一个端点定义一个情况。如果我们在对这些端点使用 switch 的时候没有包含所有情况的话，我们会被给予警告。所以说当我们需要添加一个情况的时候我们需要更新每一个用到这个 enum 的函数。</p>

<p>除非能够拿到源代码，其他使用我们 enum 的人不能添加新的情况，这是一个非常有用的限制。想想要是你能够加一种新情况到 <code>Bool</code> 或者 <code>Optional</code> 里会怎么样吧 -- 所有用到 它的函数都需要重写。</p>

<p>比如说我们正在开发一个货币转换器。我们可以将货币给定义成 enum：</p>

<p><code>objc
enum Currency {  
    case Eur
    case Usd
}
</code></p>

<p>我们现在可以做一个获取任何货币符号的函数：</p>

<p><code>objc
func symbol(input: Currency) -&gt; String {  
    switch input {
        case .Eur: return "€"
        case .Usd: return "$"
    }
}
</code></p>

<p>最后，我们可以用我们的 <code>symbol</code> 函数，来依据系统本地设置得到一个很好地格式化过的字符串：</p>

<p><code>objc
func format(amount: Double, currency: Currency) -&gt; String {  
    let formatter = NSNumberFormatter()
    formatter.numberStyle = .CurrencyStyle
    formatter.currencySymbol = symbol(currency)
    return formatter.stringFromNumber(amount)
}
</code></p>

<p>这样一来有一个很大的限制。我们可能会想让我们 API 的使用者在将来可以修改一些情况。在 Objective-C 当中向一个接口里添加更多类型的常见解决方法是子类化。在 Objective-C 里面理论上你可以子类化任何一个类，然后通过这种办法来扩展它。在 Swift 里面你仍然可以使用子类化，但是只能对 <code>class</code> 使用，对于 <code>enum</code> 则不行。然而，我们可以用另一种技术来达到目的 (这种办法在 Objetive-C 和 Swift 的 protocol 中都可行）。</p>

<p>假设我们定义一个货币符号的协议：</p>

<p><code>objc
protocol CurrencySymbol {  
    func symbol() -&gt; String
}
</code></p>

<p>现在我们让 <code>Currency</code> 类型遵守这个协议。注意我们可以将 <code>input</code> 参数去掉，因为这里它被作为 self 隐式地进行传递：</p>

<p><code>objc
extension Currency : CurrencySymbol {  
   func symbol() -&gt; String {
        switch self {
            case .Eur: return "€"
            case .Usd: return "$"
        }
    }
}
</code></p>

<p>现在我们可以重写 <code>format</code> 方法来格式化任何遵守我们协议的类型：</p>

<p><code>objc
func format(amount: Double, currency: CurrencySymbol) -&gt; String {  
    let formatter = NSNumberFormatter()
    formatter.numberStyle = .CurrencyStyle
    formatter.currencySymbol = currency.symbol()
    return formatter.stringFromNumber(amount)
}
</code></p>

<p>这样一来我们将我们代码的可延展性大大提升类 -- 任何遵守 <code>CurrencySymbol</code> 协议的类型都可以被格式化。比如说，我们建立一个新的类型来储存比特币，我们可以立刻让它拥有格式化功能：</p>

<p><code>objc
struct Bitcoin : CurrencySymbol {  
    func symbol() -&gt; String {
        return "B⃦"
    }
}
</code></p>

<p>这是一种写出具有延展性函数的很好的方法。通过使用一个需要遵守协议，而不是一个实实在在的类型，你的 API 的用户能够加入更多的类型。你仍然可以利用 enum 的灵活性，但是通过让它们遵守协议，你可以更好地表达自己的意思。根据你的具体情况，你现在可以轻松地选择是否开放你的 API。</p>

<h2>类型安全</h2>

<p>我认为类型的安全性是 Swift 一个很大的优势。就像我们在讨论 optionals 时看见的一样，我们可以用一些聪明的手段将某些检测从运行时转移到编译时。Swift 中数组的工作方式就是一个例子：一个数组是泛型的，它只能容纳一个类型的对象。将一个整数附加在一个字符组数组后面是做不到的。这样以来就消灭了一个类的潜在 bug。(值得注意的是如果你需要同时将字符串或者整数放到一个数组里的话，你可以使用上面谈到过的 <code>Either</code> 类型。)</p>

<p>再比如说，我们要将我们到货币转换器延展为一个通用的单位换算器。如果我们使用 <code>Double</code> 去表示数量，会有一点点误导性。比如说，100.0 可以表示 100 美元，100 千克或者任何能用 100 表示的东西。我们可以借助类型系统来制作不同的类型来表示不同的物理上的数量。比如说我们可以定义一个类型来表示钱：</p>

<p><code>objc
struct Money {  
    let amount : Double
    let currency: Currency
}
</code></p>

<p>我们可以定义另外一个结构来表示质量：</p>

<p><code>objc
struct Mass {  
    let kilograms: Double
}
</code></p>

<p>现在我们就消除了不小心将 <code>Money</code>  和 <code>Mass</code> 相加的可能性。基于你应用的特质有时候将一些简单的类型包装成这样是很有效的。不仅如此，阅读代码也会变得更加简单。假设我们遇到一个 <code>pounds</code> 函数：</p>

<p><code>objc
func pounds(input: Double) -&gt; Double  
</code></p>

<p>光看类型定义很难看出来这个函数的功能。它将欧元装换成英镑？还是将千克转换成磅？ (英文中英镑和磅均为 pound) 我们可以用不同的名字，或者可以建立文档 (都是很好的办法)，但是我们有第三种选择。我们可以将这个类型变得更明确：</p>

<p><code>objc
func pounds(input: Mass) -&gt; Double  
</code></p>

<p>我们不仅让这个函数的用户能够立刻理解这个函数的功能，我们也防止了不小心传入其他单位的参数。如果你试图将 <code>Money</code> 作为参数来使用这个函数，编译器是不会接受的。另外一个可能的提升是使用一个更精确的返回值。现在它只是一个 <code>Double</code>。</p>

<h2>不可变性</h2>

<p>Swift 另外一个很棒的功能是内置的不可变性。在 Cocoa 当中很多的 API 都已经体现出了不可变性的价值。想了解这一点为什么如此重要，<a href="http://nomothetis.svbtle.com/error-handling-in-swift">“Error Handling in Swift”</a> 是一个很好的参考。比如，作为一个 Cocoa 开发者，我们使用很多成对的类 (<code>NSString</code> vs. <code>NSMutableString</code>，<code>NSArray</code> vs. <code>NSMutableArray</code>)。当你得到一个字符串值，你可以假设它不会被改变。但是如果你要完全确信，你依然要复制它。然后你才知道你有一份不可变的版本。</p>

<p>在 Swifit 里面，不可变性被直接加入这门语言。比如说如果你想建立一个可变的字符串，你可以如下的代码：</p>

<p><code>objc
var myString = "Hello"  
</code></p>

<p>然而，如果你想要一个不可变的字符串，你可以做如下的事情：</p>

<p><code>objc
let myString = "Hello"  
</code></p>

<p>不可变的数据在创建可能会被未知用户使用的 API 时会给你很大的帮助。比如说，你有一个需要字符串作为参数的函数，在你迭代它的时候，确定它不会被改变是很重要的。在 Swift 当中这是默认的行为。正是因为这个原因，在写多线程代码的时候使用不可变资料会使难度大大降低。</p>

<p>还有另外一个巨大的优势。如果你的函数只使用不可变的数据，你的类型签名就会成为很好的文档。在 Objective-C 当中则不然。比如说，假设你准备在 OS X 上使用 <code>CIFilter</code>。在实例化之后你需要使用 <code>setDefaults</code> 方法。这一点在文档中有提到。有很多这样类都是这个样子。在实例化之后，在你使用它之前你必须要使用另外一个方法。问题在于，如果不阅读文档的话，经常会不清楚哪些函数需要被使用，最后你有可能遇到很奇怪的状况。</p>

<p>当使用不可变资料的时候，类型签名让事情变得很清晰。比如说，<code>map</code> 的类签名。我们知道有一个可选的 <code>T</code> 值，而且有一个将 <code>T</code> 转换成 <code>U</code> 的函数。结果是一个可选的 <code>U</code> 值。原始值是不可能改变的：</p>

<p><code>objc
func map&lt;T, U&gt;(x: T?, f: T -&gt; U) -&gt; U?  
</code></p>

<p>对于数组的 <code>map</code> 来说是一样的。它被定义成一个数组的延伸，所以参数本身是 <code>self</code>。我们可以看到它用一个函数将 <code>T</code> 转化成 <code>U</code>，并且生成一个 <code>U</code> 的数组。因为它是一个不可变的函数，我们知道原数组是不会变化的，而且我们知道结果也是不会改变的。将这些限制内置在l类型系统中，并有编译器来监督执行，让我们不再需要去查看文档并记住什么会变化。</p>

<p><code>objc
extension Array {  
    func map&lt;U&gt;(transform: T -&gt; U) -&gt; [U]
}
</code></p>

<h2>总结</h2>

<p>Swift 带来了很多有趣的可能性。我尤其喜欢的一点是过去我们需要手动检测或者阅读文档的事情现在编译器可以帮我们来完成。我们可以选择在合适的时机去使用这些可能性。我们依然会用我们现有的，成熟的办法去写代码，但是我们可以在合适的时候在我们代码的某些地方应用这些新的可能性。</p>

<p>我预测：Swift 会很大程度上改变我们写代码的方式，而且是向好的方向改变。脱离 Objective-C 会需要几年的时间，但是我相信我们中的大多数人会做出这个改变并且不会后悔。有些人会很快的适应，对另外一些人可能会花上很长的时间。但是我相信总有一天绝大多数人会看到 Swift 带给我们的种种好处。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift的函数式API]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-han-shu-shi-api/"/>
    <updated>2014-09-18T10:19:05+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-han-shu-shi-api</id>
    <content type="html"><![CDATA[<p>在过去的时间里，人们对于设计 API 总结了很多通用的模式和最佳实践方案。一般情况下，我们总是可以从苹果的 Foundation、Cocoa、Cocoa Touch 和很多其他框架中总结出一些开发中的范例。毫无疑问，对于“特定情境下的 API 应该如何设计”这个问题，不同的人总是有着不同的意见，对于这个问题有很大的讨论空间。不过对于很多 Objective-C 的开发者来说，对于那些常用的模式早已习以为常。</p>

<p>随着 Swift 的出现，设计 API 引起了更多的问题。绝大多数情况下，我们只能继续做着手头的工作，然后把现有的方法翻译成 Swift 版本。不过，这对于 Swift 来说并不公平，因为和 Objective-C 相比，Swift 添加了很多新的特性。引用 Swift 创始人 <a href="https://twitter.com/clattner_llvm">Chris Lattner</a> 的一段话：</p>

<blockquote>
  <p>Swift 引入了泛型和函数式编程的思想，极大地扩展了设计的空间。</p>
</blockquote>

<p>在这篇文章里，我们将会围绕 <code>Core Image</code> 进行 API 封装，以此为例，探索如何在 API 设计中使用这些新的工具。 <code>Core Image</code> 是一个功能强大的图像处理框架，但是它的 API 有时有点笨重。 <code>Core Image</code> 的 API 是弱类型的 - 它通过键值对 (key-value) 设置图像滤镜。这样在设置参数的类型和名字时很容易失误，会导致运行时错误。新的 API 将会十分的安全和模块化，通过使用类型而不是键值对来规避这样的运行时错误。</p>

<h2>目标</h2>

<p>我们的目标是构建一个 API ，让我们可以简单安全的组装自定义滤镜。举个例子，在文章的结尾，我们可以这样写：</p>

<p><code>objc
let myFilter = blur(blurRadius) &gt;|&gt; colorOverlay(overlayColor)
let result = myFilter(image)
</code></p>

<p>上面构建了一个自定义的滤镜，先模糊图像，然后再添加一个颜色蒙版。为了达到这个目标，我们将充分利用 Swift 函数是一等公民这一特性。项目源码可以在 Github 上的这个<a href="https://github.com/objcio/issue-16-functional-apis">示例项目</a>中下载。</p>

<h2 id="filter">Filter 类型</h2>

<p><code>CIFilter</code> 是 <code>Core Image</code> 中的一个核心类，用来创建图像滤镜。当实例化一个 <code>CIFilter</code> 对象之后，你 (几乎) 总是通过 <code>kCIInputImageKey</code> 来输入图像，然后通过 <code>kCIOutputImageKey</code> 获取返回的图像，返回的结果可以作为下一个滤镜的参数输入。</p>

<p>在我们即将开发的 API 里，我们会把这些键值对 (key-value) 对应的真实内容抽离出来，为用户提供一个安全的强类型 API。我们定义了自己的滤镜类型 <code>Filter</code>，它是一个可以传入图片作为参数的函数，并且返回一个新的图片。</p>

<p><code>objc
typealias Filter = CIImage -&gt; CIImage
</code>
<!-- more--></p>
<p>这里我们用 <code>typealias</code> 关键字，为 <code>CIImage -&gt; CIImage</code>类型定义了我们自己的名字，这个类型是一个函数，它的参数是一个 <code>CIImage</code> ，返回值也是 <code>CIImage</code> 。这是我们后面开发需要的基础类型。</p>

<p>如果你不太熟悉函数式编程，你可能对于把一个函数类型命名为 <code>Filter</code> 感觉有点奇怪，通常来说，我们会用这样的命名来定义一个类。如果我们很想以某种方式来表现这个类型的函数式的特性，我们可以把它命名成 <code>FilterFunction</code> 或者一些其他的类似的名字。但是，我们有意识的选择了 <code>Filter</code> 这个名字，因为在函数式编程的核心哲学里，函数就是值，函数和结构体、整数、多元组、或者类，并没有任何区别。一开始我也不是很适应，不过一段时间之后发现，这样做确实很有意义。</p>

<h2>构建滤镜</h2>

<p>现在我们已经定义了 <code>Filter</code> 类型，接下来可以定义函数来构建特定的滤镜了。这些函数需要参数来设置特定的滤镜，并且返回一个类型为 <code>Filter</code> 的值。这些函数大概是这个样子：</p>

<p><code>objc
func myFilter(/* parameters */) -&gt; Filter
</code></p>

<p>注意返回的值 <code>Filter</code> 本身就是一个函数，在后面有利于我们将多个滤镜组合起来，以达到理想的处理效果。</p>

<p>为了让后面的开发更轻松一点，我们扩展了 <code>CIFilter</code> 类，添加了一个 convenience 的初始化方法，以及一个用来获取输出图像的计算属性：</p>

<p>```objc
typealias Parameters = Dictionary&lt;String, AnyObject&gt;</p>

<p>extension CIFilter {</p>

<pre><code>convenience init(name: String, parameters: Parameters) {
    self.init(name: name)
    setDefaults()
    for (key, value : AnyObject) in parameters {
        setValue(value, forKey: key)
    }
}

var outputImage: CIImage { return self.valueForKey(kCIOutputImageKey) as CIImage }
</code></pre>

<p>}
```</p>

<p>这个 convenience 初始化方法有两个参数，第一个参数是滤镜的名字，第二个参数是一个字典。字典中的键值对将会被设置成新滤镜的参数。我们 convenience 初始化方法先调用了指定的初始化方法，这符合 Swift 的开发规范。</p>

<p>计算属性 <code>outputImage</code> 可以方便地从滤镜对象中获取到输出的图像。它查找 <code>kCIOutputImageKey</code> 对应的值并且将其转换成一个 <code>CIImage</code> 对象。通过提供这个属性， API 的用户不再需要对返回的结果手动进行类型转换了。</p>

<h2>模糊</h2>

<p>有了这些东西，现在我们就可以定义属于自己的简单滤镜了。高斯模糊滤镜只需要一个模糊半径作为参数，我们可以非常容易的完成一个模糊滤镜：</p>

<p><code>objc
func blur(radius: Double) -&gt; Filter {
    return { image in
        let parameters : Parameters = [kCIInputRadiusKey: radius, kCIInputImageKey: image]
        let filter = CIFilter(name:"CIGaussianBlur", parameters:parameters)
        return filter.outputImage
    }
}
</code></p>

<p>就是这么简单，这个模糊函数返回了一个函数，新的函数的参数是一个类型为 <code>CIImage</code> 的图片，返回值 (<code>filter.outputImage</code>) 是一个新的图片 。这个模糊函数的格式是 <code>CIImage -&gt; CIImage</code> ，满足我们前面定义的 <code>Filter</code> 类型的格式。</p>

<p>这个例子只是对 <code>Core Image</code> 中已有滤镜的一个简单的封装，我们可以多次重复同样的模式，创建属于我们自己的滤镜函数。</p>

<h2>颜色蒙版</h2>

<p>现在让我们定义一个颜色滤镜，可以在现有的图片上面加上一层颜色蒙版。 <code>Core Image</code> 默认没有提供这个滤镜，不过我们可以通过已有的滤镜组装一个。</p>

<p>我们使用两个模块来完成这个工作，一个是颜色生成滤镜 (<code>CIConstantColorGenerator</code>)，另一个是资源合成滤镜 (<code>CISourceOverCompositing</code>)。让我们先定义一个生成一个常量颜色面板的滤镜：</p>

<p><code>objc
func colorGenerator(color: UIColor) -&gt; Filter {
    return { _ in
        let filter = CIFilter(name:"CIConstantColorGenerator", parameters: [kCIInputColorKey: color])
        return filter.outputImage
    }
}
</code></p>

<p>这段代码看起来和前面的模糊滤镜差不多，不过有一个较为明显的差异：颜色生成滤镜不会检测输入的图片。所以在函数里我们不需要给传入的图片参数命名，我们使用了一个匿名参数 <code>_</code> 来强调这个 filter 的图片参数是被忽略的。</p>

<p>接下来，我们来定义合成滤镜：</p>

<p><code>objc
func compositeSourceOver(overlay: CIImage) -&gt; Filter {
    return { image in
        let parameters : Parameters = [ 
            kCIInputBackgroundImageKey: image, 
            kCIInputImageKey: overlay
        ]
        let filter = CIFilter(name:"CISourceOverCompositing", parameters: parameters)
        return filter.outputImage.imageByCroppingToRect(image.extent())
    }
}
</code></p>

<p>在这里我们将输出图像裁剪到和输入大小一样。这并不是严格需要的，要取决于我们想让滤镜如何工作。不过，在后面我们的例子中我们可以看出来这是一个明智之举。</p>

<p><code>objc
func colorOverlay(color: UIColor) -&gt; Filter {
    return { image in
        let overlay = colorGenerator(color)(image)
        return compositeSourceOver(overlay)(image)
    }
}
</code></p>

<p>我们再一次返回了一个参数为图片的函数，<code>colorOverlay</code> 在一开始先调用了 <code>colorGenerator</code> 滤镜。<code>colorGenerator</code> 滤镜需要一个颜色作为参数，并且返回一个滤镜。因此 <code>colorGenerator(color)</code> 是 <code>Filter</code> 类型的。但是 <code>Filter</code> 类型本身是一个 <code>CIImage</code> 向 <code>CIImage</code> 转换的函数，我们可以在 <code>colorGenerator(color)</code> 后面加上一个类型为 <code>CIImage</code> 的参数，这样可以得到一个类型为 <code>CIImage</code> 的蒙版图片。这就是在定义 <code>overlay</code> 的时候发生的事情：我们用 <code>colorGenerator</code> 函数创建了一个滤镜，然后把图片作为一个参数传给了这个滤镜，从而得到了一张新的图片。返回值 <code>compositeSourceOver(overlay)(image)</code> 和这个基本相似，它由一个滤镜 <code>compositeSourceOver(overlay)</code> 和一个图片参数 <code>image</code> 组成。</p>

<h2>组合滤镜</h2>

<p>现在我们已经定义了一个模糊滤镜和一个颜色滤镜，我们在使用的时候可以把它们组合在一起：我们先将图片做模糊处理，然后再在上面放一个红色的蒙层。让我们先加载一张图片：</p>

<p><code>objc
let url = NSURL(string: "http://tinyurl.com/m74sldb");
let image = CIImage(contentsOfURL: url)
</code></p>

<p>现在我们可以把滤镜组合起来，同时应用到一张图片上：</p>

<p><code>objc
let blurRadius = 5.0
let overlayColor = UIColor.redColor().colorWithAlphaComponent(0.2)
let blurredImage = blur(blurRadius)(image)
let overlaidImage = colorOverlay(overlayColor)(blurredImage)
</code></p>

<p>我们又一次的通过滤镜组装了图片。比如在倒数第二行，我们先得到了模糊滤镜 <code>blur(blurRadius)</code> ，然后再把这个滤镜应用到图片上。</p>

<h2>函数组装</h2>

<p>不过，我们可以做的比上面的更好。我们可以简单的把两行滤镜的调用组合在一起变成一行，这是我脑海中想到的第一个能改进的地方：</p>

<p><code>objc
let result = colorOverlay(overlayColor)(blur(blurRadius)(image))
</code></p>

<p>不过，这些圆括号让这行代码完全不具有可读性，更好的方式是定义一个函数来完成这项任务：</p>

<p><code>objc
func composeFilters(filter1: Filter, filter2: Filter) -&gt; Filter {
    return { img in filter2(filter1(img)) }
}
</code></p>

<p><code>composeFilters</code> 函数的两个参数都是 Filter ，并且返回了一个新的 Filter 滤镜。组装后的滤镜需要一个 <code>CIImage</code> 类型的参数，并且会把这个参数分别传给 <code>filter1</code> 和 <code>filter2</code> 。现在我们可以用 <code>composeFilters</code> 来定义我们自己的组合滤镜：</p>

<p><code>objc
let myFilter = composeFilters(blur(blurRadius), colorOverlay(overlayColor))
let result = myFilter(image)
</code></p>

<p>我们还可以更进一步的定义一个滤镜运算符，让代码更具有可读性，</p>

<p>```objc
infix operator &gt;|&gt; { associativity left }</p>

<p>func &gt;|&gt; (filter1: Filter, filter2: Filter) -&gt; Filter {
    return { img in filter2(filter1(img)) }
}
```</p>

<p>运算符通过 <code>infix</code> 关键字定义，表明运算符具有 <code>左</code> 和 <code>右</code> 两个参数。<code>associativity left</code> 表明这个运算满足左结合律，即：f1 &gt;|&gt; f2 &gt;|&gt; f3 等价于 (f1 &gt;|&gt; f2) &gt;|&gt; f3。通过使这个运算满足左结合律，再加上运算内先应用了左侧的滤镜，所以在使用的时候滤镜顺序是从左往右的，就像 Unix 管道一样。</p>

<p>剩余的部分是一个函数，内容和 <code>composeFilters</code> 基本相同，只不过函数名变成了 <code>&gt;|&gt;</code>。</p>

<p>接下来我们把这个组合滤镜运算器应用到前面的例子中：</p>

<p><code>objc
let myFilter = blur(blurRadius) &gt;|&gt; colorOverlay(overlayColor)
let result = myFilter(image)
</code></p>

<p>运算符让代码变得更易于阅读和理解滤镜使用的顺序，调用滤镜的时候也更加的方便。就好比是 <code>1 + 2 + 3 + 4</code> 要比 <code>add(add(add(1, 2), 3), 4)</code> 更加清晰，更加容易理解。</p>

<h2>自定义运算符</h2>

<p>很多 Objective-C 的开发者对于自定义运算符持有怀疑态度。在 Swift 刚发布的时候，这是一个并没有很受欢迎的特性。很多人在 C++ 中遭遇过自定义运算符过度使用 (甚至滥用) 的情况，有些是个人经历过的，有些是听到别人谈起的。</p>

<p>你可能对于前面定义的运算符 <code>&gt;|&gt;</code> 持有同样的怀疑态度，毕竟如果每个人都定义自己的运算符，那代码岂不是很难理解了？值得庆幸的是在函数式编程里有很多的操作，为这些操作定义一个运算符并不是一件很罕见的事情。</p>

<p>我们定义的滤镜组合运算符是一个<a href="http://en.wikipedia.org/wiki/Function_composition_%28computer_science%29">函数组合</a>的例子，这是一个在函数式编程中广泛使用的概念。在数学里，两个函数 <code>f</code> 和 <code>g</code> 的组合有时候写做 <code>f ∘ g</code>，这样定义了一种全新的函数，将输入的 <code>x</code> 映射到 <code>f(g(x))</code> 上。这恰好就是我们的 <code>&gt;|&gt;</code> 所做的工作 (除了函数的逆向调用)。 </p>

<h2>泛型</h2>

<p>仔细想想，其实我们并没有必要去定义一个用来专门组装滤镜的运算符，我们可以用一个泛型的运算符来组装函数。目前我们的 <code>&gt;|&gt;</code> 是这样的：</p>

<p><code>objc
func &gt;|&gt; (filter1: Filter, filter2: Filter) -&gt; Filter
</code></p>

<p>这样定义之后，我们传入的参数只能是 <code>Filter</code> 类型的滤镜。</p>

<p>但是，我们可以利用 Swift 的通用特性来定义一个泛型的函数组合运算符：</p>

<p><code>objc
func &gt;|&gt; &lt;A, B, C&gt;(lhs: A -&gt; B, rhs: B -&gt; C) -&gt; A -&gt; C {
    return { x in rhs(lhs(x)) }
}
</code></p>

<p>这个一开始可能很难理解 -- 至少对我来说是这样。但是分开的看了各个部分之后，一切都变得清晰起来。</p>

<p>首先，我们来看一下函数名后面的尖括号。尖括号定义了这个函数适用的泛型类型。在这个例子里我们定义了三个类型：A、B 和 C。因为我们并没有指定这些类型，所以它们可以代表任何东西。</p>

<p>接下来让我们来看看函数的参数：第一个参数：lhs (left-hand side 的缩写)，是一个类型为 A -&gt; B 的函数。这代表一个函数的参数为 A，返回值的类型为 B。第二个参数：rhs (right-hand side 的缩写)，是一个类型为 B -&gt; C 的函数。参数命名为 lhs 和 rhs，因为它们分别对应操作符左边和右边的值。</p>

<p>重写了没有 <code>Filter</code> 的滤镜组合运算符之后，我们很快就发现其实前面实现的组合运算符只是泛型函数中的一个特殊情况：</p>

<p><code>objc
func &gt;|&gt; (filter1: CIImage -&gt; CIImage, filter2: CIImage -&gt; CIImage) -&gt; CIImage -&gt; CIImage
</code></p>

<p>把我们脑海中的泛型类型 A、B、C 都换成 <code>CIImage</code>，这样可以清晰的理解用通用运算符的来替换滤镜组合运算符是多么的有用。</p>

<h2>结论</h2>

<p>至此，我们成功的用函数式 API 封装了 <code>Core Image</code>。希望这个例子能够很好的说明，对于 Objective-C 的开发者来说，在我们所熟知的 API 的设计模式之外有一片完全不同的世界。有了 Swift，我们现在可以动手探索那些全新的领域，并且将它们充分地利用起来。</p>

<hr />

]]></content>
  </entry>
  
</feed>
