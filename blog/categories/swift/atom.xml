<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | IT Monkey Life]]></title>
  <link href="http://ITMonkeyLife.github.io/Blog/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://ITMonkeyLife.github.io/Blog/"/>
  <updated>2015-12-13T13:21:48+08:00</updated>
  <id>http://ITMonkeyLife.github.io/Blog/</id>
  <author>
    <name><![CDATA[Rick]]></name>
    <email><![CDATA[382542165@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift 2.2 源码解读 Swift 的 ABI]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2015/12/11/swift-2-dot-2-yuan-ma-jie-du/"/>
    <updated>2015-12-11T10:10:22+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2015/12/11/swift-2-dot-2-yuan-ma-jie-du</id>
    <content type="html"><![CDATA[<p>
随着Swift的开源，苹果开发者迎来了新的开端。其实这个是我一直想要表达的，随着对Swift这个语言的深入了解，越发感觉到Swift的魅力。Swift是系统编程语言，现在C语言之所以能统治底层开发的最重要原因是C规范统一的ABI，使其能做到与汇编程序无缝衔接。而Swift的ABI兼容C（并不包括name mangling部分）。基于强大的llvm生成具体平台代码。不仅仅作为Objective-C的翻译。
</p>
<p>
通过开发Swift，了解到Swift文件的中间编译结果（介于Swift代码合llvm ir）是SIL。SIL我下一章着重介绍。这张暂时把焦点放在Swift的ABI。那么什么是ABI，你一定很陌生吧，那么对于API呢，你是不是明白了什么？
</p>
<p>
ABI的全称是Application Binary Interface。翻译过来就是应用二进制接口，描述了应用程序和操作系统或其他应用程序之间的低级接口。
</p>
<p>
ABI涵盖了各个细节：
<!-- more-->
<ul>
<li>数据类型的大小、设计和对齐;</li>
<li>调用约定（控制着函数的参数如何传送以及如何接受返回值），例如，是所有的参数都通过栈传递，还是部分参数通过寄存器传递；哪个寄存器用于哪个函数参数；通过栈传递的第一个函数参数是最先push到栈上还是最后</li>
<li>系统调用的编码和一个应用如何向操作系统进行系统调用</li>
<li>以及在一个完整的操作系统ABI中，目标文件的二进制格式、程序库等等。</li>
</ul>
一个完整的ABI，像Intel二进制兼容标准（iBCS），允许支持它的操作系统上的程序不经修改在其他支持此ABI的操作系统上运行。
</p>
<p>
ABI不同于应用程序接口（API），API定义了源代码和库之间的接口，因此同样的代码可以在支持这个API的任何系统中编译，然而ABI允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行。 在Unix风格的操作系统中，存在很多运行在同一硬件平台上互相相关但是不兼容的操作系统（尤其是Intel 80386兼容系统）。有一些努力尝试标准化ABI，以减少销售商将程序移植到其他系统时所需的工作。然而，直到现在还没有很成功的例子，虽然Linux标准化工作组正在为Linux做这方面的努力。
</p>
<p>
我在上面说了，ABI的各个细节。在这我需要强调一点：在Swift类，如果没有明确标识对象基类则一律继承SwiftObject Objective-C类。这个是Swift的硬性规定。
</p>
<h2>类型设计</h2>
<h4>脆弱的结构体和元组设计</h4>
<p>
结构和元组目前共享相同的设计算法，编译器实现“通用”设计算法。该算法如下：
<ul>
  <li>从0开始，以1对齐增长</li>
  <li>遍历字段,在元素的元组,或顺序结构var声明。每个字段:<ul>
      <li>通过舍入更新字节来对齐字段，字段增长的值至少大于或等于字节，整除的一致性</li>
      <li>&lt;字段的当前值的大小赋给偏移量/li&gt;
      <li>更新字节通过添加字段的字节大小</li>
      <li>更新对齐最大字节，和更新对齐的字段</li>
      
  </li>
  <li>最终的大小和对齐的大小和对齐集合。类型是最后的，步长大小来对齐。</li>
</ul>

注意这不同于C或LLVM是正常的设计规则,大小和步幅是不同的,而C设计要求,嵌入式结构的大小是填充其对齐,迅速设计允许外部结构布置内部结构的尾巴填充字段,允许对齐。与C不同,大小结构和元组也允许,没有存储在包含总量。快速编译器发出LLVM包装结构类型与手动填充必要的控制二进制设计。一些例子:
<br />
``` swift
// LLVM &lt;{ i64, i8 }&gt;
struct S {
  var x: Int
  var y: UInt8
}

// LLVM &lt;{ i8, [7 x i8], &lt;{ i64, i8 }&gt;, i8 }&gt;
struct S2 {
  var x: UInt8
  var s: S
  var y: UInt8
}

// LLVM &lt;{}&gt;
struct Empty {}

// LLVM &lt;{ i64, i64 }&gt;
struct ContainsEmpty {
  var x: Int
  var y: Empty
  var z: Int
}
```


<h4>类设计</h4>
<p>
Swift依赖下面的关于Objective-C运行时的假设，是Objective-C ABI的一部分：
<ul>
<li>32位平台从未标记指针。ObjC指针类型是nil或一个对象指针。</li>
<li>在x86-64,一个标记指针设置指针的最低位或最高位的指针。因此,这两位都是0当且仅当该值不是一个标记指针。</li>
<li>ARM64,标记指针总是设置最高位的指针。</li>
<li>32位平台不会执行任何isa掩饰<code>object_getClass</code>总是相当于<code>*(Class*)object</code></li>
<li>64位平台上执行isa掩饰只有在运行时才导出的符号<code>uintptr_t objc_debug_isa_class_mask;</code>。如果导出这个符号，<code>object_getClass</code>在一个非标记指针总是相当于<code>(Class)(objc_debug_isa_class_mask &amp; *(uintptr_t*)object)</code></li>
<li>超类的类对象总是isa字段后立即存储。它的值是nil或一个指向父类的类对象;它从来没有其他设置。</li>
</ul>

下面是Swift ABI的一部分：
<ul>
<li>Swift指针不会是标记指针。</li>
</ul>
</p>

<h2>脆弱的Enum设计</h2>
<p>
在设计enum类型、ABI试图避免需要额外存储来存储枚举的标签。ABI选择的五个策略基于enum的设计:
</p>
<h4>空枚举</h4>
<p>enum在没有case的情况下,枚举是一个空的类型。
<br />
```swift
enum Empty {} // =&gt; empty type
```
</p>
<h4>单一类型枚举</h4>
<p>只有一个情况下的枚举，没有必要筛选,和枚举类型相同的设计的情况下的数据类型,可以是空的,如果没有数据类型。
<br />
```swift
enum EmptyCase { case X }             // =&gt; empty type
enum DataCase { case Y(Int, Double) } // =&gt; LLVM &lt;{ i64, double }&gt;
```
</p>
<h4>类C枚举</h4>
<p>如果没有一个case有数据类型(一个典型的“c”enum),那么enum是最小整数标记包含的比特数的所有情况。遵循LLVM的数据设计规则整数类型在目标平台上。被分配的case标签的值依次排列声明顺序。
<br />
```swift
enum EnumLike2 { // =&gt; LLVM i1
  case A         // =&gt; i1 0
  case B         // =&gt; i1 1
}

enum EnumLike8 { // =&gt; LLVM i3
  case A         // =&gt; i3 0
  case B         // =&gt; i3 1
  case C         // =&gt; i3 2
  case D         // etc.
  case E
  case F
  case G
  case H
}
```
<br />
辨别值之后，一个用于最后的case成为额外例子的枚举类型。
</p>

<h4>单一的对应枚举</h4>
<p>
如果枚举数据类型和一个或多个单情况没有数据的情况下(一个“单一的对应枚举”),然后与数据类型使用的数据类型来表示的二进制表示,必要时添加了零位标记。如果数据类型的二进制表示额外的条件,也就是说,有些模式类型的大小和对齐,但没有形成有效的值的类型,它们是用来表示没有数据的情况下,case的提升数值匹配的顺序没有数据情况下按声明顺序。如果类型有空闲位(见多个对应枚举),它们被用来形成额外的条件。然后枚举值表示为一个整数的存储大小的数据类型。额外的条件使用的负载类型不是枚举类型成为额外的条件enum类型本身。
<br />
```swift
enum CharOrSectionMarker { =&gt; LLVM i32
  case Paragraph            =&gt; i32 0x0020_0000
  case Char(UnicodeScalar)  =&gt; i32 (zext i21 %Char to i32)
  case Chapter              =&gt; i32 0x0020_0001
}

CharOrSectionMarker.Char('\x00') =&gt; i32 0x0000_0000
CharOrSectionMarker.Char('\u10FFFF') =&gt; i32 0x0010_FFFF

enum CharOrSectionMarkerOrFootnoteMarker { =&gt; LLVM i32
  case CharOrSectionMarker(CharOrSectionMarker) =&gt; i32 %CharOrSectionMarker
  case Asterisk                                 =&gt; i32 0x0020_0002
  case Dagger                                   =&gt; i32 0x0020_0003
  case DoubleDagger                             =&gt; i32 0x0020_0004
}
```
<br />
如果数据类型没有额外的条件,或者没有足够的额外的条件表示没有数据的情况下,然后添加一个标记位enum的表示。没有数据的标记位设置情况下,然后分配数据区域中的值的枚举声明的顺序。
<br />
```swift
enum IntOrInfinity { =&gt; LLVM &lt;{ i64, i1 }&gt;
  case NegInfinity    =&gt; &lt;{ i64, i1 }&gt; {    0, 1 }
  case Int(Int)       =&gt; &lt;{ i64, i1 }&gt; { %Int, 0 }
  case PosInfinity    =&gt; &lt;{ i64, i1 }&gt; {    1, 1 }
}

IntOrInfinity.Int(    0) =&gt; &lt;{ i64, i1 }&gt; {     0, 0 }
IntOrInfinity.Int(20721) =&gt; &lt;{ i64, i1 }&gt; { 20721, 0 }
```
</p>
<h4>多个对应枚举</h4>
<p>
如果一个枚举数据类型有多个情况,然后一个标签来区分数据类型是必要的。ABI首先会尝试找到共同闲置比特,即二进制数据类型的表示fixed-zero或忽略的有效值的所有数据类型。标签将被分散到这些闲置比特尽可能多。目前只备用的原始的整数类型,如高位被认为是<code>i21</code>类型。枚举数据表示为一个整数的存储大小的最大数据类型。
<br />
```swift
enum TerminalChar {             =&gt; LLVM i32
  case Plain(UnicodeScalar)     =&gt; i32     (zext i21 %Plain     to i32)
  case Bold(UnicodeScalar)      =&gt; i32 (or (zext i21 %Bold      to i32), 0x0020_0000)
  case Underline(UnicodeScalar) =&gt; i32 (or (zext i21 %Underline to i32), 0x0040_0000)
  case Blink(UnicodeScalar)     =&gt; i32 (or (zext i21 %Blink     to i32), 0x0060_0000)
  case Empty                    =&gt; i32 0x0080_0000
  case Cursor                   =&gt; i32 0x0080_0001
}
```
<br />
如果没有足够的空闲位包含标签,然后添加额外的比特表示包含标签。标签的值分配给数据情况下按声明顺序。如果有任何数据的情况下,他们被收集在一个共同的标签,并指定数据区域中的值的枚举声明的顺序。
<br />
```swift
class Bignum {}

enum IntDoubleOrBignum { =&gt; LLVM &lt;{ i64, i2 }&gt;
  case Int(Int)           =&gt; &lt;{ i64, i2 }&gt; {           %Int,            0 }
  case Double(Double)     =&gt; &lt;{ i64, i2 }&gt; { (bitcast  %Double to i64), 1 }
  case Bignum(Bignum)     =&gt; &lt;{ i64, i2 }&gt; { (ptrtoint %Bignum to i64), 2 }
}
```
</p>
<h2>存在容器的设计</h2>
<p>值的协议类型,协议组成类型,或“any”类型(<code>protocol&lt;&gt;</code>)提出使用存在容器(所谓的因为这些类型是类型理论中的“生存类型”)。</p>
<h4>存在的不透明容器</h4>
<p>如果没有类限制协议或协议组成类型,存在的容器必须适应值为任意大小和对齐。它使用一个固定大小的缓冲区,这是三个指针大小和pointer-aligned。这个直接包含的值,如果它的大小和对齐都小于或等于固定大小的缓冲区,或包含一个指针指向一个分配属于存在的容器。所包含的值的类型是由其类型标识元数据记录,为所有需要的协议和映射表的一致性。设计好像声明在C结构体如下:
<br />
```
struct OpaqueExistentialContainer {
  void *fixedSizeBuffer[3];
  Metadata *type;
  WitnessTable *witnessTables[NUM_WITNESS_TABLES];
};
```
</p>
<h4>存在的类的容器</h4>
<p>
如果一个或多个协议的协议或协议组成类型有一个类约束,然后只能存储在已经存在的容器,并使用一个更有效的表示。类实例总是一个指针的大小,所以不需要分配一个固定大小的缓冲区,和类实例总是有自己的引用类型的元数据,因此不需要单独的元数据记录。声明中的设计就好像下面C结构体:
<br />
```
struct ClassExistentialContainer {
  HeapObject *value;
  WitnessTable *witnessTables[NUM_WITNESS_TABLES];
};
```
<br />
注意,如果不需要映射表,如“任何类”类型的<code>protocol\\&lt;class\\&gt;</code>或一个Objective-C协议类型,然后唯一元素设计堆对象的指针。这是ABI兼容的id,<code>id \\&lt;Protocol\\&gt;</code>类型在Objective-C中。
</p>

<h2>元数据类型</h2>
<p>快速运行时保持元数据记录为每一类型在程序中使用,包括每一个实例化泛型类型的。可以使用这些元数据记录(TODO:映射)调试器工具发现的信息类型。对于非泛型名义类型,这些元数据是由编译器生成的静态记录。对泛型类型的实例,和内在类型如元组、功能、协议等等组成,元数据记录懒洋洋地根据需要运行时创建的。每个类型都有一个独特的元数据记录,两种元数据指针值相等,如果他们的类型相同。<br />
在下面的设计描述中,抵消了相对于元数据指针作为指针数组的索引。在32位平台上,抵消1意味着一个偏移量的4个字节,在64位平台上,这意味着8个字节的偏移量。<br />
</p>
<h4>通用元数据设计</h4>
<p>
所有元数据记录共享一个共同的数据头,下面字段:
<ul>
<li>映射价值表指针引用的vtable函数实现值的语义类型,提供了基本的操作,如分配,复制,销毁的类型。映射表也记录的值大小、对齐、步长等基本属性的类型。映射价值表指针偏移-1元数据的指针,即指针字节所在位置立即在指针的引用地址偏移。</li>
<li>类型字段是一个pointer-sized整数描述元数据描述。这个字段的偏移量为0的元数据的指针。</li>
</ul>
</p>
<h4>结构体元数据</h4>
<p>
除了常见的元数据字段设计、结构元数据记录包含以下字段:<br />
<ul>
<li>名义类型描述符引用偏移量1。</li>
<li>引用父元数据记录存储在偏移2。是一个封闭的名义类型的成员的结构,这是一个封闭类型的元数据的引用。对于高层结构体,这是null。（父指针总是空）</li>
<li>矢量偏移量从3开始。每个字段的结构体,在var声明顺序,字段的偏移字节从一开始的结构是存储为pointer-sized整数倍。</li>
<li>如果结构是通用的,那么通用参数向量始于抵消3 + n,其中n是结构中的字段的数量</li>
</ul>
</p>
<h4>枚举元数据</h4>
<p>除了常见的元数据字段设计,enum记录元数据包含以下字段:<br />
<ul>
<li>名义类型描述符引用偏移量1。</li>
<li>引用父元数据记录存储在偏移2。是一个封闭的名义类型的成员的结构,这是一个封闭类型的元数据的引用。对于高层结构体,这是null。（父指针总是空）</li>
<li>如果enum是通用的,那么通用参数向量始于偏移地址3。</li>
</ul>
</p>
<h4>元组元数据</h4>
<p>
除了常见的元数据字段设计、元组元数据记录包含以下字段:<br />
<ul>
<li>名义类型描述符引用偏移量1。</li>
<li>标签字符串指针连续以null结尾的标签名称的列表在元组偏移2。每个标签的名字是作为一个以null结尾,UTF-8编码的字符串序列。如果元组没有标签,这是一个空指针。(目前标签字符串指针总是空,独特的标签不考虑元组元数据)</li>
<li>向量的元素开始的偏移地址3,由一个向量type-offset对。第n个元素的元数据类型是指针的偏移地址3+2*n。字节的偏移量从一开始的第n个元素的元组开始的偏移量是3+2*n+1。</li>
</ul>
</p>
<h4>函数元数据</h4>
<p>除了常见的元数据字段设计,函数元数据记录包含以下字段:<br />
<ul>
<li>参数的数量函数存储在偏移量为1的地址。</li>
<li>结果的引用类型元数据记录存储在偏移量为2。如果函数有多个返回,这引用一个元组元数据记录</li>
<li>参数向量始于偏移地址3,由指针指向的函数的参数元数据记录。</li>
</ul>
<p>
如果函数需要任何in/out参数,每个参数的元数据记录指针将另外附加,一些被设置如果in/out最低位。由于指针对准,最低位持有这个标签总是空。
如果函数没有in/out参数,将只有一个指针在下列情形的向量:
</p>
<ul>
<li>0参数:一个元组元数据记录为空元组</li>
<li>1参数:第一个也是唯一一个参数的元数据记录</li>
<li>&gt; 1的参数:tuple包含参数的元数据记录</li>
</ul>
</p>
<h4>协议元数据</h4>
<p>
除了常见的元数据字段设计,协议元数据记录包含以下字段:</p>
<ul>
<li>设计标志词是储存在偏移为1。这个词的部分描述存在容器设计用于表示值的类型。这个词设计如下:<ul>
<li>映射表存储在最低位31位。协议类型的值包含这个数字映射表指针的设计。</li>
<li>类约束条件是储存在31位。这个位设置如果不类容器类型,这意味着结构、枚举、或类值中可以存储类型。如果没有设置,那么只能存储在类值类型,并使用一个更高效的设计类型。</li>
</ul>
注意字段pointer-sized,尽管只有最低的32位目前在所有平台上。这些值可以来自协议描述符记录,但预计算会更便利。
</li>
<li>协议的协议组成的数量是储存在偏移2。“任何”<code>protocol&lt;&gt; </code>或<code>protocol\\&lt;class\\&gt; </code>。对于单一协议 <code>P</code>。协议构成类型<code>protocol&lt;P, Q, ...&gt;</code>,这是协议的数量</li>
<li>协议描述符向量始于偏移地址3。这是内联的协议描述符的指针数组中的每个协议组成,或单一协议为协议类型描述符。“任何”类型,没有协议描述符向量。</li>
</ul>

<h4>变型的元数据</h4>
<p>
除了常见的元数据字段设计、变型的元数据记录包含以下字段:
<ul>
<li>引用的实例类型的元数据记录变型代表是储存在偏移为1的地址。</li>
</ul>
</p>

<h4>类元数据</h4>
<p>
类元数据设计和Objective-C互操作;所有类元数据记录也有效的Objective-C类对象。类元数据指针的值被用作类变型,所以派生类的元数据记录也作为一个有效的为其父类的所有类变型价值。
</p>







<hr />
</li></ul></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift的强大之处]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-qiang-da-zhi-chu/"/>
    <updated>2014-09-18T13:38:34+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-qiang-da-zhi-chu</id>
    <content type="html"><![CDATA[<p>在写任何东西之前我需要承认我是带有偏见的：我爱 Swift。我认为这是从我开始接触 Cocoa 生态系统以来这个平台上发生的最好的事情。我想通过分享我在 Swift，Objective-C 和 Haskell 上的经验让大家知道我为何这样认为。写这篇文章并不是为了介绍一些最好的实践 (写这些的时候 Swift 还太年轻，还没最好实践被总结出来)，而是举几个关于 Swift 强大之处的例子。</p>

<p>给大家一些我的个人背景：在成为全职 iOS/Mac 工程师之前我花了几年的时间做 Haskell (包括一些其他函数式编程语言) 开发。我仍然认为 Haskell 是我所有使用过的语言中最棒的之一。然而我转战到了 Objective-C，是因为我相信 iOS 是最令人激动的平台。刚开始接触 Objective-C 的时候我有些许沮丧，但我慢慢地学会了欣赏它。</p>

<p>当苹果在 WWDC 发布 Swift 的时候我非常的激动。我已经很久没有对新技术的发布感的如此兴奋了。在看过文档之后我意识到 Swift 使我们能够将现有的函数式编程知识和 Cocoa API 无缝地整合到一起。我觉得这两者的组合非常独特：没有任何其他的语言将它们融合地如此完美。就拿 Haskell 来说，想要用它来使用 Objective-C API 相当的困难。同样，想用 Objective-C 去做函数式编程也是十分困难的。</p>

<p>在 Utrecht 大学期间我学会了函数式编程。因为是在很学术的环境下学习所以并没有觉得很多复杂的术语 (moands，applicative functors 以及很多其他的东西) 有多么难懂。我觉得对很多想学习函数式编程的人来说这些名称是一个很大的阻碍。</p>

<p>不仅仅名称很不同，风格也不一样。作为 Objective-C 程序员，我们很习惯于面向对象编程。而且因为大多数语言不是面对对象编程就是与之类似，我们可以看懂很多不同语言的代码。阅读函数式编程语言的时候则大不相同 -- 如果你没有习惯的话看起来简直莫名其妙。</p>

<p>那么，为什么你要使用函数式编程呢？它很奇怪，很多人都不习惯而且学习它要花费大量的时间。并且对于大多数问题面向对象编程都能解决，所以没有必要去学习任何新的东西对吧？</p>

<p>对于我来说，函数式编程只是工具箱中的一件工具。它是一个改变了我对编程的理解的强大工具。在解决问题的时候它非常强大。对于大多数问题面向对象编程都很棒，但是对于其他一些问题应用函数式编程会给你带来巨大的时间/精力的节省。</p>

<p>开始学习函数式编程或许有些痛苦。第一，你必须放手一些老的模式。而因为我们很多人常年用面对对象的方式去思考，做到这一点是很困难的。在函数式编程当中你想的是不变的数据结构以及那些转换它们的函数。在面对对象编程当中你考虑的是互相发送信息的对象。如果你没有马上理解函数式编程，这是一个好的信号。你的大脑很可能已经完全适应了用面对对象的方法来解决问题。</p>

<h2>例子</h2>
<!-- more-->
<p>我最喜欢的 Swift 功能之一是对 optionals 的使用。Optionals 让我们能够应对有可能存在也有可能不存在的值。在 Objective-C 里我们必须在文档中清晰地说明 nil 是否是允许的。Optionals 让我们将这份责任交给了类型系统。如果你有一个可选值，你就知道它可以是 nil。如果它不是可选值，你知道它不可能是 nil。</p>

<p>举个例子，看看下面一小段 Objective-C 代码</p>

<p><code>objc
- (NSAttributedString *)attributedString:(NSString *)input 
{
    return [[NSAttributedString alloc] initWithString:input];
}
</code></p>

<p>看上去没有什么问题，但是如果 <code>input</code> 是 nil, 它就会崩溃。这种问题你只能在运行的时候才能发现。取决于你如何使用它，你可能很快能发现问题，但是你也有可能在发布应用之后才发现，导致用户正在使用的应用崩溃。</p>

<p>用相同的 Swift 的 API 来做对比。</p>

<p><code>objc
extension NSAttributedString {  
    init(string str: String)
}
</code></p>

<p>看起来像对Objective-C的直接翻译，但是 Swift 不允许 <code>nil</code> 被传入。如果要达到这个目的，API 需要变成这个样子：</p>

<p><code>objc
extension NSAttributedString {  
    init(string str: String?)
}
</code></p>

<p>注意新加上的问号。这意味着你可以使用一个值或者是 nil。类非常的精确：只需要看一眼我们就知道什么值是允许的。使用 optionals 一段时间之后你会发现你只需要阅读类型而不用再去看文档了。如果犯了一个错误，你会得到一个编译时警告而不是一个运行时错误。</p>

<h2>建议</h2>

<p>如果可能的话避免使用 optionals。Optionals 对于使用你 API 的人们来说是一个多余的负担。话虽如此，还是有很多地方可以很好使用它们。如果你有一个函数会因为一个明显的原因失败你可以返回一个 optional。举例来说，比如将一个  #00ff00 字符串转换成颜色。如果你的参数不符合正确的格式，你应该返回一个 <code>nil</code> 。</p>

<p><code>objc
func parseColorFromHexString(input: String) -&gt; UIColor? {  
    // ...
}
</code></p>

<p>如果你需要阐明错误信息，你可以使用 <code>Either</code> 或者 <code>Result</code> 类型 (不在标准库里面)。当失败的原因很重要的时候，这种做法会非常有用。<a href="http://nomothetis.svbtle.com/error-handling-in-swift">“Error Handling in Swift”</a> 一文中有个很好的例子。</p>

<h2 id="enums">Enums</h2>

<p>Enums 是一个随 Swift 推出的新东西，它和我们在 Objective-C 中见过的东西都大不相同。在 Objective-C 里面我们有一个东西叫做 enums, 但是它们差不多就是升级版的整数。</p>

<p>我们来看看布尔类型。一个布尔值是两种可能性 -- true 或者 false -- 中的一个。很重要的一点是没有办法再添加另外一个值 -- 布尔类型是<strong>封闭的</strong>。布尔类型的封闭性的好处是每当使用布尔值的时候我们只需要考虑 true 或者 false 这两种情况。</p>

<p>在这一点上面 optionals 是一样的。总共只有两种情况：<code>nil</code> 或者有值。在 Swift 里面布尔和 optional 都可以被定义为 enums。但有一个不同点：在 optional enum 中有一种可能性有一个相关值。我们来看看它们不同的定义：</p>

<p>```objc
enum Boolean {<br />
    case False
    case True
}</p>

<p>enum Optional<a> {<br />
    case Nil
    case Some(A)
}
```</a></p>

<p>它们非常的相似。如果你把它们的名称改成一样的话，那么唯一的区别就是括号里的相关值。如果你给 optional 中的 <code>Nil</code>  情况也加上一个值，你就会得到一个 <code>Either</code> 类型：</p>

<p><code>objc
enum Either&lt;A,B&gt; {  
    case Left&lt;A&gt;
    case Right&lt;B&gt;
}
</code></p>

<p>在函数式编程当中，在你想表示两件事情之间的选择时候你会经常用到 <code>Either</code> 类型。举个例子：如果你有一个函数返回一个整数或者一个错误，你就可以用 <code>Either&lt;Int, NSError&gt;</code>。如果你想在一个字典中储存布尔值或者字符串，你就可以使用 <code>Either&lt;Bool,String&gt;</code> 作为键。</p>

<blockquote>
  <p>理论旁白：有些时候 enums 被称为 <strong>sum 类型</strong>，因为它们是几个不同类型的总和。在 <code>Either</code> 类型的例子中，它们表达的是 <code>A</code> 类型和 <code>B</code> 类型的和。Structs 和 tuples 被称为 <strong>product 类型</strong>，因为它们代表几个不同类型的乘积。参见<a href="http://en.wikipedia.org/wiki/Algebraic_data_type">“algebraic data types.”</a></p>
</blockquote>

<p>理解什么时候使用 enums 什么时候使用其他的数据类型 (比如 <a href="http://objccn.io/issue-16-2">class 或者 structs</a>)会有一些难度。当你有一个固定数量的值的集合的时候，enum 是最有用的。比如说，如果我们设计一个 Github API 的 wrapper，我们可以用 enum 来表示端点。比如有一个不需要任何参数的 <code>/zen</code> 的 API 端点。再比如为了获取用户的资料我们需要提供用户名。最后我们显示用户的仓库时，我们需要提供用户名以及一个值去说明是否从小到大地排列结果。</p>

<p><code>objc
enum Github {  
    case Zen
    case UserProfile(String)
    case Repositories(username: String, sortAscending: Bool)
}
</code></p>

<p>定义 API 端点是很好的使用 enum 的场景。API 的端点是有限的，所以我们可以为每一个端点定义一个情况。如果我们在对这些端点使用 switch 的时候没有包含所有情况的话，我们会被给予警告。所以说当我们需要添加一个情况的时候我们需要更新每一个用到这个 enum 的函数。</p>

<p>除非能够拿到源代码，其他使用我们 enum 的人不能添加新的情况，这是一个非常有用的限制。想想要是你能够加一种新情况到 <code>Bool</code> 或者 <code>Optional</code> 里会怎么样吧 -- 所有用到 它的函数都需要重写。</p>

<p>比如说我们正在开发一个货币转换器。我们可以将货币给定义成 enum：</p>

<p><code>objc
enum Currency {  
    case Eur
    case Usd
}
</code></p>

<p>我们现在可以做一个获取任何货币符号的函数：</p>

<p><code>objc
func symbol(input: Currency) -&gt; String {  
    switch input {
        case .Eur: return "€"
        case .Usd: return "$"
    }
}
</code></p>

<p>最后，我们可以用我们的 <code>symbol</code> 函数，来依据系统本地设置得到一个很好地格式化过的字符串：</p>

<p><code>objc
func format(amount: Double, currency: Currency) -&gt; String {  
    let formatter = NSNumberFormatter()
    formatter.numberStyle = .CurrencyStyle
    formatter.currencySymbol = symbol(currency)
    return formatter.stringFromNumber(amount)
}
</code></p>

<p>这样一来有一个很大的限制。我们可能会想让我们 API 的使用者在将来可以修改一些情况。在 Objective-C 当中向一个接口里添加更多类型的常见解决方法是子类化。在 Objective-C 里面理论上你可以子类化任何一个类，然后通过这种办法来扩展它。在 Swift 里面你仍然可以使用子类化，但是只能对 <code>class</code> 使用，对于 <code>enum</code> 则不行。然而，我们可以用另一种技术来达到目的 (这种办法在 Objetive-C 和 Swift 的 protocol 中都可行）。</p>

<p>假设我们定义一个货币符号的协议：</p>

<p><code>objc
protocol CurrencySymbol {  
    func symbol() -&gt; String
}
</code></p>

<p>现在我们让 <code>Currency</code> 类型遵守这个协议。注意我们可以将 <code>input</code> 参数去掉，因为这里它被作为 self 隐式地进行传递：</p>

<p><code>objc
extension Currency : CurrencySymbol {  
   func symbol() -&gt; String {
        switch self {
            case .Eur: return "€"
            case .Usd: return "$"
        }
    }
}
</code></p>

<p>现在我们可以重写 <code>format</code> 方法来格式化任何遵守我们协议的类型：</p>

<p><code>objc
func format(amount: Double, currency: CurrencySymbol) -&gt; String {  
    let formatter = NSNumberFormatter()
    formatter.numberStyle = .CurrencyStyle
    formatter.currencySymbol = currency.symbol()
    return formatter.stringFromNumber(amount)
}
</code></p>

<p>这样一来我们将我们代码的可延展性大大提升类 -- 任何遵守 <code>CurrencySymbol</code> 协议的类型都可以被格式化。比如说，我们建立一个新的类型来储存比特币，我们可以立刻让它拥有格式化功能：</p>

<p><code>objc
struct Bitcoin : CurrencySymbol {  
    func symbol() -&gt; String {
        return "B⃦"
    }
}
</code></p>

<p>这是一种写出具有延展性函数的很好的方法。通过使用一个需要遵守协议，而不是一个实实在在的类型，你的 API 的用户能够加入更多的类型。你仍然可以利用 enum 的灵活性，但是通过让它们遵守协议，你可以更好地表达自己的意思。根据你的具体情况，你现在可以轻松地选择是否开放你的 API。</p>

<h2>类型安全</h2>

<p>我认为类型的安全性是 Swift 一个很大的优势。就像我们在讨论 optionals 时看见的一样，我们可以用一些聪明的手段将某些检测从运行时转移到编译时。Swift 中数组的工作方式就是一个例子：一个数组是泛型的，它只能容纳一个类型的对象。将一个整数附加在一个字符组数组后面是做不到的。这样以来就消灭了一个类的潜在 bug。(值得注意的是如果你需要同时将字符串或者整数放到一个数组里的话，你可以使用上面谈到过的 <code>Either</code> 类型。)</p>

<p>再比如说，我们要将我们到货币转换器延展为一个通用的单位换算器。如果我们使用 <code>Double</code> 去表示数量，会有一点点误导性。比如说，100.0 可以表示 100 美元，100 千克或者任何能用 100 表示的东西。我们可以借助类型系统来制作不同的类型来表示不同的物理上的数量。比如说我们可以定义一个类型来表示钱：</p>

<p><code>objc
struct Money {  
    let amount : Double
    let currency: Currency
}
</code></p>

<p>我们可以定义另外一个结构来表示质量：</p>

<p><code>objc
struct Mass {  
    let kilograms: Double
}
</code></p>

<p>现在我们就消除了不小心将 <code>Money</code>  和 <code>Mass</code> 相加的可能性。基于你应用的特质有时候将一些简单的类型包装成这样是很有效的。不仅如此，阅读代码也会变得更加简单。假设我们遇到一个 <code>pounds</code> 函数：</p>

<p><code>objc
func pounds(input: Double) -&gt; Double  
</code></p>

<p>光看类型定义很难看出来这个函数的功能。它将欧元装换成英镑？还是将千克转换成磅？ (英文中英镑和磅均为 pound) 我们可以用不同的名字，或者可以建立文档 (都是很好的办法)，但是我们有第三种选择。我们可以将这个类型变得更明确：</p>

<p><code>objc
func pounds(input: Mass) -&gt; Double  
</code></p>

<p>我们不仅让这个函数的用户能够立刻理解这个函数的功能，我们也防止了不小心传入其他单位的参数。如果你试图将 <code>Money</code> 作为参数来使用这个函数，编译器是不会接受的。另外一个可能的提升是使用一个更精确的返回值。现在它只是一个 <code>Double</code>。</p>

<h2>不可变性</h2>

<p>Swift 另外一个很棒的功能是内置的不可变性。在 Cocoa 当中很多的 API 都已经体现出了不可变性的价值。想了解这一点为什么如此重要，<a href="http://nomothetis.svbtle.com/error-handling-in-swift">“Error Handling in Swift”</a> 是一个很好的参考。比如，作为一个 Cocoa 开发者，我们使用很多成对的类 (<code>NSString</code> vs. <code>NSMutableString</code>，<code>NSArray</code> vs. <code>NSMutableArray</code>)。当你得到一个字符串值，你可以假设它不会被改变。但是如果你要完全确信，你依然要复制它。然后你才知道你有一份不可变的版本。</p>

<p>在 Swifit 里面，不可变性被直接加入这门语言。比如说如果你想建立一个可变的字符串，你可以如下的代码：</p>

<p><code>objc
var myString = "Hello"  
</code></p>

<p>然而，如果你想要一个不可变的字符串，你可以做如下的事情：</p>

<p><code>objc
let myString = "Hello"  
</code></p>

<p>不可变的数据在创建可能会被未知用户使用的 API 时会给你很大的帮助。比如说，你有一个需要字符串作为参数的函数，在你迭代它的时候，确定它不会被改变是很重要的。在 Swift 当中这是默认的行为。正是因为这个原因，在写多线程代码的时候使用不可变资料会使难度大大降低。</p>

<p>还有另外一个巨大的优势。如果你的函数只使用不可变的数据，你的类型签名就会成为很好的文档。在 Objective-C 当中则不然。比如说，假设你准备在 OS X 上使用 <code>CIFilter</code>。在实例化之后你需要使用 <code>setDefaults</code> 方法。这一点在文档中有提到。有很多这样类都是这个样子。在实例化之后，在你使用它之前你必须要使用另外一个方法。问题在于，如果不阅读文档的话，经常会不清楚哪些函数需要被使用，最后你有可能遇到很奇怪的状况。</p>

<p>当使用不可变资料的时候，类型签名让事情变得很清晰。比如说，<code>map</code> 的类签名。我们知道有一个可选的 <code>T</code> 值，而且有一个将 <code>T</code> 转换成 <code>U</code> 的函数。结果是一个可选的 <code>U</code> 值。原始值是不可能改变的：</p>

<p><code>objc
func map&lt;T, U&gt;(x: T?, f: T -&gt; U) -&gt; U?  
</code></p>

<p>对于数组的 <code>map</code> 来说是一样的。它被定义成一个数组的延伸，所以参数本身是 <code>self</code>。我们可以看到它用一个函数将 <code>T</code> 转化成 <code>U</code>，并且生成一个 <code>U</code> 的数组。因为它是一个不可变的函数，我们知道原数组是不会变化的，而且我们知道结果也是不会改变的。将这些限制内置在l类型系统中，并有编译器来监督执行，让我们不再需要去查看文档并记住什么会变化。</p>

<p><code>objc
extension Array {  
    func map&lt;U&gt;(transform: T -&gt; U) -&gt; [U]
}
</code></p>

<h2>总结</h2>

<p>Swift 带来了很多有趣的可能性。我尤其喜欢的一点是过去我们需要手动检测或者阅读文档的事情现在编译器可以帮我们来完成。我们可以选择在合适的时机去使用这些可能性。我们依然会用我们现有的，成熟的办法去写代码，但是我们可以在合适的时候在我们代码的某些地方应用这些新的可能性。</p>

<p>我预测：Swift 会很大程度上改变我们写代码的方式，而且是向好的方向改变。脱离 Objective-C 会需要几年的时间，但是我相信我们中的大多数人会做出这个改变并且不会后悔。有些人会很快的适应，对另外一些人可能会花上很长的时间。但是我相信总有一天绝大多数人会看到 Swift 带给我们的种种好处。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift的函数式API]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-han-shu-shi-api/"/>
    <updated>2014-09-18T10:19:05+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-han-shu-shi-api</id>
    <content type="html"><![CDATA[<p>在过去的时间里，人们对于设计 API 总结了很多通用的模式和最佳实践方案。一般情况下，我们总是可以从苹果的 Foundation、Cocoa、Cocoa Touch 和很多其他框架中总结出一些开发中的范例。毫无疑问，对于“特定情境下的 API 应该如何设计”这个问题，不同的人总是有着不同的意见，对于这个问题有很大的讨论空间。不过对于很多 Objective-C 的开发者来说，对于那些常用的模式早已习以为常。</p>

<p>随着 Swift 的出现，设计 API 引起了更多的问题。绝大多数情况下，我们只能继续做着手头的工作，然后把现有的方法翻译成 Swift 版本。不过，这对于 Swift 来说并不公平，因为和 Objective-C 相比，Swift 添加了很多新的特性。引用 Swift 创始人 <a href="https://twitter.com/clattner_llvm">Chris Lattner</a> 的一段话：</p>

<blockquote>
  <p>Swift 引入了泛型和函数式编程的思想，极大地扩展了设计的空间。</p>
</blockquote>

<p>在这篇文章里，我们将会围绕 <code>Core Image</code> 进行 API 封装，以此为例，探索如何在 API 设计中使用这些新的工具。 <code>Core Image</code> 是一个功能强大的图像处理框架，但是它的 API 有时有点笨重。 <code>Core Image</code> 的 API 是弱类型的 - 它通过键值对 (key-value) 设置图像滤镜。这样在设置参数的类型和名字时很容易失误，会导致运行时错误。新的 API 将会十分的安全和模块化，通过使用类型而不是键值对来规避这样的运行时错误。</p>

<h2>目标</h2>

<p>我们的目标是构建一个 API ，让我们可以简单安全的组装自定义滤镜。举个例子，在文章的结尾，我们可以这样写：</p>

<p><code>objc
let myFilter = blur(blurRadius) &gt;|&gt; colorOverlay(overlayColor)
let result = myFilter(image)
</code></p>

<p>上面构建了一个自定义的滤镜，先模糊图像，然后再添加一个颜色蒙版。为了达到这个目标，我们将充分利用 Swift 函数是一等公民这一特性。项目源码可以在 Github 上的这个<a href="https://github.com/objcio/issue-16-functional-apis">示例项目</a>中下载。</p>

<h2 id="filter">Filter 类型</h2>

<p><code>CIFilter</code> 是 <code>Core Image</code> 中的一个核心类，用来创建图像滤镜。当实例化一个 <code>CIFilter</code> 对象之后，你 (几乎) 总是通过 <code>kCIInputImageKey</code> 来输入图像，然后通过 <code>kCIOutputImageKey</code> 获取返回的图像，返回的结果可以作为下一个滤镜的参数输入。</p>

<p>在我们即将开发的 API 里，我们会把这些键值对 (key-value) 对应的真实内容抽离出来，为用户提供一个安全的强类型 API。我们定义了自己的滤镜类型 <code>Filter</code>，它是一个可以传入图片作为参数的函数，并且返回一个新的图片。</p>

<p><code>objc
typealias Filter = CIImage -&gt; CIImage
</code>
<!-- more--></p>
<p>这里我们用 <code>typealias</code> 关键字，为 <code>CIImage -&gt; CIImage</code>类型定义了我们自己的名字，这个类型是一个函数，它的参数是一个 <code>CIImage</code> ，返回值也是 <code>CIImage</code> 。这是我们后面开发需要的基础类型。</p>

<p>如果你不太熟悉函数式编程，你可能对于把一个函数类型命名为 <code>Filter</code> 感觉有点奇怪，通常来说，我们会用这样的命名来定义一个类。如果我们很想以某种方式来表现这个类型的函数式的特性，我们可以把它命名成 <code>FilterFunction</code> 或者一些其他的类似的名字。但是，我们有意识的选择了 <code>Filter</code> 这个名字，因为在函数式编程的核心哲学里，函数就是值，函数和结构体、整数、多元组、或者类，并没有任何区别。一开始我也不是很适应，不过一段时间之后发现，这样做确实很有意义。</p>

<h2>构建滤镜</h2>

<p>现在我们已经定义了 <code>Filter</code> 类型，接下来可以定义函数来构建特定的滤镜了。这些函数需要参数来设置特定的滤镜，并且返回一个类型为 <code>Filter</code> 的值。这些函数大概是这个样子：</p>

<p><code>objc
func myFilter(/* parameters */) -&gt; Filter
</code></p>

<p>注意返回的值 <code>Filter</code> 本身就是一个函数，在后面有利于我们将多个滤镜组合起来，以达到理想的处理效果。</p>

<p>为了让后面的开发更轻松一点，我们扩展了 <code>CIFilter</code> 类，添加了一个 convenience 的初始化方法，以及一个用来获取输出图像的计算属性：</p>

<p>```objc
typealias Parameters = Dictionary&lt;String, AnyObject&gt;</p>

<p>extension CIFilter {</p>

<pre><code>convenience init(name: String, parameters: Parameters) {
    self.init(name: name)
    setDefaults()
    for (key, value : AnyObject) in parameters {
        setValue(value, forKey: key)
    }
}

var outputImage: CIImage { return self.valueForKey(kCIOutputImageKey) as CIImage }
</code></pre>

<p>}
```</p>

<p>这个 convenience 初始化方法有两个参数，第一个参数是滤镜的名字，第二个参数是一个字典。字典中的键值对将会被设置成新滤镜的参数。我们 convenience 初始化方法先调用了指定的初始化方法，这符合 Swift 的开发规范。</p>

<p>计算属性 <code>outputImage</code> 可以方便地从滤镜对象中获取到输出的图像。它查找 <code>kCIOutputImageKey</code> 对应的值并且将其转换成一个 <code>CIImage</code> 对象。通过提供这个属性， API 的用户不再需要对返回的结果手动进行类型转换了。</p>

<h2>模糊</h2>

<p>有了这些东西，现在我们就可以定义属于自己的简单滤镜了。高斯模糊滤镜只需要一个模糊半径作为参数，我们可以非常容易的完成一个模糊滤镜：</p>

<p><code>objc
func blur(radius: Double) -&gt; Filter {
    return { image in
        let parameters : Parameters = [kCIInputRadiusKey: radius, kCIInputImageKey: image]
        let filter = CIFilter(name:"CIGaussianBlur", parameters:parameters)
        return filter.outputImage
    }
}
</code></p>

<p>就是这么简单，这个模糊函数返回了一个函数，新的函数的参数是一个类型为 <code>CIImage</code> 的图片，返回值 (<code>filter.outputImage</code>) 是一个新的图片 。这个模糊函数的格式是 <code>CIImage -&gt; CIImage</code> ，满足我们前面定义的 <code>Filter</code> 类型的格式。</p>

<p>这个例子只是对 <code>Core Image</code> 中已有滤镜的一个简单的封装，我们可以多次重复同样的模式，创建属于我们自己的滤镜函数。</p>

<h2>颜色蒙版</h2>

<p>现在让我们定义一个颜色滤镜，可以在现有的图片上面加上一层颜色蒙版。 <code>Core Image</code> 默认没有提供这个滤镜，不过我们可以通过已有的滤镜组装一个。</p>

<p>我们使用两个模块来完成这个工作，一个是颜色生成滤镜 (<code>CIConstantColorGenerator</code>)，另一个是资源合成滤镜 (<code>CISourceOverCompositing</code>)。让我们先定义一个生成一个常量颜色面板的滤镜：</p>

<p><code>objc
func colorGenerator(color: UIColor) -&gt; Filter {
    return { _ in
        let filter = CIFilter(name:"CIConstantColorGenerator", parameters: [kCIInputColorKey: color])
        return filter.outputImage
    }
}
</code></p>

<p>这段代码看起来和前面的模糊滤镜差不多，不过有一个较为明显的差异：颜色生成滤镜不会检测输入的图片。所以在函数里我们不需要给传入的图片参数命名，我们使用了一个匿名参数 <code>_</code> 来强调这个 filter 的图片参数是被忽略的。</p>

<p>接下来，我们来定义合成滤镜：</p>

<p><code>objc
func compositeSourceOver(overlay: CIImage) -&gt; Filter {
    return { image in
        let parameters : Parameters = [ 
            kCIInputBackgroundImageKey: image, 
            kCIInputImageKey: overlay
        ]
        let filter = CIFilter(name:"CISourceOverCompositing", parameters: parameters)
        return filter.outputImage.imageByCroppingToRect(image.extent())
    }
}
</code></p>

<p>在这里我们将输出图像裁剪到和输入大小一样。这并不是严格需要的，要取决于我们想让滤镜如何工作。不过，在后面我们的例子中我们可以看出来这是一个明智之举。</p>

<p><code>objc
func colorOverlay(color: UIColor) -&gt; Filter {
    return { image in
        let overlay = colorGenerator(color)(image)
        return compositeSourceOver(overlay)(image)
    }
}
</code></p>

<p>我们再一次返回了一个参数为图片的函数，<code>colorOverlay</code> 在一开始先调用了 <code>colorGenerator</code> 滤镜。<code>colorGenerator</code> 滤镜需要一个颜色作为参数，并且返回一个滤镜。因此 <code>colorGenerator(color)</code> 是 <code>Filter</code> 类型的。但是 <code>Filter</code> 类型本身是一个 <code>CIImage</code> 向 <code>CIImage</code> 转换的函数，我们可以在 <code>colorGenerator(color)</code> 后面加上一个类型为 <code>CIImage</code> 的参数，这样可以得到一个类型为 <code>CIImage</code> 的蒙版图片。这就是在定义 <code>overlay</code> 的时候发生的事情：我们用 <code>colorGenerator</code> 函数创建了一个滤镜，然后把图片作为一个参数传给了这个滤镜，从而得到了一张新的图片。返回值 <code>compositeSourceOver(overlay)(image)</code> 和这个基本相似，它由一个滤镜 <code>compositeSourceOver(overlay)</code> 和一个图片参数 <code>image</code> 组成。</p>

<h2>组合滤镜</h2>

<p>现在我们已经定义了一个模糊滤镜和一个颜色滤镜，我们在使用的时候可以把它们组合在一起：我们先将图片做模糊处理，然后再在上面放一个红色的蒙层。让我们先加载一张图片：</p>

<p><code>objc
let url = NSURL(string: "http://tinyurl.com/m74sldb");
let image = CIImage(contentsOfURL: url)
</code></p>

<p>现在我们可以把滤镜组合起来，同时应用到一张图片上：</p>

<p><code>objc
let blurRadius = 5.0
let overlayColor = UIColor.redColor().colorWithAlphaComponent(0.2)
let blurredImage = blur(blurRadius)(image)
let overlaidImage = colorOverlay(overlayColor)(blurredImage)
</code></p>

<p>我们又一次的通过滤镜组装了图片。比如在倒数第二行，我们先得到了模糊滤镜 <code>blur(blurRadius)</code> ，然后再把这个滤镜应用到图片上。</p>

<h2>函数组装</h2>

<p>不过，我们可以做的比上面的更好。我们可以简单的把两行滤镜的调用组合在一起变成一行，这是我脑海中想到的第一个能改进的地方：</p>

<p><code>objc
let result = colorOverlay(overlayColor)(blur(blurRadius)(image))
</code></p>

<p>不过，这些圆括号让这行代码完全不具有可读性，更好的方式是定义一个函数来完成这项任务：</p>

<p><code>objc
func composeFilters(filter1: Filter, filter2: Filter) -&gt; Filter {
    return { img in filter2(filter1(img)) }
}
</code></p>

<p><code>composeFilters</code> 函数的两个参数都是 Filter ，并且返回了一个新的 Filter 滤镜。组装后的滤镜需要一个 <code>CIImage</code> 类型的参数，并且会把这个参数分别传给 <code>filter1</code> 和 <code>filter2</code> 。现在我们可以用 <code>composeFilters</code> 来定义我们自己的组合滤镜：</p>

<p><code>objc
let myFilter = composeFilters(blur(blurRadius), colorOverlay(overlayColor))
let result = myFilter(image)
</code></p>

<p>我们还可以更进一步的定义一个滤镜运算符，让代码更具有可读性，</p>

<p>```objc
infix operator &gt;|&gt; { associativity left }</p>

<p>func &gt;|&gt; (filter1: Filter, filter2: Filter) -&gt; Filter {
    return { img in filter2(filter1(img)) }
}
```</p>

<p>运算符通过 <code>infix</code> 关键字定义，表明运算符具有 <code>左</code> 和 <code>右</code> 两个参数。<code>associativity left</code> 表明这个运算满足左结合律，即：f1 &gt;|&gt; f2 &gt;|&gt; f3 等价于 (f1 &gt;|&gt; f2) &gt;|&gt; f3。通过使这个运算满足左结合律，再加上运算内先应用了左侧的滤镜，所以在使用的时候滤镜顺序是从左往右的，就像 Unix 管道一样。</p>

<p>剩余的部分是一个函数，内容和 <code>composeFilters</code> 基本相同，只不过函数名变成了 <code>&gt;|&gt;</code>。</p>

<p>接下来我们把这个组合滤镜运算器应用到前面的例子中：</p>

<p><code>objc
let myFilter = blur(blurRadius) &gt;|&gt; colorOverlay(overlayColor)
let result = myFilter(image)
</code></p>

<p>运算符让代码变得更易于阅读和理解滤镜使用的顺序，调用滤镜的时候也更加的方便。就好比是 <code>1 + 2 + 3 + 4</code> 要比 <code>add(add(add(1, 2), 3), 4)</code> 更加清晰，更加容易理解。</p>

<h2>自定义运算符</h2>

<p>很多 Objective-C 的开发者对于自定义运算符持有怀疑态度。在 Swift 刚发布的时候，这是一个并没有很受欢迎的特性。很多人在 C++ 中遭遇过自定义运算符过度使用 (甚至滥用) 的情况，有些是个人经历过的，有些是听到别人谈起的。</p>

<p>你可能对于前面定义的运算符 <code>&gt;|&gt;</code> 持有同样的怀疑态度，毕竟如果每个人都定义自己的运算符，那代码岂不是很难理解了？值得庆幸的是在函数式编程里有很多的操作，为这些操作定义一个运算符并不是一件很罕见的事情。</p>

<p>我们定义的滤镜组合运算符是一个<a href="http://en.wikipedia.org/wiki/Function_composition_%28computer_science%29">函数组合</a>的例子，这是一个在函数式编程中广泛使用的概念。在数学里，两个函数 <code>f</code> 和 <code>g</code> 的组合有时候写做 <code>f ∘ g</code>，这样定义了一种全新的函数，将输入的 <code>x</code> 映射到 <code>f(g(x))</code> 上。这恰好就是我们的 <code>&gt;|&gt;</code> 所做的工作 (除了函数的逆向调用)。 </p>

<h2>泛型</h2>

<p>仔细想想，其实我们并没有必要去定义一个用来专门组装滤镜的运算符，我们可以用一个泛型的运算符来组装函数。目前我们的 <code>&gt;|&gt;</code> 是这样的：</p>

<p><code>objc
func &gt;|&gt; (filter1: Filter, filter2: Filter) -&gt; Filter
</code></p>

<p>这样定义之后，我们传入的参数只能是 <code>Filter</code> 类型的滤镜。</p>

<p>但是，我们可以利用 Swift 的通用特性来定义一个泛型的函数组合运算符：</p>

<p><code>objc
func &gt;|&gt; &lt;A, B, C&gt;(lhs: A -&gt; B, rhs: B -&gt; C) -&gt; A -&gt; C {
    return { x in rhs(lhs(x)) }
}
</code></p>

<p>这个一开始可能很难理解 -- 至少对我来说是这样。但是分开的看了各个部分之后，一切都变得清晰起来。</p>

<p>首先，我们来看一下函数名后面的尖括号。尖括号定义了这个函数适用的泛型类型。在这个例子里我们定义了三个类型：A、B 和 C。因为我们并没有指定这些类型，所以它们可以代表任何东西。</p>

<p>接下来让我们来看看函数的参数：第一个参数：lhs (left-hand side 的缩写)，是一个类型为 A -&gt; B 的函数。这代表一个函数的参数为 A，返回值的类型为 B。第二个参数：rhs (right-hand side 的缩写)，是一个类型为 B -&gt; C 的函数。参数命名为 lhs 和 rhs，因为它们分别对应操作符左边和右边的值。</p>

<p>重写了没有 <code>Filter</code> 的滤镜组合运算符之后，我们很快就发现其实前面实现的组合运算符只是泛型函数中的一个特殊情况：</p>

<p><code>objc
func &gt;|&gt; (filter1: CIImage -&gt; CIImage, filter2: CIImage -&gt; CIImage) -&gt; CIImage -&gt; CIImage
</code></p>

<p>把我们脑海中的泛型类型 A、B、C 都换成 <code>CIImage</code>，这样可以清晰的理解用通用运算符的来替换滤镜组合运算符是多么的有用。</p>

<h2>结论</h2>

<p>至此，我们成功的用函数式 API 封装了 <code>Core Image</code>。希望这个例子能够很好的说明，对于 Objective-C 的开发者来说，在我们所熟知的 API 的设计模式之外有一片完全不同的世界。有了 Swift，我们现在可以动手探索那些全新的领域，并且将它们充分地利用起来。</p>

<hr />

]]></content>
  </entry>
  
</feed>
