<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | IT Monkey Life]]></title>
  <link href="http://ITMonkeyLife.github.io/Blog/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://ITMonkeyLife.github.io/Blog/"/>
  <updated>2015-12-28T09:48:13+08:00</updated>
  <id>http://ITMonkeyLife.github.io/Blog/</id>
  <author>
    <name><![CDATA[Rick]]></name>
    <email><![CDATA[382542165@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[编写高性能的Swift代码]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2015/12/16/bian-xie-gao-zhi-liang-de-swiftdai-ma/"/>
    <updated>2015-12-16T20:00:26+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2015/12/16/bian-xie-gao-zhi-liang-de-swiftdai-ma</id>
    <content type="html"><![CDATA[<p>
下面这篇文档收集了一系列编写高性能 Swift 代码的要诀和技巧。文档的目标读者是编译器和标准库开发人员。

文档中的一些技巧可以帮助提升您的 Swift 程序质量，使您的代码不容易出错且可读性更好。显式地标记最终类和类协议是两个显而易见的例子。 然而文档中还有一些技巧是不符合规矩的，扭曲的，仅仅解决一些比编译器或语言的特殊的临时性需求。文档中的很多建议来自于多方面的权衡，例如：运行时、字节大小、代码可读性等等。
</p>
<h2>启用优化</h2>
<p>第一个应该做的事情就是启用优化。Swift 提供了三种不同的优化级别：<br />
<ul>
<li>-Onone: 这意味着正常的开发。它执行最小优化和保存所有调试信息。</li>
<li>-O: 这意味着对于大多数生产代码。编译器执行积极地优化，可以大大改变提交代码的类型和数量。调试信息将被省略但还是会有损害的。</li>
<li>-Ounchecked: 这是一个特殊的优化模式，它意味着特定的库或应用程序，这是以安全性来交换的。编译器将删除所有溢出检查以及一些隐式类型检查。这不是在通常情况下使用的，因为它可能会导致内存安全问题和整数溢出。如果你仔细审查你的代码，那么对整数溢出和类型转换来说是安全的。</li>
<!-- more -->
</ul>
在 Xcode UI 中，可以修改的当前优化级别如下：
</p>
<h2>整个组件优化</h2>
<p>默认情况下Swift单独编译每个文件。这使得Xcode可以非常快速的并行编译多个文件。然而，分开编译每个文件可以预防某些编译器优化。Swift也可以是一个单一的编译单元一样优化这个程序。这个模式可以使用命令行flag-whole-module-optimization来激活。在这种模式下编译的程序将最有可能需要更长时间来编译，但可以运行更快。<br />
这个模式可以通过Xcode构建设置中的<code>Whole Module Optimization</code>来激活。
</p>
<h2>降低动态调度</h2>
<p>
Swift在默认下是一个类似Objective-C的非常动态的语言。与Objective-C不同的是，Swift给了程序员通过消除和减少这种特性来提供运行时性能的能力。本节提供几个可以这样操作的语言结构的示例。
</p>
<h2>动态调度</h2>
<p>
类使用动态调度的方法和默认的属性访问。因此在下面的代码中，a.aProperty、a.doSomething() 和 a.doSomethingElse() 都将通过动态调度来调用：
```swift
class A {
  var aProperty: [Int]
  func doSomething() { ... }
  dynamic doSomethingElse() { ... }
}

class B : A {
  override var aProperty {
    get { ... }
    set { ... }
  }

  override func doSomething() { ... }
}

func usingAnA(a: A) {
  a.doSomething()
  a.aProperty = ...
}
```
<br />
在Swift 中，动态调度默认通过一个vtable（虚函数表）间接调用。如果使用一个dynamic关键字声明，Swift将通过调用Objective-C通知来发送调用代替。这两种情况中，这种情况会比直接的函数调用较慢，因为它防止了对间接调用本身之外的程序开销的编译器优化。在关键性能的代码出，人常常会想限制这种动态行为。
</p>
<h4>建议：当你知道声明不需要被重写时使用<code>final</code></h4>
<p>
final是一个类、方法、或一个属性声明中的一个限制，使这样的声明不会被重写。
这意味着编译器可以调用直接的函数调用来代替间接调用。例如下面的 C.array1 和 D.array1 将会被直接访问。与之相反，D.array2 将通过一个虚函数表访问。
```swift
final class C {
  // No declarations in class 'C' can be overridden.
  var array1: [Int]
  func doSomething() { ... }
}

class D {
  final var array1 [Int] // 'array1' cannot be overridden by a computed property.
  var array2: [Int]      // 'array2' *can* be overridden by a computed property.
}

func usingC(c: C) {
   c.array1[i] = ... // Can directly access C.array without going through dynamic dispatch.
   c.doSomething() = ... // Can directly call C.doSomething without going through virtual dispatch.
}

func usingD(d: D) {
   d.array1[i] = ... // Can directly access D.array1 without going through dynamic dispatch.
   d.array2[i] = ... // Will access D.array2 through dynamic dispatch.
}
```
</p>

<h4>当声明的不用被文件外部被访问的时候，使用<code>private</code></h4>
<p>将<code>private</code>关键字用在声明上，会限制对其进行了声明的文件的可见性。这会让编辑器有能力甄别出所有其他潜在的覆盖声明。如此，由于没有了任何这样的声明，使得编译器可以自动的推断出<code>final</code>关键字，并对此去掉对方法的间接调用和属性的访问。例如在如下的e.doSomething() 和 f.myPrivateVar 中，就将可以被直接访问，假定在同一个文件中，E,F 并没有任何覆盖的声明：<br />
```swift
private class E {
  func doSomething() { ... }
}

class F {
  private var myPrivateVar : Int
}

func usingE(e: E) {
  e.doSomething() // There is no sub class in the file that declares this class.
                  // The compiler can remove virtual calls to doSomething()
                  // and directly call A’s doSomething method.
}

func usingF(f: F) -&gt; Int {
  return f.myPrivateVar
}
```
</p>
<h2>高效的使用容器类型</h2>
<p>通用的容器 Array 和 Dictionary 是有 Swift 标准库提供的一个重要的功能特性。本节将介绍如何用一种高性能的方式使用这些类型。
</p>
<h4>建议在数组中使用值类型</h4>
<p>
在Swift中，类型可以分成两种不同的类型:值类型（结构体，枚举，元组）和引用类型（类）。一个关键的区分是 NSArray 不能含有值类型。因此当使用值类型时，优化器就不需要去处理对 NSArray 的支持，从而可以在数组上省去大部分消耗。<br />
此外，相比引用类型，如果值类型递归地含有引用类型，那么值类型仅仅需要引用计数器。而如果使用没有引用类型的值类型，就可以避免额外的开销，从而释放数组内的流量。<br />
```swift
// Don't use a class here.
struct PhonebookEntry {
  var name : String
  var number : [Int]
}

var a : [PhonebookEntry]
```
记住要在使用大值类型和使用引用类型之间做好权衡。在某些情况下，拷贝和移动大值类型数据的消耗要大于移除桥接和持有/释放的消耗。
</p>
<h4>建议当 <code>NSArray</code> 桥接不必要时，使用<code> ContiguousArray </code>存储引用类型。</h4>
<p>
如果你需要一个引用类型的数组，而且数组不需要桥接到 NSArray 时，使用 ContiguousArray 替代 Array：
```swift
class C { ... }
var a: ContiguousArray<c> = [C(...), C(...), ..., C(...)]
```

<h4>建议使用适当的改变而不是对象分配。</h4>
<p>
在 Swift 中所有的标准库容器都使用 COW(copy-on-write) 执行拷贝代替即时拷贝。在很多情况下，这可以让编译器通过持有容器而不是深度拷贝，从而省掉不必要的拷贝。如果容器的引用计数大于 1 并容器时被改变时，就会拷贝底层容器。例如：在下面这种情况：当 d 被分配给 c 时不拷贝，但是当 d 经历了结构性的改变追加 2，那么 d 将会被拷贝，然后 2 被追加到 d：
```swift
var c: [Int] = [ ... ]
var d = c        // No copy will occur here.
d.append(2)      // A copy *does* occur here.
```
如果用户不小心时，有时 COW 会引起额外的拷贝。例如，在函数中，试图通过对象分配执行修改。在 Swift 中，所有的参数传递时都会被拷贝一份，例如，参数在调用点之前持有一份，然后在调用的函数结束时释放。也就是说，像下面这样的函数：
```swift
func append_one(a: [Int]) -&gt; [Int] {
  a.append(1)
  return a
}

var a = [1, 2, 3]
a = append_one(a)
```
尽管由于分配，a 的版本没有任何改变 ，在 append_one后也没有使用 ， 但 a 也许会被拷贝。这可以通过使用 inout 参数来避免这个问题：
```swift
func append_one_in_place(inout a: [Int]) {
  a.append(1)
}

var a = [1, 2, 3]
append_one_in_place(&amp;a)
```
<h2>未检查操作</h2>
<p>Swift 通过在执行普通计算时检查溢出的方法解决了整数溢出的 bug。这些检查在已确定没有内存安全问题会发生的高效的代码中，是不合适的。
</p>
<h4>建议当你确切的知道不会发生溢出时使用不检查整型计算</h4>
<p>
在对性能要求高的代码中，如果你知道你的代码是安全的，那么你可以忽略溢出检查。
```swift
a : [Int]
b : [Int]
c : [Int]

// Precondition: for all a[i], b[i]: a[i] + b[i] does not overflow!
for i in 0 ... n {
  c[i] = a[i] &amp;+ b[i]
}
```
</p>
<h4>泛型</h4>
<p>
Swift 通过泛型类型的使用，提供了一个非常强大的抽象机制 。Swift 编译器发出一个可以对任何 T 执行 MySwiftFunc<t> 的具体的代码块。生成的代码需要一个函数指针表和一个包含 T 的盒子作为额外的参数。MySwiftFunc<int>和 MySwiftFunc<string> 之间的不同的行为通过传递不同的函数指针表和通过盒子提供的抽象大小来说明。一个泛型的例子:
```swift
class MySwiftFunc<t> { ... }

MySwiftFunc<int> X    // Will emit code that works with Int...
MySwiftFunc<string> Y // ... as well as String.
```
当优化器启用时，Swift 编译器寻找这段代码的调用，并试着确认在调用中具体使用的类型（例如：非泛型类型）。如果泛型函数的定义对优化器来说是可见的，并知道具体类型，Swift 编译器将生成一个有特殊类型的特殊泛型函数。那么调用这个特殊函数的这个过程就可以避免关联泛型的消耗。一些泛型的例子：
```swift
class MyStack<t> {
  func push(element: T) { ... }
  func pop() -&gt; T { ... }
}

func myAlgorithm(a: [T], length: Int) { ... }

// The compiler can specialize code of MyStack[Int]
var stackOfInts: MyStack[Int]
// Use stack of ints.
for i in ... {
  stack.push(...)
  stack.pop(...)
}

var arrayOfInts: [Int]
// The compiler can emit a specialized version of 'myAlgorithm' targeted for
// [Int]' types.
myAlgorithm(arrayOfInts, arrayOfInts.length)
```

<h4>建议将泛型的声明放在使用它的文件中</h4>
<p>只有在泛型声明在当前模块可见的情况下优化器才能执行特殊化。这只有在使用泛型的代码和声明泛型的代码在同一个文件中才能发生。注意标准库是一个例外。在标准库中声明的泛型对所有模块可见并可以进行特殊化。
</p>
<h4>建议允许编译器进行特殊化</h4>
<p>只有当调用位置和被调函数位于同一个编译单元的时候编译器才能对泛型代码进行特殊化。我们可以使用一个技巧让编译器对被调函数进行优化，这个技巧就是在被调函数所在的编译单元中执行类型检查。执行类型检查的代码会重新分发这个调用到泛型函数---可是这一次它携带了类型信息。在下面的代码中，我们在函数 play_a_game 中插入了类型检查，使得代码的速度提高了几百倍。<br />
```swift
//Framework.swift:

protocol Pingable { func ping() -&gt; Self }
protocol Playable { func play() }

extension Int : Pingable {
  func ping() -&gt; Int { return self + 1 }
}

class Game<t :="" pingable=""> : Playable {
  var t : T

  init (_ v : T) {t = v}

  func play() {
    for _ in 0...100_000_000 { t = t.ping() }
  }
}

func play_a_game(game : Playable ) {
  // This check allows the optimizer to specialize the
  // generic call 'play'
  if let z = game as? Game<int> {
    z.play()
  } else {
    game.play()
  }
}

/// -------------- &gt;8

// Application.swift:

play_a_game(Game(10))
```

<h4>数值大的值对象的开销</h4>
<p>
在Swift语言中，值类型保存它们数据独有的一份拷贝。使用值类型有很多优点，比如值类型具有独立的状态。当我们拷贝值类型时（相当于复制，初始化参数传递等操作），程序会创建值类型的一个拷贝。对于大的值类型，这种拷贝时很耗费时间的，可能会影响到程序的性能。

让我们看一下下面这段代码。这段代码使用值类型的节点定义了一个树，树的节点包含了协议类型的其他节点，计算机图形场景经常由可以使用值类型表示的实体以及形态变化，因此这个例子很有实践意义。
```swift
protocol P {}
struct Node : P {
  var left, right : P?
}

struct Tree {
  var node : P?
  init() { ... }
}
```
当树进行拷贝时（参数传递，初始化或者赋值）整个树都需要被复制.这是一项花销很大的操作，需要很多的 malloc/free 调用以及以及大量的引用计数操作

然而，我们并不关系值是否被拷贝，只要在这些值还在内存中存在就可以。
</p>
<h4>对大的值类型使用 COW（copy-on-write，写时复制和数组有点类似）</h4>
<p>
减少复制大的值类型数据开销的办法时采用写时复制行为（当对象改变时才进行实际的复制工作）。最简单的实现写时复制的方案时使用已经存在的写时复制的数据结构，比如数组。Swift 的数据是值类型，但是当数组作为参数被传递时并不每次都进行复制，因为它具有写时复制的特性。

在我们的 Tree 的例子中我们通过将 tree 的内容包装成一个数组来减少复制的代价。这个简单的改变对我们 tree 数据结构的性能影响时巨大的，作为参数传递数组的代价从 O(n) 变为 O(1)。
```swift
struct tree : P {
  var node : [P?]
  init() {
    node = [ thing ]
  }
}
```
但是使用数组实现 COW 机制有两个明显的不足，第一个问题是数组暴露的诸如 append 以及 count 之类的方法在值包装的上下文中没有任何作用，这些方法使得引用类型的封装变得棘手。也许我们可以通过创建一个封装的结构体并隐藏这些不用的 API 来解决这个问题，但是却无法解决第二个问题。第二个问题就是数组内部存在保证程序安全性的代码以及和 OC 交互的代码。Swift 要检查给出的下表是否搂在数组的边界内，当保存值的时候需要检查是否需要扩充存储空间。这些运行时检查会降低速度。

一个替代的方案是实现一个专门的使用 COW 机制的数据结构代替采用数组作为值的封装。构建这样一个数据结构的示例如下所示：
```swift
final class Ref<t> {
  var val : T
  init(_ v : T) {val = v}
}

struct Box<t> {
    var ref : Ref<t>
    init(_ x : T) { ref = Ref(x) }

    var value: T {
        get { return ref.val }
        set {
          if (!isUniquelyReferencedNonObjC(&amp;ref)) {
            ref = Ref(newValue)
            return
          }
          ref.val = newValue
        }
    }
}
```
类型 Box 可以代替上个例子中的数组

<h4>不安全的代码</h4>
Swift语言的类都是采用引用计数进行内存管理的。Swift编译器会在每次对象被访问的时候插入增加引用计数的代码。例如，考虑一个遍历使用类实现的一个链表的例子。遍历链表是通过移动引用到链表的下一个节点来完成的：<code>elem = elem.next</code>，每次移动这个引用，Swift 都要增加 next 对象的引用计数并减少前一个对象的引用计数，这种引用计数代价昂贵但是只要使用 Swift 类就无法避免
```swift
final class Node {
 var next: Node?
 var data: Int
 ...
}
```

<h4>使用未托管的引用避免引用计数的负荷</h4>
<p>
在效率至上的代码中你可以选择使用未托管的引用。Unmanaged<t>结构体允许开发者对特别的引用关闭引用计数
```swift
var Ref : Unmanaged<node> = Unmanaged.passUnretained(Head)

while let Next = Ref.takeUnretainedValue().next {
  ...
  Ref = Unmanaged.passUnretained(Next)
}
```

<h2>协议</h2>
<h4>建议将只有类实现的协议标记为类协议</h4>
<p>Swift 可以指定协议只能由类实现。标记协议只能由类实现的一个好处是编译器可以基于这一点对程序进行优化。例如，ARC 内存管理系统能够容易的持有（增加该对象的引用计数）如果它知道它正在处理一个类对象。如果编译器不知道这一点，它就必须假设结构体也可以实现协议，那么它就必须准备好持有或者释放不同的数据结构，而这代价将会十分昂贵。<br />
如果限制只能由类实现某协议那么就标记该协议为类协议以获得更好的性能
```swift
protocol Pingable : class { func ping() -&gt; Int }
```
</p>

<ul>
<li>虚函数:虚拟方法表或者<code>vtable</code>是被一个实例引用的一种包含类型方法地址的类型约束表。进行动态分发时，首先从对象中查找这张表然后查找表中的方法</li>
<li>编译器对很多方法进行优化:这是因为编译器并不知道那个具体的方法要被调用</li>
<li>直接访问：例如，直接加载一个类的字段或者直接调用一个方法</li>
<li>拷贝:在特定情况下优化器能够通过内联和 ARC 优化技术移除 retain，release 因为没有引起复制</li>
</ul>
</node></t></p></t></t></t></p></int></t></p></t></string></int></t></string></int></t></p></p></c></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 的 ABI]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2015/12/11/swift-2-dot-2-yuan-ma-jie-du/"/>
    <updated>2015-12-11T10:10:22+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2015/12/11/swift-2-dot-2-yuan-ma-jie-du</id>
    <content type="html"><![CDATA[<p>
随着Swift的开源，苹果开发者迎来了新的开端。其实这个是我一直想要表达的，随着对Swift这个语言的深入了解，越发感觉到Swift的魅力。Swift是系统编程语言，现在C语言之所以能统治底层开发的最重要原因是C规范统一的ABI，使其能做到与汇编程序无缝衔接。而Swift的ABI兼容C（并不包括name mangling部分）。基于强大的llvm生成具体平台代码。不仅仅作为Objective-C的翻译。
</p>
<p>
通过开发Swift，了解到Swift文件的中间编译结果（介于Swift代码合llvm ir）是SIL。SIL我下一章着重介绍。这张暂时把焦点放在Swift的ABI。那么什么是ABI，你一定很陌生吧，那么对于API呢，你是不是明白了什么？
</p>
<p>
ABI的全称是Application Binary Interface。翻译过来就是应用二进制接口，描述了应用程序和操作系统或其他应用程序之间的低级接口。
</p>
<p>
ABI涵盖了各个细节：
<!-- more-->
<ul>
<li>数据类型的大小、设计和对齐;</li>
<li>调用约定（控制着函数的参数如何传送以及如何接受返回值），例如，是所有的参数都通过栈传递，还是部分参数通过寄存器传递；哪个寄存器用于哪个函数参数；通过栈传递的第一个函数参数是最先push到栈上还是最后</li>
<li>系统调用的编码和一个应用如何向操作系统进行系统调用</li>
<li>以及在一个完整的操作系统ABI中，目标文件的二进制格式、程序库等等。</li>
</ul>
一个完整的ABI，像Intel二进制兼容标准（iBCS），允许支持它的操作系统上的程序不经修改在其他支持此ABI的操作系统上运行。
</p>
<p>
ABI不同于应用程序接口（API），API定义了源代码和库之间的接口，因此同样的代码可以在支持这个API的任何系统中编译，然而ABI允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行。 在Unix风格的操作系统中，存在很多运行在同一硬件平台上互相相关但是不兼容的操作系统（尤其是Intel 80386兼容系统）。有一些努力尝试标准化ABI，以减少销售商将程序移植到其他系统时所需的工作。然而，直到现在还没有很成功的例子，虽然Linux标准化工作组正在为Linux做这方面的努力。
</p>
<p>
我在上面说了，ABI的各个细节。在这我需要强调一点：在Swift类，如果没有明确标识对象基类则一律继承SwiftObject Objective-C类。这个是Swift的硬性规定。
</p>
<h2>类型设计</h2>
<h4>脆弱的结构体和元组设计</h4>
<p>
结构和元组目前共享相同的设计算法，编译器实现“通用”设计算法。该算法如下：
<ul>
  <li>从0开始，以1对齐增长</li>
  <li>遍历字段,在元素的元组,或顺序结构var声明。每个字段:<ul>
      <li>通过舍入更新字节来对齐字段，字段增长的值至少大于或等于字节，整除的一致性</li>
      <li>&lt;字段的当前值的大小赋给偏移量/li&gt;
      <li>更新字节通过添加字段的字节大小</li>
      <li>更新对齐最大字节，和更新对齐的字段</li>
      
  </li>
  <li>最终的大小和对齐的大小和对齐集合。类型是最后的，步长大小来对齐。</li>
</ul>

注意这不同于C或LLVM是正常的设计规则,大小和步幅是不同的,而C设计要求,嵌入式结构的大小是填充其对齐,迅速设计允许外部结构布置内部结构的尾巴填充字段,允许对齐。与C不同,大小结构和元组也允许,没有存储在包含总量。快速编译器发出LLVM包装结构类型与手动填充必要的控制二进制设计。一些例子:
<br />
``` swift
// LLVM &lt;{ i64, i8 }&gt;
struct S {
  var x: Int
  var y: UInt8
}

// LLVM &lt;{ i8, [7 x i8], &lt;{ i64, i8 }&gt;, i8 }&gt;
struct S2 {
  var x: UInt8
  var s: S
  var y: UInt8
}

// LLVM &lt;{}&gt;
struct Empty {}

// LLVM &lt;{ i64, i64 }&gt;
struct ContainsEmpty {
  var x: Int
  var y: Empty
  var z: Int
}
```


<h4>类设计</h4>
<p>
Swift依赖下面的关于Objective-C运行时的假设，是Objective-C ABI的一部分：
<ul>
<li>32位平台从未标记指针。ObjC指针类型是nil或一个对象指针。</li>
<li>在x86-64,一个标记指针设置指针的最低位或最高位的指针。因此,这两位都是0当且仅当该值不是一个标记指针。</li>
<li>ARM64,标记指针总是设置最高位的指针。</li>
<li>32位平台不会执行任何isa掩饰<code>object_getClass</code>总是相当于<code>*(Class*)object</code></li>
<li>64位平台上执行isa掩饰只有在运行时才导出的符号<code>uintptr_t objc_debug_isa_class_mask;</code>。如果导出这个符号，<code>object_getClass</code>在一个非标记指针总是相当于<code>(Class)(objc_debug_isa_class_mask &amp; *(uintptr_t*)object)</code></li>
<li>超类的类对象总是isa字段后立即存储。它的值是nil或一个指向父类的类对象;它从来没有其他设置。</li>
</ul>

下面是Swift ABI的一部分：
<ul>
<li>Swift指针不会是标记指针。</li>
</ul>
</p>

<h2>脆弱的Enum设计</h2>
<p>
在设计enum类型、ABI试图避免需要额外存储来存储枚举的标签。ABI选择的五个策略基于enum的设计:
</p>
<h4>空枚举</h4>
<p>enum在没有case的情况下,枚举是一个空的类型。
<br />
```swift
enum Empty {} // =&gt; empty type
```
</p>
<h4>单一类型枚举</h4>
<p>只有一个情况下的枚举，没有必要筛选,和枚举类型相同的设计的情况下的数据类型,可以是空的,如果没有数据类型。
<br />
```swift
enum EmptyCase { case X }             // =&gt; empty type
enum DataCase { case Y(Int, Double) } // =&gt; LLVM &lt;{ i64, double }&gt;
```
</p>
<h4>类C枚举</h4>
<p>如果没有一个case有数据类型(一个典型的“c”enum),那么enum是最小整数标记包含的比特数的所有情况。遵循LLVM的数据设计规则整数类型在目标平台上。被分配的case标签的值依次排列声明顺序。
<br />
```swift
enum EnumLike2 { // =&gt; LLVM i1
  case A         // =&gt; i1 0
  case B         // =&gt; i1 1
}

enum EnumLike8 { // =&gt; LLVM i3
  case A         // =&gt; i3 0
  case B         // =&gt; i3 1
  case C         // =&gt; i3 2
  case D         // etc.
  case E
  case F
  case G
  case H
}
```
<br />
辨别值之后，一个用于最后的case成为额外例子的枚举类型。
</p>

<h4>单一的对应枚举</h4>
<p>
如果枚举数据类型和一个或多个单情况没有数据的情况下(一个“单一的对应枚举”),然后与数据类型使用的数据类型来表示的二进制表示,必要时添加了零位标记。如果数据类型的二进制表示额外的条件,也就是说,有些模式类型的大小和对齐,但没有形成有效的值的类型,它们是用来表示没有数据的情况下,case的提升数值匹配的顺序没有数据情况下按声明顺序。如果类型有空闲位(见多个对应枚举),它们被用来形成额外的条件。然后枚举值表示为一个整数的存储大小的数据类型。额外的条件使用的负载类型不是枚举类型成为额外的条件enum类型本身。
<br />
```swift
enum CharOrSectionMarker { =&gt; LLVM i32
  case Paragraph            =&gt; i32 0x0020_0000
  case Char(UnicodeScalar)  =&gt; i32 (zext i21 %Char to i32)
  case Chapter              =&gt; i32 0x0020_0001
}

CharOrSectionMarker.Char('\x00') =&gt; i32 0x0000_0000
CharOrSectionMarker.Char('\u10FFFF') =&gt; i32 0x0010_FFFF

enum CharOrSectionMarkerOrFootnoteMarker { =&gt; LLVM i32
  case CharOrSectionMarker(CharOrSectionMarker) =&gt; i32 %CharOrSectionMarker
  case Asterisk                                 =&gt; i32 0x0020_0002
  case Dagger                                   =&gt; i32 0x0020_0003
  case DoubleDagger                             =&gt; i32 0x0020_0004
}
```
<br />
如果数据类型没有额外的条件,或者没有足够的额外的条件表示没有数据的情况下,然后添加一个标记位enum的表示。没有数据的标记位设置情况下,然后分配数据区域中的值的枚举声明的顺序。
<br />
```swift
enum IntOrInfinity { =&gt; LLVM &lt;{ i64, i1 }&gt;
  case NegInfinity    =&gt; &lt;{ i64, i1 }&gt; {    0, 1 }
  case Int(Int)       =&gt; &lt;{ i64, i1 }&gt; { %Int, 0 }
  case PosInfinity    =&gt; &lt;{ i64, i1 }&gt; {    1, 1 }
}

IntOrInfinity.Int(    0) =&gt; &lt;{ i64, i1 }&gt; {     0, 0 }
IntOrInfinity.Int(20721) =&gt; &lt;{ i64, i1 }&gt; { 20721, 0 }
```
</p>
<h4>多个对应枚举</h4>
<p>
如果一个枚举数据类型有多个情况,然后一个标签来区分数据类型是必要的。ABI首先会尝试找到共同闲置比特,即二进制数据类型的表示fixed-zero或忽略的有效值的所有数据类型。标签将被分散到这些闲置比特尽可能多。目前只备用的原始的整数类型,如高位被认为是<code>i21</code>类型。枚举数据表示为一个整数的存储大小的最大数据类型。
<br />
```swift
enum TerminalChar {             =&gt; LLVM i32
  case Plain(UnicodeScalar)     =&gt; i32     (zext i21 %Plain     to i32)
  case Bold(UnicodeScalar)      =&gt; i32 (or (zext i21 %Bold      to i32), 0x0020_0000)
  case Underline(UnicodeScalar) =&gt; i32 (or (zext i21 %Underline to i32), 0x0040_0000)
  case Blink(UnicodeScalar)     =&gt; i32 (or (zext i21 %Blink     to i32), 0x0060_0000)
  case Empty                    =&gt; i32 0x0080_0000
  case Cursor                   =&gt; i32 0x0080_0001
}
```
<br />
如果没有足够的空闲位包含标签,然后添加额外的比特表示包含标签。标签的值分配给数据情况下按声明顺序。如果有任何数据的情况下,他们被收集在一个共同的标签,并指定数据区域中的值的枚举声明的顺序。
<br />
```swift
class Bignum {}

enum IntDoubleOrBignum { =&gt; LLVM &lt;{ i64, i2 }&gt;
  case Int(Int)           =&gt; &lt;{ i64, i2 }&gt; {           %Int,            0 }
  case Double(Double)     =&gt; &lt;{ i64, i2 }&gt; { (bitcast  %Double to i64), 1 }
  case Bignum(Bignum)     =&gt; &lt;{ i64, i2 }&gt; { (ptrtoint %Bignum to i64), 2 }
}
```
</p>
<h2>存在容器的设计</h2>
<p>值的协议类型,协议组成类型,或“any”类型(<code>protocol&lt;&gt;</code>)提出使用存在容器(所谓的因为这些类型是类型理论中的“生存类型”)。</p>
<h4>存在的不透明容器</h4>
<p>如果没有类限制协议或协议组成类型,存在的容器必须适应值为任意大小和对齐。它使用一个固定大小的缓冲区,这是三个指针大小和pointer-aligned。这个直接包含的值,如果它的大小和对齐都小于或等于固定大小的缓冲区,或包含一个指针指向一个分配属于存在的容器。所包含的值的类型是由其类型标识元数据记录,为所有需要的协议和映射表的一致性。设计好像声明在C结构体如下:
<br />
```
struct OpaqueExistentialContainer {
  void *fixedSizeBuffer[3];
  Metadata *type;
  WitnessTable *witnessTables[NUM_WITNESS_TABLES];
};
```
</p>
<h4>存在的类的容器</h4>
<p>
如果一个或多个协议的协议或协议组成类型有一个类约束,然后只能存储在已经存在的容器,并使用一个更有效的表示。类实例总是一个指针的大小,所以不需要分配一个固定大小的缓冲区,和类实例总是有自己的引用类型的元数据,因此不需要单独的元数据记录。声明中的设计就好像下面C结构体:
<br />
```
struct ClassExistentialContainer {
  HeapObject *value;
  WitnessTable *witnessTables[NUM_WITNESS_TABLES];
};
```
<br />
注意,如果不需要映射表,如“任何类”类型的<code>protocol&lt;&gt;</code>或一个Objective-C协议类型,然后唯一元素设计堆对象的指针。这是ABI兼容的id,<code>Protocol</code>类型在Objective-C中。
</p>

<h2>元数据类型</h2>
<p>快速运行时保持元数据记录为每一类型在程序中使用,包括每一个实例化泛型类型的。可以使用这些元数据记录(TODO:映射)调试器工具发现的信息类型。对于非泛型名义类型,这些元数据是由编译器生成的静态记录。对泛型类型的实例,和内在类型如元组、功能、协议等等组成,元数据记录懒洋洋地根据需要运行时创建的。每个类型都有一个独特的元数据记录,两种元数据指针值相等,如果他们的类型相同。<br />
在下面的设计描述中,抵消了相对于元数据指针作为指针数组的索引。在32位平台上,抵消1意味着一个偏移量的4个字节,在64位平台上,这意味着8个字节的偏移量。<br />
</p>
<h4>通用元数据设计</h4>
<p>
所有元数据记录共享一个共同的数据头,下面字段:
<ul>
<li>映射价值表指针引用的vtable函数实现值的语义类型,提供了基本的操作,如分配,复制,销毁的类型。映射表也记录的值大小、对齐、步长等基本属性的类型。映射价值表指针偏移-1元数据的指针,即指针字节所在位置立即在指针的引用地址偏移。</li>
<li>类型字段是一个pointer-sized整数描述元数据描述。这个字段的偏移量为0的元数据的指针。</li>
</ul>
</p>
<h4>结构体元数据</h4>
<p>
除了常见的元数据字段设计、结构元数据记录包含以下字段:<br />
<ul>
<li>名义类型描述符引用偏移量1。</li>
<li>引用父元数据记录存储在偏移2。是一个封闭的名义类型的成员的结构,这是一个封闭类型的元数据的引用。对于高层结构体,这是null。（父指针总是空）</li>
<li>矢量偏移量从3开始。每个字段的结构体,在var声明顺序,字段的偏移字节从一开始的结构是存储为pointer-sized整数倍。</li>
<li>如果结构是通用的,那么通用参数向量始于抵消3 + n,其中n是结构中的字段的数量</li>
</ul>
</p>
<h4>枚举元数据</h4>
<p>除了常见的元数据字段设计,enum记录元数据包含以下字段:<br />
<ul>
<li>名义类型描述符引用偏移量1。</li>
<li>引用父元数据记录存储在偏移2。是一个封闭的名义类型的成员的结构,这是一个封闭类型的元数据的引用。对于高层结构体,这是null。（父指针总是空）</li>
<li>如果enum是通用的,那么通用参数向量始于偏移地址3。</li>
</ul>
</p>
<h4>元组元数据</h4>
<p>
除了常见的元数据字段设计、元组元数据记录包含以下字段:<br />
<ul>
<li>名义类型描述符引用偏移量1。</li>
<li>标签字符串指针连续以null结尾的标签名称的列表在元组偏移2。每个标签的名字是作为一个以null结尾,UTF-8编码的字符串序列。如果元组没有标签,这是一个空指针。(目前标签字符串指针总是空,独特的标签不考虑元组元数据)</li>
<li>向量的元素开始的偏移地址3,由一个向量type-offset对。第n个元素的元数据类型是指针的偏移地址3+2*n。字节的偏移量从一开始的第n个元素的元组开始的偏移量是3+2*n+1。</li>
</ul>
</p>
<h4>函数元数据</h4>
<p>除了常见的元数据字段设计,函数元数据记录包含以下字段:<br />
<ul>
<li>参数的数量函数存储在偏移量为1的地址。</li>
<li>结果的引用类型元数据记录存储在偏移量为2。如果函数有多个返回,这引用一个元组元数据记录</li>
<li>参数向量始于偏移地址3,由指针指向的函数的参数元数据记录。</li>
</ul>
<p>
如果函数需要任何in/out参数,每个参数的元数据记录指针将另外附加,一些被设置如果in/out最低位。由于指针对准,最低位持有这个标签总是空。
如果函数没有in/out参数,将只有一个指针在下列情形的向量:
</p>
<ul>
<li>0参数:一个元组元数据记录为空元组</li>
<li>1参数:第一个也是唯一一个参数的元数据记录</li>
<li>&gt; 1的参数:tuple包含参数的元数据记录</li>
</ul>
</p>
<h4>协议元数据</h4>
<p>
除了常见的元数据字段设计,协议元数据记录包含以下字段:</p>
<ul>
<li>设计标志词是储存在偏移为1。这个词的部分描述存在容器设计用于表示值的类型。这个词设计如下:<ul>
<li>映射表存储在最低位31位。协议类型的值包含这个数字映射表指针的设计。</li>
<li>类约束条件是储存在31位。这个位设置如果不类容器类型,这意味着结构、枚举、或类值中可以存储类型。如果没有设置,那么只能存储在类值类型,并使用一个更高效的设计类型。</li>
</ul>
注意字段pointer-sized,尽管只有最低的32位目前在所有平台上。这些值可以来自协议描述符记录,但预计算会更便利。
</li>
<li>协议的协议组成的数量是储存在偏移2。“任何”<code>protocol&lt;&gt; </code>。对于单一协议 <code>P</code>。协议构成类型<code>protocol&lt;P, Q, ...&gt;</code>,这是协议的数量</li>
<li>协议描述符向量始于偏移地址3。这是内联的协议描述符的指针数组中的每个协议组成,或单一协议为协议类型描述符。“任何”类型,没有协议描述符向量。</li>
</ul>

<h4>变型的元数据</h4>
<p>
除了常见的元数据字段设计、变型的元数据记录包含以下字段:
<ul>
<li>引用的实例类型的元数据记录变型代表是储存在偏移为1的地址。</li>
</ul>
</p>

<h4>类元数据</h4>
<p>
类元数据设计和Objective-C互操作;所有类元数据记录也有效的Objective-C类对象。类元数据指针的值被用作类变型,所以派生类的元数据记录也作为一个有效的为其父类的所有类变型价值。
<ul>
<li>析构函数指针存储在从元数据指针偏移2的地址，背后的价值关联表。此功能由Swift的析构器调用时的类实例被销毁<ul>
<li>isa指针指向Objective-C的兼容元类记录村春在偏移量是0的地址</li>
<li>父类指针指向元类数据记录的父类存储在偏移量1的地址，如果是根类，它为null</li>
<li>偏移2和偏移3保留用于Objective-C的运行时使用</li>
<li>该rodata指针存储在偏移4;它指向的类的Objective-C兼容rodata记录。该指针值包括标签。低位始终设置为1，Swift类和始终设置为0的Objective-C类。</li>
<li>类标志是一个32位字段偏移量5</li>
<li>实例地址指针是一个32位的字段后面的这个类的标志。此类指针实例的开始之后此字节数的实例指针。</li>
<li>实例大小是32位的字段后面的这个实例地址指针。这是存储本字节在这种类型的每一个对象的数</li>
<li>实例对准mask是一个16位的字段后面的这个实例的大小。这是一组低位，它们不能在一指针被设置为这个类的一个实例的。 </li>
<li>运行时保留字段是一个16位的字段后面的这个实例对齐mask。编译器初始化这个为零。 </li>
<li>类对象的大小是32位的字段，运行时保留字段之后。这是存储在类元数据对象的字节的总数。</li>
<li>对象的地址指针是一个32位的字段后面的这个类的对象的大小。这是存储在类元数据对象的字节数。 </li>
<li>名义类型描述为最派生类的类型被引用以立即偏移后的类对象的地址点。这是在64位的平台偏移8或在32位平台偏移11。 </li>
<li>对于每一个Swift类在类的继承层次结构，从根类订单开始一直到最派生类，以下领域都存在： </li>
<li>首先，参考到母体元数据记录被存储。对于类是一个封闭的名义类型的成员，这是一个引用封闭类型的元数据。对于顶级类，这是空。 </li>
<li>如果类是通用的，它的泛型参数向量的内联存储</li>
<li>V表被内嵌存储，并包含一个函数指针类的声明顺序的每一个方法的实现。 </li>
<li>如果一个类的实例的布局是依赖于它的通用参数，则字段偏置矢量存储直列，含有以字节偏移从实例指针类的每个字段中声明的顺序。 （对于类与固定布局，字段偏移都可以访问静态的全局变量，类似于Objective-C的ivar偏移。）</li>
</ul>

<p>请注意，这些字段都存在在继承层次的Objective-C基类。 </p>
<h4>通用参数向量</h4>
<p>元数据记录泛型类型的实例包含有关其泛型参数信息。对于类型的每个参数，引用为类型参数的元数据记录存储。在所有类型参数的元数据参考，对于每种类型的参数，如果有该类​​型参数的协议要求，引用的证人表中为每个协议，要求符合储存在声明顺序。 <br />
例如，给定一个泛型类型，在继承的参数&lt;T，U，V&gt;，它的泛型参数的记录将包括引用的元数据记录，T，U型和V，仿佛在C结构布局：<br />
```swift
struct GenericParameterVector {
  TypeMetadata *T, *U, *V;
};
```
如果再加协议要求的参数，例如，<code> &lt;T: Runcible, U: protocol&lt;Fungible, Ansible&gt;, V&gt; </code>，那么该类型的泛型参数向量包含这些协议关联表，设计：
```swift
struct GenericParameterVector {
  TypeMetadata *T, *U, *V;
  RuncibleWitnessTable *T_Runcible;
  FungibleWitnessTable *U_Fungible;
  AnsibleWitnessTable *U_Ansible;
};
```
</p>
<h4>通用类型描述符</h4>
<p>元数据记录类，结构和枚举类型包含一个指向类型描述符，其中包含有关名义类型的基本信息，如名称，成员和元数据的布局。对于泛型类型，一是名义类型描述符是该类型的所有实例共享。布局如下：
<ul>
<li>偏移0的存储类型<ul>
<li>若为0则是类</li>
<li>结构体为1</li>
<li>枚举是2</li>
</ul></li>
<li>错位的名称被引用为空值终止的C字符串量。本名称不包括绑定泛型参数。 </li>
<li>以下四个字段依赖于一种通用类型。 <ul>
<li>对一个类或者结构体来说:<ul>
<li>字段的数量被存储在偏移2。这是在元数据记录中的字段偏置向量的长度，如果有的话。 </li>
<li>的偏移到字段偏移矢量被存储在偏移3.这是中的偏移在元数据记录中的类型字段偏置向量的指针大小词语。如果没有字段偏置矢量被存储在元数据记录，这是零。 </li>
<li>字段名称偏移量4名的顺序对应的字段的领域偏移向量的顺序被引用为C字符串的双空结尾的列表。</li>
<li>该字段类型的访问是一个函数指针偏移5.如果非空，该函数需要一个指针类型的元数据标称类型的实例，并返回一个指针类型的元数据引用的字段类型的数组该实例。的顺序相匹配的领域偏移向量和字段名列表。 </li></ul></li>
<li>对一个枚举来说：<ul>
<li>的有效载荷的情况下和有效载荷大小偏移数被存储在偏移2的至少显著24位是有效载荷的情况下的数量，和在类型元数据的有效载荷大小的最显著8位的偏移，如果有的话。</li>
<li>没有效载荷的情况下的数量被存储在偏移3。 </li>
<li>case名称偏移量4名进行排序，从而有效载荷的情况下是第一位的，其次是无负载情况下被引用为C字符串的双空结尾的列表。在列表中的每个一半，名称的顺序对应于枚举声明的情况下的顺序。 </li>
<li>case类型的访问是一个函数指针偏移5.如果非空，该函数需要一个指针类型的元数据枚举的一个实例，并返回一个指针类型的元数据的引用为案件的类型数组该实例。的顺序相匹配的情况下，名单中。这个功能类似于字段类型存取器为一个结构，除了还结果中的每个元件的至少显著位如果枚举的情况下是一种间接的情况下设置的。 </li></ul></li>
</ul></li>
<li>如果名义类型是通用的，一个指针，在用于形成该类型的实例的元图形存储在偏移6.指针是空的，如果类型是不通用的。 </li>
<li>泛型参数描述开始于偏移7。这说明在元数据记录中的泛型参数向量的布局： <ul>
<li>通用参数向量的偏移存储在偏移7.这是中的偏移元数据记录内的通用参数向量的指针大小词语。如果该类型不是通用的，这是零。 </li>
<li>类型参数的数量存储在偏移8.这个计数包括相关类型的类型参数与协议约束。 </li>
<li>类型参数的数目被储存在仅偏移9.本计数包括初级形式类型参数。 </li>
<li>对于每个类型的参数n，以下字段中存储： <ul>
<li>该类型参数的数目存储在偏移10 + N。这是存储用于在通用参数向量类型参数表指针的数目。 </li></ul></li></ul></li>
</ul>
请注意，没有名义类型说明符的协议或协议类型。请参阅下面的协议描述符描述。
</p>
<h4>Protocol描述符</h4>
协议元数据包含描述所需的类型的协议值以符合引用零个，一个或多个协议的描述符。本协议描述的布局要与Objective-C的协议对象是兼容的。设计如下：
<ul>
<li>一个isa占位符存放在偏移0填充这个字段的Objective-C运行。 </li>
<li>错位的名称被引用为空值终止的C字符串偏移量1。 </li>
<li>如果协议继承的一个或多个其他协议，一个指针到继承的协议列表存储在偏移2.名单开始的继承协议作为一个指针大小整数的数目，和后跟许多协议描述符指针。如果协议继承了没有其他协议，这个指针为空。 </li>
<li>对于ObjC兼容协议，它需要的实例方法存储在偏移3作为ObjC兼容的方法列表。这是原生Swift协议无效。 </li>
<li>对于ObjC兼容协议，它需要的类方法都存储在偏移4作为ObjC兼容的方法列表。这是原生Swift协议无效。 </li>
<li>对于ObjC兼容协议，其可选实例方法存储在偏移5作为ObjC兼容的方法列表。这是原生Swift协议无效。 </li>
<li>对于ObjC兼容协议，其可选类的方法存储在偏移6作为ObjC兼容的方法列表。这是原生Swift协议无效。 </li>
<li>对于ObjC兼容协议，它的实例属性存储在偏移7作为ObjC兼容属性列表。这是原生Swift协议无效。 </li>
<li>该协议描述符记录的大小存储为一个32位整数偏移量8。这是目前72在64位的平台和40在32位的平台。</li>
<li>标志被存储为尺寸后的32位整数。以下位目前使用的（从最低计数显著零位）： <ul>
<li>位0是Swift位。坐落在Swift定义和取消的Objective-C中定义的协议所有协议。 </li>
<li>第1位是类约束一下。如果该协议不是类的限制，这意味着任何结构，枚举，或类类型可能符合协议设置它。它没有设置，如果只有类能遵守协议。 （该倒的意思是使用Objective-C协议的记录，在该位从未设置的兼容性。Objective-C的协议只能由类效法。） </li>
<li>第2位是映射表位。它设置，如果派遣协议的方法是通过映射表，可以是传递一个额外的参数，以通用的功能或包含在协议类型的存在容器设计完成。这是未设置如果调度是通过objc_msgSend完成，不需要额外的信息，陪符合类型的值。 </li>
<li>第31位是由Objective-C运行时设置它已经完成了它的初始化协议纪录。它是未使用的Swift运行。 </li>
</ul></li>
</ul>

<h2>重整</h2>
<p>
```
mangled-name ::= '_T' global
```
所有Swift-重整的名称以此前缀开头。
</p>
<h4>全局</h4>
<p>
```
global ::= 't' type                    // standalone type (for DWARF)
global ::= 'M' type                    // type metadata (address point)
                                       // -- type starts with [BCOSTV]
global ::= 'Mf' type                   // 'full' type metadata (start of object)
global ::= 'MP' type                   // type metadata pattern
global ::= 'Ma' type                   // type metadata access function
global ::= 'ML' type                   // type metadata lazy cache variable
global ::= 'Mm' type                   // class metaclass
global ::= 'Mn' nominal-type           // nominal type descriptor
global ::= 'Mp' protocol               // protocol descriptor
global ::= 'PA' .*                     // partial application forwarder
global ::= 'PAo' .*                    // ObjC partial application forwarder
global ::= 'w' value-witness-kind type // value witness
global ::= 'WV' type                   // value witness table
global ::= 'Wo' entity                 // witness table offset
global ::= 'Wv' directness entity      // field offset
global ::= 'WP' protocol-conformance   // protocol witness table
global ::= 'Wa' protocol-conformance   // protocol witness table accessor
global ::= 'Wl' type protocol-conformance // lazy protocol witness table accessor
global ::= 'WL' protocol-conformance   // lazy protocol witness table cache variable
global ::= 'WD' protocol-conformance   // dependent proto witness table generator
global ::= 'Wd' protocol-conformance   // dependent proto witness table template
global ::= entity                      // some identifiable thing
global ::= 'TO' global                 // ObjC-as-swift thunk
global ::= 'To' global                 // swift-as-ObjC thunk
global ::= 'TD' global                 // dynamic dispatch thunk
global ::= 'Td' global                 // direct method reference thunk
global ::= 'TR' reabstract-signature   // reabstraction thunk helper function
global ::= 'Tr' reabstract-signature   // reabstraction thunk

global ::= 'TS' specializationinfo '_' mangled-name
specializationinfo ::= 'g' passid (type protocol-conformance* '_')+            // Generic specialization info.
specializationinfo ::= 'f' passid (funcspecializationarginfo '_')+             // Function signature specialization kind
passid ::= integer                                                             // The id of the pass that generated this specialization.
funcsigspecializationarginfo ::= 'cl' closurename type*                        // Closure specialized with closed over types in argument order.
funcsigspecializationarginfo ::= 'n'                                           // Unmodified argument
funcsigspecializationarginfo ::= 'cp' funcsigspecializationconstantproppayload // Constant propagated argument
funcsigspecializationarginfo ::= 'd'                                           // Dead argument
funcsigspecializationarginfo ::= 'g' 's'?                                      // Owned =&gt; Guaranteed and Exploded if 's' present.
funcsigspecializationarginfo ::= 's'                                           // Exploded
funcsigspecializationarginfo ::= 'k'                                           // Exploded
funcsigspecializationconstantpropinfo ::= 'fr' mangled-name
funcsigspecializationconstantpropinfo ::= 'g' mangled-name
funcsigspecializationconstantpropinfo ::= 'i' 64-bit-integer
funcsigspecializationconstantpropinfo ::= 'fl' float-as-64-bit-integer
funcsigspecializationconstantpropinfo ::= 'se' stringencoding 'v' md5hash

global ::= 'TV' global                 // vtable override thunk
global ::= 'TW' protocol-conformance entity
                                       // protocol witness thunk
entity ::= nominal-type                // named type declaration
entity ::= static? entity-kind context entity-name
entity-kind ::= 'F'                    // function (ctor, accessor, etc.)
entity-kind ::= 'v'                    // variable (let/var)
entity-kind ::= 'i'                    // subscript ('i'ndex) itself (not the individual accessors)
entity-kind ::= 'I'                    // initializer
entity-name ::= decl-name type         // named declaration
entity-name ::= 'A' index              // default argument generator
entity-name ::= 'a' addressor-kind decl-name type     // mutable addressor
entity-name ::= 'C' type               // allocating constructor
entity-name ::= 'c' type               // non-allocating constructor
entity-name ::= 'D'                    // deallocating destructor; untyped
entity-name ::= 'd'                    // non-deallocating destructor; untyped
entity-name ::= 'g' decl-name type     // getter
entity-name ::= 'i'                    // non-local variable initializer
entity-name ::= 'l' addressor-kind decl-name type     // non-mutable addressor
entity-name ::= 'm' decl-name type     // materializeForSet
entity-name ::= 's' decl-name type     // setter
entity-name ::= 'U' index type         // explicit anonymous closure expression
entity-name ::= 'u' index type         // implicit anonymous closure
entity-name ::= 'w' decl-name type     // willSet
entity-name ::= 'W' decl-name type     // didSet
static ::= 'Z'                         // entity is a static member of a type
decl-name ::= identifier
decl-name ::= local-decl-name
decl-name ::= private-decl-name
local-decl-name ::= 'L' index identifier  // locally-discriminated declaration
private-decl-name ::= 'P' identifier identifier  // file-discriminated declaration
reabstract-signature ::= ('G' generic-signature)? type type
addressor-kind ::= 'u'                 // unsafe addressor (no owner)
addressor-kind ::= 'O'                 // owning addressor (non-native owner)
addressor-kind ::= 'o'                 // owning addressor (native owner)
addressor-kind ::= 'p'                 // pinning addressor (native owner)
```
实体开始于<code>entity</code> <code>nominal-type-kind ([COPV])</code>,去取代 <code>([Ss])</code> <code> entity-kind ([FIiv])</code>。
<code>entity-name</code>开头<code>[AaCcDggis]</code>或<code>decl-name</code>。一个<code>decl-name</code>开头<code>[LP]</code>或标识符<code>（[0-9oX]）</code>。
一个上下文开始于任一实体，一个扩展（其开头[EE]），或者一个模块，它可能是一个标识符（[0-9oX]）或模块的取代（[SS]）。
全局的修正开始于<code>[MTWw]</code>。
如果部分应用程序转发器是一个静态符号，它的名字将开始与序列_TPA_随后转发的目的地的错位符号名称。
一个普通的专业化的mangling由一个头，指定用于专门的泛型函数的类型和不合格，其次是原来的非专业化的通用符号的全面重整名称。
在一<private-decl-name>中的第一标识符是表示原始声明来自文件的字符串。应考虑的包围模块内是唯一的。第二标识符是实体的名称。
并非所有的声明标志着民营声明中，将使用<private-decl-name>压延;如果实体的上下文是足以唯一标识该实体中，简单的标识符形式是优选的。
在<reabstract-signature>的类型始终是非多态<实现了一套功能型>类型。

<h4>直接和间接的符号</h4>
<p>
```
directness ::= 'd'                         // direct
directness ::= 'i'                         // indirect
```
直接符号解析直接对象的地址。间接符号解析为一个指向对象的地址。他们是不同的manglings做某一类的错误显而易见。

讨论补偿时的术语稍微超载。直接抵消解析为一个变量持有真正的偏移。间接偏移解析为一个变量保持的偏移被应用到输入的元数据，以获得真实的地址偏移。 （偏移量是必需的变量时，被一个弹性的结构，当物体的布局可能依赖于通用的参数中访问谎言的对象，这些偏移量必须保持在元数据中，间接磁场偏移访问泛型类型的字段时，因此，需要地方元数据本身具有未知的布局。）
</p>
<h4>声明上下文</h4>
<p>
```
context ::= module
context ::= extension
context ::= entity
module ::= substitution                    // other substitution
module ::= identifier                      // module name
module ::= known-module                    // abbreviation
extension ::= 'E' module entity
extension ::= 'e' module generic-signature entity
```
这些manglings确定封闭的上下文中，一个实体被声明，如它的封闭模块，功​​能，或名义类型。
一个扩展的mangling时则使用一个实体的声明上下文是一个扩展和被扩展的实体是在不同的模块。在这种情况下，扩展的模块第一错位，随后由实体被扩展。如果延伸和扩展的实体都在同一模块中，普通实体重整是首选。如果扩展受到限制，在延长的限制被损毁，其一般签名。
当重整本地实体的一个构造或析构，该非分配或非重新分配的方式用于内的上下文。
</p>
<h4>类型</h4>
<p>
```
type ::= 'Bb'                              // Builtin.BridgeObject
type ::= 'BB'                              // Builtin.UnsafeValueBuffer
type ::= 'Bf' natural '_'                  // Builtin.Float<n>
type ::= 'Bi' natural '_'                  // Builtin.Int<n>
type ::= 'BO'                              // Builtin.ObjCPointer
type ::= 'Bo'                              // Builtin.ObjectPointer
type ::= 'Bp'                              // Builtin.RawPointer
type ::= 'Bv' natural type                 // Builtin.Vec<n>x<type>
type ::= 'Bw'                              // Builtin.Word
type ::= nominal-type
type ::= associated-type
type ::= 'a' context identifier            // Type alias (DWARF only)
type ::= 'b' type type                     // objc block function type
type ::= 'c' type type                     // C function pointer type
type ::= 'F' throws-annotation? type type  // function type
type ::= 'f' throws-annotation? type type  // uncurried function type
type ::= 'G' type <type>+ '_'              // generic type application
type ::= 'K' type type                     // @auto_closure function type
type ::= 'M' type                          // metatype without representation
type ::= 'XM' metatype-repr type           // metatype with representation
type ::= 'P' protocol-list '_'             // protocol type
type ::= 'PM' type                         // existential metatype without representation
type ::= 'XPM' metatype-repr type          // existential metatype with representation
type ::= archetype
type ::= 'R' type                          // inout
type ::= 'T' tuple-element* '_'            // tuple
type ::= 't' tuple-element* '_'            // variadic tuple
type ::= 'Xo' type                         // @unowned type
type ::= 'Xu' type                         // @unowned(unsafe) type
type ::= 'Xw' type                         // @weak type
type ::= 'XF' impl-function-type           // function implementation type
type ::= 'Xf' type type                    // @thin function type
nominal-type ::= known-nominal-type
nominal-type ::= substitution
nominal-type ::= nominal-type-kind declaration-name
nominal-type-kind ::= 'C'                  // class
nominal-type-kind ::= 'O'                  // enum
nominal-type-kind ::= 'V'                  // struct
archetype ::= 'Q' index                    // archetype with depth=0, idx=N
archetype ::= 'Qd' index index             // archetype with depth=M+1, idx=N
archetype ::= associated-type
archetype ::= qualified-archetype
associated-type ::= substitution
associated-type ::= 'Q' protocol-context     // self type of protocol
associated-type ::= 'Q' archetype identifier // associated type
qualified-archetype ::= 'Qq' index context   // archetype+context (DWARF only)
protocol-context ::= 'P' protocol
tuple-element ::= identifier? type
metatype-repr ::= 't'                      // Thin metatype representation
metatype-repr ::= 'T'                      // Thick metatype representation
metatype-repr ::= 'o'                      // ObjC metatype representation
throws-annotation ::= 'z'                  // 'throws' annotation on function types


type ::= 'u' generic-signature type        // generic type
type ::= 'x'                               // generic param, depth=0, idx=0
type ::= 'q' generic-param-index           // dependent generic parameter
type ::= 'q' type assoc-type-name          // associated type of non-generic param
type ::= 'w' generic-param-index assoc-type-name // associated type
type ::= 'W' generic-param-index assoc-type-name+ '_' // associated type at depth

generic-param-index ::= 'x'                // depth = 0,   idx = 0
generic-param-index ::= index              // depth = 0,   idx = N+1
generic-param-index ::= 'd' index index    // depth = M+1, idx = N
```
<type>从未开始或以数字结束。 <type>从不以下划线开头。 <type>从来没有开始与D。 <type>从来没有开始以Z。

请注意，协议裂伤不同的类型和作为背景。一个协议方面总是由一个单一的协议名称等等轧液没有一个结尾下划线。协议类型可以有并列设置，结束于结尾下划线零个，一个或多个协议的范围。
```
assoc-type-name ::= ('P' protocol-name)? identifier
assoc-type-name ::= substitution
```
相关类型因此使用缩写的mangling当基座通用参数或关联式是由一个单一的规约要求的限制。在这种情况下，相关联的类型可以明确引用的名字单独。如果基有多个符合性限制，那么协议名称是错位的消除歧义。
```
impl-function-type ::=
  impl-callee-convention impl-function-attribute* generic-signature? '_'
  impl-parameter* '_' impl-result* '_'
impl-callee-convention ::= 't'              // thin
impl-callee-convention ::= impl-convention  // thick, callee transferred with given convention
impl-convention ::= 'a'                     // direct, autoreleased
impl-convention ::= 'd'                     // direct, no ownership transfer
impl-convention ::= 'D'                     // direct, no ownership transfer,
                                            // dependent on 'self' parameter
impl-convention ::= 'g'                     // direct, guaranteed
impl-convention ::= 'e'                     // direct, deallocating
impl-convention ::= 'i'                     // indirect, ownership transfer
impl-convention ::= 'l'                     // indirect, inout
impl-convention ::= 'G'                     // indirect, guaranteed
impl-convention ::= 'o'                     // direct, ownership transfer
impl-convention ::= 'z' impl-convention     // error result
impl-function-attribute ::= 'Cb'            // compatible with C block invocation function
impl-function-attribute ::= 'Cc'            // compatible with C global function
impl-function-attribute ::= 'Cm'            // compatible with Swift method
impl-function-attribute ::= 'CO'            // compatible with ObjC method
impl-function-attribute ::= 'Cw'            // compatible with protocol witness
impl-function-attribute ::= 'N'             // noreturn
impl-function-attribute ::= 'G'             // generic
impl-parameter ::= impl-convention type
impl-result ::= impl-convention type
```
在大多数情况下，manglings遵循的正式语言类型的结构。然而，在某些情况下，它是更为有用的函数类型的准确实现细节进行编码。
任何<impl-function-attribute>产品必须出现在它们上面指定的顺序：例如：一个不返回的C函数的错位与CCN。
需要注意的是，公约和功能属性的制作并不需要从一个<type>的开始消除歧义。

<h4>泛型</h4>
<p>
```
protocol-conformance ::= ('u' generic-signature)? type protocol module
```
<protocol-conformance>是指一个类型的一致性协议。命名模块包含声明的一致性扩展或类型声明之一。
```
generic-signature ::= (generic-param-count+)? ('R' requirement*)? 'r'
generic-param-count ::= 'z'       // zero parameters
generic-param-count ::= index     // N+1 parameters
requirement ::= type-param protocol-name // protocol requirement
requirement ::= type-param type          // base class requirement
                                         // type starts with [CS]
requirement ::= type-param 'z' type      // 'z'ame-type requirement

// Special type mangling for type params that saves the initial 'q' on
// generic params
type-param ::= generic-param-index       // generic parameter
type-param ::= 'w' generic-param-index assoc-type-name // associated type
type-param ::= 'W' generic-param-index assoc-type-name+ '_'
```
一个通用的签名首先描述在每个深度的签名，随后要求的通用参数的数量。作为一个特殊的情况下，没有generic-param-count表示在最外深度单个通用参数：
```
urFq_q_                           // <t_0_0> T_0_0 -&gt; T_0_0
u_0_rFq_qd_0_                     // <t_0_0>&lt;T_1_0, T_1_1&gt; T_0_0 -&gt; T_1_1
```

<h4>映射值</h4>
<p>
```
value-witness-kind ::= 'al'           // allocateBuffer
value-witness-kind ::= 'ca'           // assignWithCopy
value-witness-kind ::= 'ta'           // assignWithTake
value-witness-kind ::= 'de'           // deallocateBuffer
value-witness-kind ::= 'xx'           // destroy
value-witness-kind ::= 'XX'           // destroyBuffer
value-witness-kind ::= 'Xx'           // destroyArray
value-witness-kind ::= 'CP'           // initializeBufferWithCopyOfBuffer
value-witness-kind ::= 'Cp'           // initializeBufferWithCopy
value-witness-kind ::= 'cp'           // initializeWithCopy
value-witness-kind ::= 'TK'           // initializeBufferWithTakeOfBuffer
value-witness-kind ::= 'Tk'           // initializeBufferWithTake
value-witness-kind ::= 'tk'           // initializeWithTake
value-witness-kind ::= 'pr'           // projectBuffer
value-witness-kind ::= 'xs'           // storeExtraInhabitant
value-witness-kind ::= 'xg'           // getExtraInhabitantIndex
value-witness-kind ::= 'Cc'           // initializeArrayWithCopy
value-witness-kind ::= 'Tt'           // initializeArrayWithTakeFrontToBack
value-witness-kind ::= 'tT'           // initializeArrayWithTakeBackToFront
value-witness-kind ::= 'ug'           // getEnumTag
value-witness-kind ::= 'up'           // destructiveProjectEnumData
value-witness-kind ::= 'ui'           // destructiveInjectEnumTag
<value-witness-kind> differentiates the kinds of value witness functions for a type.

Identifiers

identifier ::= natural identifier-start-char identifier-char*
identifier ::= 'o' operator-fixity natural operator-char+

operator-fixity ::= 'p'                    // prefix operator
operator-fixity ::= 'P'                    // postfix operator
operator-fixity ::= 'i'                    // infix operator

operator-char ::= 'a'                      // &amp; 'and'
operator-char ::= 'c'                      // @ 'commercial at'
operator-char ::= 'd'                      // / 'divide'
operator-char ::= 'e'                      // = 'equals'
operator-char ::= 'g'                      // &gt; 'greater'
operator-char ::= 'l'                      // &lt; 'less'
operator-char ::= 'm'                      // * 'multiply'
operator-char ::= 'n'                      // ! 'not'
operator-char ::= 'o'                      // | 'or'
operator-char ::= 'p'                      // + 'plus'
operator-char ::= 'q'                      // ? 'question'
operator-char ::= 'r'                      // % 'remainder'
operator-char ::= 's'                      // - 'subtract'
operator-char ::= 't'                      // ~ 'tilde'
operator-char ::= 'x'                      // ^ 'xor'
operator-char ::= 'z'                      // . 'zperiod'
```
<identifier>是运行长度编码：自然表示的字符如何跟进。操作字符映射到字母字符给出。在两种情况下可以一个标识符以数字开头，所以有与运行长度没有歧义。
```
identifier ::= 'X' natural identifier-start-char identifier-char*
identifier ::= 'X' 'o' operator-fixity natural identifier-char*
```
包含非ASCII字符都使用在RFC 3492中指定Punycode算法编码，与该_用作编码定界符的修改和大写字母A至J标识符被用来代替数字0至9中的编码字符集。是混淆然后由一个X后跟编码串的游程长度和所述编码的字符串本身。例如，标识符vergüenza被错位到X12vergenza_JFa。 （在标准的Punycode编码是vergenza-95A）

包含非ASCII字符，运营商首先映射ASCII运营字符的字母作为纯ASCII运营商名称错位，然后Punycode码编码取代字符串。是混淆然后由XO后跟的固定性，该编码串的运行长度，以及编码的字符串本身。例如，管道符“+”的错位，以Xoi7p_qcaDc（p_qcaDc是的替代字符串“P»编码）。

<h4>代替</h4>
<p>
```
substitution ::= 'S' index
```
<substitution>是一个向后引用到先前错位实体。该重整算法维护实体的映射来替代指标，因为它运行。时，可以通过取代（的模块，名义类型或协议）来表示一个实体是错位，一个取代是第一所期望的是取代的地图，并且如果存在，该实体使用相关替代索引错位。否则，该实体通常错位，且随后添加到替代地图，并与下一个可利用的取代索引相关联。
例如，在重整函数类型（zim.zang.zung，zim.zang.zung，zim.zippity） - &gt; zim.zang.zoo（与模块ZIM和类zim.zang），重复上下文ZIM，以星。臧和zim.zang.zung将使用替代被错位的第一次后，被截断。第一个参数类型将在长形裂伤，CC3zim4zang4zung，并在这样做，ZIM将获得替代S_，zim.zang将获得替代S0_，并zim.zang.zung将收购S1_。第二个参数是一样的第一和裂伤将利用其替换，CS1_。第三个参数类型将裂伤使用替代ZIM，CS_7zippity。 （它也获得替代S2_这将被使用，如果再次错位。）结果类型将裂伤使用替代zim.zang，CS0_zoo（并获得替代S3_）。全功能型因而轧液作为fTCC3zim4zang4zungCS1_CS_7zippity_CS0_zoo。
```
substitution ::= 's'
```
在特殊的替换s被用于Swift标准库模块。

<h4>预定义替换</h4>
<p>
```
known-module ::= 's'                       // Swift
known-module ::= 'SC'                      // C
known-module ::= 'So'                      // Objective-C
known-nominal-type ::= 'Sa'                // Swift.Array
known-nominal-type ::= 'Sb'                // Swift.Bool
known-nominal-type ::= 'Sc'                // Swift.UnicodeScalar
known-nominal-type ::= 'Sd'                // Swift.Float64
known-nominal-type ::= 'Sf'                // Swift.Float32
known-nominal-type ::= 'Si'                // Swift.Int
known-nominal-type ::= 'SP'                // Swift.UnsafePointer
known-nominal-type ::= 'Sp'                // Swift.UnsafeMutablePointer
known-nominal-type ::= 'SQ'                // Swift.ImplicitlyUnwrappedOptional
known-nominal-type ::= 'Sq'                // Swift.Optional
known-nominal-type ::= 'SR'                // Swift.UnsafeBufferPointer
known-nominal-type ::= 'Sr'                // Swift.UnsafeMutableBufferPointer
known-nominal-type ::= 'SS'                // Swift.String
known-nominal-type ::= 'Su'                // Swift.UInt
```
<known-module> 以及 <known-nominal-type>是内置的替换对于某些常见的实体。像任何其他的替代，他们都以'S'。
Objective-C的模块作为上下文重整Objective-C类为的<type>。

<h4>索引</h4>
<p>
```
index ::= '_'                              // 0
index ::= natural '_'                      // N+1
natural ::= [0-9]+
```
<index>是一个生产环境中不能在一个数字结尾的数字编码;它的编码数量较少的优化。


</index></p></type></known-nominal-type></known-module></p></substitution></p></identifier></value-witness-kind></p></t_0_0></t_0_0></protocol-conformance></p></type></impl-function-attribute></type></type></type></type></type></type></n></n></n></p></实现了一套功能型></reabstract-signature></private-decl-name></private-decl-name></p></li></ul></p></li></ul></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift的强大之处]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-qiang-da-zhi-chu/"/>
    <updated>2014-09-18T13:38:34+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-qiang-da-zhi-chu</id>
    <content type="html"><![CDATA[<p>在写任何东西之前我需要承认我是带有偏见的：我爱 Swift。我认为这是从我开始接触 Cocoa 生态系统以来这个平台上发生的最好的事情。我想通过分享我在 Swift，Objective-C 和 Haskell 上的经验让大家知道我为何这样认为。写这篇文章并不是为了介绍一些最好的实践 (写这些的时候 Swift 还太年轻，还没最好实践被总结出来)，而是举几个关于 Swift 强大之处的例子。</p>

<p>给大家一些我的个人背景：在成为全职 iOS/Mac 工程师之前我花了几年的时间做 Haskell (包括一些其他函数式编程语言) 开发。我仍然认为 Haskell 是我所有使用过的语言中最棒的之一。然而我转战到了 Objective-C，是因为我相信 iOS 是最令人激动的平台。刚开始接触 Objective-C 的时候我有些许沮丧，但我慢慢地学会了欣赏它。</p>

<p>当苹果在 WWDC 发布 Swift 的时候我非常的激动。我已经很久没有对新技术的发布感的如此兴奋了。在看过文档之后我意识到 Swift 使我们能够将现有的函数式编程知识和 Cocoa API 无缝地整合到一起。我觉得这两者的组合非常独特：没有任何其他的语言将它们融合地如此完美。就拿 Haskell 来说，想要用它来使用 Objective-C API 相当的困难。同样，想用 Objective-C 去做函数式编程也是十分困难的。</p>

<p>在 Utrecht 大学期间我学会了函数式编程。因为是在很学术的环境下学习所以并没有觉得很多复杂的术语 (moands，applicative functors 以及很多其他的东西) 有多么难懂。我觉得对很多想学习函数式编程的人来说这些名称是一个很大的阻碍。</p>

<p>不仅仅名称很不同，风格也不一样。作为 Objective-C 程序员，我们很习惯于面向对象编程。而且因为大多数语言不是面对对象编程就是与之类似，我们可以看懂很多不同语言的代码。阅读函数式编程语言的时候则大不相同 -- 如果你没有习惯的话看起来简直莫名其妙。</p>

<p>那么，为什么你要使用函数式编程呢？它很奇怪，很多人都不习惯而且学习它要花费大量的时间。并且对于大多数问题面向对象编程都能解决，所以没有必要去学习任何新的东西对吧？</p>

<p>对于我来说，函数式编程只是工具箱中的一件工具。它是一个改变了我对编程的理解的强大工具。在解决问题的时候它非常强大。对于大多数问题面向对象编程都很棒，但是对于其他一些问题应用函数式编程会给你带来巨大的时间/精力的节省。</p>

<p>开始学习函数式编程或许有些痛苦。第一，你必须放手一些老的模式。而因为我们很多人常年用面对对象的方式去思考，做到这一点是很困难的。在函数式编程当中你想的是不变的数据结构以及那些转换它们的函数。在面对对象编程当中你考虑的是互相发送信息的对象。如果你没有马上理解函数式编程，这是一个好的信号。你的大脑很可能已经完全适应了用面对对象的方法来解决问题。</p>

<h2>例子</h2>
<!-- more-->
<p>我最喜欢的 Swift 功能之一是对 optionals 的使用。Optionals 让我们能够应对有可能存在也有可能不存在的值。在 Objective-C 里我们必须在文档中清晰地说明 nil 是否是允许的。Optionals 让我们将这份责任交给了类型系统。如果你有一个可选值，你就知道它可以是 nil。如果它不是可选值，你知道它不可能是 nil。</p>

<p>举个例子，看看下面一小段 Objective-C 代码</p>

<p><code>objc
- (NSAttributedString *)attributedString:(NSString *)input 
{
    return [[NSAttributedString alloc] initWithString:input];
}
</code></p>

<p>看上去没有什么问题，但是如果 <code>input</code> 是 nil, 它就会崩溃。这种问题你只能在运行的时候才能发现。取决于你如何使用它，你可能很快能发现问题，但是你也有可能在发布应用之后才发现，导致用户正在使用的应用崩溃。</p>

<p>用相同的 Swift 的 API 来做对比。</p>

<p><code>objc
extension NSAttributedString {  
    init(string str: String)
}
</code></p>

<p>看起来像对Objective-C的直接翻译，但是 Swift 不允许 <code>nil</code> 被传入。如果要达到这个目的，API 需要变成这个样子：</p>

<p><code>objc
extension NSAttributedString {  
    init(string str: String?)
}
</code></p>

<p>注意新加上的问号。这意味着你可以使用一个值或者是 nil。类非常的精确：只需要看一眼我们就知道什么值是允许的。使用 optionals 一段时间之后你会发现你只需要阅读类型而不用再去看文档了。如果犯了一个错误，你会得到一个编译时警告而不是一个运行时错误。</p>

<h2>建议</h2>

<p>如果可能的话避免使用 optionals。Optionals 对于使用你 API 的人们来说是一个多余的负担。话虽如此，还是有很多地方可以很好使用它们。如果你有一个函数会因为一个明显的原因失败你可以返回一个 optional。举例来说，比如将一个  #00ff00 字符串转换成颜色。如果你的参数不符合正确的格式，你应该返回一个 <code>nil</code> 。</p>

<p><code>objc
func parseColorFromHexString(input: String) -&gt; UIColor? {  
    // ...
}
</code></p>

<p>如果你需要阐明错误信息，你可以使用 <code>Either</code> 或者 <code>Result</code> 类型 (不在标准库里面)。当失败的原因很重要的时候，这种做法会非常有用。<a href="http://nomothetis.svbtle.com/error-handling-in-swift">“Error Handling in Swift”</a> 一文中有个很好的例子。</p>

<h2 id="enums">Enums</h2>

<p>Enums 是一个随 Swift 推出的新东西，它和我们在 Objective-C 中见过的东西都大不相同。在 Objective-C 里面我们有一个东西叫做 enums, 但是它们差不多就是升级版的整数。</p>

<p>我们来看看布尔类型。一个布尔值是两种可能性 -- true 或者 false -- 中的一个。很重要的一点是没有办法再添加另外一个值 -- 布尔类型是<strong>封闭的</strong>。布尔类型的封闭性的好处是每当使用布尔值的时候我们只需要考虑 true 或者 false 这两种情况。</p>

<p>在这一点上面 optionals 是一样的。总共只有两种情况：<code>nil</code> 或者有值。在 Swift 里面布尔和 optional 都可以被定义为 enums。但有一个不同点：在 optional enum 中有一种可能性有一个相关值。我们来看看它们不同的定义：</p>

<p>```objc
enum Boolean {<br />
    case False
    case True
}</p>

<p>enum Optional<a> {<br />
    case Nil
    case Some(A)
}
```</a></p>

<p>它们非常的相似。如果你把它们的名称改成一样的话，那么唯一的区别就是括号里的相关值。如果你给 optional 中的 <code>Nil</code>  情况也加上一个值，你就会得到一个 <code>Either</code> 类型：</p>

<p><code>objc
enum Either&lt;A,B&gt; {  
    case Left&lt;A&gt;
    case Right&lt;B&gt;
}
</code></p>

<p>在函数式编程当中，在你想表示两件事情之间的选择时候你会经常用到 <code>Either</code> 类型。举个例子：如果你有一个函数返回一个整数或者一个错误，你就可以用 <code>Either&lt;Int, NSError&gt;</code>。如果你想在一个字典中储存布尔值或者字符串，你就可以使用 <code>Either&lt;Bool,String&gt;</code> 作为键。</p>

<blockquote>
  <p>理论旁白：有些时候 enums 被称为 <strong>sum 类型</strong>，因为它们是几个不同类型的总和。在 <code>Either</code> 类型的例子中，它们表达的是 <code>A</code> 类型和 <code>B</code> 类型的和。Structs 和 tuples 被称为 <strong>product 类型</strong>，因为它们代表几个不同类型的乘积。参见<a href="http://en.wikipedia.org/wiki/Algebraic_data_type">“algebraic data types.”</a></p>
</blockquote>

<p>理解什么时候使用 enums 什么时候使用其他的数据类型 (比如 <a href="http://objccn.io/issue-16-2">class 或者 structs</a>)会有一些难度。当你有一个固定数量的值的集合的时候，enum 是最有用的。比如说，如果我们设计一个 Github API 的 wrapper，我们可以用 enum 来表示端点。比如有一个不需要任何参数的 <code>/zen</code> 的 API 端点。再比如为了获取用户的资料我们需要提供用户名。最后我们显示用户的仓库时，我们需要提供用户名以及一个值去说明是否从小到大地排列结果。</p>

<p><code>objc
enum Github {  
    case Zen
    case UserProfile(String)
    case Repositories(username: String, sortAscending: Bool)
}
</code></p>

<p>定义 API 端点是很好的使用 enum 的场景。API 的端点是有限的，所以我们可以为每一个端点定义一个情况。如果我们在对这些端点使用 switch 的时候没有包含所有情况的话，我们会被给予警告。所以说当我们需要添加一个情况的时候我们需要更新每一个用到这个 enum 的函数。</p>

<p>除非能够拿到源代码，其他使用我们 enum 的人不能添加新的情况，这是一个非常有用的限制。想想要是你能够加一种新情况到 <code>Bool</code> 或者 <code>Optional</code> 里会怎么样吧 -- 所有用到 它的函数都需要重写。</p>

<p>比如说我们正在开发一个货币转换器。我们可以将货币给定义成 enum：</p>

<p><code>objc
enum Currency {  
    case Eur
    case Usd
}
</code></p>

<p>我们现在可以做一个获取任何货币符号的函数：</p>

<p><code>objc
func symbol(input: Currency) -&gt; String {  
    switch input {
        case .Eur: return "€"
        case .Usd: return "$"
    }
}
</code></p>

<p>最后，我们可以用我们的 <code>symbol</code> 函数，来依据系统本地设置得到一个很好地格式化过的字符串：</p>

<p><code>objc
func format(amount: Double, currency: Currency) -&gt; String {  
    let formatter = NSNumberFormatter()
    formatter.numberStyle = .CurrencyStyle
    formatter.currencySymbol = symbol(currency)
    return formatter.stringFromNumber(amount)
}
</code></p>

<p>这样一来有一个很大的限制。我们可能会想让我们 API 的使用者在将来可以修改一些情况。在 Objective-C 当中向一个接口里添加更多类型的常见解决方法是子类化。在 Objective-C 里面理论上你可以子类化任何一个类，然后通过这种办法来扩展它。在 Swift 里面你仍然可以使用子类化，但是只能对 <code>class</code> 使用，对于 <code>enum</code> 则不行。然而，我们可以用另一种技术来达到目的 (这种办法在 Objetive-C 和 Swift 的 protocol 中都可行）。</p>

<p>假设我们定义一个货币符号的协议：</p>

<p><code>objc
protocol CurrencySymbol {  
    func symbol() -&gt; String
}
</code></p>

<p>现在我们让 <code>Currency</code> 类型遵守这个协议。注意我们可以将 <code>input</code> 参数去掉，因为这里它被作为 self 隐式地进行传递：</p>

<p><code>objc
extension Currency : CurrencySymbol {  
   func symbol() -&gt; String {
        switch self {
            case .Eur: return "€"
            case .Usd: return "$"
        }
    }
}
</code></p>

<p>现在我们可以重写 <code>format</code> 方法来格式化任何遵守我们协议的类型：</p>

<p><code>objc
func format(amount: Double, currency: CurrencySymbol) -&gt; String {  
    let formatter = NSNumberFormatter()
    formatter.numberStyle = .CurrencyStyle
    formatter.currencySymbol = currency.symbol()
    return formatter.stringFromNumber(amount)
}
</code></p>

<p>这样一来我们将我们代码的可延展性大大提升类 -- 任何遵守 <code>CurrencySymbol</code> 协议的类型都可以被格式化。比如说，我们建立一个新的类型来储存比特币，我们可以立刻让它拥有格式化功能：</p>

<p><code>objc
struct Bitcoin : CurrencySymbol {  
    func symbol() -&gt; String {
        return "B⃦"
    }
}
</code></p>

<p>这是一种写出具有延展性函数的很好的方法。通过使用一个需要遵守协议，而不是一个实实在在的类型，你的 API 的用户能够加入更多的类型。你仍然可以利用 enum 的灵活性，但是通过让它们遵守协议，你可以更好地表达自己的意思。根据你的具体情况，你现在可以轻松地选择是否开放你的 API。</p>

<h2>类型安全</h2>

<p>我认为类型的安全性是 Swift 一个很大的优势。就像我们在讨论 optionals 时看见的一样，我们可以用一些聪明的手段将某些检测从运行时转移到编译时。Swift 中数组的工作方式就是一个例子：一个数组是泛型的，它只能容纳一个类型的对象。将一个整数附加在一个字符组数组后面是做不到的。这样以来就消灭了一个类的潜在 bug。(值得注意的是如果你需要同时将字符串或者整数放到一个数组里的话，你可以使用上面谈到过的 <code>Either</code> 类型。)</p>

<p>再比如说，我们要将我们到货币转换器延展为一个通用的单位换算器。如果我们使用 <code>Double</code> 去表示数量，会有一点点误导性。比如说，100.0 可以表示 100 美元，100 千克或者任何能用 100 表示的东西。我们可以借助类型系统来制作不同的类型来表示不同的物理上的数量。比如说我们可以定义一个类型来表示钱：</p>

<p><code>objc
struct Money {  
    let amount : Double
    let currency: Currency
}
</code></p>

<p>我们可以定义另外一个结构来表示质量：</p>

<p><code>objc
struct Mass {  
    let kilograms: Double
}
</code></p>

<p>现在我们就消除了不小心将 <code>Money</code>  和 <code>Mass</code> 相加的可能性。基于你应用的特质有时候将一些简单的类型包装成这样是很有效的。不仅如此，阅读代码也会变得更加简单。假设我们遇到一个 <code>pounds</code> 函数：</p>

<p><code>objc
func pounds(input: Double) -&gt; Double  
</code></p>

<p>光看类型定义很难看出来这个函数的功能。它将欧元装换成英镑？还是将千克转换成磅？ (英文中英镑和磅均为 pound) 我们可以用不同的名字，或者可以建立文档 (都是很好的办法)，但是我们有第三种选择。我们可以将这个类型变得更明确：</p>

<p><code>objc
func pounds(input: Mass) -&gt; Double  
</code></p>

<p>我们不仅让这个函数的用户能够立刻理解这个函数的功能，我们也防止了不小心传入其他单位的参数。如果你试图将 <code>Money</code> 作为参数来使用这个函数，编译器是不会接受的。另外一个可能的提升是使用一个更精确的返回值。现在它只是一个 <code>Double</code>。</p>

<h2>不可变性</h2>

<p>Swift 另外一个很棒的功能是内置的不可变性。在 Cocoa 当中很多的 API 都已经体现出了不可变性的价值。想了解这一点为什么如此重要，<a href="http://nomothetis.svbtle.com/error-handling-in-swift">“Error Handling in Swift”</a> 是一个很好的参考。比如，作为一个 Cocoa 开发者，我们使用很多成对的类 (<code>NSString</code> vs. <code>NSMutableString</code>，<code>NSArray</code> vs. <code>NSMutableArray</code>)。当你得到一个字符串值，你可以假设它不会被改变。但是如果你要完全确信，你依然要复制它。然后你才知道你有一份不可变的版本。</p>

<p>在 Swifit 里面，不可变性被直接加入这门语言。比如说如果你想建立一个可变的字符串，你可以如下的代码：</p>

<p><code>objc
var myString = "Hello"  
</code></p>

<p>然而，如果你想要一个不可变的字符串，你可以做如下的事情：</p>

<p><code>objc
let myString = "Hello"  
</code></p>

<p>不可变的数据在创建可能会被未知用户使用的 API 时会给你很大的帮助。比如说，你有一个需要字符串作为参数的函数，在你迭代它的时候，确定它不会被改变是很重要的。在 Swift 当中这是默认的行为。正是因为这个原因，在写多线程代码的时候使用不可变资料会使难度大大降低。</p>

<p>还有另外一个巨大的优势。如果你的函数只使用不可变的数据，你的类型签名就会成为很好的文档。在 Objective-C 当中则不然。比如说，假设你准备在 OS X 上使用 <code>CIFilter</code>。在实例化之后你需要使用 <code>setDefaults</code> 方法。这一点在文档中有提到。有很多这样类都是这个样子。在实例化之后，在你使用它之前你必须要使用另外一个方法。问题在于，如果不阅读文档的话，经常会不清楚哪些函数需要被使用，最后你有可能遇到很奇怪的状况。</p>

<p>当使用不可变资料的时候，类型签名让事情变得很清晰。比如说，<code>map</code> 的类签名。我们知道有一个可选的 <code>T</code> 值，而且有一个将 <code>T</code> 转换成 <code>U</code> 的函数。结果是一个可选的 <code>U</code> 值。原始值是不可能改变的：</p>

<p><code>objc
func map&lt;T, U&gt;(x: T?, f: T -&gt; U) -&gt; U?  
</code></p>

<p>对于数组的 <code>map</code> 来说是一样的。它被定义成一个数组的延伸，所以参数本身是 <code>self</code>。我们可以看到它用一个函数将 <code>T</code> 转化成 <code>U</code>，并且生成一个 <code>U</code> 的数组。因为它是一个不可变的函数，我们知道原数组是不会变化的，而且我们知道结果也是不会改变的。将这些限制内置在l类型系统中，并有编译器来监督执行，让我们不再需要去查看文档并记住什么会变化。</p>

<p><code>objc
extension Array {  
    func map&lt;U&gt;(transform: T -&gt; U) -&gt; [U]
}
</code></p>

<h2>总结</h2>

<p>Swift 带来了很多有趣的可能性。我尤其喜欢的一点是过去我们需要手动检测或者阅读文档的事情现在编译器可以帮我们来完成。我们可以选择在合适的时机去使用这些可能性。我们依然会用我们现有的，成熟的办法去写代码，但是我们可以在合适的时候在我们代码的某些地方应用这些新的可能性。</p>

<p>我预测：Swift 会很大程度上改变我们写代码的方式，而且是向好的方向改变。脱离 Objective-C 会需要几年的时间，但是我相信我们中的大多数人会做出这个改变并且不会后悔。有些人会很快的适应，对另外一些人可能会花上很长的时间。但是我相信总有一天绝大多数人会看到 Swift 带给我们的种种好处。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift的函数式API]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-han-shu-shi-api/"/>
    <updated>2014-09-18T10:19:05+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/09/18/swiftde-han-shu-shi-api</id>
    <content type="html"><![CDATA[<p>在过去的时间里，人们对于设计 API 总结了很多通用的模式和最佳实践方案。一般情况下，我们总是可以从苹果的 Foundation、Cocoa、Cocoa Touch 和很多其他框架中总结出一些开发中的范例。毫无疑问，对于“特定情境下的 API 应该如何设计”这个问题，不同的人总是有着不同的意见，对于这个问题有很大的讨论空间。不过对于很多 Objective-C 的开发者来说，对于那些常用的模式早已习以为常。</p>

<p>随着 Swift 的出现，设计 API 引起了更多的问题。绝大多数情况下，我们只能继续做着手头的工作，然后把现有的方法翻译成 Swift 版本。不过，这对于 Swift 来说并不公平，因为和 Objective-C 相比，Swift 添加了很多新的特性。引用 Swift 创始人 <a href="https://twitter.com/clattner_llvm">Chris Lattner</a> 的一段话：</p>

<blockquote>
  <p>Swift 引入了泛型和函数式编程的思想，极大地扩展了设计的空间。</p>
</blockquote>

<p>在这篇文章里，我们将会围绕 <code>Core Image</code> 进行 API 封装，以此为例，探索如何在 API 设计中使用这些新的工具。 <code>Core Image</code> 是一个功能强大的图像处理框架，但是它的 API 有时有点笨重。 <code>Core Image</code> 的 API 是弱类型的 - 它通过键值对 (key-value) 设置图像滤镜。这样在设置参数的类型和名字时很容易失误，会导致运行时错误。新的 API 将会十分的安全和模块化，通过使用类型而不是键值对来规避这样的运行时错误。</p>

<h2>目标</h2>

<p>我们的目标是构建一个 API ，让我们可以简单安全的组装自定义滤镜。举个例子，在文章的结尾，我们可以这样写：</p>

<p><code>objc
let myFilter = blur(blurRadius) &gt;|&gt; colorOverlay(overlayColor)
let result = myFilter(image)
</code></p>

<p>上面构建了一个自定义的滤镜，先模糊图像，然后再添加一个颜色蒙版。为了达到这个目标，我们将充分利用 Swift 函数是一等公民这一特性。项目源码可以在 Github 上的这个<a href="https://github.com/objcio/issue-16-functional-apis">示例项目</a>中下载。</p>

<h2 id="filter">Filter 类型</h2>

<p><code>CIFilter</code> 是 <code>Core Image</code> 中的一个核心类，用来创建图像滤镜。当实例化一个 <code>CIFilter</code> 对象之后，你 (几乎) 总是通过 <code>kCIInputImageKey</code> 来输入图像，然后通过 <code>kCIOutputImageKey</code> 获取返回的图像，返回的结果可以作为下一个滤镜的参数输入。</p>

<p>在我们即将开发的 API 里，我们会把这些键值对 (key-value) 对应的真实内容抽离出来，为用户提供一个安全的强类型 API。我们定义了自己的滤镜类型 <code>Filter</code>，它是一个可以传入图片作为参数的函数，并且返回一个新的图片。</p>

<p><code>objc
typealias Filter = CIImage -&gt; CIImage
</code>
<!-- more--></p>
<p>这里我们用 <code>typealias</code> 关键字，为 <code>CIImage -&gt; CIImage</code>类型定义了我们自己的名字，这个类型是一个函数，它的参数是一个 <code>CIImage</code> ，返回值也是 <code>CIImage</code> 。这是我们后面开发需要的基础类型。</p>

<p>如果你不太熟悉函数式编程，你可能对于把一个函数类型命名为 <code>Filter</code> 感觉有点奇怪，通常来说，我们会用这样的命名来定义一个类。如果我们很想以某种方式来表现这个类型的函数式的特性，我们可以把它命名成 <code>FilterFunction</code> 或者一些其他的类似的名字。但是，我们有意识的选择了 <code>Filter</code> 这个名字，因为在函数式编程的核心哲学里，函数就是值，函数和结构体、整数、多元组、或者类，并没有任何区别。一开始我也不是很适应，不过一段时间之后发现，这样做确实很有意义。</p>

<h2>构建滤镜</h2>

<p>现在我们已经定义了 <code>Filter</code> 类型，接下来可以定义函数来构建特定的滤镜了。这些函数需要参数来设置特定的滤镜，并且返回一个类型为 <code>Filter</code> 的值。这些函数大概是这个样子：</p>

<p><code>objc
func myFilter(/* parameters */) -&gt; Filter
</code></p>

<p>注意返回的值 <code>Filter</code> 本身就是一个函数，在后面有利于我们将多个滤镜组合起来，以达到理想的处理效果。</p>

<p>为了让后面的开发更轻松一点，我们扩展了 <code>CIFilter</code> 类，添加了一个 convenience 的初始化方法，以及一个用来获取输出图像的计算属性：</p>

<p>```objc
typealias Parameters = Dictionary&lt;String, AnyObject&gt;</p>

<p>extension CIFilter {</p>

<pre><code>convenience init(name: String, parameters: Parameters) {
    self.init(name: name)
    setDefaults()
    for (key, value : AnyObject) in parameters {
        setValue(value, forKey: key)
    }
}

var outputImage: CIImage { return self.valueForKey(kCIOutputImageKey) as CIImage }
</code></pre>

<p>}
```</p>

<p>这个 convenience 初始化方法有两个参数，第一个参数是滤镜的名字，第二个参数是一个字典。字典中的键值对将会被设置成新滤镜的参数。我们 convenience 初始化方法先调用了指定的初始化方法，这符合 Swift 的开发规范。</p>

<p>计算属性 <code>outputImage</code> 可以方便地从滤镜对象中获取到输出的图像。它查找 <code>kCIOutputImageKey</code> 对应的值并且将其转换成一个 <code>CIImage</code> 对象。通过提供这个属性， API 的用户不再需要对返回的结果手动进行类型转换了。</p>

<h2>模糊</h2>

<p>有了这些东西，现在我们就可以定义属于自己的简单滤镜了。高斯模糊滤镜只需要一个模糊半径作为参数，我们可以非常容易的完成一个模糊滤镜：</p>

<p><code>objc
func blur(radius: Double) -&gt; Filter {
    return { image in
        let parameters : Parameters = [kCIInputRadiusKey: radius, kCIInputImageKey: image]
        let filter = CIFilter(name:"CIGaussianBlur", parameters:parameters)
        return filter.outputImage
    }
}
</code></p>

<p>就是这么简单，这个模糊函数返回了一个函数，新的函数的参数是一个类型为 <code>CIImage</code> 的图片，返回值 (<code>filter.outputImage</code>) 是一个新的图片 。这个模糊函数的格式是 <code>CIImage -&gt; CIImage</code> ，满足我们前面定义的 <code>Filter</code> 类型的格式。</p>

<p>这个例子只是对 <code>Core Image</code> 中已有滤镜的一个简单的封装，我们可以多次重复同样的模式，创建属于我们自己的滤镜函数。</p>

<h2>颜色蒙版</h2>

<p>现在让我们定义一个颜色滤镜，可以在现有的图片上面加上一层颜色蒙版。 <code>Core Image</code> 默认没有提供这个滤镜，不过我们可以通过已有的滤镜组装一个。</p>

<p>我们使用两个模块来完成这个工作，一个是颜色生成滤镜 (<code>CIConstantColorGenerator</code>)，另一个是资源合成滤镜 (<code>CISourceOverCompositing</code>)。让我们先定义一个生成一个常量颜色面板的滤镜：</p>

<p><code>objc
func colorGenerator(color: UIColor) -&gt; Filter {
    return { _ in
        let filter = CIFilter(name:"CIConstantColorGenerator", parameters: [kCIInputColorKey: color])
        return filter.outputImage
    }
}
</code></p>

<p>这段代码看起来和前面的模糊滤镜差不多，不过有一个较为明显的差异：颜色生成滤镜不会检测输入的图片。所以在函数里我们不需要给传入的图片参数命名，我们使用了一个匿名参数 <code>_</code> 来强调这个 filter 的图片参数是被忽略的。</p>

<p>接下来，我们来定义合成滤镜：</p>

<p><code>objc
func compositeSourceOver(overlay: CIImage) -&gt; Filter {
    return { image in
        let parameters : Parameters = [ 
            kCIInputBackgroundImageKey: image, 
            kCIInputImageKey: overlay
        ]
        let filter = CIFilter(name:"CISourceOverCompositing", parameters: parameters)
        return filter.outputImage.imageByCroppingToRect(image.extent())
    }
}
</code></p>

<p>在这里我们将输出图像裁剪到和输入大小一样。这并不是严格需要的，要取决于我们想让滤镜如何工作。不过，在后面我们的例子中我们可以看出来这是一个明智之举。</p>

<p><code>objc
func colorOverlay(color: UIColor) -&gt; Filter {
    return { image in
        let overlay = colorGenerator(color)(image)
        return compositeSourceOver(overlay)(image)
    }
}
</code></p>

<p>我们再一次返回了一个参数为图片的函数，<code>colorOverlay</code> 在一开始先调用了 <code>colorGenerator</code> 滤镜。<code>colorGenerator</code> 滤镜需要一个颜色作为参数，并且返回一个滤镜。因此 <code>colorGenerator(color)</code> 是 <code>Filter</code> 类型的。但是 <code>Filter</code> 类型本身是一个 <code>CIImage</code> 向 <code>CIImage</code> 转换的函数，我们可以在 <code>colorGenerator(color)</code> 后面加上一个类型为 <code>CIImage</code> 的参数，这样可以得到一个类型为 <code>CIImage</code> 的蒙版图片。这就是在定义 <code>overlay</code> 的时候发生的事情：我们用 <code>colorGenerator</code> 函数创建了一个滤镜，然后把图片作为一个参数传给了这个滤镜，从而得到了一张新的图片。返回值 <code>compositeSourceOver(overlay)(image)</code> 和这个基本相似，它由一个滤镜 <code>compositeSourceOver(overlay)</code> 和一个图片参数 <code>image</code> 组成。</p>

<h2>组合滤镜</h2>

<p>现在我们已经定义了一个模糊滤镜和一个颜色滤镜，我们在使用的时候可以把它们组合在一起：我们先将图片做模糊处理，然后再在上面放一个红色的蒙层。让我们先加载一张图片：</p>

<p><code>objc
let url = NSURL(string: "http://tinyurl.com/m74sldb");
let image = CIImage(contentsOfURL: url)
</code></p>

<p>现在我们可以把滤镜组合起来，同时应用到一张图片上：</p>

<p><code>objc
let blurRadius = 5.0
let overlayColor = UIColor.redColor().colorWithAlphaComponent(0.2)
let blurredImage = blur(blurRadius)(image)
let overlaidImage = colorOverlay(overlayColor)(blurredImage)
</code></p>

<p>我们又一次的通过滤镜组装了图片。比如在倒数第二行，我们先得到了模糊滤镜 <code>blur(blurRadius)</code> ，然后再把这个滤镜应用到图片上。</p>

<h2>函数组装</h2>

<p>不过，我们可以做的比上面的更好。我们可以简单的把两行滤镜的调用组合在一起变成一行，这是我脑海中想到的第一个能改进的地方：</p>

<p><code>objc
let result = colorOverlay(overlayColor)(blur(blurRadius)(image))
</code></p>

<p>不过，这些圆括号让这行代码完全不具有可读性，更好的方式是定义一个函数来完成这项任务：</p>

<p><code>objc
func composeFilters(filter1: Filter, filter2: Filter) -&gt; Filter {
    return { img in filter2(filter1(img)) }
}
</code></p>

<p><code>composeFilters</code> 函数的两个参数都是 Filter ，并且返回了一个新的 Filter 滤镜。组装后的滤镜需要一个 <code>CIImage</code> 类型的参数，并且会把这个参数分别传给 <code>filter1</code> 和 <code>filter2</code> 。现在我们可以用 <code>composeFilters</code> 来定义我们自己的组合滤镜：</p>

<p><code>objc
let myFilter = composeFilters(blur(blurRadius), colorOverlay(overlayColor))
let result = myFilter(image)
</code></p>

<p>我们还可以更进一步的定义一个滤镜运算符，让代码更具有可读性，</p>

<p>```objc
infix operator &gt;|&gt; { associativity left }</p>

<p>func &gt;|&gt; (filter1: Filter, filter2: Filter) -&gt; Filter {
    return { img in filter2(filter1(img)) }
}
```</p>

<p>运算符通过 <code>infix</code> 关键字定义，表明运算符具有 <code>左</code> 和 <code>右</code> 两个参数。<code>associativity left</code> 表明这个运算满足左结合律，即：f1 &gt;|&gt; f2 &gt;|&gt; f3 等价于 (f1 &gt;|&gt; f2) &gt;|&gt; f3。通过使这个运算满足左结合律，再加上运算内先应用了左侧的滤镜，所以在使用的时候滤镜顺序是从左往右的，就像 Unix 管道一样。</p>

<p>剩余的部分是一个函数，内容和 <code>composeFilters</code> 基本相同，只不过函数名变成了 <code>&gt;|&gt;</code>。</p>

<p>接下来我们把这个组合滤镜运算器应用到前面的例子中：</p>

<p><code>objc
let myFilter = blur(blurRadius) &gt;|&gt; colorOverlay(overlayColor)
let result = myFilter(image)
</code></p>

<p>运算符让代码变得更易于阅读和理解滤镜使用的顺序，调用滤镜的时候也更加的方便。就好比是 <code>1 + 2 + 3 + 4</code> 要比 <code>add(add(add(1, 2), 3), 4)</code> 更加清晰，更加容易理解。</p>

<h2>自定义运算符</h2>

<p>很多 Objective-C 的开发者对于自定义运算符持有怀疑态度。在 Swift 刚发布的时候，这是一个并没有很受欢迎的特性。很多人在 C++ 中遭遇过自定义运算符过度使用 (甚至滥用) 的情况，有些是个人经历过的，有些是听到别人谈起的。</p>

<p>你可能对于前面定义的运算符 <code>&gt;|&gt;</code> 持有同样的怀疑态度，毕竟如果每个人都定义自己的运算符，那代码岂不是很难理解了？值得庆幸的是在函数式编程里有很多的操作，为这些操作定义一个运算符并不是一件很罕见的事情。</p>

<p>我们定义的滤镜组合运算符是一个<a href="http://en.wikipedia.org/wiki/Function_composition_%28computer_science%29">函数组合</a>的例子，这是一个在函数式编程中广泛使用的概念。在数学里，两个函数 <code>f</code> 和 <code>g</code> 的组合有时候写做 <code>f ∘ g</code>，这样定义了一种全新的函数，将输入的 <code>x</code> 映射到 <code>f(g(x))</code> 上。这恰好就是我们的 <code>&gt;|&gt;</code> 所做的工作 (除了函数的逆向调用)。 </p>

<h2>泛型</h2>

<p>仔细想想，其实我们并没有必要去定义一个用来专门组装滤镜的运算符，我们可以用一个泛型的运算符来组装函数。目前我们的 <code>&gt;|&gt;</code> 是这样的：</p>

<p><code>objc
func &gt;|&gt; (filter1: Filter, filter2: Filter) -&gt; Filter
</code></p>

<p>这样定义之后，我们传入的参数只能是 <code>Filter</code> 类型的滤镜。</p>

<p>但是，我们可以利用 Swift 的通用特性来定义一个泛型的函数组合运算符：</p>

<p><code>objc
func &gt;|&gt; &lt;A, B, C&gt;(lhs: A -&gt; B, rhs: B -&gt; C) -&gt; A -&gt; C {
    return { x in rhs(lhs(x)) }
}
</code></p>

<p>这个一开始可能很难理解 -- 至少对我来说是这样。但是分开的看了各个部分之后，一切都变得清晰起来。</p>

<p>首先，我们来看一下函数名后面的尖括号。尖括号定义了这个函数适用的泛型类型。在这个例子里我们定义了三个类型：A、B 和 C。因为我们并没有指定这些类型，所以它们可以代表任何东西。</p>

<p>接下来让我们来看看函数的参数：第一个参数：lhs (left-hand side 的缩写)，是一个类型为 A -&gt; B 的函数。这代表一个函数的参数为 A，返回值的类型为 B。第二个参数：rhs (right-hand side 的缩写)，是一个类型为 B -&gt; C 的函数。参数命名为 lhs 和 rhs，因为它们分别对应操作符左边和右边的值。</p>

<p>重写了没有 <code>Filter</code> 的滤镜组合运算符之后，我们很快就发现其实前面实现的组合运算符只是泛型函数中的一个特殊情况：</p>

<p><code>objc
func &gt;|&gt; (filter1: CIImage -&gt; CIImage, filter2: CIImage -&gt; CIImage) -&gt; CIImage -&gt; CIImage
</code></p>

<p>把我们脑海中的泛型类型 A、B、C 都换成 <code>CIImage</code>，这样可以清晰的理解用通用运算符的来替换滤镜组合运算符是多么的有用。</p>

<h2>结论</h2>

<p>至此，我们成功的用函数式 API 封装了 <code>Core Image</code>。希望这个例子能够很好的说明，对于 Objective-C 的开发者来说，在我们所熟知的 API 的设计模式之外有一片完全不同的世界。有了 Swift，我们现在可以动手探索那些全新的领域，并且将它们充分地利用起来。</p>

<hr />

]]></content>
  </entry>
  
</feed>
