<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | IT Monkey Life]]></title>
  <link href="http://ITMonkeyLife.github.io/Blog/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://ITMonkeyLife.github.io/Blog/"/>
  <updated>2014-05-18T10:58:26+08:00</updated>
  <id>http://ITMonkeyLife.github.io/Blog/</id>
  <author>
    <name><![CDATA[Rick]]></name>
    <email><![CDATA[382542165@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自定义Formatters]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/16/zi-ding-yi-formatters/"/>
    <updated>2014-05-16T14:09:57+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/16/zi-ding-yi-formatters</id>
    <content type="html"><![CDATA[<p>我们希望有一种快速的一次性的解决方案，可以把数据格式化为一种易读的格式。Foundation 框架中的就有 <code>NSFormatter</code> 可以很好地胜任这个工作。另外，在 Mac 上，Appkit 已经内建了 <code>NSFormatter</code> 的支持。</p>

<h2>内建格式器</h2>

<p>Foundation 框架中的 <code>NSFormatter</code> 是一个抽象类，它有两个已经实现的子类：<code>NSNumberFormatter</code> 与 <code>NSDateFormatter</code>。现在我们先跳过这些，来实现我们自己的子类。</p>

<p>如果你想了解更多的相关知识，我推荐阅读 <a href="http://nshipster.com/nsformatter/">NSHipster</a>。</p>

<h2>介绍</h2>

<p><code>NSFormatter</code> 除了抛出错误，其它什么事也不做。我还不知道有人想要用这个，当然如果它对你有用，就去用它吧。</p>

<p>因为我们不喜欢错误，我们在此实现一个 <code>NSFormatter</code> 的子类，它可以把 <code>UIColor</code> 实例转换成可读的名字。例如，以下代码可以返回字符串“Blue”:</p>

<pre><code>KPAColorFormatter *colorFormatter = [[KPAColorFormatter alloc] init];
[colorFormatter stringForObjectValue:[UIColor blueColor]] // Blue
</code></pre>

<p><code>NSFormatter</code> 的子类化有两个方法需要实现：<code>stringForObjectValue:</code> 与 <code>getObjectValue:ForString:errorDescription:</code>。我们先开始介绍第一个方法，因为这个方法更常用。第二个方法，就我所知，经常用于 OS X 上，并且通常不是很有用，我们将稍后介绍。</p>

<h2>初始化</h2>

<p>首先，我们需要做些初始化的工作。由于没有事先定义好的字典可以把颜色映射至名字，这些工作将由我们来完成。为了简化，这些工作将在初始化方法中完成：</p>

<p><code>objc
- (id)init;
{
    return [self initWithColors:@{
        [UIColor redColor]: @"Red",
        [UIColor blueColor]: @"Blue",
        [UIColor greenColor]: @"Green"
    }];
}
</code></p>

<p>这里的 colors 是一个以 <code>UIColor</code> 实例为键，英语名为值的字典。大家可以自行地去实现 <code>initWithColors:</code> 方法。当然你也可以自行实现，或者直接前往 <a href="https://github.com/klaaspieter/KPAColorFormatter">Github repo</a> 获得答案。</p>

<h2>格式化对象值</h2>

<p>由于我们这里只可以格式化 <code>UIColor</code> 实例对象，于是在方法 <code>stringForObjectValue:</code> 中的第一件事就是判断传入的参数类型是否是 <code>UIColor</code> 类。</p>

<p>```
- (NSString *)stringForObjectValue:(id)value;
{
    if (![value isKindOfClass:[UIColor class]]) {
        return nil;
    }</p>

<pre><code>// To be continued... } ```
</code></pre>

<p>在判断参数合法后，我们可以实现真正的逻辑了。我们的格式器中包含一个 <code>UIColor</code> 对象为键，颜色名为值的字典。因此，我们只需要以 <code>UIColor</code> 对象为键找到对应的值：</p>

<p>```objc
- (NSString *)stringForObjectValue:(id)value;
{
    // Previously on KPAColorFormatter</p>

<pre><code>return [self.colors objectForKey:value]; } ```
</code></pre>

<p>以上代码是一个尽可能简单的实现。一个更高级（有用）的格式器应该是在我们的颜色字典中没有找到匹配的颜色时，返回一个最接近的颜色。大家可以自行实现，或是你不想花费太多功夫，可以前往 <a href="https://github.com/klaaspieter/KPAColorFormatter">Github repo</a>。</p>

<h2>反向格式化</h2>

<p>我们的格式器也应该支持反向格式化，即把字符串转成实例对象。这是通过 <code>getObjectValue:forString:errorDescription:</code> 方法实现。在 OS X 上，在使用 <code>NSCell</code> 时会经常用到这个方法。</p>

<p><code>NSCell</code> 有一个 <code>objectValue</code> 属性。默认情况下，<code>NSCell</code> 会用 <code>objectValue</code> 的描述，但是它也可以选择用一个格式器。在用 <code>NSTextFieldCell</code> 时，用户可以输入值，作为程序员，我们可能期望 <code>objedctValue</code> 可以根据根据输入的字符串转成一个 <code>UIColor</code> 实例。例如，用户如果输入“Blue”，我们需要返回一个 <code>[UIColor blueColor]</code> 实例的引用。</p>

<p>实现反向格式化分为两部分：一部分为当格式器可以成功地把字符串转成 <code>UIColor</code> 实例，另一部分当其不能成功转换。第一部分代码如下：</p>

<p>```objc
- (BOOL)getObjectValue:(out __autoreleasing id *)obj 
             forString:(NSString *)string 
      errorDescription:(out NSString *__autoreleasing *)error;
{
    __block UIColor *matchingColor = nil;
    [self.colors enumerateKeysAndObjectsUsingBlock:^(UIColor *color, NSString *name, BOOL *stop) {
        if([name isEqualToString:string]) {
            matchingColor = color;
            *stop = YES;
        }
    }];</p>

<pre><code>if (matchingColor) {
    *obj = matchingColor;
    return YES;
} // Snip ```
</code></pre>

<p>这里可以做一些优化，但是我们先不去做这些。以上方法会遍历我们颜色字典里的每一个对象 ，当一个颜色名字找到时，则会返回其对应关联的 <code>UIColor</code> 实例对象的引用，同时返回 YES 告知调用者我们已经成功地把字符串转成了一个 <code>UIColor</code> 实例对象。</p>

<p>现在处理第二部分：</p>

<p>```objc
if (matchingColor) {
    // snap
} else if (error) {
    *error = [NSString stringWithFormat:@”No known color for name: %@”, string];
}</p>

<p>return NO;
```</p>

<p>这里，我们如果不能找到一个匹配的颜色，我们会检测调用者是否需要错误信息，如果需要，则把错误通过引用返回。这里检查错误很重要。如果你不这样做，程序就会 crash。同时，我们也会返回 NO，告知调用者这次转换失败。</p>

<h2>本地化</h2>

<p>到现在，我们已经建立了一个完全功能的 <code>NSFormatter</code> 的子类，当然这只是对于生活在美国的英语使用者而言有用。</p>

<p>但相比全世界 71.3 亿人，那才 3.19 亿。或者说，你还有 96% 的潜在用户。当然你可以说：这些潜在用户绝大部分都不是 iPhone 或 Mac 使用者，这么做有什么意思呢？这么想你就太扫兴了。</p>

<p><code>NSNumberFormatter</code> 与 <code>NSDateFormatter</code> 都有一个 locale 属性，它是 <code>NSLocale</code> 实例对象。我们现在来扩展格式器以支持本地化，让它可以根据 local 属性来返回对应翻译的名字。</p>

<h3>翻译</h3>

<p>首先，我们需要翻译颜色名字字符串。有关 genstring 与 *.lprojs 超出了本文的范围。有<a href="http://www.getlocalization.com/library/get-localization-mac/">很多文章</a>讨论这点。好了，不需要其它工作了，快要结束了。</p>

<h3>本地化的格式化</h3>

<p>接下来是本地化功能的实现。在获取翻译的字符串后，我们需要更新 <code>stringForObejectValue:</code> 方法。以前已经使用过 <code>NSLocalizedString</code> 的人可能已经早早的把每一个字符串都用 <code>NSLocalizedString</code> 替换了。但是我们不会这么做。</p>

<p>我们现在处理的是一个动态的 local，而 <code>NSLocalizedString</code> 只会查找当前默认的语言的翻译。在99%的情况下，这种默认的行为是你所想要的，但是我们会用格式化器的 locale 属性来动态查询语言。</p>

<p>以下是 <code>stringForObjectValue:</code> 的新的实现：</p>

<p>```objc
- (NSString *)stringForObjectValue:(id)value;
{
    // Previously on… don’t you hate these? I just watched that 20 seconds ago!</p>

<pre><code>NSString *languageCode = [self.locale objectForKey:NSLocaleLanguageCode];
NSURL *bundleURL = [[NSBundle bundleForClass:self.class] URLForResource:languageCode 
                                                          withExtension:@"lproj"];
NSBundle *languageBundle = [NSBundle bundleWithURL:bundleURL];
return [languageBundle localizedStringForKey:name value:name table:nil]; } ```
</code></pre>

<p>上面的代码还有可以重构改进的地方，但因为把代码都放在同一个地方可以方便阅读，所以请大家多多包涵了。</p>

<p>首先，我们通过 locale 属性查找相应的语言，之后通过 NSBundle 找到对应的语言代码。最后，我们会让 bundle 对英语名称进行翻译。如果找不到对应的翻译，则会返回 name: 方法的参数（即英语名称）。如上即是 <code>NSLocalizedString</code> 的具体实现。</p>

<h3>本地化的反向格式化</h3>

<p>同样，我们也可以把颜色名称转成 <code>UIColor</code> 实例对象，当然，我认为这样做是不值得的。我们当前的实现适用于99%的情况。另外1%的情况是在 Mac 的 <code>NSCell</code> 上使用，而且你允许用户输入一个你试图解析的颜色的名字，这所需要做的要比简单的 子类化 NSFormatter 复杂很多。或许，你不应该允许你的用户通过文本输入颜色值。<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSColorPanel_Class/">NSColorPanel</a> 在这里是一个更好的解决方案。</p>

<h2>属性化字符串</h2>

<p>到目前为止，我们的格式器都按我们预期的工作。接下来让我们做一个完全没用的功能，只是示范一下我们可以这么做，你懂的。</p>

<p>格式器同时支持属性化字符串。要不要支持它取决于你特定的应用与其用户界面。因此，你最好把这个功能做成可配置。</p>

<p>以下代码就是将文本颜色设置为当前正在格式化的颜色：</p>

<p>```objc
- (NSAttributedString *)attributedStringForObjectValue:(id)value 
                                 withDefaultAttributes:(NSDictionary *)defaultAttributes;
{
    NSString *string = [self stringForObjectValue:value];</p>

<pre><code>if  (!string) {
    return nil;
}

NSMutableDictionary *attributes = [NSMutableDictionary dictionaryWithDictionary:defaultAttributes];
attributes[NSForegroundColorAttributeName] = value;
return [[NSAttributedString alloc] initWithString:string attributes:attributes]; } ```
</code></pre>

<p>首先，我们如之前一样处理字符串，然后检查格式化是否成功。然后我们把默认的属性值与前面设置的颜色属性结合后，最终返回属性化字符串。很容易，是吗？</p>

<h2>便捷</h2>

<p>因为初始化内建的格式器<a href="https://twitter.com/ID_AA_Carmack/status/28939697453">太慢了</a>，所以通常需要对外给你的格式器提供一个便利的类方法。这个格式器应该用默认值与当前的本地化环境。以下是格式器的实现：</p>

<pre><code>+ (NSString *)localizedStringFromColor:(UIColor *)color;
{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        KPAColorFormatterReusableInstance = [[KPAColorFormatter alloc] init];
    });

    return [KPAColorFormatterReusableInstance stringForObjectValue:color];
}
</code></pre>

<p>除非你的格式器像 <code>NSNumberFormatter</code> 与 <code>NSDateFormatter</code> 一样做一些疯狂的事情 ，你可能不需要因为性能问题这么做。但是这样做也可以让使用格式器简单许多。</p>

<h2>总结</h2>

<p>我们的颜色格式器现在可以把一个 <code>UIColor</code> 实例格式成一个可读的名字或是反过来也行。当然还有放多有关 <code>NSFormatter</code> 的事情没有涉及。特别是在 Mac 上，因为它跟 <code>NSCell</code> 相关，你可以用更多高级的特性。例如当用户在编辑的时，你可以对字符串做一些检测。</p>

<p>我们的格式器还可以做更多自定义的事情。例如，在没查找到一个你需要的颜色名字时，我们可以返回给你最相近的颜色名字。有时，你可能需要我们的格式器有一个 Boolean 属性来控制该功能。或许我们的属性化字符串的格式化不是你想要的，并且应该支持更多自定义操作。</p>

<p>就此，我们完成了一个非常可靠的格式器。所有的代码（伴有 OS X 示例）都放在了 <a href="https://github.com/klaaspieter/KPAColorFormatter">Github</a> 上， 并且你也可以在 <a href="http://cocoapods.org/">CocoaPods</a> 上看到。如果你应用需要此功能，可以将 "KPAColorFormatter" 放在你的 Podfile 中，开始使用它吧。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[消息传递机制]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/14/xiao-xi-chuan-di-ji-zhi/"/>
    <updated>2014-05-14T21:31:58+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/14/xiao-xi-chuan-di-ji-zhi</id>
    <content type="html"><![CDATA[<p>每个应用或多或少都由一些需要相互传递消息的对象结合起来以完成任务。在这篇文章里，我们将介绍所有可用的消息传递机制，并通过例子来介绍怎样在苹果的框架里使用。我们还会选择一些最佳范例来介绍什么时候该用什么机制。</p>

<p>虽然这一期的主题是关于 Foundation 框架的，但是我们会超出 Foundation 的消息传递机制 (KVO 和 通知) 来讲一讲 delegation，block 和 target-action 几种机制。</p>

<p>当然，有些情况下该使用什么机制没有唯一的答案，所以应该按照自己的喜好去试试。另外大多数情况下该使用什么机制应该是很清楚的。</p>

<p>本文中，我们会常常提及“接收者”和“发送者”。它们在消息传递中的意思可以通过以下的例子解释：一个 table view 是发送者，它的 delegate 就是接收者。Core Data managed object context 是它所发出的 notification 的发送者，获取 notification 的就是接收者。一个滑块 (slider) 是 action 消息的发送者，而实现这个 action （方法）的是它的接收者。任何修改一个支持 KVO 的对象的对象是发送者，这个 KVO 对象的观察者就是接收者。明白精髓了吗？</p>

<h2>几种消息传递机制</h2>

<p>首先我们来看看每种机制的具体特点。在这个基础上，下一节我们会画一个流程图来帮我们在具体情况下正确选择应该使用的机制。最后，我们会介绍一些苹果框架里的例子并且解释为什么在那些用例中会选择这样的机制。</p>

<h3 id="kvo">KVO</h3>

<p>KVO 是提供对象属性被改变时的通知的机制。KVO 的实现在 Foundation 中，很多基于 Foundation 的框架都依赖它。想要了解更多有关 KVO 的最佳实践，请阅读本期 Daniel 写的 <a href="http://objccn.io/issue-7-3">KVO 和 KVC 文章</a>。</p>

<p>如果只对某个对象的值的改变感兴趣的话，就可以使用 KVO 消息传递。不过有一些前提：第一，接收者（接收对象改变的通知的对象）需要知道发送者 （值会改变的对象）；第二，接收者需要知道发送者的生命周期，因为它需要在发送者被销毁前注销观察者身份。如果这两个要去符合的话，这个消息传递机制可以一对多（多个观察者可以注册观察同一个对象的变化）</p>

<p>If you plan to use KVO on Core Data objects, you have to know that things work a bit differently here. This has to do with Core Data's faulting mechanism. Once a managed object turns into a fault, it will fire the observers on its properties although their values haven't changed.</p>

<p>如果要在 Core Data 上使用 KVO 的话，方法会有些许差别。这和 Core Data 的 faulting 机制有关。一旦一个 managed object 被 faulting 处理的话，即使它的属性没有被改变，它还是会触发相应的观察者。</p>

<blockquote>
  <span class="secondary radius label">编者注</span> 把属性值先取入缓存中，在对象需要的时候再进行一次访问，这在 Core Data 中是默认行为，这种技术称为 Faulting。这么做可以避免降低内存开销，但是如果你确定将访问结果对象的具体属性值时，可以禁用 Faults 以提高获取性能。关于这个技术更多的情况，请移步<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdFaultingUniquing.html">官方文档</a>
</blockquote>

<h3>通知</h3>

<p>要在代码中的两个不相关的模块中传递消息时，通知机制是非常好的工具。通知机制广播消息，当消息内容丰富而且无需指望接收者一定要关注的话这一招特别有用。</p>

<p>通知可以用来发送任意消息，甚至可以包含一个 <code>userInfo</code> 字典。你也可以继承 <code>NSNotification</code> 写一个自己的通知类来自定义行为。通知的独特之处在于，发送者和接收者不需要相互知道对方，所以通知可以被用来在不同的相隔很远的模块之间传递消息。这就意味着这种消息传递是单向的，我们不能回复一个通知。</p>

<h3 id="delegation">委托 (Delegation)</h3>

<p>Delegation 在苹果的框架中广泛存在。它让我们能自定义对象的行为，并收到一些触发的事件。要使用 delegation 模式的话，发送者需要知道接收者，但是反过来没有要求。因为发送者只需要知道接收者符合一定的协议，所以它们两者结合的很松。</p>

<p>因为 delegate 协议可以定义任何的方法，我们可以照着自己的需求来传递消息。可以用方法参数来传递消息内容，delegate 可以通过返回值的形式来给发送者作出回应。如果只要在相对接近的两个模块间传递消息，delgation 是很灵活很直接的消息传递机制。</p>

<p>过度使用 delegation 也会带来风险。如果两个对象结合得很紧密，任何其中一个对象都不能单独运转，那么就不需要用 delegate 协议了。这些情况下，对象已经知道各自的类型，可以直接交流。两个比较新的例子是 <code>UICollectionViewLayout</code> 和 <code>NSURLSessionConfiguration</code>。</p>

<p><a name="blocks"> </a>  </p>

<h3 id="block">Block</h3>

<p>Block 是最近才加入 Objective-C 的，首次出现在 OS X 10.6 和 iOS 4 平台上。Block 通常可以完全替代 delegation 消息传递机制的角色。不过这两种机制都有它们自己的独特需求和优势。</p>

<p>一个不使用 block 的理由通常是 block 会存在导致 retain 环 (<a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/memorymgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-1000810">retain cycles</a>) 的风险。如果发送者需要 retain block 但又不能确保引用在什么时候被赋值为 <code>nil</code>， 那么所有在 block 内对 <code>self</code> 的引用就会发生潜在的 retain 环。</p>

<p>假设我们要实现一个用 block 回调而不是 delegate 机制的 table view 里的选择方法，如下所示：</p>

<pre><code>self.myTableView.selectionHandler = ^void(NSIndexPath *selectedIndexPath) {
    // 处理选择
};
</code></pre>

<p>这儿的问题是，<code>self</code> 会 retain table view，table view 为了让 block 之后可以使用而又需要 retain 这个 block。然而 table view 不能把这个引用设为 nil，因为它不知道什么时候不需要这个 block 了。如果我们不能保证打破 retain 环并且我们需要 retain 发送者，那么 block 就不是一个的好选择。</p>

<p><code>NSOperation</code> 是使用 block 的一个好范例。因为它在一定的地方打破了 retain 环，解决了上述的问题。</p>

<p><code>objc
self.queue = [[NSOperationQueue alloc] init];
MyOperation *operation = [[MyOperation alloc] init];
operation.completionBlock = ^{
    [self finishedOperation];
};
[self.queue addOperation:operation];
</code></p>

<p>一眼看来好像上面的代码有一个 retain 环：<code>self</code> retain 了 queue，queue retain 了 operation， operation retain 了 completionBlock， 而 completionBlock retain 了 <code>self</code>。然而，把 operation 加入 queue 中会使 operation 在某个时间被执行，然后被从 queue 中移除。（如果没被执行，问题就大了。）一旦 queue 把 operation 移除，retain 环就被打破了。</p>

<p>另一个例子是：我们在写一个视频编码器的类，在类里面我们会调用一个 <code>encodeWithCompletionHandler:</code> 的方法。为了不出问题，我们需要保证编码器对象在某个时间点会释放对 block 的引用。其代码如下所示：</p>

<p>```objc
@interface Encoder ()
@property (nonatomic, copy) void (^completionHandler)();
@end</p>

<p>@implementation Encoder</p>

<ul>
  <li>(void)encodeWithCompletionHandler:(void (^)())handler
{
  self.completionHandler = handler;
  // 进行异步处理…
}</li>
</ul>

<p>// 这个方法会在完成后被调用一次
- (void)finishedEncoding
{
    self.completionHandler();
    self.completionHandler = nil; // &lt;- 不要忘了这个!
}</p>

<p>@end
```</p>

<p>一旦任务完成，completion block 调用过了以后，我们就应该把它设为 <code>nil</code>。</p>

<p>如果一个被调用的方法需要发送一个一次性的消息作为回复，那么使用 block 是很好的选择， 因为这样做我们可以打破潜在的 retain 环。另外，如果将处理的消息和对消息的调用放在一起可以增强可读性的话，我们也很难拒绝使用 block 来进行处理。在用例之中，使用 block 来做完成的回调，错误的回调，或者类似的事情，是很常见的情况。</p>

<h3 id="targetaction">Target-Action</h3>

<p>Target-Action 是回应 UI 事件时典型的消息传递方式。iOS 上的 <code>UIControl</code> 和 Mac 上的 <code>NSControl</code>/<code>NSCell</code> 都支持这个机制。Target-Action 在消息的发送者和接收者之间建立了一个松散的关系。消息的接收者不知道发送者，甚至消息的发送者也不知道消息的接收者会是什么。如果 target 是 <code>nil</code>，action 会在<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/Devpedia-CocoaApp/Responder.html">响应链 (responder chain)</a> 中被传递下去，直到找到一个响应它的对象。在 iOS 中，每个控件甚至可以和多个 target-action 关联。</p>

<p>基于 target-action 传递机制的一个局限是，发送的消息不能携带自定义的信息。在 Mac 平台上 action 方法的第一个参数永远接收者。iOS 中，可以选择性的把发送者和触发 action 的事件作为参数。除此之外就没有别的控制 action 消息内容的方法了。</p>

<h2>做出正确的选择</h2>

<p>基于上述对不同消息传递机制的特点，我们画了一个流程图来帮助我们在不同情境下做出不同的选择。一句忠告：流程图的建议不代表最终答案。有些时候别的选择依然能达到应有的效果。只不过大多数情况下这张图能引导你做出正确的决定。</p>

<p><img src="http://img.objccn.io/issue-7/communication-patterns-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="688" /></p>

<p>图中有些细节值得深究：</p>

<p>有个框中说到： <em>发送者支持 KVO</em>。这不仅仅是说发送者会在值改变的时候发送 KVO 通知，而且说明观察者需要知道发送者的生命周期。如果发送者被存在一个 weak 属性中，那么发送者有可能会自己变成 nil，那时观察者会导致内存泄露。</p>

<p>一个在最后一行的框里说，<em>消息直接响应方法调用</em>。也就是说方法调用的接收者需要给调用者一个消息作为方法调用的直接反馈。这也就是说处理消息的代码和调用方法的代码必须在同一个地方。</p>

<p>最后在右下角的地方，一个选择分支这样说：<em>发送者能确保释放对 block 的引用吗？</em>这涉及到了我们<a href="#block">之前</a>讨论 block 的 API 存在潜在的 retain 环的问题。如果发送者不能保证在某个时间点会释放对 block 的引用，那么你会惹上 retain 环的麻烦。</p>

<h2 id="framework">Framework 示例</h2>

<p>本节我们通过一些苹果框架里的例子来验证流程图的选择是否有道理，同时解释为什么苹果会选择用这些机制。</p>

<h3 id="kvo">KVO</h3>

<p><code>NSOperationQueue</code> 用了 KVO 观察队列中的 operation 状态属性的改变情况 (<code>isFinished</code>，<code>isExecuting</code>，<code>isCancelled</code>)。当状态改变的时候，队列会收到 KVO 通知。为什么 operation 队列要用 KVO 呢？</p>

<p>消息的接收者（operation 队列）知道消息的发送者（operation），并 retain 它并控制后者的生命周期。另外，在这种情况下只需要单向的消息传递机制。当然如果考虑到 oepration 队列只关心那些改变 operation 的值的改变情况的话，就还不足以说服大家使用 KVO 了。但我们可以这么理解：被传递的消息可以被当成值的改变来处理。因为 state 属性在 operation 队列以外也是有用的，所以这里适合用 KVO。</p>

<p><img src="http://img.objccn.io/issue-7/kvo-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="678" /></p>

<p>当然 KVO 不是唯一的选择。我们也可以将 operation 队列作为 operation 的 delegate 来使用，operation 会调用类似 <code>operationDidFinish:</code> 或者 <code>operationDidBeginExecuting:</code> 等方法把它的 state 传递给 queue。这样就不太方便了，因为 operation 要保存 state 属性，以便于调用这些 delegate 方法。另外，由于 queue 不能主动获取 state 信息，所以 queue 也必须保存所有 operation 的 state。</p>

<h3 id="notifications">Notifications</h3>

<p>Core Data 使用 notification 传递事件（例如一个 managed object context 中的改变————<code>NSManagedObjectContextObjectsDidChangeNotification</code>）</p>

<p>发生改变时触发的 notification 是由 managed object contexts 发出的，所以我们不能假定消息的接收者知道消息的发送者。因为消息的源头不是一个 UI 事件，很多接收者可能在关注着此消息，并且消息传递是单向的，所以 notification 是唯一可行的选择。</p>

<p><img src="http://img.objccn.io/issue-7/notification-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="687" /></p>

<h3 id="delegation">Delegation</h3>

<p>Table view 的 delegate 有多重功能，它可以从管理 accessory view，直到追踪在屏幕上显示的 cell。例如我们可以看看 <code>tableView:didSelectRowAtIndexPath:</code> 方法。为什么用 delegate 实现而不是 target-action 机制？</p>

<p>正如我们在上述流程图中看到的，用 target-action 时，不能传递自定义的数据。而选中 table view 的某个 cell 时，collection view 不仅需要告诉我们一个 cell 被选中了，也要通过 index path 告诉我们哪个 cell 被选中了。如果我们照着这个思路，流程图会引导我们使用 delegation 机制。</p>

<p><img src="http://img.objccn.io/issue-7/delegation-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="687" /></p>

<p>如果不在消息传递中包含选中 cell 的 index path，而是让选中项改变时我们像 table view 主动询问并获取选中 cell 的相关信息，会怎样呢？这会非常不方便，因为我们必须记住当前选中项的数据，这样才能在多选择中知道哪些 cell 是被新选中的。</p>

<p>同理，我们可以想象通过观察 table view 选中项的 index path 属性，当该值发生改变的时候，获得一个选中项改变的通知。不过我们会遇到上述相似问题：不做记录的话我们就不能分辨哪一个 cell 被选择或取消选择了。</p>

<h3 id="block">Block</h3>

<p>我们用 <code>-[NSURLSession dataTaskWithURL:completionHandler:]</code> 来作为一个 block API 的介绍。那么从 URL 加载部分返回给调用者是怎么传递消息的呢？首先，作为 API 的调用者，我们知道消息的发送者，但是我们并没有 retain 它。另外，这是个单向的消息传递————它直接调用 <code>dataTaskWithURL:</code> 的方法。如果我们对照流程图，会发现这属于 block 消息传递机制。</p>

<p><img src="http://img.objccn.io/issue-7/block-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="688" /></p>

<p>有其他的选项吗？当然，苹果自己的 <code>NSURLConnection</code> 就是最好的例子。<code>NSURLConnection</code>在 block 问世之前就存在了，所以它并没有用 block 来实现消息传递，而是使用 delegation 来完成。当 block 出现以后，苹果就在 OS X 10.7 和 iOS 5 平台上的 <code>NSURLConnection</code> 中加了 <code>sendAsynchronousRequest:queue:completionHandler:</code>，所以我们不再在简单的任务中使用 delegate 了。</p>

<p>因为 <code>NSURLSession</code> 是个最近在 OS X 10.9 和 iOS 7 才出现的 API，所以它们使用 block 来实现消息传递机制（<code>NSURLSession</code> 有一个 delegate，但是是用于其他目的）。</p>

<h3 id="targetaction">Target-Action</h3>

<p>一个明显的 target-action 用例是按钮。按钮在不被按下的时候不需要发送任何的信息。为了这个目的，target-action 是 UI 中消息传递的最佳选择。</p>

<p><img src="http://img.objccn.io/issue-7/target-action-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="678" /></p>

<p>如果 target 是明确指定的，那么 action 消息会发送给指定的对象。如果 target 是 <code>nil</code>， action 消息会一直在响应链中被传递下去，直到找到一个能处理它的对象。在这种情况下，我们有一个完全解耦的消息传递机制：发送者不需要知道接收者，反之亦然。</p>

<p>Target-action 机制非常适合响应 UI 的事件。没有其他的消息传递机制能够提供相同的功能。虽然 notification 在发送者和接收者的松散关系上最接近它，但是 target-action 可以用于响应链——只有一个对象获得 action 并响应，action 在响应链中传递，直到能遇到响应这个 action 的对象。</p>

<h2>总结</h2>

<p>一开始接触这么多的消息传递机制的时候，我们可能有些无所适从，觉得所有的机制都可以被选用。不过一旦我们仔细分析每个机制的时候，它们各自都有特殊的要求和能力。</p>

<p>文中的选择流程图是帮助你清楚认识这些机制的好的开始，当然它不是所有问题的答案。如果你觉得这和你自己选择机制的方式相似或是有任何缺漏，欢迎来信指正。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[语言标签]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/14/yu-yan-biao-qian/"/>
    <updated>2014-05-14T21:13:29+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/14/yu-yan-biao-qian</id>
    <content type="html"><![CDATA[<p>当我们处理自然语言（相对于程序语言而言）的时候会遇到一项挑战，即涵义模棱两可。程序语言是被设计成为有且只有一个可能解释的语言，而人类语言可能由于模糊性和不确定性衍生出很多问题。这是由于有时候你并不想确切地告诉别人你对某事物的想法。在社交场合这完全没有问题，但是当你试图使用计算机来处理人类语言的话，就会非常痛苦。</p>

<p>词法标识（token）就是一个简单的例子。程序语言的词法分析对于标识表示什么，它是什么类型（语句分隔符，标识符，保留关键字等等）是什么有着明确的规则。而自然语言则远不能如此清晰可辩。<em>can’t</em> 是一个还是两个标识？并且根据你做出的判断，<em>cannot</em> 或者 <em>can not</em> 这两个应该是相同意思的词又各是几个标识呢？很多复合词都可以写成一个词（比如：<em>bookshelf</em>），或者两个词（比如：<em>lawn mower</em>），甚至还可以用连字符来连接（比如：<em>life-cycle</em>）。有些字符 （比如说连字符或者右肩单撇号），可以有很多种解释，而如何选择正确字符往往取决于上下文语言环境（撇号在一个单词的最后是表示所有格符号还是后单引号？）</p>

<p>句子的情况同样不怎么好：如果简单认为句号是用来结束一个句子的话，在我们使用缩写或是序数的时候就悲剧了。虽然通常情况下，我们是可以解决这个问题的，但是对有些句子而言，除非将整个段落彻底分析，否则无法真正确定这些句子的意思。我们人类甚至也无法有意识地考虑这些问题。</p>

<p>不过我们希望能够处理人类语言，因为在跟软件交流的时候，使用人类语言对用户更加友好。我们更愿意直接告诉计算机要做什么，让计算机为我们分析报纸文章，并对我们感兴趣的新闻做个总结，而不是通过敲击键盘或者点击小小的按钮（或者在小小的虚拟键盘上打字）来让计算机为我们做这些事。其中有些还在我们的能力范围之外（至少在苹果为我们提供与 Siri 交互的  API 之前）。但是有些已经成为可能，那就是 <code>NSLinguisticTagger</code>。</p>

<p><code>NSLinguisticTagger</code> 是 Foundation 框架中命名极为不当的类之一，这是因为它远远不止是一个小小的词性 tagger，而是集词法分析，分词器，命名实体识别及词性标注为一体的类。换句话说，它几乎可以满足你处理某些计算机语言处理的全部要求。</p>

<p>为了展示 <code>NSLinguisticTagger</code> 类的用法，我们会开发一个灵活的工具用来搜索。我们有一个充满了文本（比如新闻，电邮，或者其他的任意文本）的集合，然后我们输入一个单词，这个单词将返回所有包含这个单词的句子。我们会忽略功能词（比如 <em>the</em>，<em>of</em> 或者 <em>and</em>），因为它们在这个语言环境中太过于常见，没有什么用处。我们目前要实现的是第一步：从一个单独文件中提取相关单词。由此可以迅速地扩展到提供完整功能。</p>

<p><a href="https://github.com/objcio/issue-7-linguistic-tagging">GitHub</a> 上有源代码和样本文本。这是《卫报》上一篇关于中英贸易的文章。当用软件分析这份文本时，你会发现，它并不是总是运行良好，不过，出现运行故障完全正常：人类语言和任何正式语言都不同，人类语言凌乱复杂，无法简单划归到整齐划一的规则系统。很多理论问题（哪怕就像词性一样基础的问题）在某种程度上是无法解决的，这是由于我们仍然对如何才能最好地描述语言还所知甚少。比如说，词的分类是以拉丁语为依据的，但这并不意味着就必定适合英语。它们充其量只是大概近似而已。不过从很多实际的目的来看，这样就已经足够了，不需要让人怎么担心了。</p>

<h2 id="tagschemes">标签体系 (Tag Schemes)</h2>

<p>注释和标记文本的核心方法就是标签体系的核心方法。以下是几个可用的标签体系：</p>

<ul>
<li><code>NSLinguisticTagSchemeTokenType</code></li>
<li><code>NSLinguisticTagSchemeLexicalClass</code></li>
<li><code>NSLinguisticTagSchemeNameType</code></li>
<li><code>NSLinguisticTagSchemeNameTypeOrLexicalClass</code></li>
<li><code>NSLinguisticTagSchemeLemma</code></li>
<li><code>NSLinguisticTagSchemeLanguage</code></li>
<li><code>NSLinguisticTagSchemeScript</code></li>
</ul>

<p><code>NSLinguisticTagger</code> 实例扫描文本中的所有条目，并调用一个包含被请求的标签体系值的 block。最基础的是 <code>NSLinguisticTagSchemeTokenType</code>：词，标点，空格，或是“其他”。我们可以使用这个来识别哪些是真正的词，那么我们在应用程序中就可以简单地忽略其他那些不是有效词的语素。<code>NSLinguisticTagSchemeLexicalClass</code> 和词性有关，是一组非常基础的标签（就严格意义上的语言分析而言，这组标签还远远不够精细），我们可以使用这组标签来分辨我们想要的实词（名词，动词，形容词，副词）和我们想忽略的虚词（连词，介词，冠词等等）。在 <code>NSLinguisticTagger</code> 类的<a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/NSLinguisticTagger_Class/Reference/Reference.html">文档</a>中写明了全套可能值。</p>

<p><code>NSLinguisticTagSchemeNameType</code> 是指命名实体识别：我们可以知道一个词是不是表示人物，地点或者组织。同样的，这相对于自然语言的处理而言是相当基本，但却非常有用的，比如说你想搜索一个特定的人物或者地点。还有一种潜在的应用是“给我一份文本中所提到的所有政治家的名录”，你可以浏览这份文本中的人名，然后查阅数据库（比如维基）来核对他们是否确实是政治家。这也可以跟 lexical 类相结合，因为这往往包含一个分类叫做“名字”。</p>

<p><code>NSLinguisticTagSchemeLemma</code> 是词汇的标准形式，或者说是其基本形式。对英语而言，这不是什么大问题，不过对于其它语言而言却重要得多。原型基本上就是你在词典中查的到的那个形式。比如说，<em>tables</em> 是一个复数名词，它的基本形式是单数的 <em>table</em>。同样的，动词 <em>running</em> 是由 <em>run</em> 变形而来的不定式。如果你想要以同样的方式处理各种词类的变形，使用原形就非常有用，事实上这也是我们要为我们的示例应用程序所做的 (因为这可以有助于保持索引不过于庞大)。</p>

<p><code>NSLinguisticTagSchemeLanguage</code> 和我们所使用的语言相关。如果你使用iOS（截至iOS7），目前只能处理英语。使用OS X（截至10.9 / Mavericks）你可以稍微多几种语言可以选择。<code>+[NSLinguisticTagger availableTagSchemesForLanguage:]</code> 方法为我们列举了对于给定语言的所有可用体系。对于在 iOS 中对应语言数量限制的原因很可能是资源文件要占用大量空间。在笔记本或者台式电脑上不是什么大问题，但是在手机或者平板上的话就不太妙了。</p>

<p><code>NSLinguisticTagSchemeScript</code> 是书写体系，比如拉丁字母 (Latin)，西里尔字母 (Cyrillic) 等等。对于英语，我们将使用拉丁字母。如果你知道你将处理哪种语言，使用 <code>setOrthography</code> 方法可以改善标签的结果，特别对相对较短的字符而言更是如此。</p>

<h2>标签选项</h2>

<p>目前我们已经知道 <code>NSLinguisticTagger</code> 可以为我们识别什么了，我们需要告诉它我们想要什么，以及我们想如何获得。这里有几个可以定义 tagger 行为的选项，它们都是 <code>NSUInteger</code> 类型的，并且可以使用位运算 OR 组合使用。</p>

<p>第一个选项是“省略单词”，除非你只想看标点或者其它非词类，否则这个选项毫无意义。比较有用的是下面的三个选项：“省略标点（omit punctuation）”，“省略空格（omit whitespace）”以及“省略其他（omit other）”。除非你想要对文本做全面语言分析，否则你基本上只会对单词感兴趣，而对其中的逗号句号则兴趣不大。有了这些选项，就可以轻轻松松让 tagger 对单词作出限制，再也不用挂虑在心。最后一个选项是“连接名字（join names）”，因为名字有时不仅仅是一个标识。这个选项会将它们结合在一起，作为一个独立的语言单位来处理。这个选项可能不会总是用得上，但是确实非常有用。举个例子，在样本文本中，字符串“Owen Patterson”被识别为一个名称，并且作为一个独立的语言单位被返回。</p>

<h2>处理架构</h2>

<p>程序会给一定数量的文本在独立文件中建立索引（我们假设是使用UTF-8编码）。我们将使用一个 <code>FileProcessor</code> 类来处理一个单独文件，将文件内容分为一个一个单词，再把这些单词传递给另一类来进行处理。后一个类将实现 <code>WordReceiver</code> 接口，其中包括一个方法：</p>

<pre><code>-(void)receiveWord:(NSDictionary*)word
</code></pre>

<p>我们不是使用 <code>NSString</code> 来表示单词，而是使用字典，这是因为一个单词会有很多属性，包括实际标识，词性或名称类型，原型，所在句子的数目，句子中的位置等。为了建立索引，我们还想储存文件名。调用 <code>FileProcessor</code> 的这个方法：</p>

<pre><code>- (BOOL)processFile:(NSString*)filename
</code></pre>

<p>将触发分析，如果一切进行顺利的话，返回 <code>YES</code>，在出现错误的时候返回 <code>NO</code>。它首先由文件创建一个 <code>NSString</code>，然后将其传递给一个 <code>NSLinguisticTagger</code> 实例来处理。</p>

<p><code>NSLinguisticTagger</code> 主要做的是的在一个 <code>NSString</code> 中进行扫描并对寻找到的每一个元素调用 block。为了稍作简化，我们首先将文本分解为一个个的句子，然后分别扫描每一个句子。这样比较容易追踪句子的 ID。至于标签，我们会处理大量的 <code>NSRange</code>，它们可以被用来界定源文件中文本的注解。我们从在第一个句子范围内创建一个搜索范围开始，并使用其在最大程度上获得初始语句的标签。</p>

<pre><code>NSRange currentSentence = [tagger sentenceRangeForRange:NSMakeRange(0, 1)];
</code></pre>

<p>一旦句子处理结束，就检查是否成功完成全部的文本，或者是否还有更多的句子等待处理：</p>

<pre><code>if (currentSentence.location + currentSentence.length == [fileContent length]) {
    currentSentence.location = NSNotFound;
} else {
    NSRange nextSentence = NSMakeRange(currentSentence.location + currentSentence.length + 1, 1);
    currentSentence = [tagger sentenceRangeForRange:nextSentence];
}
</code></pre>

<p>如果已经到了文本的末尾，我们将使用 <code>NSNotFound</code> 来对 <code>while</code> 循环发出终止信号。如果我们使用一个超出文本之外的范围，<code>NSLinguisticTagger</code> 将抛出一个异常并且直接崩溃。</p>

<p>句子处理循环中的主要方法调用如下：</p>

<p><code>objc
while (currentSentence.location != NSNotFound) {
    __block NSUInteger tokenPosition = 0;
    [tagger enumerateTagsInRange:currentSentence
                          scheme:NSLinguisticTagSchemeNameTypeOrLexicalClass
                         options:options
                      usingBlock:^(NSString *tag, NSRange tokenRange, NSRange sentenceRange, BOOL *stop) 
    {
        NSString *token = [fileContent substringWithRange:tokenRange];
        NSString *lemma = [tagger tagAtIndex:tokenRange.location 
                                      scheme:NSLinguisticTagSchemeLemma 
                                  tokenRange: NULL 
                               sentenceRange:NULL];
        if (lemma == nil) {
            lemma = token;
        }
        [self.delegate receiveWord:@{
            @"token": token, 
            @"postag": tag, 
            @"lemma": lemma, 
            @"position": @(tokenPosition), 
            @"sentence": @(sentenceCounter), 
            @"filename": filename
        }];
        tokenPosition++;
    }];
}
</code></p>

<p>我们让 tagger 处理 <code>NSLinguisticTagSchemeNameTypeOrLexicalClass</code>，指定一组选项（连接名字，省略标点和空格）。然后我们获取这个标签，以及搜索到的每一项条目的范围，并进一步检索信息。标识（token）是字符串一部分，仅仅由字符范围来描述。lemma 是基本形式，如果不可能用的这个值会是 <code>nil</code>，所以我们需要做检查，并使用标识字符串作为候补值。一旦收集到这个信息，我们就可以将其打包到一个字典中，然后发送给 delegate 进行处理。</p>

<p>在我们的示例应用中，我们仅仅输出了我们接收到的单词，但是我们在这里基本上可以做任何我们想做的一切。为了实现搜索，我们可以过滤掉除了名词，动词，形容词，副词和名字以外的所有词，并且在索引数据库中储存这些单词的位置。使用原形，而不使用标识值，可以使我们合并各种词的变形 (<em>pig</em> 和 <em>pigs</em>)，这可以保持索引不过于庞大，并且与仅只匹配实际标识词相比，也可以检索出更相关的词。请记住，你可能还要将所有查询按照原形变化进行归类，否则，搜索 <em>pigs</em> 的话将不会返回任何结果。</p>

<p>为了更加真实，我在样本文本头部信息中加进了一些基本 HTML 标签，比如确定标题，署名，日期。在通过 tagger 运行的时候出现一个问题，即 <code>NSLinguisticTagger</code> 是不知道关于 HTML 的东西的，并试图将这些 HTML 标记当做文本来处理。下面是最前面的三个检索词。</p>

<pre><code>{
    filename = "/Users/oliver/tmp/guardian-article.txt";
    lemma = "&lt;";
    position = 0;
    postag = Particle;
    sentence = 0;
    token = "&lt;";
}
{
    filename = "/Users/oliver/tmp/guardian-article.txt";
    lemma = h1;
    position = 1;
    postag = Verb;
    sentence = 0;
    token = h1;
}
{
    filename = "/Users/oliver/tmp/guardian-article.txt";
    lemma = "&gt;";
    position = 2;
    postag = Adjective;
    sentence = 0;
    token = "&gt;";
}
</code></pre>

<p>不仅仅是标签被分成了几个部分，被当做词来处理，而且还得到了奇怪和完全错误的标签。所以，如果你在处理包含标记的文件，最好先将其过滤出来。或许，你想要识别出标签，并返回覆盖标签区域的 <code>NSRange</code>，而不是像我们之前处理示例应用一样将整个文本分成一个个句子。或者说，如果存在内嵌标签（比如加粗，斜体，超链接），将标签全部剔除出来会更好些。</p>

<h2>结果</h2>

<p>就算是用 tagger 来处理通用语言，其表现也出人意料的优秀。如果你仅仅处理某一个领域（比如技术文本）的话，你可以做出一些在处理不受限制的文本时无法做到的假设。但是苹果的 tagger 必须在无法预知会遇到什么的情况下也能工作，鉴于如此，它偶尔也会出错，不过相对来说是非常少的。很显然，很多名称无法识别，比如说 <em>Chengdu</em> 这样的地名。但另一方面，文本中大多数人名的处理都是非常不错的。由于某些原因，日期（<em>Wednesday 4 December 2013 10.35 GMT</em>）被当做了人名来处理，可能是来源于鲁宾逊•克鲁索的命名习惯吧。环境大臣 <em>Owen Patterson</em> 可以被识别出来，但是，一般被认为更加重要的首相 <em>David Cameron</em> 却没有被识别出来，尽管 <em>David</em> 是个更为常见的名字。</p>

<p>这是概率 tagger 的问题：有时候很难理解为什么某些词以特定的方式被加上标签。也没有什么像钩子一样的东西可以挂靠 tagger，可以让你提供比如说已知的地点，人物或者组织的名称列表。你只能用默认设置进行处理。因此，最好使用大量数据来测试那些带有 tagger 的应用程序，通过观察结果，你可以大概知道哪些可以正常运行，哪些会遇到问题。</p>

<h2>概率</h2>

<p>有很多种方法来实现词性标签：两个主要的途径，一个是规则性的，一个是随机性。两种途径都有一套相当庞大的规则来告诉你，形容词的后面是名词，而不是冠词，或者有一个概率矩阵告诉你某一个特定的标签会出现在一个特定的语言环境中的可能性有多大。你也可以使用基于概率性的模型，同时添加一些规则来修正反复出现的典型错误，这就是所谓的混合 tagger。由于为不同语言开发规则集比自动学习随机语言模型的成本要高得多，所以我猜测 <code>NSLinguisticTagger</code> 应该是基于完全的随机模型。这个实现细节也可以从下面的方法中窥探一二：</p>

<p><code>objc
- (NSArray *)possibleTagsAtIndex:(NSUInteger)charIndex 
                          scheme:(NSString *)tagScheme 
                      tokenRange:(NSRangePointer)tokenRange 
                   sentenceRange:(NSRangePointer)sentenceRange 
                          scores:(NSArray **)scores
</code></p>

<p>这说明了一个事实，那就是有时候（其实是大多数时候）会出现多个可能的标签值，tagger 必须判断哪个可能是错误的。使用这个方法，你可以获得一份选项列表和概率得分。得分最高的词则被 tagger 选中，但是如果你想要创建一套基于规则的后处理来改善 tagger 工作，你依然可以访问得分第二的词或者其他候选项。</p>

<p>对于这个方法要提高警惕，其中有个 bug，实际上它并没有返回任何的分数。不过在 OS X 10.9 / Mavericks 中这个 bug 已被修复。所以，如果你需要支持 OS X 10.9 / Mavericks 之前的版本，会提示你无法使用这个方法。顺带一提，在 iOS 7 中这个方法可以良好运行。</p>

<p>下面是几个 <em>When is the next train…:</em> 的输出案例：</p>

<table><thead><tr><th style="text-align: left;padding-right:1em;">When</th><th style="text-align: left;padding-right:1em;">is</th><th style="text-align: left;padding-right:1em;">the</th><th style="text-align: left;padding-right:1em;">next</th><th style="text-align: left;padding-right:1em;">train</th></tr></thead><tbody><tr><td style="text-align: left;padding-right:1em;">Pronoun, 0.9995162</td><td style="text-align: left;padding-right:1em;">Verb, 1</td><td style="text-align: left;padding-right:1em;">Determiner, 0.9999986</td><td style="text-align: left;padding-right:1em;">Adjective, 0.9292629</td><td style="text-align: left;padding-right:1em;">Noun, 0.8741992</td>  
</tr><tr><td style="text-align: left;padding-right:1em;">Conjunction, 0.0004337671</td><td style="text-align: left;padding-right:1em;" /><td style="text-align: left;padding-right:1em;">Adverb, 1.344403e-06</td><td style="text-align: left;padding-right:1em;">Adverb, 0.0636334</td><td style="text-align: left;padding-right:1em;">Verb, 0.1258008</td>  
</tr><tr><td style="text-align: left;padding-right:1em;">Adverb, 4.170838e-05</td><td style="text-align: left;padding-right:1em;" /><td style="text-align: left;padding-right:1em;" /><td style="text-align: left;padding-right:1em;">Preposition, 0.007003677</td><td style="text-align: left;padding-right:1em;">  
</td></tr><tr><td style="text-align: left;padding-right:1em;">Noun, 8.341675e-06</td><td style="text-align: left;padding-right:1em;" /><td style="text-align: left;padding-right:1em;" /><td style="text-align: left;padding-right:1em;">Noun, 0.0001000525</td><td style="text-align: left;padding-right:1em;">  
</td></tr></tbody></table>

<p>正如你所见，在这个例子中到现在为止，正确的 tag 拥有最高的概率。对于大多数应用程序而言，你可以保持程序简单，并认可 tagger 所提供的标签，而不对概率进行深究。不过你得承认 tagger 偶然也是会出错的，而你也可以访问到这些识别结果，并做出相应处理。 当然，如果你不亲自检查的话，你就不会知道 tagger 什么时候会出错。然而，其中一个线索是概率差：如果概率非常接近（和上面的例子不同），说不定就表示可能出错了。</p>

<h2>结论</h2>

<p>处理自然语言是很困难的，苹果给我们提供了一个非常好的工具，这个工具可以简便地支持绝大多数使用情况。当然，它也不是完美无缺的，即使最先进的语言处理工具也不是完美无缺的。iOS 目前只支持英语，不过随着技术改善，以及如果有足够大的内存来储存（毫无疑问会很大的）语言模型的话，这将有所改变。在此之前，我们会受到一些限制。不过还是有很多方法可以给应用程序添加语言支持。在文本编辑器中突出动词，理解用户键入的内容，或者处理外部数据文件等工作还是很简单的，<code>NSLinguisticTagger</code> 可以帮助你做到这一点。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[View-Layer协作]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/14/view-layerxie-zuo/"/>
    <updated>2014-05-14T11:30:43+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/14/view-layerxie-zuo</id>
    <content type="html"><![CDATA[<p>在 iOS 中，所有的 view 都是由一个底层的 layer 来驱动的。view 和它的 layer 之间有着紧密的联系，view 其实直接从 layer 对象中获取了绝大多数它所需要的数据。在 iOS 中也有一些单独的 layer，比如 <code>AVCaptureVideoPreviewLayer</code> 和 <code>CAShapeLayer</code>，它们不需要附加到 view 上就可以在屏幕上显示内容。两种情况下其实都是 layer 在起决定作用。当然了，附加到 view 上的 layer 和单独的 layer 在行为上还是稍有不同的。</p>

<p>基本上你改变一个单独的 layer 的任何属性的时候，都会触发一个从旧的值过渡到新值的简单动画（这就是所谓的可动画 <code>animatable</code>）。然而，如果你改变的是 view 中 layer 的同一个属性，它只会从这一帧直接跳变到下一帧。尽管两种情况中都有 layer，但是当 layer 附加在 view 上时，它的默认的隐式动画的 layer 行为就不起作用了。</p>

<blockquote>
  <p>animatable；几乎所有的层的属性都是隐性可动画的。你可以在文档中看到它们的简介是以 'animatable' 结尾的。这不仅包括了比如位置，尺寸，颜色或者透明度这样的绝大多数的数值属性，甚至也囊括了像 isHidden 和 doubleSided 这样的布尔值。 像 paths 这样的属性也是 animatable 的，但是它不支持隐式动画。</p>
</blockquote>

<p>在 Core Animation 编程指南的 “How to Animate Layer-Backed Views” 中，对<em>为什么</em>会这样做出了一个解释：</p>

<blockquote>
  <p>UIView 默认情况下禁止了 layer 动画，但是在 animation block 中又重新启用了它们</p>
</blockquote>

<p>这正是我们所看到的行为；当一个属性在动画 block 之外被改变时，没有动画，但是当属性在动画 block 内被改变时，就带上了动画。对于这是<em>如何</em>发生的这一问题的答案十分简单和优雅，它优美地阐明和揭示了 view 和 layer 之间是如何协同工作和被精心设计的。</p>

<p>无论何时一个可动画的 layer 属性改变时，layer 都会寻找并运行合适的 'action' 来实行这个改变。在 Core Animation 的专业术语中就把这样的动画统称为动作 (action，或者 <code>CAAction</code>)。</p>

<blockquote>
  <p>CAAction：技术上来说，这是一个接口，并可以用来做各种事情。但是实际中，某种程度上你可以只把它理解为用来处理动画。</p>
</blockquote>

<p>layer 将像文档中所写的的那样去寻找动作，整个过程分为五个步骤。第一步中的在 view 和 layer 中交互的部分是最有意思的：</p>

<p>layer 通过向它的 delegate 发送 <code>actionForLayer:forKey:</code> 消息来询问提供一个对应属性变化的 action。delegate 可以通过返回以下三者之一来进行响应：</p>

<ol>
<li>它可以返回一个动作对象，这种情况下 layer 将使用这个动作。  </li>
<li>它可以返回一个 <code>nil</code>， 这样 layer 就会到其他地方继续寻找。  </li>
<li>它可以返回一个 <code>NSNull</code> 对象，告诉 layer 这里不需要执行一个动作，搜索也会就此停止。</li>
</ol>

<p>而让这一切变得有趣的是，当 layer 在背后支持一个 view 的时候，view 就是它的 delegate；</p>

<blockquote>
  <p>在 iOS 中，如果 layer 与一个 UIView 对象关联时，这个属性<code>必须</code>被设置为持有这个 layer 的那个 view。</p>
</blockquote>

<p>理解这些之后，前一分钟解释起来还复杂无比的现象瞬间就易如反掌了：属性改变时 layer 会向 view 请求一个动作，而一般情况下 view 将返回一个 <code>NSNull</code>，只有当属性改变发生在动画 block 中时，view 才会返回实际的动作。哈，但是请别轻信我的这些话，你可以非常容易地验证到底是不是这样。只要对一个一般来说可以动画的 layer 属性向 view 询问动作就可以了，比如对于 'position'：</p>

<p>```objc
NSLog(@”outside animation block: %@”,
      [myView actionForLayer:myView.layer forKey:@”position”]);</p>

<p>[UIView animateWithDuration:0.3 animations:^{
    NSLog(@”inside animation block: %@”,
          [myView actionForLayer:myView.layer forKey:@”position”]);
}];
```</p>

<p>运行上面的代码，可以看到在 block 外 view 返回的是 NSNull 对象，而在 block 中时返回的是一个 CABasicAnimation。很优雅，对吧？值得注意的是打印出的 NSNull 是带着一对尖括号的 ("<code>&lt;null&gt;</code>")，这和其他对象一样，而打印 nil 的时候我们得到的是普通括号(<code>(null)</code>)： </p>

<pre><code>outside animation block: &lt;null&gt;
inside animation block: &lt;CABasicAnimation: 0x8c2ff10&gt;
</code></pre>

<p>对于 view 中的 layer 来说，对动作的搜索只会到第一步为止（至少我没有见过 view 返回一个 <code>nil</code> 然后导致继续搜索动作的情况）。对于单独的 layer 来说，剩余的四个步骤可以在 <a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CALayer_class/Introduction/Introduction.html#//apple_ref/occ/instm/CALayer/actionForKey:">CALayer 的 <code>actionForKey:</code> 文档</a>中找到。</p>

<h1 id="uikit">从 UIKit 中学习</h1>

<p>我很确定我们都会同意 UIView 动画是一组非常优秀的 API，它简洁明确。实际上，它使用了 Core Animation 来执行动画，这给了我们一个绝佳的机会来深入研究 UIKit 是如何使用 Core Animation 的。在这里甚至还有很多非常棒的实践和技巧可以让我们借鉴。:)</p>

<p>当属性在动画 block 中改变时，view 将向 layer 返回一个基本的动画，然后动画通过通常的 <code>addAnimation:forKey:</code> 方法被添加到 layer 中，就像显式地添加动画那样。再一次，别直接信我，让我们实践检验一下。</p>

<p>归功于 UIView 的 <code>+layerClass</code> 类方法，view 和 layer 之间的交互很容易被观测到。通过这个方法我们可以在为 view 创建 layer 时为其指定要使用的类。通过子类一个 UIView，以及用这个方法返回一个自定义的 layer 类，我们就可以重写 layer 子类中的 <code>addAnimation:forKey:</code> 并输出一些东西来验证它是否确实被调用。唯一要记住的是我们需要调用 super 方法，不然的话我们就把要观测的行为完全改变了：</p>

<p>```objc
@interface DRInspectionLayer : CALayer
@end</p>

<p>@implementation DRInspectionLayer
- (void)addAnimation:(CAAnimation *)anim forKey:(NSString *)key
{
    NSLog(@”adding animation: %@”, [anim debugDescription]);
    [super addAnimation:anim forKey:key];
}
@end</p>

<p>@interface DRInspectionView : UIView
@end</p>

<p>@implementation DRInspectionView
+ (Class)layerClass
{
    return [DRInspectionLayer class];
}
@end
```</p>

<p>通过输出动画的 debug 信息，我们不仅可以验证它确实如预期一样被调用了，还可以看到动画是如何组织构建的：</p>

<pre><code>&lt;CABasicAnimation:0x8c73680; 
    delegate = &lt;UIViewAnimationState: 0x8e91fa0&gt;;
    fillMode = both; 
    timingFunction = easeInEaseOut; 
    duration = 0.3; 
    fromValue = NSPoint: {5, 5}; 
    keyPath = position
&gt;
</code></pre>

<p>当动画刚被添加到 layer 时，属性的新值还没有被改变。在构建动画时，只有 <code>fromValue</code> (也就是当前值) 被显式地指定了。<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html">CABasicAnimation 的文档</a>向我们简单介绍了这么做对于动画的插值来说的的行为应该是：</p>

<blockquote>
  <p>只有 <code>fromValue</code> 不是 <code>nil</code> 时，在 <code>fromValue</code> 和属性当前显示层的值之间进行插值。</p>
</blockquote>

<p>这也是我在处理显式动画时选择的做法，将一个属性改变为新的值，然后将动画对象添加到 layer 上：</p>

<p>```objc
CABasicAnimation *fadeIn = [CABasicAnimation animationWithKeyPath:@”opacity”];
fadeIn.duration  = 0.75;
fadeIn.fromValue = @0;</p>

<p>myLayer.opacity = 1.0; // 更改 model 的值 …
// … 然后添加动画对象
[myLayer addAnimation:fadeIn forKey:@”fade in slowly”];
```</p>

<p>这很简洁，你也不需要在动画被移除的时候做什么额外操作。如果动画是在一段延迟后才开始的话，你可以使用 backward 填充模式 (或者 'both' 填充模式)，就像 UIKit 所创建的动画那样。</p>

<p>可能你看见上面输出中的动画的 delegate 了，想知道这个类是用来做什么的吗？我们可以来看看 <a href="https://github.com/rpetrich/iphoneheaders/blob/master/UIKit/UIViewAnimationState.h">dump 出来的头文件</a>，它主要用来维护动画的一些状态 (持续时间，延时，重复次数等等)。它还负责对一个栈做 push 和 pop，这是为了在多个动画 block 嵌套时能够获取正确的动画状态。这些都是些实现细节，除非你想要写一套自己的基于 block 的动画 API，否则可能你不会用到它们 (实际上这是一个很有趣的点子)。</p>

<p>然后真正<em>有意思</em>的是这个 delegate 实现了 <code>animationDidStart:</code> 和 <code>animationDidStop:finished:</code>，并将信息传给了它自己的 delegate。</p>

<blockquote>
  <p><span class="secondary radius label">编者注</span> 这里不太容易理解，加以说明：从上面的头文件中可以看出，作为 CAAnimation 的 delegate 的私有类 <code>UIViewAnimationState</code> 中还有一个 <code>_delegate</code> 成员，并且 <code>animationDidStart:</code> 和 <code>animationDidStop:finished:</code> 也是典型的 delegate 的实现方法。</p>
</blockquote>

<p>通过打印这个 delegate 的 delegate，我们可以发现它也是一个私有类：UIViewAnimationBlockDelegate。同样进行 <a href="https://github.com/EthanArbuckle/IOS-7-Headers/blob/master/Frameworks/UIKit.framework/UIViewAnimationBlockDelegate.h">class dump 得到它的头文件</a>，这是一个很小的类，只负责一件事情：响应动画的 delegate 回调并且执行相应的 block。如果我们使用自己的 Core Animation 代码，并且选择 block 而不是 delegate 做回调的话，添加这个是很容易的：</p>

<p>```
@interface DRAnimationBlockDelegate : NSObject</p>

<p>@property (copy) void(^start)(void);
@property (copy) void(^stop)(BOOL);</p>

<p>+(instancetype)animationDelegateWithBeginning:(void(^)(void))beginning
                                   completion:(void(^)(BOOL finished))completion;</p>

<p>@end</p>

<p>@implementation DRAnimationBlockDelegate</p>

<ul>
  <li>
    <p>(instancetype)animationDelegateWithBeginning:(void (^)(void))beginning
                                  completion:(void (^)(BOOL))completion
{
  DRAnimationBlockDelegate *result = [DRAnimationBlockDelegate new];
  result.start = beginning;
  result.stop  = completion;
  return result;
}</p>
  </li>
  <li>
    <p>(void)animationDidStart:(CAAnimation *)anim
{
  if (self.start) {
      self.start();
  }
  self.start = nil;
}</p>
  </li>
  <li>
    <p>(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
{
  if (self.stop) {
      self.stop(flag);
  }
  self.stop = nil;
}</p>
  </li>
</ul>

<p>@end
```</p>

<p>虽然是我个人的喜好，但是我觉得像这样的基于 block 的回调风格可能会比实现一个 delegate 回调更适合你的代码：</p>

<p><code>objc
fadeIn.delegate = [DRAnimationBlockDelegate animationDelegateWithBeginning:^{
    NSLog(@"beginning to fade in");
} completion:^(BOOL finished) {
    NSLog(@"did fade %@", finished ? @"to the end" : @"but was cancelled");
}];
</code></p>

<h1 id="blockapis">自定义基于 block 的动画 APIs</h1>

<p>一旦你知道了 <code>actionForKey:</code> 的机理之后，UIView 就远没有它一开始看起来那么神秘了。实际上我们完全可以按照我们的需求量身定制地写出一套自己的基于 block 的动画 APIs。我所设计的动画将通过在 block 中用一个很激进的时间曲线来做动画，以吸引用户对该 view 的注意，之后做一个缓慢的动画回到原始状态。你可以把它看作一种类似 pop (请不要和 Facebook 最新的 Pop 框架弄混了)的行为。与一般使用 <code>UIViewAnimationOptionAutoreverse</code> 的动画 block 不同，因为动画设计和概念上的需要，我自己实现了将 model 值改变回原始值的过程。自定义的动画 API 的使用方法就像这样：</p>

<pre><code>[UIView DR_popAnimationWithDuration:0.7
                             animations:^{
                                 myView.transform = CGAffineTransformMakeRotation(M_PI_2);
                                }];
</code></pre>

<p>当我们完成后，效果是这个样子的 (对四个不同的 view 为位置，尺寸，颜色和旋转进行动画)：</p>

<p><img alt="The custom block animation API, used to animate the position, size, color, and rotation of four different views" src="http://img.objccn.io/issue-12/2014-05-01-view-layer-synergy-custom-block-animations.gif" width="238" /></p>

<p>要开始实现它，我们首先要做的是当一个 layer 属性变化时获取 delegate 的回调。因为我们无法事先预测 layer 要改变什么，所以我选择在一个 UIView 的 category 中 swizzle <code>actionForLayer:forKey:</code> 方法：</p>

<p>```objc
@implementation UIView (DR_CustomBlockAnimations)</p>

<ul>
  <li>
    <p>(void)load
{      <br />
  SEL originalSelector = @selector(actionForLayer:forKey:);
  SEL extendedSelector = @selector(DR_actionForLayer:forKey:);</p>

    <p>Method originalMethod = class_getInstanceMethod(self, originalSelector);
  Method extendedMethod = class_getInstanceMethod(self, extendedSelector);</p>

    <p>NSAssert(originalMethod, @”original method should exist”);
  NSAssert(extendedMethod, @”exchanged method should exist”);</p>

    <p>if(class_addMethod(self, originalSelector, method_getImplementation(extendedMethod), method_getTypeEncoding(extendedMethod))) {
      class_replaceMethod(self, extendedSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
  } else {
      method_exchangeImplementations(originalMethod, extendedMethod);
  }
}
```</p>
  </li>
</ul>

<p>为了保证我们不破坏其他依赖于 <code>actionForLayer:forKey:</code> 回调的代码，我们使用一个静态变量来判断现在是不是处于我们自己定义的上下文中。对于这个例子来说一个简单的 <code>BOOL</code> 其实就够了，但是如果我们之后要写更多内容的话，上下文的话就要灵活得多了：</p>

<pre><code>static void *DR_currentAnimationContext = NULL;
static void *DR_popAnimationContext     = &amp;DR_popAnimationContext;

- (id&lt;CAAction&gt;)DR_actionForLayer:(CALayer *)layer forKey:(NSString *)event
{
    if (DR_currentAnimationContext == DR_popAnimationContext) {
        // 这里写我们自定义的代码...
    }

    // 调用原始方法
    return [self DR_actionForLayer:layer forKey:event]; // 没错，你没看错。因为它们已经被交换了
}
</code></pre>

<p>在我们的实现中，我们要确保在执行动画 block 之前设置动画的上下文，并且在执行后恢复上下文：</p>

<p><code>objc
 + (void)DR_popAnimationWithDuration:(NSTimeInterval)duration
                          animations:(void (^)(void))animations
 {
     DR_currentAnimationContext = DR_popAnimationContext;
     // 执行动画 (它将触发交换后的 delegate 方法)
     animations();
     /* 一会儿再添加 */
     DR_currentAnimationContext = NULL;
 }
</code></p>

<p>如果我们想要做的不过是添加一个从旧的值向新的值过度的动画的话，我们可以直接在 delegate 的回调中来做。然而因为我们想要更精确地控制动画，我们需要用一个帧动画来实现。帧动画需要所有的值都是已知的，而对我们的情况来说，新的值还没有被设定，因此我们也就无从知晓。</p>

<p>有意思的是，iOS 添加的一个基于 block 的动画 API 也遇到了同样的问题。使用和上面一样的观察手段，我们就能知道它是如何绕开这个麻烦的。对于每个关键帧，在属性变化时，view 返回 <code>nil</code>，但是却存储下需要的状态。这样就能在所有关键帧 block 执行后创建一个 <code>CAKeyframeAnimationz</code> 对象。</p>

<p>受到这种方法的启发，我们可以创建一个小的类来存储我们创建动画时所需要的信息：什么 layer 被更改了，什么 key path 的值被改变了，以及原来的值是什么：</p>

<p>```objc
 @interface DRSavedPopAnimationState : NSObject</p>

<p>@property (strong) CALayer  *layer;
 @property (copy)   NSString *keyPath;
 @property (strong) id        oldValue;</p>

<ul>
  <li>(instancetype)savedStateWithLayer:(CALayer *)layer
                          keyPath:(NSString *)keyPath;</li>
</ul>

<p>@end</p>

<p>@implementation DRSavedPopAnimationState</p>

<ul>
  <li>(instancetype)savedStateWithLayer:(CALayer *)layer
                          keyPath:(NSString *)keyPath
 {
  DRSavedPopAnimationState *savedState = [DRSavedPopAnimationState new];
  savedState.layer    = layer;
  savedState.keyPath  = keyPath;
  savedState.oldValue = [layer valueForKeyPath:keyPath];
  return savedState;
 }</li>
</ul>

<p>@end
```</p>

<p>接下来，在我们的交换后的 delegate 回调中，我们简单地将被变更的属性的状态存入一个静态可变数组中：</p>

<pre><code> if (DR_currentAnimationContext == DR_popAnimationContext) {
       [[UIView DR_savedPopAnimationStates] addObject:[DRSavedPopAnimationState savedStateWithLayer:layer
                                                                                 keyPath:event]];

       // 没有隐式的动画 (稍后添加)
       return (id&lt;CAAction&gt;)[NSNull null];
   }
</code></pre>

<p>在动画 block 执行完毕后，所有的属性都被变更了，它们的状态也被保存了。现在，创建关键帧动画：</p>

<p>```objc
 + (void)DR_popAnimationWithDuration:(NSTimeInterval)duration
                          animations:(void (^)(void))animations
 {
     DR_currentAnimationContext = DR_popAnimationContext;</p>

<pre><code> // 执行动画 (它将触发交换后的 delegate 方法)
 animations();

 [[self DR_savedPopAnimationStates] enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
     DRSavedPopAnimationState *savedState   = (DRSavedPopAnimationState *)obj;
     CALayer *layer    = savedState.layer;
     NSString *keyPath = savedState.keyPath;
     id oldValue       = savedState.oldValue;
     id newValue       = [layer valueForKeyPath:keyPath];

     CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:keyPath];

     CGFloat easing = 0.2;
     CAMediaTimingFunction *easeIn  = [CAMediaTimingFunction functionWithControlPoints:1.0 :0.0 :(1.0-easing) :1.0];
     CAMediaTimingFunction *easeOut = [CAMediaTimingFunction functionWithControlPoints:easing :0.0 :0.0 :1.0];

     anim.duration = duration;
     anim.keyTimes = @[@0, @(0.35), @1];
     anim.values = @[oldValue, newValue, oldValue];
     anim.timingFunctions = @[easeIn, easeOut];

     // 不带动画地返回原来的值
     [CATransaction begin];
     [CATransaction setDisableActions:YES];
     [layer setValue:oldValue forKeyPath:keyPath];
     [CATransaction commit];

     // 添加 "pop" 动画
     [layer addAnimation:anim forKey:keyPath];

 }];

 // 扫除工作 (移除所有存储的状态)
 [[self DR_savedPopAnimationStates] removeAllObjects];

 DR_currentAnimationContext = nil;  } ```
</code></pre>

<p>注意老的 model 值被射到了 layer 上，所以在当动画结束和移除后，model 的值和 presentation 的值是相符合的。</p>

<p>创建像这样的你自己的 API 不会对没种情况都很适合，但是如果你需要在你的应用中的很多地方都做同样的动画的话，这可以帮助你写出整洁的代码，并减少重复。就算你之后从来不会使用这种方法，实际做一遍也能帮助你搞懂 UIView block 动画的 APIs，特别是你已经在 Core Animation 的舒适区的时候，这非常有助于你的提高。</p>

<h1>其他的动画灵感</h1>

<p>UIImageView 动画是一个完全不同的更高层次的动画 API 的实现方式，我会把它留给你来探索。表面上，它只不过是重新组装了一个传统的动画 API。你所要做的事情就是指定一个图片数组和一段时间，然后告诉 image view 开始动画。在抽象背后，其实是一个添加在 image view 的 layer 上的 contents 属性的离散的关键帧动画：</p>

<pre><code>&lt;CAKeyframeAnimation:0x8e5b020; 
    removedOnCompletion = 0; 
    delegate = &lt;_UIImageViewExtendedStorage: 0x8e49230&gt;; 
    duration = 2.5; 
    repeatCount = 2.14748e+09; 
    calculationMode = discrete; 
    values = (
        "&lt;CGImage 0x8d6ce80&gt;",
        "&lt;CGImage 0x8d6d2d0&gt;",
        "&lt;CGImage 0x8d5cd30&gt;"
    ); 
    keyPath = contents
&gt;
</code></pre>

<p>动画 APIs 可以以很多不同形式出现，而对于你自己写的动画 API 来说，也是这样的。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CollectionView布局动画]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/13/collectionviewbu-ju-dong-hua/"/>
    <updated>2014-05-13T16:33:11+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/13/collectionviewbu-ju-dong-hua</id>
    <content type="html"><![CDATA[<p><code>UICollectionView</code> 和相关类的设置非常灵活和强大。但是灵活性一旦增强，某种程度上也增加了其复杂性： <code>UICollectionView</code> 比老式的 <code>UITableView</code> 更有深度，适用性也更强。</p>

<p>Collection View 深入太多了，事实上，<a href="http://oleb.net">Ole Begeman</a> 和 <a href="https://twitter.com/ashfurrow">Ash Furrow</a> 之前曾在 objc.io 上发表过 <a href="http://objccn.io/issue-3-3/">自定义 Collection View 布局</a> 和 <a href="http://objccn.io/issue-5-2/">UICollectionView + UIKit 力学</a>，但是我依然有一些他们没有提及的内容可以写。在这篇文章中，我假设你已经非常熟悉 <code>UICollectionView</code> 的基本布局，并且至少阅读了苹果精彩的<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012334">编程指南</a>以及 Ole 之前的<a href="http://objccn.io/issue-3-3/">文章</a>。</p>

<p>本文的第一部分将集中讨论并举例说明如何用不同的类和方法来共同帮助实现一些常见的 <code>UICollectionView</code> 动画。在第二部分，我们将看一下带有 collection views 的 view controller 转场动画以及在 <code>useLayoutToLayoutNavigationTransitions</code> 可用时使用其进行转场，如果不可用时，我们会实现一个自定义转场动画。</p>

<p>你可以在 GitHub 中找到本文提到的两个示例工程:</p>

<ul>
<li><a href="https://github.com/objcio/issue-12-CollectionViewAnimations">布局动画</a></li>
<li><a href="https://github.com/objcio/issue-12-CustomCollectionViewTransition">自定义 collection view 转场动画</a></li>
</ul>

<h2 id="collectionview">Collection View 布局动画</h2>

<p>标准 <code>UICollectionViewFlowLayout</code> 除了动画是非常容易自定义的，苹果选择了一种安全的途径去实现一个简单的淡入淡出动画作为所有布局的默认动画。如果你想实现自定义动画，最好的办法是子类化 <code>UICollectionViewFlowLayout</code> 并且在适当的地方实现你的动画。让我们通过一些例子来了解 <code>UICollectionViewFlowLayout</code> 子类中的一些方法如何协助完成自定义动画。</p>

<h3>插入删除元素</h3>

<p>一般来说，我们对布局属性从初始状态到结束状态进行线性插值来计算 collection view 的动画参数。然而，新插入或者删除的元素并没有最初或最终状态来进行插值。要计算这样的 cells 的动画，collection view 将通过  <code>initialLayoutAttributesForAppearingItemAtIndexPath:</code> 以及 <code>finalLayoutAttributesForAppearingItemAtIndexPath:</code> 方法来询问其布局对象，以获取最初的和最后的属性。苹果默认的实现中，对于特定的某个 indexPath，返回的是它的通常的位置，但 <code>alpha</code> 值为 0.0，这就产生了一个淡入或淡出动画。如果你想要更漂亮的效果，比如你的新的 cells 从屏幕底部发射并且旋转飞到对应位置，你可以如下实现这样的布局子类：</p>

<p>```objc
- (UICollectionViewLayoutAttributes*)initialLayoutAttributesForAppearingItemAtIndexPath:(NSIndexPath *)itemIndexPath
{
    UICollectionViewLayoutAttributes *attr = [self layoutAttributesForItemAtIndexPath:itemIndexPath];</p>

<pre><code>attr.transform = CGAffineTransformRotate(CGAffineTransformMakeScale(0.2, 0.2), M_PI);
attr.center = CGPointMake(CGRectGetMidX(self.collectionView.bounds), CGRectGetMaxY(self.collectionView.bounds));

return attr; } ```
</code></pre>

<p>结果如下：</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-collectionview-animations-1-insertion.gif" alt="Insertion and Deletion" /></p>

<p>对应的 <code>finalLayoutAttributesForAppearingItemAtIndexPath:</code> 方法中，除了设定了不同的 transform 以外，其他都很相似。</p>

<h3>响应设备旋转</h3>

<p>设备方向变化通常会导致 collection view 的 bounds 变化。如果通过 <code>shouldInvalidateLayoutForBoundsChange:</code> 判定为布局需要被无效化并重新计算的时候，布局对象会被询问以提供新的布局。<code>UICollectionViewFlowLayout</code> 的默认实现正确地处理了这个情况，但是如果你子类化 <code>UICollectionViewLayout</code> 的话，你需要在边界变化时返回 <code>YES</code>：</p>

<p><code>objc
- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds
{
    CGRect oldBounds = self.collectionView.bounds;
    if (!CGSizeEqualToSize(oldBounds.size, newBounds.size)) {
        return YES;
    }
    return NO;
}
</code></p>

<p>在 bounds 变化的动画中，collection view 表现得像当前显示的元素被移除然后又在新的 bounds 中被被重新插入，这会对每个 IndexPath 产生一系列的 <code>finalLayoutAttributesForAppearingItemAtIndexPath:</code> 和 <code>initialLayoutAttributesForAppearingItemAtIndexPath:</code> 的调用。</p>

<p>如果你在插入和删除的时候加入了非常炫的动画，现在你应该看看为何苹果明智的使用简单的淡入淡出动画作为默认效果：</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-collectionview-animations-2-wrong-rotation.gif" alt="设备旋转的错误反应" /></p>

<p>啊哦...</p>

<p>为了防止这种不想要的动画，初始化位置 -&gt; 删除动画 -&gt; 插入动画 -&gt; 最终位置的顺序必须完全匹配 collection view 的每一项，以便最终呈现出一个平滑动画。换句话说，<code>finalLayoutAttributesForAppearingItemAtIndexPath:</code> 以及 <code>initialLayoutAttributesForAppearingItemAtIndexPath:</code> 应该针对元素到底是真的在显示或者消失，还是 collection view 正在经历的边界改变动画的不同情况，做出不同反应，并返回不同的布局属性。</p>

<p>幸运的是，collection view 会告知布局对象哪一种动画将被执行。它分别通过调用 <code>prepareForAnimatedBoundsChange:</code> 和 <code>prepareForCollectionViewUpdates:</code> 来对应 bounds 变化以及元素更新。出于本实例的说明目的，我们可以使用 <code>prepareForCollectionViewUpdates:</code> 来跟踪更新对象：</p>

<p><code>objc
- (void)prepareForCollectionViewUpdates:(NSArray *)updateItems
{
    [super prepareForCollectionViewUpdates:updateItems];
    NSMutableArray *indexPaths = [NSMutableArray array];
    for (UICollectionViewUpdateItem *updateItem in updateItems) {
        switch (updateItem.updateAction) {
            case UICollectionUpdateActionInsert:
                [indexPaths addObject:updateItem.indexPathAfterUpdate];
                break;
            case UICollectionUpdateActionDelete:
                [indexPaths addObject:updateItem.indexPathBeforeUpdate];
                break;
            case UICollectionUpdateActionMove:
                [indexPaths addObject:updateItem.indexPathBeforeUpdate];
                [indexPaths addObject:updateItem.indexPathAfterUpdate];
                break;
            default:
                NSLog(@"unhandled case: %@", updateItem);
                break;
        }
    }  
    self.indexPathsToAnimate = indexPaths;
}
</code></p>

<p>以及修改我们元素的插入动画，让元素只在其正在被插入 collection view 时进行发射：</p>

<p>```objc
- (UICollectionViewLayoutAttributes*)initialLayoutAttributesForAppearingItemAtIndexPath:(NSIndexPath *)itemIndexPath
{
    UICollectionViewLayoutAttributes *attr = [self layoutAttributesForItemAtIndexPath:itemIndexPath];</p>

<pre><code>if ([_indexPathsToAnimate containsObject:itemIndexPath]) {
    attr.transform = CGAffineTransformRotate(CGAffineTransformMakeScale(0.2, 0.2), M_PI);
    attr.center = CGPointMake(CGRectGetMidX(self.collectionView.bounds), CGRectGetMaxY(self.collectionView.bounds));
    [_indexPathsToAnimate removeObject:itemIndexPath];
}

return attr; } ```
</code></pre>

<p>如果这个元素没有正在被插入，那么将通过 <code>layoutAttributesForItemAtIndexPath</code> 来返回一个普通的属性，以此取消特殊的外观动画。结合 <code>finalLayoutAttributesForAppearingItemAtIndexPath:</code> 中相应的逻辑，最终将会使元素能够在 bounds 变化时，从初始位置到最终位置以很流畅的动画形式实现，从而建立一个简单但很酷的动画效果：</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-collectionview-animations-3-correct-rotation.gif" alt="Wrong reaction to device rotation" /></p>

<h3>交互式布局动画</h3>

<p>Collection views 让用户通过手势实现与布局交互这件事变得很容易。如苹果<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/IncorporatingGestureSupport/IncorporatingGestureSupport.html#//apple_ref/doc/uid/TP40012334-CH4-SW1">建议</a>的那样，为 collection view 布局添加交互的途径一般会遵循以下步骤：</p>

<ol>
<li>创建手势识别  </li>
<li>将手势识别添加给 collection view  </li>
<li>通过手势来驱动布局动画</li>
</ol>

<p>让我们来看看我们如何可以建立一些用户可缩放捏合的元素，以及一旦用户释放他们的捏合手势元素返回到原始大小。</p>

<p>我们的处理方式可能会是这样：</p>

<p>```objc
- (void)handlePinch:(UIPinchGestureRecognizer *)sender {
    if ([sender numberOfTouches] != 2)
        return;</p>

<pre><code>if (sender.state == UIGestureRecognizerStateBegan ||
    sender.state == UIGestureRecognizerStateChanged) {
    // 获取捏合的点
    CGPoint p1 = [sender locationOfTouch:0 inView:[self collectionView]];
    CGPoint p2 = [sender locationOfTouch:1 inView:[self collectionView]];

    // 计算扩展距离
    CGFloat xd = p1.x - p2.x;
    CGFloat yd = p1.y - p2.y;
    CGFloat distance = sqrt(xd*xd + yd*yd);

    // 更新自定义布局参数以及无效化
    FJAnimatedFlowLayout* layout = (FJAnimatedFlowLayout*)[[self collectionView] collectionViewLayout];

    NSIndexPath *pinchedItem = [self.collectionView indexPathForItemAtPoint:CGPointMake(0.5*(p1.x+p2.x), 0.5*(p1.y+p2.y))];
    [layout resizeItemAtIndexPath:pinchedItem withPinchDistance:distance];
    [layout invalidateLayout];

}
else if (sender.state == UIGestureRecognizerStateCancelled ||
         sender.state == UIGestureRecognizerStateEnded){
    FJAnimatedFlowLayout* layout = (FJAnimatedFlowLayout*)[[self collectionView] collectionViewLayout];
    [self.collectionView
     performBatchUpdates:^{
        [layout resetPinchedItem];
     }
     completion:nil];
} } ```
</code></pre>

<p>这个捏合操作需要计算捏合距离并找出被捏合的元素，并且在用户捏合的时候通知布局以实现自身更新。当捏合手势结束的时候，布局会做一个批量更新动画返回原始尺寸。</p>

<p>另一方面，我们的布局始终在跟踪捏合的元素以及期望尺寸，并在需要的时候提供正确的属性：</p>

<p>```objc
- (NSArray*)layoutAttributesForElementsInRect:(CGRect)rect
{
    NSArray *attrs = [super layoutAttributesForElementsInRect:rect];</p>

<pre><code>if (_pinchedItem) {
    UICollectionViewLayoutAttributes *attr = [[attrs filteredArrayUsingPredicate:[NSPredicate predicateWithFormat:@"indexPath == %@", _pinchedItem]] firstObject];

    attr.size = _pinchedItemSize;
    attr.zIndex = 100;
}
return attrs; } ```
</code></pre>

<h3>小结</h3>

<p>我们通过一些例子来说明了如何在 collection view 布局中创建自定义动画。虽然 <code>UICollectionViewFlowLayout</code> 并不直接允许定制动画，但是苹果工程师提供了清晰的架构让你可以子类化并实现各种自定义行为。从本质来说，在你的 <code>UICollectionViewLayout</code> 子类中正确地响应以下信号，并对那些要求返回 <code>UICollectionViewLayoutAttributes</code> 的方法返回合适的属性，那么实现自定义布局和动画的唯一约束就是你的想象力：</p>

<ul>
<li><code>prepareLayout</code></li>
<li><code>prepareForCollectionViewUpdates:</code></li>
<li><code>finalizeCollectionViewUpdates</code></li>
<li><code>prepareForAnimatedBoundsChange:</code></li>
<li><code>finalizeAnimatedBoundsChange</code></li>
<li><code>shouldInvalidateLayoutForBoundsChange:</code></li>
</ul>

<p>更引人入胜的动画可以结合像在 objc.io <a href="http://objccn.io/issue-5-2/">话题 #5</a> 中 UIKit 力学这样的技术来实现。</p>

<h2 id="collectionviewsviewcontroller">带有 Collection views 的 View controller 转场</h2>

<p>就如 <a href="https://twitter.com/chriseidhof">Chris</a> 之前在 objc.io 的<a href="http://objccn.io/issue-5-3/">文章</a>中所说的那样，iOS 7 中的一个重大更新是自定义 view controller 转场动画。与自定义转场动画相呼应，苹果也在 <code>UICollectionViewController</code> 添加了 <code>useLayoutToLayoutNavigationTransitions</code> 标记来在可复用的单个 collection view 间启用导航转场。苹果自己的照片和日历应用就是这类转场动画的非常好的代表作。</p>

<h3 id="uicollectionviewcontroller">UICollectionViewController 实例之间的转场动画</h3>

<p>让我们来看看我们如何能够利用上一节相同的示例项目达到类似的效果：</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-collectionview-animations-4-layout2layout.gif" alt="Layout to Layout Navigation Transitions" /></p>

<p>为了使布局到布局的转场动画工作，navigation controller 的 root view controller 必须是一个 <code>useLayoutToLayoutNavigationTransitions</code> 设置为 <code>NO</code> 的 collection view controller。当另一个 <code>useLayoutToLayoutNavigationTransitions</code> 设置为 <code>YES</code> 的 <code>UICollectionViewController</code> 实例被 push 到根视图控制器之上时，navigation controller 会用布局转场动画来代替标准的 push 转场动画。这里要注意一个重要的细节，根视图控制器的 collection view 实例被回收用于在导航栈上 push 进来的 collection 控制器中，如果你试图在 <code>viewDidLoad</code> 之类的方法中中设置 collection view 属性， 它们将不会有任何反应，你也不会收到任何警告。</p>

<p>这个行为可能最常见的陷阱是期望回收的 collection view 根据顶层的 collection 视图控制器来更新数据源和委托。它当然不会这样：根 collection 视图控制器会保持数据源和委托，除非我们做点什么。</p>

<p>解决此问题的方法是实现 navigation controller 的委托方法，并根据导航堆栈顶部的当前视图控制器的需要正确设置 collection view 的数据源和委托。在我们简单的例子中，这可以通过以下方式实现：</p>

<p><code>objc
- (void)navigationController:(UINavigationController *)navigationController didShowViewController:(UIViewController *)viewController animated:(BOOL)animated
{
    if ([viewController isKindOfClass:[FJDetailViewController class]]) {
        FJDetailViewController *dvc = (FJDetailViewController*)viewController;
        dvc.collectionView.dataSource = dvc;
        dvc.collectionView.delegate = dvc;
        [dvc.collectionView scrollToItemAtIndexPath:[NSIndexPath indexPathForItem:_selectedItem inSection:0] atScrollPosition:UICollectionViewScrollPositionCenteredVertically animated:NO];
    }
    else if (viewController == self){
        self.collectionView.dataSource = self;
        self.collectionView.delegate = self;
    }
}
</code>objc</p>

<p>当详细页面的 collection view 被推入导航栈时，我们重新设置 collection view 的数据源到详细视图控制器，确保只有被选择的 cell 颜色显示在详细页面的 collection view 中。如果我们不打算这样做，布局依然可以正确过渡，但是collection 将显示所有的 cells。在实际应用中，detail 的数据源通常负责在转场动画过程中显示更详细的数据。</p>

<h3 id="collectionview">用于常规转换的 Collection View 布局动画</h3>

<p>使用了 <code>useLayoutToLayoutNavigationTransitions</code> 的布局和布局间导航转换是很有用的，但却局限于仅在 两个 view controller 都是 <code>UICollectionViewController</code> 的实例，并且转场的必须发生在顶级 collection views 之间。为了达到在任意视图控制器的任意 collection view 之间都能实现相似的过渡，我们需要自定义一个 view collection 的转场动画。</p>

<p><img src="http://img.objccn.io/issue-12/2014-05-01-collectionview-animations-5-custom-transitions.gif" alt="Custom Collection View Transition" /></p>

<p>针对此类自定义过渡的动画控制器，需要遵循以下步骤进行设计：</p>

<ol>
<li>对初始的 collection view 中的所有可见元素制作截图  </li>
<li>将截图添加到转场上下文的 container view 中  </li>
<li>运用目标 collection view 的布局计算最终位置  </li>
<li>制作动画使快照到正确的位置  </li>
<li>当目标 collection view 可见时删除截图</li>
</ol>

<p>一个这样的动画设计有两重缺陷：它只能对初始的 collection view 的可见元素制作动画，因为<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/uiview_class/UIView/UIView.html#//apple_ref/doc/uid/TP40006816-CH3-SW198">快照 APIs </a> 只能工作于屏幕上可见的 view，另外，依赖于可见的元素数量，可能会有很多的 views 需要进行正确的跟踪并为其制作动画。但另一方面，这种设计又具有一个明显的优势，那就是它可以为所有类型的 <code>UICollectionViewLayout</code> 组合所使用。这样一个系统的实现就留给读者们去进行练习吧。</p>

<p>在附带的演示项目中我们用另一种途径进行了实现，它依赖于一些 <code>UICollectionViewFlowLayout</code> 的巧合。</p>

<p>基本的想法是，因为源 collection view 和目标 collection view 都拥有有效的 flow layouts，因此源 layout 的布局属性正好可以用作目标 collection view 的布局中的初始布局属性，以此驱动转场动画。一旦正确建立，就算对于那些一开始在屏幕上不可见的元素，collection view 的机制都将为我们追踪它们并进行动画。下面是我们的动画控制器中的 <code>animateTransition:</code> 的核心代码：</p>

<p>```objc
    CGRect initialRect = [inView.window convertRect:_fromCollectionView.frame fromView:_fromCollectionView.superview];
    CGRect finalRect   = [transitionContext finalFrameForViewController:toVC];</p>

<pre><code>UICollectionViewFlowLayout *toLayout = (UICollectionViewFlowLayout*) _toCollectionView.collectionViewLayout;

UICollectionViewFlowLayout *currentLayout = (UICollectionViewFlowLayout*) _fromCollectionView.collectionViewLayout;

//制作原来布局的拷贝
UICollectionViewFlowLayout *currentLayoutCopy = [[UICollectionViewFlowLayout alloc] init];

currentLayoutCopy.itemSize = currentLayout.itemSize;
currentLayoutCopy.sectionInset = currentLayout.sectionInset;
currentLayoutCopy.minimumLineSpacing = currentLayout.minimumLineSpacing;
currentLayoutCopy.minimumInteritemSpacing = currentLayout.minimumInteritemSpacing;
currentLayoutCopy.scrollDirection = currentLayout.scrollDirection;

//将拷贝赋值给源 collection view
[self.fromCollectionView setCollectionViewLayout:currentLayoutCopy animated:NO];

UIEdgeInsets contentInset = _toCollectionView.contentInset;

CGFloat oldBottomInset = contentInset.bottom;

//强制在目标 collection view 中设定一个很大的 bottom inset
contentInset.bottom = CGRectGetHeight(finalRect)-(toLayout.itemSize.height+toLayout.sectionInset.bottom+toLayout.sectionInset.top);
self.toCollectionView.contentInset = contentInset;

//将源布局设置给目标 collection view
[self.toCollectionView setCollectionViewLayout:currentLayout animated:NO];

toView.frame = initialRect;

[inView insertSubview:toView aboveSubview:fromView];

[UIView
 animateWithDuration:[self transitionDuration:transitionContext]
 delay:0
 options:UIViewAnimationOptionBeginFromCurrentState
 animations:^{
   //使用最终 frame 制作动画
     toView.frame = finalRect;
     //在 performUpdates 中设定最终的布局
     [_toCollectionView
      performBatchUpdates:^{
          [_toCollectionView setCollectionViewLayout:toLayout animated:NO];
      }
      completion:^(BOOL finished) {
          _toCollectionView.contentInset = UIEdgeInsetsMake(contentInset.top,
                                                            contentInset.left,
                                                            oldBottomInset,
                                                            contentInset.right);
      }];

 } completion:^(BOOL finished) {
     [transitionContext completeTransition:YES];
 }]; ```
</code></pre>

<p>首先，动画控制器确保目标 collection view 以与原来的 collection view 完全相同的框架和布局作为开始。接着，它将源 collection view 的布局设定给目标 collection view，以确保其不会失效。与此同时，该布局已经复制到另一个新的布局对象中，而这个布局对象则是为防止在导航回原始视图控制器时出现奇怪的布局 bug。我们还会强制在目标 collection view 的底部设定一个很大的 content inset，来确保布局在动画的初始位置时保持在一行上。观察日志的话，你会发现由于元素的尺寸加上 inset 的尺寸会比 collection view 的非滚动维度要大，因此 collection view 会在控制台警告。在这样的情况下，collection view 的行为是没有定义的，我们也只是使用这样一个不稳定的状态来作为我们转换动画的初始状态。最后，复杂的动画 block 将展现它的魅力，首先将目标 collection view 的框架设定到最终位置，然后在 <code>performBatchUpdates:completion:</code> 的 update block 中执行一个无动画的布局来改变至最终布局，紧随其后便是在 completion block 中将 content insets 重置为原始值。</p>

<h3>小结</h3>

<p>我们讨论了两种可以在 collection view 之间实现布局转场的途径。一种使用了内置的 <code>useLayoutToLayoutNavigationTransitions</code>，看起来令人印象深刻并且极其容易实现，缺点就是可以使用的范围较为局限。由于 <code>useLayoutToLayoutNavigationTransitions</code> 在一些案例中不能使用，想驱动自定义的过渡动画的话，就需要一个自定义的 animator。这篇文章中，我们看到了如何实现这样一个 animator，然而，由于你的应用程序大概肯定会需要在两个和本例完全不同的 view 结构中实现完全不同的动画，所以正如此例中做的那样，不要吝于尝试不同的方法来探究其是否能够工作。</p>

<hr />

]]></content>
  </entry>
  
</feed>
