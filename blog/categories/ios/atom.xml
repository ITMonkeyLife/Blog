<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | IT Monkey Life]]></title>
  <link href="http://ITMonkeyLife.github.io/Blog/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://ITMonkeyLife.github.io/Blog/"/>
  <updated>2014-04-21T18:07:44+08:00</updated>
  <id>http://ITMonkeyLife.github.io/Blog/</id>
  <author>
    <name><![CDATA[Rick]]></name>
    <email><![CDATA[382542165@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解CocoaPods]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/04/21/shen-ru-li-jie-cocoapods/"/>
    <updated>2014-04-21T18:06:50+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/04/21/shen-ru-li-jie-cocoapods</id>
    <content type="html"><![CDATA[<p>CocoaPods 是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具。利用 CocoaPods，可以定义自己的依赖关系 (称作 <code>pods</code>)，并且随着时间的变化，以及在整个开发环境中对第三方库的版本管理非常方便。</p>

<p>CocoaPods 背后的理念主要体现在两个方面。首先，在工程中引入第三方代码会涉及到许多内容。针对 Objective-C 初级开发者来说，工程文件的配置会让人很沮丧。在配置 build phases 和 linker flags 过程中，会引起许多人为因素的错误。CocoaPods 简化了这一切，它能够自动配置编译选项。</p>

<p>其次，通过 CocoaPods，可以很方便的查找到新的第三方库。当然，这并不是说你可以简单的将别人提供的库拿来拼凑成一个应用程序。它的真正作用是让你能够找到真正好用的库，以此来缩短我们的开发周期和提升软件的质量。</p>

<p>本文中，我们将通过分析 <code>pod 安装 (</code>pod install<code>)</code> 的过程，一步一步揭示 CocoaPods 背后的技术。</p>

<h2>核心组件</h2>

<p>CocoaPods是用 Ruby 写的，并由若干个 Ruby 包 (gems) 构成的。在解析整合过程中，最重要的几个 gems 分别是： <a href="https://github.com/CocoaPods/CocoaPods/">CocoaPods/CocoaPods</a>, <a href="https://github.com/CocoaPods/Core">CocoaPods/Core</a>, 和 <a href="https://github.com/CocoaPods/Xcodeproj">CocoaPods/Xcodeproj</a> (是的，CocoaPods 是一个依赖管理工具 -- 利用依赖管理进行构建的！)。</p>

<blockquote>
  <p><p><span class="secondary radius label">编者注</span> CocoaPods 是一个 objc 的依赖管理工具，而其本身是利用 ruby 的依赖管理 gem 进行构建的</p>


<h3 id="cocoapodscocoapod">CocoaPods/CocoaPod</h3>

<p>这是是一个面向用户的组件，每当执行一个 <code>pod</code> 命令时，这个组件都将被激活。该组件包括了所有使用 CocoaPods 涉及到的功能，并且还能通过调用所有其它的 gems 来执行任务。</p>

<h3 id="cocoapodscore">CocoaPods/Core</h3>

<p>Core 组件提供支持与 CocoaPods 相关文件的处理，文件主要是 Podfile 和 podspecs。</p>

<h5 id="podfile">Podfile</h5>

<p>Podfile 是一个文件，用于定义项目锁需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 <a href="http://guides.cocoapods.org/syntax/podfile.html">Podfile 指南</a>。</p>

<h4 id="podspec">Podspec</h4>

<p><code>.podspec</code> 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。</p>

<h3 id="cocoapodsxcodeproj">CocoaPods/Xcodeproj</h3>

<p>这个 gem 组件负责所有工程文件的整合。它能够对创建并修改 <code>.xcodeproj</code> 和 <code>.xcworkspace</code> 文件。它也可以作为单独的一个 gem 包使用。如果你想要写一个脚本来方便的修改工程文件，那么可以使用这个 gem。</p>

<h2 id="podinstall">运行 <code>pod install</code> 命令</h2>

<p>当运行 <code>pod install</code> 命令时会引发许多操作。要想深入了解这个命令执行的详细内容，可以在这个命令后面加上 <code>--verbose</code>。现在运行这个命令 <code>pod install --verbose</code>，可以看到类似如下的内容：</p>

<pre><code>$ pod install --verbose

Analyzing dependencies

Updating spec repositories
Updating spec repo `master`
  $ /usr/bin/git pull
  Already up-to-date.


Finding Podfile changes
  - AFNetworking
  - HockeySDK

Resolving dependencies of `Podfile`
Resolving dependencies for target `Pods' (iOS 6.0)
  - AFNetworking (= 1.2.1)
  - SDWebImage (= 3.2)
    - SDWebImage/Core

Comparing resolved specification to the sandbox manifest
  - AFNetworking
  - HockeySDK

Downloading dependencies

-&gt; Using AFNetworking (1.2.1)

-&gt; Using HockeySDK (3.0.0)
  - Running pre install hooks
    - HockeySDK

Generating Pods project
  - Creating Pods project
  - Adding source files to Pods project
  - Adding frameworks to Pods project
  - Adding libraries to Pods project
  - Adding resources to Pods project
  - Linking headers
  - Installing libraries
    - Installing target `Pods-AFNetworking` iOS 6.0
      - Adding Build files
      - Adding resource bundles to Pods project
      - Generating public xcconfig file at `Pods/Pods-AFNetworking.xcconfig`
      - Generating private xcconfig file at `Pods/Pods-AFNetworking-Private.xcconfig`
      - Generating prefix header at `Pods/Pods-AFNetworking-prefix.pch`
      - Generating dummy source file at `Pods/Pods-AFNetworking-dummy.m`
    - Installing target `Pods-HockeySDK` iOS 6.0
      - Adding Build files
      - Adding resource bundles to Pods project
      - Generating public xcconfig file at `Pods/Pods-HockeySDK.xcconfig`
      - Generating private xcconfig file at `Pods/Pods-HockeySDK-Private.xcconfig`
      - Generating prefix header at `Pods/Pods-HockeySDK-prefix.pch`
      - Generating dummy source file at `Pods/Pods-HockeySDK-dummy.m`
    - Installing target `Pods` iOS 6.0
      - Generating xcconfig file at `Pods/Pods.xcconfig`
      - Generating target environment header at `Pods/Pods-environment.h`
      - Generating copy resources script at `Pods/Pods-resources.sh`
      - Generating acknowledgements at `Pods/Pods-acknowledgements.plist`
      - Generating acknowledgements at `Pods/Pods-acknowledgements.markdown`
      - Generating dummy source file at `Pods/Pods-dummy.m`
  - Running post install hooks
  - Writing Xcode project file to `Pods/Pods.xcodeproj`
  - Writing Lockfile in `Podfile.lock`
  - Writing Manifest in `Pods/Manifest.lock`

Integrating client project
</code></pre>

<p>可以上到，整个过程执行了很多操作，不过把它们分解之后，再看看，会发现它们都很简单。让我们逐步来分析一下。</p>

<h3 id="podfile">读取 Podfile 文件</h3>

<p>你是否对 Podfile 的语法格式感到奇怪过，那是因为这是用 Ruby 语言写的。相较而言，这要比现有的其他格式更加简单好用一些。</p>

<p>在安装期间，第一步是要弄清楚显示或隐式的声明了哪些第三方库。在加载 podspecs 过程中，CocoaPods 就建立了包括版本信息在内的所有的第三方库的列表。Podspecs 被存储在本地路径 <code>~/.cocoapods</code> 中。</p>

<h4>版本控制和冲突</h4>

<p>CocoaPods 使用<a href="http://semver.org/">语义版本控制 - Semantic Versioning</a> 命名约定来解决对版本的依赖。由于冲突解决系统建立在非重大变更的补丁版本之间，这使得解决依赖关系变得容易很多。例如，两个不同的 pods 依赖于 CocoaLumberjack 的两个版本，假设一个依赖于 <code>2.3.1</code>，另一个依赖于 <code>2.3.3</code>，此时冲突解决系统可以使用最新的版本 <code>2.3.3</code>，因为这个可以向后与 <code>2.3.1</code> 兼容。</p>

<p>但这并不总是有效。有许多第三方库并不使用这样的约定，这让解决方案变得非常复杂。</p>

<p>当然，总会有一些冲突需要手动解决。如果一个库依赖于 CocoaLumberjack 的 <code>1.2.5</code>，另外一个库则依赖于 <code>2.3.1</code>，那么只有最终用户通过明确指定使用某个版本来解决冲突。</p>

<h3>加载源文件</h3>

<p>CocoaPods 执行的下一步是加载源码。每个 <code>.podspec</code> 文件都包含一个源代码的索引，这些索引一般包裹一个 git 地址和 git tag。它们以 commit SHAs 的方式存储在 <code>~/Library/Caches/CocoaPods</code> 中。这个路径中文件的创建是由 Core gem 负责的。</p>

<p>CocoaPods 将依照 <code>Podfile</code>、<code>.podspec</code> 和缓存文件的信息将源文件下载到 <code>Pods</code> 目录中。</p>

<h3 id="podsxcodeproj">生成 Pods.xcodeproj</h3>

<p>每次 <code>pod install</code> 执行，如果检测到改动时，CocoaPods 会利用 Xcodeproj gem 组件对 <code>Pods.xcodeproj</code> 进行更新。如果该文件不存在，则用默认配置生成。否则，会将已有的配置项加载至内存中。</p>

<h3>安装第三方库</h3>

<p>当 CocoaPods 往工程中添加一个第三方库时，不仅仅是添加代码这么简单，还会添加很多内容。由于每个第三方库有不同的 target，因此对于每个库，都会有几个文件需要添加，每个 target 都需要：</p>

<ul>
<li>一个包含编译选项的 <code>.xcconfig</code> 文件</li>
<li>一个同时包含编译设置和 CocoaPods 默认配置的私有 <code>.xcconfig</code> 文件</li>
<li>一个编译所必须的 <code>prefix.pch</code> 文件</li>
<li>另一个编译必须的文件 <code>dummy.m</code></li>
</ul>

<p>一旦每个 pod 的 target 完成了上面的内容，整个 <code>Pods</code> target 就会被创建。这增加了相同文件的同时，还增加了另外几个文件。如果源码中包含有资源 bundle，将这个 bundle 添加至程序 target 的指令将被添加到 <code>Pods-Resources.sh</code> 文件中。还有一个名为 <code>Pods-environment.h</code> 的文件，文件中包含了一些宏，这些宏可以用来检查某个组件是否来自 pod。最后，将生成两个认可文件，一个是 <code>plist</code>，另一个是 <code>markdown</code>，这两个文件用于给最终用户查阅相关许可信息。</p>

<h3>写入至磁盘</h3>

<p>直到现在，许多工作都是在内存中进行的。为了让这些成果能被重复利用，我们需要将所有的结果保存到一个文件中。所以 <code>Pods.xcodeproj</code> 文件被写入磁盘，另外两个非常重要的文件：<code>Podfile.lock</code> 和 <code>Manifest.lock</code> 都将被写入磁盘。</p>

<h4 id="podfilelock">Podfile.lock</h4>

<p>这是 CocoaPods 创建的最重要的文件之一。它记录了需要被安装的 pod 的每个已安装的版本。如果你想知道已安装的 pod 是哪个版本，可以查看这个文件。推荐将 Podfile.lock 文件加入到版本控制中，这有助于整个团队的一致性。</p>

<h4 id="manifestlock">Manifest.lock</h4>

<p>这是每次运行 <code>pod install</code> 命令时创建的 <code>Podfile.lock</code> 文件的副本。如果你遇见过这样的错误 <code>沙盒文件与 Podfile.lock 文件不同步 (The sandbox is not in sync with the Podfile.lock)</code>，这是因为 Manifest.lock 文件和 <code>Podfile.lock</code> 文件不一致所引起。由于 <code>Pods</code> 所在的目录并不总在版本控制之下，这样可以保证开发者运行 app 之前都能更新他们的 pods，否则 app 可能会 crash，或者在一些不太明显的地方编译失败。</p>

<h3 id="xcproj">xcproj</h3>

<p>如果你已经依照我们的建议在系统上安装了 <a href="https://github.com/0xced/xcproj">xcproj</a>，它会对 <code>Pods.xcodeproj</code> 文件执行一下 <code>touch</code> 以将其转换成为旧的 ASCII plist 格式的文件。为什么要这么做呢？虽然在很久以前就不被其它软件支持了，但是 Xcode 仍然依赖于这种格式。如果没有 xcproj，你的 <code>Pods.xcodeproj</code> 文件将会以 XML 格式的 plist 文件存储，当你用 Xcode 打开它时，它会被改写，并造成大量的文件改动。</p>

<h2>结果</h2>

<p>运行 <code>pod install</code> 命令的最终结果是许多文件被添加到你的工程和系统中。这个过程通常只需要几秒钟。当然没有 Cocoapods 这些事也都可以完成。只不过所花的时间就不仅仅是几秒而已了。</p>

<h2>补充：持续集成</h2>

<p>CocoaPods 和持续集成在一起非常融洽。虽然持续集成很大程度上取决于你的项目配置，但 Cocoapods 依然能很容易地对项目进行编译。</p>

<h3 id="pods">Pods 文件夹的版本控制</h3>

<p>如果 Pods 文件夹和里面的所有内容都在版本控制之中，那么你不需要做什么特别的工作，就能够持续集成。我们只需要给 <code>.xcworkspace</code> 选择一个正确的 scheme 即可。</p>

<h3 id="pods">不受版本控制的 Pods 文件夹</h3>

<p>如果你的 <code>Pods</code> 文件夹不受版本控制，那么你需要做一些额外的步骤来保证持续集成的顺利进行。最起码，<code>Podfile</code> 文件要放入版本控制之中。另外强烈建议将生成的 <code>.xcworkspace</code> 和 <code>Podfile.lock</code> 文件纳入版本控制，这样不仅简单方便，也能保证所使用 Pod 的版本是正确的。</p>

<p>一旦配置完毕，在持续集成中运行 CocoaPods 的关键就是确保每次编译之前都执行了 <code>pod install</code> 命令。在大多数系统中，例如 Jenkins 或 Travis，只需要定义一个编译步骤即可 (实际上，Travis 会自动执行 <code>pod install</code> 命令)。对于 <a href="https://groups.google.com/d/msg/cocoapods/eYL8QB3XjyQ/10nmCRN8YxoJ">Xcode Bots，在书写这篇文章时我们还没能找到非常流畅的方式</a>，不过我们正朝着解决方案努力，一旦成功，我们将会立即分享。</p>

<h2>结束语</h2>

<p>CocoaPods 简化了 Objective-C 的开发流程，我们的目标是让第三方库更容易被发现和添加。了解 CocoaPods 的原理能让你做出更好的应用程序。我们沿着 CocoaPods 的整个执行过程，从载入 specs 文件和源代码、创建 <code>.xcodeproj</code> 文件和所有组件，到将所有文件写入磁盘。所以接下来，我们运行 <code>pod install --verbose</code>，静静观察 CocoaPods 的魔力如何显现。</p>

<hr />
</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac可执行文件]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/04/21/macke-zhi-xing-wen-jian/"/>
    <updated>2014-04-21T17:51:10+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/04/21/macke-zhi-xing-wen-jian</id>
    <content type="html"><![CDATA[<p>我们用 Xcode 构建一个程序的过程中，会把源文件 (<code>.m</code> 和 <code>.h</code>) 文件转换为一个可执行文件。这个可执行文件中包含的字节码会将被 CPU (iOS 设备中的 ARM 处理器或 Mac 上的 Intel 处理器) 执行。</p>

<p>本文将介绍一下上面的过程中编译器都做了些什么，同时深入看看可执行文件内部是怎样的。实际上里面的东西要比我们第一眼看到的多得多。</p>

<p>这里我们把 Xcode 放一边，将使用命令行工具 (command-line tools)。当我们用 Xcode 构建一个程序时，Xcode 只是简单的调用了一系列的工具而已。Florian 对工具调用是如何工作的做了更详细的讨论。本文我们就直接调用这些工具，并看看它们都做了些什么。</p>

<p>真心希望本文能帮助你更好的理解 iOS 或 OS X 中的一个可执行文件 (也叫做 <em>Mach-O executable</em>) 是如何执行，以及怎样组装起来的。</p>

<h2 id="xcrun">xcrun</h2>

<p>先来看一些基础性的东西：这里会大量使用一个名为 <code>xcrun</code> 的命令行工具。看起来可能会有点奇怪，不过它非常的出色。这个小工具用来调用别的一些工具。原先，我们在终端执行如下命令：</p>

<pre><code>% clang -v
</code></pre>

<p>现在我们用下面的命令代替：</p>

<pre><code>% xcrun clang -v
</code></pre>

<p>在这里 <code>xcrun</code> 做的是定位到 <code>clang</code>，并执行它，附带输入 <code>clang</code> 后面的参数。</p>

<p>我们为什么要这样做呢？看起来没有什么意义。不过 <code>xcode</code> 允许我们: (1) 使用多个版本的 Xcode，以及使用某个特定 Xcode 版本中的工具。(2) 针对某个特定的 SDK (software development kit) 使用不同的工具。如果你有 Xcode 4.5 和 Xcode 5，通过 <code>xcode-select</code> 和 <code>xcrun</code> 可以选择使用 Xcode 5 中 iOS SDK 的工具，或者 Xcode 4.5 中的 OS X 工具。在许多其它平台中，这是不可能做到的。查阅 <code>xcrun</code> 和 <code>xcode-select</code> 的主页内容可以了解到详细内容。不用安装 <em>Command Line Tools</em>，就能使用命令行中的开发者工具。</p>

<h2 id="idehelloworld">不使用 IDE 的 Hello World</h2>

<p>回到终端 (Terminal)，创建一个包含一个 C 文件的文件夹：</p>

<pre><code>% mkdir ~/Desktop/objcio-command-line
% cd !$
% touch helloworld.c
</code></pre>

<p>接着使用你喜欢的文本编辑器来编辑这个文件 -- 例如 TextEdit.app：</p>

<pre><code>% open -e helloworld.c
</code></pre>

<p>输入如下代码：</p>

<p><code>c
#include &lt;stdio.h&gt;
int main(int argc, char *argv[])
{
    printf("Hello World!\n");
    return 0;
}
</code></p>

<p>保存并返回到终端，然后运行如下命令：</p>

<pre><code>% xcrun clang helloworld.c
% ./a.out
</code></pre>

<p>现在你能够在终端上看到熟悉的 <code>Hello World!</code>。这里我们编译并运行 C 程序，全程没有使用 IDE。深呼吸一下，高兴高兴。</p>

<p>上面我们到底做了些什么呢？我们将 <code>helloworld.c</code> 编译为一个名为 <code>a.out</code> 的 Mach-O 二进制文件。注意，如果我们没有指定名字，那么编译器会默认的将其指定为 a.out。</p>

<p>这个二进制文件是如何生成的呢？实际上有许多内容需要观察和理解。我们先看看编译器吧。</p>

<h3 id="helloworld">Hello World 和编译器</h3>

<p>时下 Xcode 中编译器默认选择使用 <code>clang</code>(读作 /klæŋ/)。<a href="http://objccn.io/issue-6-2/">关于编译器</a>，Chris 写了更详细的文章。</p>

<p>简单的说，编译器处理过程中，将 <code>helloworld.c</code> 当做输入文件，并生成一个可执行文件 <code>a.out</code>。这个过程有多个步骤/阶段。我们需要做的就是正确的执行它们。</p>

<h5>预处理</h5>

<ul>
<li>符号化 (Tokenization)</li>
<li>宏定义的展开</li>
<li><code>#include</code> 的展开</li>
</ul>

<h5>语法和语义分析</h5>

<ul>
<li>将符号化后的内容转化为一棵解析树 (parse tree)</li>
<li>解析树做语义分析</li>
<li>输出一棵<em>抽象语法树</em>（Abstract Syntax Tree* (AST)）</li>
</ul>

<h5>生成代码和优化</h5>

<ul>
<li>将 AST 转换为更低级的中间码 (LLVM IR)</li>
<li>对生成的中间码做优化</li>
<li>生成特定目标代码</li>
<li>输出汇编代码</li>
</ul>

<h5>汇编器</h5>

<ul>
<li>将汇编代码转换为目标对象文件。</li>
</ul>

<h5>链接器</h5>

<ul>
<li>将多个目标对象文件合并为一个可执行文件 (或者一个动态库)</li>
</ul>

<p>我们来看一个关于这些步骤的简单的例子。</p>

<h4>预处理</h4>

<p>编译过程中，编译器首先要做的事情就是对文件做处理。预处理结束之后，如果我们停止编译过程，那么我们可以让编译器显示出预处理的一些内容：</p>

<pre><code>% xcrun clang -E helloworld.c
</code></pre>

<p>喔喔。 上面的命令输出的内容有 413 行。我们用编辑器打开这些内容，看看到底发生了什么：</p>

<pre><code>% xcrun clang -E helloworld.c | open -f
</code></pre>

<p>在顶部可以看到的许多行语句都是以 <code>#</code> 开头 (读作 <code>hash</code>)。这些被称为 <em>行标记</em> 的语句告诉我们后面跟着的内容来自哪里。如果再回头看看 <code>helloworld.c</code> 文件，会发现第一行是：</p>

<p><code>c
#include &lt;stdio.h&gt;
</code></p>

<p>我们都用过 <code>#include</code> 和 <code>import</code>。它们所做的事情是告诉预处理器将文件 <code>stdio.h</code> 中的内容插入到 <code>#include</code> 语句所在的位置。这是一个递归的过程：<code>stdio.h</code> 可能会包含其它的文件。</p>

<p>由于这样的递归插入过程很多，所以我们需要确保记住相关行号信息。为了确保无误，预处理器在发生变更的地方插入以 <code>#</code> 开头的 <code>行标记</code>。跟在 <code>#</code> 后面的数字是在源文件中的行号，而最后的数字是在新文件中的行号。回到刚才打开的文件，紧跟着的是系统头文件，或者是被看做为封装了 <code>extern "C"</code> 代码块的文件。</p>

<p>如果滚动到文件末尾，可以看到我们的 <code>helloworld.c</code> 代码：</p>

<p><code>c
# 2 "helloworld.c" 2
int main(int argc, char *argv[])
{
 printf("Hello World!\n");
 return 0;
}
</code></p>

<p>在 Xcode 中，可以通过这样的方式查看任意文件的预处理结果：<strong>Product</strong> -&gt; <strong>Perform Action</strong> -&gt; <strong>Preprocess</strong>。注意，编辑器加载预处理后的文件需要花费一些时间 -- 接近 100,000 行代码。</p>

<h4>编译</h4>

<p>下一步：分析和代码生成。我们可以用下面的命令让 <code>clang</code> 输出汇编代码：</p>

<pre><code>% xcrun clang -S -o - helloworld.c | open -f
</code></pre>

<p>我们来看看输出的结果。首先会看到有一些以点 <code>.</code> 开头的行。这些就是汇编指令。其它的则是实际的 x86_64 汇编代码。最后是一些标记 (label)，与 C 语言中的类似。</p>

<p>我们先看看前三行：</p>

<pre><code>    .section    __TEXT,__text,regular,pure_instructions
    .globl  _main
    .align  4, 0x90
</code></pre>

<p>这三行是汇编指令，不是汇编代码。<code>.section</code> 指令指定接下来会执行哪一个段。</p>

<p>第二行的 <code>.globl</code> 指令说明 <code>_main</code> 是一个外部符号。这就是我们的 <code>main()</code> 函数。这个函数对于二进制文件外部来说是可见的，因为系统要调用它来运行可执行文件。</p>

<p><code>.align</code> 指令指出了后面代码的对齐方式。在我们的代码中，后面的代码会按照 16(2^4) 字节对齐，如果需要的话，用 <code>0x90</code> 补齐。</p>

<p>接下来是 main 函数的头部：</p>

<pre><code>_main:                                  ## @main
    .cfi_startproc
## BB#0:
    pushq   %rbp
Ltmp2:
    .cfi_def_cfa_offset 16
Ltmp3:
    .cfi_offset %rbp, -16
    movq    %rsp, %rbp
Ltmp4:
    .cfi_def_cfa_register %rbp
    subq    $32, %rsp
</code></pre>

<p>上面的代码中有一些与 C 标记工作机制一样的一些标记。它们是某些特定部分的汇编代码的符号链接。首先是 <code>_main</code> 函数真正开始的地址。这个符号会被 export。二进制文件会有这个位置的一个引用。</p>

<p><code>.cfi_startproc</code> 指令通常用于函数的开始处。CFI 是调用帧信息 (Call Frame Information) 的缩写。这个调用 <code>帧</code> 以松散的方式对应着一个函数。当开发者使用 debugger 和 <em>step in</em> 或 <em>step out</em> 时，实际上是 stepping in/out 一个调用帧。在 C 代码中，函数有自己的调用帧，当然，别的一些东西也会有类似的调用帧。<code>.cfi_startproc</code> 指令给了函数一个 <code>.eh_frame</code> 入口，这个入口包含了一些调用栈的信息（抛出异常时也是用其来展开调用帧堆栈的）。这个指令也会发送一些和具体平台相关的指令给 CFI。它与后面的 <code>.cfi_endproc</code> 相匹配，以此标记出 <code>main()</code> 函数结束的地方。</p>

<p>接着是另外一个 label <code>## BB#0:</code>。然后，终于，看到第一句汇编代码：<code>pushq %rbp</code>。从这里开始事情开始变得有趣。在 OS X上，我们会有 X86_64 的代码，对于这种架构，有一个东西叫做 <em>ABI</em> ( 应用二进制接口 application binary interface)，ABI 指定了函数调用是如何在汇编代码层面上工作的。在函数调用期间，ABI 会让 <code>rbp</code> 寄存器 (基础指针寄存器 base pointer register) 被保护起来。当函数调用返回时，确保 <code>rbp</code> 寄存器的值跟之前一样，这是属于 main 函数的职责。<code>pushq %rbp</code> 将 <code>rbp</code> 的值 push 到栈中，以便我们以后将其 pop 出来。</p>

<p>接下来是两个 CFI 指令：<code>.cfi_def_cfa_offset 16</code> 和 <code>.cfi_offset %rbp, -16</code>。这将会输出一些关于生成调用堆栈展开和调试的信息。我们改变了堆栈和基础指针，而这两个指令可以告诉编译器它们都在哪儿，或者更确切的，它们可以确保之后调试器要使用这些信息时，能找到对应的东西。</p>

<p>接下来，<code>movq %rsp, %rbp</code> 将把局部变量放置到栈上。<code>subq $32, %rsp</code> 将栈指针移动 32 个字节，也就是函数会调用的位置。我们先将老的栈指针存储到 <code>rbp</code> 中，然后将此作为我们局部变量的基址，接着我们更新堆栈指针到我们将会使用的位置。</p>

<p>之后，我们调用了 <code>printf()</code>：</p>

<pre><code>leaq    L_.str(%rip), %rax
movl    $0, -4(%rbp)
movl    %edi, -8(%rbp)
movq    %rsi, -16(%rbp)
movq    %rax, %rdi
movb    $0, %al
callq   _printf
</code></pre>

<p>首先，<code>leaq</code> 会将 <code>L_.str</code> 的指针加载到 <code>rax</code> 寄存器中。留意 <code>L_.str</code> 标记在后面的汇编代码中是如何定义的。它就是 C 字符串<code>"Hello World!\n"</code>。 <code>edi</code> 和 <code>rsi</code> 寄存器保存了函数的第一个和第二个参数。由于我们会调用别的函数，所以首先需要将它们的当前值保存起来。这就是为什么我们使用刚刚存储的 <code>rbp</code> 偏移32个字节的原因。第一个 32 字节的值是 0，之后的 32 字节的值是 <code>edi</code> 寄存器的值 (存储了 <code>argc</code>)。然后是 64 字节 的值：<code>rsi</code> 寄存器的值 (存储了 <code>argv</code>)。我们在后面并没有使用这些值，但是编译器在没有经过优化处理的时候，它们还是会被存下来。</p>

<p>现在我们把第一个函数 <code>printf()</code> 的参数 <code>rax</code> 设置给第一个函数参数寄存器 <code>edi</code> 中。<code>printf()</code> 是一个可变参数的函数。ABI 调用约定指定，将会把使用来存储参数的寄存器数量存储在寄存器 <code>al</code> 中。在这里是 0。最后 <code>callq</code> 调用了 <code>printf()</code> 函数。</p>

<pre><code>    movl    $0, %ecx
    movl    %eax, -20(%rbp)         ## 4-byte Spill
    movl    %ecx, %eax
</code></pre>

<p>上面的代码将 <code>ecx</code> 寄存器设置为 0，并把 <code>eax</code> 寄存器的值保存至栈中，然后将 <code>ect</code> 中的 0 拷贝至 <code>eax</code> 中。ABI 规定 <code>eax</code> 将用来保存一个函数的返回值，或者此处 <code>main()</code> 函数的返回值 0：</p>

<pre><code>    addq    $32, %rsp
    popq    %rbp
    ret
    .cfi_endproc
</code></pre>

<p>函数执行完成后，将恢复堆栈指针 —— 利用上面的指令 <code>subq $32, %rsp</code> 把堆栈指针 <code>rsp</code> 上移 32 字节。最后，把之前存储至 <code>rbp</code> 中的值从栈中弹出来，然后调用 <code>ret</code> 返回调用者， <code>ret</code> 会读取出栈的返回地址。 <code>.cfi_endproc</code> 平衡了 <code>.cfi_startproc</code> 指令。</p>

<p>接下来是输出字符串 <code>"Hello World!\n"</code>:</p>

<pre><code>    .section    __TEXT,__cstring,cstring_literals
L_.str:                                 ## @.str
    .asciz   "Hello World!\n"
</code></pre>

<p>同样，<code>.section</code> 指令指出下面将要进入的段。<code>L_.str</code> 标记运行在实际的代码中获取到字符串的一个指针。<code>.asciz</code> 指令告诉编译器输出一个以 ‘\0’ (null) 结尾的字符串。</p>

<p><code>__TEXT __cstring</code> 开启了一个新的段。这个段中包含了 C 字符串：</p>

<pre><code>L_.str:                                 ## @.str
    .asciz     "Hello World!\n"
</code></pre>

<p>上面两行代码创建了一个 null 结尾的字符串。注意 <code>L_.str</code> 是如何命名，之后会通过它来访问字符串。</p>

<p>最后的 <code>.subsections_via_symbols</code> 指令是静态链接编辑器使用的。</p>

<p>更过关于汇编指令的资料可以在 苹果的 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/Assembler/">OS X Assembler Reference</a> 中看到。AMD 64 网站有关于 <a href="http://www.x86-64.org/documentation/abi.pdf">ABI for x86 的文档</a>。另外还有 <a href="http://www.x86-64.org/documentation/assembly.html">Gentle Introduction to x86-64 Assembly</a>。</p>

<p>重申一下，通过下面的选择操作，我们可以用 Xcode 查看任意文件的汇编输出结果：<strong>Product</strong> -&gt; <strong>Perform Action</strong> -&gt; <strong>Assemble</strong>.</p>

<h4>汇编器</h4>

<p>汇编器将可读的汇编代码转换为机器代码。它会创建一个目标对象文件，一般简称为 <em>对象文件</em>。这些文件以 <code>.o</code> 结尾。如果用 Xcode 构建应用程序，可以在工程的 <em>derived data</em> 目录中，<code>Objects-normal</code> 文件夹下找到这些文件。</p>

<h4>链接器</h4>

<p>稍后我们会对链接器做更详细的介绍。这里简单介绍一下：链接器解决了目标文件和库之间的链接。什么意思呢？还记得下面的语句吗：</p>

<pre><code>callq   _printf
</code></pre>

<p><code>printf()</code> 是 <em>libc</em> 库中的一个函数。无论怎样，最后的可执行文件需要能需要知道 <code>printf()</code> 在内存中的具体位置：例如，<code>_printf</code> 的地址符号是什么。链接器会读取所有的目标文件 (此处只有一个) 和库 (此处是 <em>libc</em>)，并解决所有未知符号 (此处是 <code>_printf</code>) 的问题。然后将它们编码进最后的可执行文件中  （可以在 <em>libc</em> 中找到符号 <code>_printf</code>），接着链接器会输出可以运行的执行文件：<code>a.out</code>。</p>

<h2 id="section">Section</h2>

<p>就像我们上面提到的一样，这里有些东西叫做 section。一个可执行文件包含多个段，也就是多个 section。可执行文件不同的部分将加载进不同的 section，并且每个 section 会转换进某个 segment 里。这个概念对于所有的可执行文件都是成立的。</p>

<p>我们来看看 <code>a.out</code> 二进制中的 section。我们可以使用 <code>size</code> 工具来观察：</p>

<pre><code>% xcrun size -x -l -m a.out 
Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)
Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0)
    Section __text: 0x37 (addr 0x100000f30 offset 3888)
    Section __stubs: 0x6 (addr 0x100000f68 offset 3944)
    Section __stub_helper: 0x1a (addr 0x100000f70 offset 3952)
    Section __cstring: 0xe (addr 0x100000f8a offset 3978)
    Section __unwind_info: 0x48 (addr 0x100000f98 offset 3992)
    Section __eh_frame: 0x18 (addr 0x100000fe0 offset 4064)
    total 0xc5
Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096)
    Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096)
    Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112)
    total 0x18
Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)
total 0x100003000
</code></pre>

<p>如上代码所示，我们的 <code>a.out</code> 文件有 4 个 segment。有些 segment 中有多个 section。</p>

<p>当运行一个可执行文件时，虚拟内存 (VM - virtual memory) 系统将 segment 映射到进程的地址空间上。映射完全不同于我们一般的认识，如果你对虚拟内存系统不熟悉，可以简单的想象虚拟内存系统将整个可执行文件加载进内存 -- 虽然在实际上不是这样的。VM 使用了一些技巧来避免全部加载。</p>

<p>当虚拟内存系统进行映射时，segment 和 section 会以不同的参数和权限被映射。</p>

<p>上面的代码中，<code>__TEXT</code> segment 包含了被执行的代码。它被以只读和可执行的方式映射。进程被允许执行这些代码，但是不能修改。这些代码也不能对自己做出修改，因此这些被映射的页从来不会被改变。</p>

<p><code>__DATA</code> segment 以可读写和不可执行的方式映射。它包含了将会被更改的数据。</p>

<p>第一个 segment 是 <code>__PAGEZERO</code>。它的大小为 4GB。这 4GB 并不是文件的真实大小，但是规定了进程地址空间的前 4GB 被映射为 不可执行、不可写和不可读。这就是为什么当读写一个 <code>NULL</code> 指针或更小的值时会得到一个 <code>EXC_BAD_ACCESS</code> 错误。这是操作系统在尝试防止<a href="http://www.xkcd.com/371/">引起系统崩溃</a>。</p>

<p>在 segment中，一般都会有多个 section。它们包含了可执行文件的不同部分。在 <code>__TEXT</code> segment 中，<code>__text</code> section 包含了编译所得到的机器码。<code>__stubs</code> 和 <code>__stub_helper</code> 是给动态链接器 (<code>dyld</code>) 使用的。通过这两个 section，在动态链接代码中，可以允许延迟链接。<code>__const</code> (在我们的代码中没有) 是常量，不可变的，就像 <code>__cstring</code> (包含了可执行文件中的字符串常量 -- 在源码中被双引号包含的字符串) 常量一样。</p>

<p><code>__DATA</code> segment 中包含了可读写数据。在我们的程序中只有 <code>__nl_symbol_ptr</code> 和 <code>__la_symbol_ptr</code>，它们分别是 <em>non-lazy</em> 和 <em>lazy</em> 符号指针。延迟符号指针用于可执行文件中调用未定义的函数，例如不包含在可执行文件中的函数，它们将会延迟加载。而针对非延迟符号指针，当可执行文件被加载同时，也会被加载。</p>

<p>在 <code>_DATA</code> segment 中的其它常见 section 包括 <code>__const</code>，在这里面会包含一些需要重定向的常量数据。例如 <code>char * const p = "foo";</code> -- <code>p</code> 指针指向的数据是可变的。<code>__bss</code> section 没有被初始化的静态变量，例如 <code>static int a;</code> -- ANSI C 标准规定静态变量必须设置为 0。并且在运行时静态变量的值是可以修改的。<code>__common</code> section 包含未初始化的外部全局变量，跟 <code>static</code> 变量类似。例如在函数外面定义的 <code>int a;</code>。最后，<code>__dyld</code> 是一个 section 占位符，被用于动态链接器。</p>

<p>苹果的 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/Assembler/">OS X Assembler Reference</a> 文档有更多关于 section 类型的介绍。</p>

<h3 id="section">Section 中的内容</h3>

<p>下面，我们用 <code>otool(1)</code> 来观察一个 section 中的内容：</p>

<pre><code>% xcrun otool -s __TEXT __text a.out 
a.out:
(__TEXT,__text) section
0000000100000f30 55 48 89 e5 48 83 ec 20 48 8d 05 4b 00 00 00 c7 
0000000100000f40 45 fc 00 00 00 00 89 7d f8 48 89 75 f0 48 89 c7 
0000000100000f50 b0 00 e8 11 00 00 00 b9 00 00 00 00 89 45 ec 89 
0000000100000f60 c8 48 83 c4 20 5d c3 
</code></pre>

<p>上面是我们 app 中的代码。由于 <code>-s __TEXT __text</code> 很常见，<code>otool</code> 对其设置了一个缩写 <code>-t</code> 。我们还可以通过添加 <code>-v</code> 来查看反汇编代码：</p>

<pre><code>% xcrun otool -v -t a.out
a.out:
(__TEXT,__text) section
_main:
0000000100000f30    pushq   %rbp
0000000100000f31    movq    %rsp, %rbp
0000000100000f34    subq    $0x20, %rsp
0000000100000f38    leaq    0x4b(%rip), %rax
0000000100000f3f    movl    $0x0, 0xfffffffffffffffc(%rbp)
0000000100000f46    movl    %edi, 0xfffffffffffffff8(%rbp)
0000000100000f49    movq    %rsi, 0xfffffffffffffff0(%rbp)
0000000100000f4d    movq    %rax, %rdi
0000000100000f50    movb    $0x0, %al
0000000100000f52    callq   0x100000f68
0000000100000f57    movl    $0x0, %ecx
0000000100000f5c    movl    %eax, 0xffffffffffffffec(%rbp)
0000000100000f5f    movl    %ecx, %eax
0000000100000f61    addq    $0x20, %rsp
0000000100000f65    popq    %rbp
0000000100000f66    ret
</code></pre>

<p>上面的内容是一样的，只不过以反汇编形式显示出来。你应该感觉很熟悉，这就是我们在前面编译时候的代码。唯一的不同就是，在这里我们没有任何的汇编指令在里面。这是纯粹的二进制执行文件。</p>

<p>同样的方法，我们可以查看别的 section：</p>

<pre><code>% xcrun otool -v -s __TEXT __cstring a.out
a.out:
Contents of (__TEXT,__cstring) section
0x0000000100000f8a  Hello World!\n
</code></pre>

<p>或:</p>

<pre><code>% xcrun otool -v -s __TEXT __eh_frame a.out 
a.out:
Contents of (__TEXT,__eh_frame) section
0000000100000fe0    14 00 00 00 00 00 00 00 01 7a 52 00 01 78 10 01 
0000000100000ff0    10 0c 07 08 90 01 00 00 
</code></pre>

<h4>性能上需要注意的事项</h4>

<p>从侧面来讲，<code>__DATA</code> 和 <code>__TEXT</code> segment对性能会有所影响。如果你有一个很大的二进制文件，你可能得去看看苹果的文档：<a href="https://developer.apple.com/library/mac/documentation/Performance/Conceptual/CodeFootprint/Articles/MachOOverview.html">关于代码大小性能指南</a>。将数据移至 <code>__TEXT</code> 是个不错的选择，因为这些页从来不会被改变。</p>

<h4>任意的片段</h4>

<p>使用链接符号 <code>-sectcreate</code> 我们可以给可执行文件以 section 的方式添加任意的数据。这就是如何将一个 Info.plist 文件添加到一个独立的可执行文件中的方法。Info.plist 文件中的数据需要放入到 <code>__TEXT</code> segment 里面的一个 <code>__info_plist</code> section 中。可以将 <code>-sectcreate segname sectname file</code> 传递给链接器（通过将下面的内容传递给 clang）：</p>

<pre><code>-Wl,-sectcreate,__TEXT,__info_plist,path/to/Info.plist
</code></pre>

<p>同样，<code>-sectalign</code> 规定了对其方式。如果你添加的是一个全新的 segment，那么需要通过 <code>-segprot</code> 来规定 segment 的保护方式 (读/写/可执行)。这些所有内容在链接器的帮助文档中都有，例如 <code>ld(1)</code>。</p>

<p>我们可以利用定义在 <code>/usr/include/mach-o/getsect.h</code> 中的函数 <code>getsectdata()</code> 得到 section，例如 <code>getsectdata()</code> 可以得到指向 section 数据的一个指针，并返回相关 section 的长度。</p>

<h3 id="macho">Mach-O</h3>

<p>在 OS X 和 iOS 中可执行文件的格式为 <a href="https://en.wikipedia.org/wiki/Mach-o">Mach-O</a>：</p>

<pre><code>% file a.out 
a.out: Mach-O 64-bit executable x86_64
</code></pre>

<p>对于 GUI 程序也是一样的：</p>

<pre><code>% file /Applications/Preview.app/Contents/MacOS/Preview 
/Applications/Preview.app/Contents/MacOS/Preview: Mach-O 64-bit executable x86_64
</code></pre>

<p>关于 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachORuntime/index.html">Mach-O 文件格式</a> 苹果有详细的介绍。</p>

<p>我们可以使用 <code>otool(1)</code> 来观察可执行文件的头部 -- 规定了这个文件是什么，以及文件是如何被加载的。通过 <code>-h</code> 可以打印出头信息：</p>

<pre><code>% otool -v -h a.out           a.out:
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64  X86_64        ALL LIB64     EXECUTE    16       1296   NOUNDEFS DYLDLINK TWOLEVEL PIE
</code></pre>

<p><code>cputype</code> 和 <code>cpusubtype</code> 规定了这个可执行文件能够运行在哪些目标架构上。<code>ncmds</code> 和 <code>sizeofcmds</code> 是加载命令，可以通过 <code>-l</code> 来查看这两个加载命令：</p>

<pre><code>% otool -v -l a.out | open -f
a.out:
Load command 0
      cmd LC_SEGMENT_64
  cmdsize 72
  segname __PAGEZERO
   vmaddr 0x0000000000000000
   vmsize 0x0000000100000000
...
</code></pre>

<p>加载命令规定了文件的逻辑结构和文件在虚拟内存中的布局。<code>otool</code> 打印出的大多数信息都是源自这里的加载命令。看一下 <code>Load command 1</code> 部分，可以找到 <code>initprot r-x</code>，它规定了之前提到的保护方式：只读和可执行。</p>

<p>对于每一个 segment，以及segment 中的每个 section，加载命令规定了它们在内存中结束的位置，以及保护模式等。例如，下面是 <code>__TEXT __text</code> section 的输出内容：</p>

<pre><code>Section
  sectname __text
   segname __TEXT
      addr 0x0000000100000f30
      size 0x0000000000000037
    offset 3888
     align 2^4 (16)
    reloff 0
    nreloc 0
      type S_REGULAR
attributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS
 reserved1 0
 reserved2 0
</code></pre>

<p>上面的代码将在 0x100000f30 处结束。它在文件中的偏移量为 3888。如果看一下之前 <code>xcrun otool -v -t a.out</code> 输出的反汇编代码，可以发现代码实际位置在 0x100000f30。</p>

<p>我们同样看看在可执行文件中，动态链接库是如何使用的：</p>

<pre><code>% otool -v -L a.out
a.out:
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 169.3.0)
    time stamp 2 Thu Jan  1 01:00:02 1970
</code></pre>

<p>上面就是我们可执行文件将要找到 <code>_printf</code> 符号的地方。</p>

<h2>一个更复杂的例子</h2>

<p>我们来看看有三个文件的复杂例子：</p>

<p><code>Foo.h</code>:</p>

<p>```objc
#import &lt;Foundation/Foundation.h&gt;</p>

<p>@interface Foo : NSObject</p>

<ul>
  <li>(void)run;</li>
</ul>

<p>@end
```</p>

<p><code>Foo.m</code>:</p>

<p>```objc
#import “Foo.h”</p>

<p>@implementation Foo</p>

<ul>
  <li>(void)run
{
  NSLog(@”%@”, NSFullUserName());
}</li>
</ul>

<p>@end
```</p>

<p><code>helloworld.m</code>:</p>

<p>```objc
#import “Foo.h”</p>

<p>int main(int argc, char *argv[])
{
    @autoreleasepool {
        Foo *foo = [[Foo alloc] init];
        [foo run];
        return 0;
    }
}
```</p>

<h3>编译多个文件</h3>

<p>在上面的示例中，有多个源文件。所以我们需要让 clang 对输入每个文件生成对应的目标文件：</p>

<pre><code>% xcrun clang -c Foo.m
% xcrun clang -c helloworld.m
</code></pre>

<p>我们从来不编译头文件。头文件的作用就是在被编译的实现文件中对代码做简单的共享。<code>Foo.m</code> 和 <code>helloworld.m</code> 都是通过 <code>#import</code> 语句将 <code>Foo.h</code> 文件中的内容添加到实现文件中的。</p>

<p>最终得到了两个目标文件：</p>

<pre><code>% file helloworld.o Foo.o
helloworld.o: Mach-O 64-bit object x86_64
Foo.o:        Mach-O 64-bit object x86_64
</code></pre>

<p>为了生成一个可执行文件，我们需要将这两个目标文件和 Foundation framework 链接起来：</p>

<pre><code>xcrun clang helloworld.o Foo.o -Wl,`xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation
</code></pre>

<p>现在可以运行我们的程序了:</p>

<pre><code>% ./a.out 
2013-11-03 18:03:03.386 a.out[8302:303] Daniel Eggert
</code></pre>

<h3>符号表和链接</h3>

<p>我们这个简单的程序是将两个目标文件合并到一起的。<code>Foo.o</code> 目标文件包含了 <code>Foo</code> 类的实现，而 <code>helloworld.o</code> 目标文件包含了 <code>main()</code> 函数，以及调用/使用 <code>Foo</code> 类。</p>

<p>另外，这两个目标对象都使用了 Foundation framework。<code>helloworld.o</code> 目标文件使用了它的 autorelease pool，并间接的使用了  <code>libobjc.dylib</code> 中的 Objective-C 运行时。它需要运行时函数来进行消息的调用。<code>Foo.o</code> 目标文件也有类似的原理。</p>

<p>所有的这些东西都被形象的称之为符号。我们可以把符号看成是一些在运行时将会变成指针的东西。虽然实际上并不是这样的。</p>

<p>每个函数、全局变量和类等都是通过符号的形式来定义和使用的。当我们将目标文件链接为一个可执行文件时，链接器 (<code>ld(1)</code>) 在目标文件盒动态库之间对符号做了解析处理。</p>

<p>可执行文件和目标文件有一个符号表，这个符号表规定了它们的符号。如果我们用 <code>nm(1)</code> 工具观察一下 <code>helloworld.0</code> 目标文件，可以看到如下内容：</p>

<pre><code>% xcrun nm -nm helloworld.o
                 (undefined) external _OBJC_CLASS_$_Foo
0000000000000000 (__TEXT,__text) external _main
                 (undefined) external _objc_autoreleasePoolPop
                 (undefined) external _objc_autoreleasePoolPush
                 (undefined) external _objc_msgSend
                 (undefined) external _objc_msgSend_fixup
0000000000000088 (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_
000000000000008e (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_1
0000000000000093 (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_2
00000000000000a0 (__DATA,__objc_msgrefs) weak private external l_objc_msgSend_fixup_alloc
00000000000000e8 (__TEXT,__eh_frame) non-external EH_frame0
0000000000000100 (__TEXT,__eh_frame) external _main.eh
</code></pre>

<p>上面就是那个目标文件的所有符号。<code>_OBJC_CLASS_$_Foo</code> 是 <code>Foo</code> Objective-C 类的符号。该符号是 <em>undefined, external</em> 。<em>External</em> 的意思是指对于这个目标文件该类并不是私有的，相反，<code>non-external</code> 的符号则表示对于目标文件是私有的。我们的 <code>helloworld.o</code> 目标文件引用了类 <code>Foo</code>，不过这并没有实现它。因此符号表中将其标示为 undefined。</p>

<p>接下来是 <code>_main</code> 符号，它是表示 <code>main()</code> 函数，同样为 <em>external</em>，这是因为该函数需要被调用，所以应该为可见的。由于在 <code>helloworld.o</code> 文件中实现了 这个 main 函数。这个函数地址位于 0处，并且需要转入到  <code>__TEXT,__text</code> section。接着是 4 个 Objective-C 运行时函数。它们同样是 undefined的，需要链接器进行符号解析。</p>

<p>如果我们转而观察 <code>Foo.o</code> 目标文件，可以看到如下输出：</p>

<pre><code>% xcrun nm -nm Foo.o
0000000000000000 (__TEXT,__text) non-external -[Foo run]
                 (undefined) external _NSFullUserName
                 (undefined) external _NSLog
                 (undefined) external _OBJC_CLASS_$_NSObject
                 (undefined) external _OBJC_METACLASS_$_NSObject
                 (undefined) external ___CFConstantStringClassReference
                 (undefined) external __objc_empty_cache
                 (undefined) external __objc_empty_vtable
000000000000002f (__TEXT,__cstring) non-external l_.str
0000000000000060 (__TEXT,__objc_classname) non-external L_OBJC_CLASS_NAME_
0000000000000068 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_$_Foo
00000000000000b0 (__DATA,__objc_const) non-external l_OBJC_$_INSTANCE_METHODS_Foo
00000000000000d0 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_$_Foo
0000000000000118 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo
0000000000000140 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo
0000000000000168 (__TEXT,__objc_methname) non-external L_OBJC_METH_VAR_NAME_
000000000000016c (__TEXT,__objc_methtype) non-external L_OBJC_METH_VAR_TYPE_
00000000000001a8 (__TEXT,__eh_frame) non-external EH_frame0
00000000000001c0 (__TEXT,__eh_frame) non-external -[Foo run].eh
</code></pre>

<p>第五行至最后一行显示了 <code>_OBJC_CLASS_$_Foo</code> 已经定义了，并且对于 <code>Foo.o</code> 是一个外部符号 -- ·Foo.o· 包含了这个类的实现。</p>

<p><code>Foo.o</code> 同样有 undefined 的符号。首先是使用了符号 <code>NSFullUserName()</code>，<code>NSLog()</code>和 <code>NSObject</code>。</p>

<p>当我们将这两个目标文件和 Foundation framework (是一个动态库) 进行链接处理时，链接器会尝试解析所有的 undefined 符号。它可以解析  <code>_OBJC_CLASS_$_Foo</code>。另外，它将使用 Foundation framework。</p>

<p>当链接器通过动态库 (此处是 Foundation framework) 解析成功一个符号时，它会在最终的链接图中记录这个符号是通过动态库进行解析的。链接器会记录输出文件是依赖于哪个动态链接库，并连同其路径一起进行记录。在我们的例子中，<code>_NSFullUserName</code>，<code>_NSLog</code>，<code>_OBJC_CLASS_$_NSObject</code>，<code>_objc_autoreleasePoolPop</code> 等符号都是遵循这个过程。</p>

<p>我们可以看一下最终可执行文件 <code>a.out</code> 的符号表，并注意观察链接器是如何解析所有符号的：</p>

<pre><code>% xcrun nm -nm a.out 
                 (undefined) external _NSFullUserName (from Foundation)
                 (undefined) external _NSLog (from Foundation)
                 (undefined) external _OBJC_CLASS_$_NSObject (from CoreFoundation)
                 (undefined) external _OBJC_METACLASS_$_NSObject (from CoreFoundation)
                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)
                 (undefined) external __objc_empty_cache (from libobjc)
                 (undefined) external __objc_empty_vtable (from libobjc)
                 (undefined) external _objc_autoreleasePoolPop (from libobjc)
                 (undefined) external _objc_autoreleasePoolPush (from libobjc)
                 (undefined) external _objc_msgSend (from libobjc)
                 (undefined) external _objc_msgSend_fixup (from libobjc)
                 (undefined) external dyld_stub_binder (from libSystem)
0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header
0000000100000e50 (__TEXT,__text) external _main
0000000100000ed0 (__TEXT,__text) non-external -[Foo run]
0000000100001128 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo
0000000100001150 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo
</code></pre>

<p>可以看到所有的 Foundation 和 Objective-C 运行时符号依旧是 undefined，不过现在的符号表中已经多了如何解析它们的信息，例如在哪个动态库中可以找到对应的符号。</p>

<p>可执行文件同样知道去哪里找到所需库：</p>

<pre><code>% xcrun otool -L a.out
a.out:
    /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1056.0.0)
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1197.1.1)
    /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 855.11.0)
    /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)
</code></pre>

<p>在运行时，动态链接器  <code>dyld(1)</code> 可以解析这些 undefined 符号，<code>dyld</code> 将会确定好 <code>_NSFullUserName</code> 等符号，并指向它们在 Foundation 中的实现等。</p>

<p>我们可以针对 Foundation 运行 <code>nm(1)</code>，并检查这些符号的定义情况： </p>

<pre><code>% xcrun nm -nm `xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation | grep NSFullUserName
0000000000007f3e (__TEXT,__text) external _NSFullUserName 
</code></pre>

<h3>动态链接编辑器</h3>

<p>有一些环境变量对于 <code>dyld</code> 的输出信息非常有用。首先，如果设置了 <code>DYLD_PRINT_LIBRARIES</code>，那么 <code>dyld</code> 将会打印出什么库被加载了：</p>

<pre><code>% (export DYLD_PRINT_LIBRARIES=; ./a.out )
dyld: loaded: /Users/deggert/Desktop/command_line/./a.out
dyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation
dyld: loaded: /usr/lib/libSystem.B.dylib
dyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation
dyld: loaded: /usr/lib/libobjc.A.dylib
dyld: loaded: /usr/lib/libauto.dylib
[...]
</code></pre>

<p>上面将会显示出在加载 Foundation 时，同时会加载的 70 个动态库。这是由于 Foundation 依赖于另外一些动态库。运行下面的命令：</p>

<pre><code>% xcrun otool -L `xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation
</code></pre>

<p>可以看到 Foundation 使用了 15 个动态库。</p>

<h3 id="dyld">dyld 的共享缓存</h3>

<p>当你构建一个真正的程序时，将会链接各种各样的库。它们又会依赖其他一些 framework 和 动态库。需要加载的动态库会非常多。而对于相互依赖的符号就更多了。可能将会有上千个符号需要解析处理，这将花费很长的时间：一般是好几秒钟。</p>

<p>为了缩短这个处理过程所花费时间，在 OS X 和 iOS 上的动态链接器使用了共享缓存，共享缓存存于 <code>/var/db/dyld/</code>。对于每一种架构，操作系统都有一个单独的文件，文件中包含了绝大多数的动态库，这些库都已经链接为一个文件，并且已经处理好了它们之间的符号关系。当加载一个 Mach-O 文件 (一个可执行文件或者一个库) 时，动态链接器首先会检查 <em>共享缓存</em> 看看是否存在其中，如果存在，那么就直接从共享缓存中拿出来使用。每一个进程都把这个共享缓存映射到了自己的地址空间中。这个方法大大优化了 OS X 和 iOS 上程序的启动时间。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Foundation基础集合类]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/04/15/foundationji-chu-ji-he-lei/"/>
    <updated>2014-04-15T17:55:48+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/04/15/foundationji-chu-ji-he-lei</id>
    <content type="html"><![CDATA[<h2 id="nsarraynssetnsorderedsetnsdictionary">NSArray, NSSet, NSOrderedSet 和 NSDictionary</h2>

<p>基础集合类是每一个 Mac/iOS 应用的基本组成部分。在本文中，我们将对”老类” (<code>NSArray</code>, <code>NSSet</code>)和”新类” (<code>NSMapTable</code>, <code>NSHashTable</code>, <code>NSPointerArray</code>) 进行一个深入的研究，探索每一个的效率细节，并讨论其使用场景。</p>

<p>作者提示：本文包含一些参照结果，但它们并不意味着绝对精确，也没有进行均差分析及多次的测试。这些结果的目的是给出运行时统计，来帮助我们认识到通常来说用什么会更快。所有的测试基于 iPhone 5s，使用 Xcode 5.1b1 和 iOS 7.1b1 的 64 位程序。编译选项设置为 -Ofast 的发布构建。Vectorize loops 和 unroll loops (默认设置) 均设置为关闭。</p>

<h2 id="o">大 O 符号，算法复杂度计量</h2>

<p>首先，我们需要一些理论知识。效率通常用<a href="https://en.wikipedia.org/wiki/Big_O_notation">大 O 符号</a>描述。它定义了一个函数的<em>极限特征</em>，通常被用于描绘其算法效率。O 定义了函数增长率的上限。不同量级的差异非常巨大，可以看看通常使用的 O 符号的量级以及它们所对应需要的操作数的关系。</p>

<p><img src="http://img.objccn.io/issue-7/big-o-notation.png" alt="" /></p>

<p>例如，如果用算法复杂度为 O(n^2)的算法对一个有 50 个元素的数组排序，需要 2,500 步的操作。而且，还有内部的系统开销和方法调用 — 所以是 250 0个操作的时间常量。 O(1)是理想的复杂度，代表着恒定的时间。<a href="http://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms">好的排序算法通常需要 O(n*log n) 的时间</a>。</p>

<h3>可变性</h3>

<p>大多数的集合类存在两个版本:可变和不可变(默认)。这和其他大多数的框架有非常大的不同，一开始会让人觉得有一点奇怪。然而其他的框架现在也应用了这一特性：就在几个月前，<a href="http://blogs.msdn.com/b/dotnet/archive/2013/09/25/immutable-collections-ready-for-prime-time.aspx">.NET公布了作为官方扩展的不可变集合</a>。</p>

<p>最大的好处是什么？<strong>线程安全</strong>。不可变的集合完全是线程安全的，可以同时在多个线程中迭代，避免各种转变时出现异常的风险。你的 API <em>绝不</em>应该暴露一个可变的集合。</p>

<p>当然从不可变到可变然后再回来是会有一定代价的 — 对象必须被拷贝两次，所有集合内的对象将被 retain/release。有时在内部使用一个可变的集合，而在访问时返回一个不可变的对象副本会更高效。</p>

<p>与其他框架不同的是，苹果没有提供一个线程安全的可变集合，<code>NSCache</code> 是例外，但它真的算不上是集合类，因为它不是一个通用的容器。大多数时候，你不会需要在集合层级的同步特性。想象一段代码，作用是检查字典中一个 key 是否存在，并根据检查结果决定设置一个新的 key 或者返回某些值 — 你通常需要把多个操作归类，这时线程安全的可变集合并不能对你有所帮助。</p>

<p>其实也有<em>一些</em>同步的，线程安全的可以使用的可变集合案例，它们往往只需要用几行代码，通过子类和组合的方法建立，比如这个 <a href="https://gist.github.com/steipete/7746843"><code>NSDictionary</code></a> 或这个 <a href="https://github.com/Cue/TheKitchenSync/blob/master/Classes/Collections/CueSyncArray.mm"><code>NSArray</code></a>。</p>

<p>需要注意的是，一些较新的集合类，如 <code>NSHashTable</code>，<code>NSMapTable</code> 和 <code>NSPointerArray</code> 默认就是可变的，它们并没有对应的不可变的类。它们用于类的内部使用，你基本应该不会能找到需要它们的不可变版本的应用场景。</p>

<h2 id="nsarray">NSArray</h2>

<p><code>NSArray</code> 作为一个存储对象的有序集合，可能是被使用最多的集合类。这也是为什么它有自己的比原来的 <code>[NSArray arrayWithObjects:..., nil]</code> 简短得多的快速语法糖符号 <code>@[...]</code>。
<code>NSArray</code> 实现了 <code>objectAtIndexedSubscript:</code>，因为我们可以使用类 C 的语法 <code>array[0]</code> 来代替原来的 <code>[array objectAtIndex:0]</code>。</p>

<h3>性能特征</h3>

<p>关于 <code>NSArray</code> 的内容比你想象的要多的多。基于存储对象的多少，它使用各种内部的变体。最有趣的部分是苹果对于个别的对象访问并不保证 O(1) 的访问时间 — 正如你在 <a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFArray.h">CFArray.h CoreFoundation 头文件</a>中的关于算法复杂度的注解中可以读到的:</p>

<blockquote>
  <p>对于 array 中值的访问时间，不管是在现在还是将来，我们保证在任何一种实现下最坏情况是 O(lg N)。但是通常来说它会是 O(1) (常数时间)。线性搜索操作很可能在最坏情况下的复杂度为 O(N*lg N)，但通常来说上限会更小一些。插入和删除操作耗时通常和数组中的值的数量成线性关系。但在某些实现的最坏情况下会是 O(N*lg N) 。在数组中，没有对于性能上特别有优势的数据位置，也就是说，为了更快地访问到元素而将其设为在较低的 index 上，或者在较高的 index 上进行插入和删除，或者类似的一些做法，是没有必要的。</p>
</blockquote>

<p>在测量的时候，<code>NSArray</code> 产生了一些<a href="http://ridiculousfish.com/blog/posts/array.html">有趣的额外的性能特征</a>。在数组的开头和结尾插入/删除元素通常是一个 O(1)操作，而随机的插入/删除通常是 O(N) 的。</p>

<h3>有用的方法</h3>

<p><code>NSArray</code> 的大多数方法使用 <code>isEqual:</code> 来检查对象间的关系(例如 <code>containsObject:</code> 中)。有一个特别的方法 <code>indexOfObjectIdenticalTo:</code> 用来检查指针相等，如果你确保在同一个集合中搜索，那么这个方法可以很大的提升搜索速度。
在 iOS 7 中，我们最终得到了与 <code>lastObject</code> 对应的公开的 <code>firstObject</code> 方法，对于空数组，这两个方法都会返回 <code>nil</code> — 而常规的访问方法会抛出一个 <code>NSRangeException</code> 异常。</p>

<p>关于构造（可变）数组有一个漂亮的细节可以节省代码量。如果你通过一个可能为 nil 的数组创建一个可变数组，通常会这么写:</p>

<p><code>objc
NSMutableArray *mutableObjects = [array mutableCopy];
if (!mutableObjects) {
    mutableObjects = [NSMutableArray array];
}
</code></p>

<p>或者通过更简洁的<a href="http://en.wikipedia.org/wiki/%3F:">三元运算符</a>:</p>

<p><code>objc
NSMutableArray *mutableObjects = [array mutableCopy] ?: [NSMutableArray array];
</code></p>

<p>更好的解决方案是使用<code>arrayWithArray:</code>，即使原数组为nil，该方法也会返回一个数组对象:</p>

<p><code>objc
NSMutableArray *mutableObjects = [NSMutableArray arrayWithArray:array];
</code></p>

<p>这两个操作在效率上几乎相等。使用 <code>copy</code> 会快一点点，不过话说回来，这不太可能是你应用的瓶颈所在。提醒：不要使用 <code>[@[] mutableCopy]</code>。经典的<code>[NSMutableArray array]</code>可读性更好。</p>

<p>逆序一个数组非常简单：<code>array.reverseObjectEnumerator.allObjects</code>。我们使用系统提供的 <code>reverseObjectEnumerator</code>，每一个 <code>NSEnumerator</code> 都实现了 <code>allObjects</code>，该方法返回一个新数组。虽然没有原生的 <code>randomObjectEnumerator</code> 方法，你可以写一个自定义的打乱数组顺序的枚举器或者使用一些<a href="https://github.com/mattt/TTTRandomizedEnumerator/blob/master/TTTRandomizedEnumerator/TTTRandomizedEnumerator.m">出色的开源代码</a>。</p>

<h3>数组排序</h3>

<p>有很多各种各样的方法来对一个数组排序。如果数组存储的是字符串对象，<code>sortedArrayUsingSelector:</code>是第一选择:</p>

<p><code>objc
NSArray *array = @[@"John Appleseed", @"Tim Cook", @"Hair Force One", @"Michael Jurewitz"];
NSArray *sortedArray = [array sortedArrayUsingSelector:@selector(localizedCaseInsensitiveCompare:)];
</code></p>

<p>下面的代码对存储数字的内容同样很好，因为 <code>NSNumber</code> 实现了 <code>compare:</code>:</p>

<p><code>objc
NSArray *numbers = @[@9, @5, @11, @3, @1];
NSArray *sortedNumbers = [numbers sortedArrayUsingSelector:@selector(compare:)];
</code></p>

<p>如果想更可控，可以使用基于函数指针的排序方法:</p>

<p><code>objc
- (NSData *)sortedArrayHint;
- (NSArray *)sortedArrayUsingFunction:(NSInteger (*)(id, id, void *))comparator
                          context:(void *)context;
- (NSArray *)sortedArrayUsingFunction:(NSInteger (*)(id, id, void *))comparator
                          context:(void *)context hint:(NSData *)hint;
</code></p>

<p>苹果增加了一个方法来加速使用 <code>sortedArrayHint</code> 的排序。</p>

<blockquote>
  <p>hinted sort 方式在你有一个已排序的大数组 (N 个元素) 并且只改变其中一小部分（P 个添加和删除，这里 P远小于 N）时，会非常有效。你可以重用原来的排序结果，然后在 N 个老项目和 P 个新项目进行一个概念上的归并排序。为了得到合适的 hint，你应该在原来的数组排序后使用 sortedArrayHint 来在你需要的时候(比如在数组改变后想重新排序时)保证持有它。</p>
</blockquote>

<p>因为block的引入，也出现了一些基于block的排序方法:</p>

<p><code>objc
- (NSArray *)sortedArrayUsingComparator:(NSComparator)cmptr;
- (NSArray *)sortedArrayWithOptions:(NSSortOptions)opts
                usingComparator:(NSComparator)cmptr;
</code></p>

<p>性能上来说，不同的方法间并没有太多的不同。有趣的是，基于 selector 的方式是最快的。<a href="https://github.com/steipete/PSTFoundationBenchmark">你可以在 GitHub 上找到测试用的源代码</a>:</p>

<blockquote>
  <p>Sorting 1000000 elements. selector: 4947.90[ms] function: 5618.93[ms] block: 5082.98[ms].</p>
</blockquote>

<h3>二分查找</h3>

<p><code>NSArray</code> 从 iOS 4 / Snow Leopard 开始内置了<a href="http://en.wikipedia.org/wiki/Binary_search_algorithm">二分查找</a></p>

<p>```objc
typedef NS_OPTIONS(NSUInteger, NSBinarySearchingOptions) {
    NSBinarySearchingFirstEqual     = (1UL « 8),
    NSBinarySearchingLastEqual      = (1UL « 9),
    NSBinarySearchingInsertionIndex = (1UL « 10),
};</p>

<ul>
  <li>(NSUInteger)indexOfObject:(id)obj
        inSortedRange:(NSRange)r
              options:(NSBinarySearchingOptions)opts
      usingComparator:(NSComparator)cmp;
```</li>
</ul>

<p>为什么要使用这个方法？类似 <code>containsObject:</code> 和 <code>indexOfObject:</code> 这样的方法从 0 索引开始搜索每个对象直到找到目标 — 这样不需要数组被排序，但是却是 O(n)的效率特性。如果使用二分查找的话，需要数组事先被排序，但在查找时只需要 O(log n) 的时间。因此，对于 一百万条记录，二分查找法最多只需要 21 次比较，而传统的线性查找则平均需要 500,000 次的比较。</p>

<p>这是个简单的衡量二分查找有多快的数据:</p>

<pre><code>Time to search for 1000 entries within 1000000 objects. Linear: 54130.38[ms]. Binary: 7.62[ms]
</code></pre>

<p>作为比较，查找 <code>NSOrderedSet</code> 中的指定索引花费 0.23 毫秒 — 就算和二分查找相比也又快了 30 多倍。</p>

<p>记住排序的开销也是昂贵的。苹果使用复杂度为 O(n*log n) 的归并排序，所以如果你执行一次 <code>indexOfObject:</code> 的话，就没有必要使用二分查找了。</p>

<p>通过指定 <code>NSBinarySearchingInsertionIndex</code>，你可以获得正确的插入索引，以确保在插入元素后仍然可以保证数组的顺序。</p>

<h3>枚举和总览</h3>

<p>作为测试，我们来看一个普通的使用场景。从一个数组中过滤出一些元素组成另一个数组。这些测试都包括了枚举的方法以及使用 API 进行过滤的方式：</p>

<p>```objc
// 第一种方式，使用 <code>indexesOfObjectsWithOptions:passingTest:</code>.
NSIndexSet *indexes = [randomArray indexesOfObjectsWithOptions:NSEnumerationConcurrent
                                               passingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop) {
    return testObj(obj);
}];
NSArray *filteredArray = [randomArray objectsAtIndexes:indexes];</p>

<p>// 使用 predicate 过滤，包括 block 的方式和文本 predicate 的方式
NSArray *filteredArray2 = [randomArray filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(id obj, NSDictionary *bindings) {
    return testObj(obj);
}]];</p>

<p>// 基于 block 的枚举
NSMutableArray *mutableArray = [NSMutableArray array];
[randomArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    if (testObj(obj)) {
        [mutableArray addObject:obj];
    }
}];</p>

<p>// 传统的枚举
NSMutableArray *mutableArray = [NSMutableArray array];
for (id obj in randomArray) {
    if (testObj(obj)) {
        [mutableArray addObject:obj];
    }
}</p>

<p>// 使用 NSEnumerator，传统学院派
NSMutableArray *mutableArray = [NSMutableArray array];
NSEnumerator *enumerator = [randomArray objectEnumerator];
id obj = nil;
while ((obj = [enumerator nextObject]) != nil) {
    if (testObj(obj)) {
        [mutableArray addObject:obj];
    }
}</p>

<p>// 通过下标使用 objectAtIndex：
NSMutableArray *mutableArray = [NSMutableArray array];
for (NSUInteger idx = 0; idx &lt; randomArray.count; idx++) {
    id obj = randomArray[idx];
    if (testObj(obj)) {
        [mutableArray addObject:obj];
    }
}
```</p>

<table><thead><tr><th style="text-align: left;padding-right:1em;">枚举方法 / 时间 [ms]</th><th style="text-align:right;padding-right:1em;">10.000.000 elements</th><th style="text-align:right;padding-right:1em;">10.000 elements</th></tr></thead><tbody><tr><td style="text-align: left;"><code>indexesOfObjects:</code>, concurrent</td><td style="text-align: right;padding-right:1em;">1844.73</td><td style="text-align: right;padding-right:1em;">2.25</td>  
</tr><tr><td style="text-align: left;padding-right:1em;"><code>NSFastEnumeration</code> (<code>for in</code>)</td><td style="text-align: right;padding-right:1em;">3223.45</td><td style="text-align: right;padding-right:1em;">3.21</td>  
</tr><tr><td style="text-align: left;padding-right:1em;"><code>indexesOfObjects:</code></td><td style="text-align: right;padding-right:1em;">4221.23</td><td style="text-align: right;padding-right:1em;">3.36</td>  
</tr><tr><td style="text-align: left;padding-right:1em;"><code>enumerateObjectsUsingBlock:</code></td><td style="text-align: right;padding-right:1em;">5459.43</td><td style="text-align: right;padding-right:1em;">5.43</td>  
</tr><tr><td style="text-align: left;padding-right:1em;"><code>objectAtIndex:</code></td><td style="text-align: right;padding-right:1em;">5282.67</td><td style="text-align: right;padding-right:1em;">5.53</td>  
</tr><tr><td style="text-align: left;padding-right:1em;"><code>NSEnumerator</code></td><td style="text-align: right;padding-right:1em;">5566.92</td><td style="text-align: right;padding-right:1em;">5.75</td>  
</tr><tr><td style="text-align: left;padding-right:1em;"><code>filteredArrayUsingPredicate:</code></td><td style="text-align: right;padding-right:1em;">6466.95</td><td style="text-align: right;padding-right:1em;">6.31</td>  
</tr></tbody></table>

<p>为了更好的理解这里的效率测量，我们首先看一下数组是如何迭代的。</p>

<p><code>indexesOfObjectsWithOptions:passingTest:</code> 必须每次都执行一次 block 因此比传统的使用 <code>NSFastEnumeration</code> 技术的基于 for 循环的枚举要稍微低效一些。但是如果开启了并发枚举，那么前者的速度则会大大的超过后者几乎 2 倍。iPhone 5s 是双核的，所以这说得通。这里并没有体现出来的是 <code>NSEnumerationConcurrent</code> 只对大量的对象有意义，如果你的集合中的对象数量很少，用哪个方法就真的无关紧要。甚至 <code>NSEnumerationConcurrent</code> 上额外的线程管理实际上会使结果变得更慢。</p>

<p>最大的输家是 <code>filteredArrayUsingPredicate:</code>。<code>NSPredicate</code> 需要在这里提及是因为，人们可以写出<a href="http://nshipster.com/nspredicate/">非常复杂的表达式</a>，尤其是用不基于 block 的变体。使用 Core Data 的用户应该会很熟悉。</p>

<p>为了比较的完整，我们也加入了 <code>NSEnumerator</code> 作为比较 — 虽然没有任何理由再使用它了。然而它竟出人意料的快(至少还是比基于 <code>NSPredicate</code> 的过滤要快)，它的运行时消耗无疑比快速枚举更多 — 现在它只用于向后兼容。甚至没有优化过的 <code>objectAtIndex:</code> 都要更快些。</p>

<h3 id="nsfastenumeration">NSFastEnumeration</h3>

<p>在OSX 10.5和iOS的最初版本中，苹果增加了 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSFastEnumeration_protocol/Reference/NSFastEnumeration.html"><code>NSFastEnumeration</code></a>。在此之前，只有每次返回一个元素的 <code>NSEnumeration</code> ，每次迭代都有运行时开销。而快速枚举，苹果通过 <code>countByEnumeratingWithState:objects:count:</code> 返回一个数据块。该数据块被解析成 <code>id</code> 类型的 C 数组。这就是更快的速度的原因；迭代一个 C 数组要快得多，而且可以被编译器更深一步的优化。手动的实现快速枚举是十分难办的，所以苹果的 <a href="https://developer.apple.com/library/ios/samplecode/FastEnumerationSample/Introduction/Intro.html">FastEnumerationSample</a> 是一个不错的开始，还有一篇 <a href="http://www.mikeash.com/pyblog/friday-qa-2010-04-16-implementing-fast-enumeration.html">Mike Ash 的文章</a>也很不错。</p>

<h3 id="arraywithcapacity">应该用arrayWithCapacity:吗?</h3>

<p>初始化<code>NSArray</code>的时候，可以选择指定数组的预期大小。在检测的时候，结果是在效率上没有差别 — 至少在统计误差范围内的测量的时间几乎相等。有消息透漏说实际上苹果根本没有使用这个参数。然而使用 <code>arrayWithCapacity:</code> 仍然好处，它可以作为一种隐性的文档来帮助你理解代码:</p>

<blockquote>
  <p>Adding 10.000.000 elements to NSArray. no count 1067.35[ms] with count: 1083.13[ms].</p>
</blockquote>

<h3>子类化注意事项</h3>

<p>很少有理由去子类化基础集合类。大多数时候，使用 CoreFoundation 级别的类并且自定义回调函数定制自定义行为是更好的解决方案。
创建一个大小写不敏感的字典，一种方法是子类化 <code>NSDictionary</code> 并且自定义访问方法，使其将字符串始终变为小写(或大写)，并对排序也做类似的修改。更快更好的解决方案是提供一组不同的 <code>CFDictionaryKeyCallBacks</code> 集，你可以提供自定义的 <code>hash</code> 和 <code>isEqual:</code> 回调。你可以在<a href="https://gist.github.com/steipete/7739473">这里</a>找到一个例子。这种方法的优美之处应该归功于 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html">toll-free 桥接</a>)，它仍然是一个简单的字典，因此可以被任何使用 <code>NSDictionary</code> 作为参数的API接受。</p>

<p>子类作用的一个例子是有序字典的用例。.NET 提供了一个 <code>SortedDictionary</code>，Java 有 <code>TreeMap</code>，C++ 有 <code>std::map</code>。虽然你<em>可以</em>使用 C++ 的 STL 容器，但却无法使它自动的 <code>retain/release</code> ，这会让使用起来笨拙得多。因为 <code>NSDictionary</code> 是一个<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html">类簇</a>，所以子类化跟人们想象的相比非常不同。这已经超过了本文的讨论范畴，<a href="https://github.com/nicklockwood/OrderedDictionary/blob/master/OrderedDictionary/OrderedDictionary.m">这里</a>有一个真实的有序字典的例子。</p>

<h2 id="nsdictionary">NSDictionary</h2>

<p>一个字典存储任意的对象键值对。 由于历史原因，初始化方法 <code>[NSDictionary dictionaryWithObjectsAndKeys:object, key, nil]</code> 使用了相反的值到键的顺序，而新的快捷语法则从 key 开始，<code>@{key : value, ...}</code>。</p>

<p><code>NSDictionary</code> 中的键是被拷贝的并且需要是不变的。如果在一个键在被用于在字典中放入一个值后被改变的话，那么这个值就会变得无法获取了。一个有趣的细节是，在 <code>NSDictionary</code> 中键是被 copy 的，但是在使用一个 toll-free 桥接的 <code>CFDictionary</code> 时却只会被 retain。CoreFoundation 类没有通用的拷贝对象的方法，因此这时拷贝是不可能的(*)。这只适用于你使用 <code>CFDictionarySetValue()</code> 的时候。如果你是通过 <code>setObject:forKey</code> 来使用一个 toll-free 桥接的 <code>CFDictionary</code> 的话，苹果会为其增加额外处理逻辑，使得键被拷贝。但是反过来这个结论则不成立 — 使用已经转换为 <code>CFDictionary</code> 的 <code>NSDictionary</code> 对象，并用对其使用 <code>CFDictionarySetValue()</code> 方法，还是会导致调用回 <code>setObject:forKey</code> 并对键进行拷贝。</p>

<blockquote>
  <p>(*)其实有一个现成的键的回调函数 <code>kCFCopyStringDictionaryKeyCallBacks</code> 可以拷贝字符串，因为对于 ObjC对象来说， <code>CFStringCreateCopy()</code> 会调用 <code>[NSObject copy]</code>，我们可以巧妙使用这个回调来创建一个能进行键拷贝的 <code>CFDictionary</code>。</p>
</blockquote>

<h3>性能特征</h3>

<p>苹果在定义字典的计算复杂度时显得相当低调。唯一的信息可以在 <a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFDictionary.h"><code>CFDictionary</code> 的头文件</a>中找到:</p>

<blockquote>
  <p>对于字典中值的访问时间，不管是在现在还是将来，我们保证在任何一种实现下最坏情况是 O(N)。但通常来说它会是 O(1) (常数时间)。插入和删除操作一般来说也会是常数时间，但是在某些实现中最坏情况将为 O(N*N)。通过键来访问值将比直接访问值要快（如果你有这样的操作要做的话）。对于同样数目的值，字典需要花费比数组多得多的内存空间。</p>
</blockquote>

<p>跟数组相似的，字典根据尺寸的不同使用不同的实现，并在其中无缝切换。</p>

<h3>枚举和总览</h3>

<p>过滤字典有几个不同的方法:</p>

<p>```objc
// 使用 keysOfEntriesWithOptions:passingTest:，可并行
NSSet *matchingKeys = [randomDict keysOfEntriesWithOptions:NSEnumerationConcurrent
                                               passingTest:^BOOL(id key, id obj, BOOL *stop)
{
    return testObj(obj);
}];
NSArray *keys = matchingKeys.allObjects;
NSArray *values = [randomDict objectsForKeys:keys notFoundMarker:NSNull.null];
__unused NSDictionary *filteredDictionary = [NSDictionary dictionaryWithObjects:values
                                                                        forKeys:keys];</p>

<p>// 基于 block 的枚举
NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary];
[randomDict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
    if (testObj(obj)) {
        mutableDictionary[key] = obj;
    }
}];</p>

<p>// NSFastEnumeration
NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary];
for (id key in randomDict) {
    id obj = randomDict[key];
    if (testObj(obj)) {
        mutableDictionary[key] = obj;
    }
}</p>

<p>// NSEnumeration
 NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary];
 NSEnumerator *enumerator = [randomDict keyEnumerator];
 id key = nil;
 while ((key = [enumerator nextObject]) != nil) {
       id obj = randomDict[key];
       if (testObj(obj)) {
           mutableDictionary[key] = obj;
       }
 }</p>

<p>// 基于 C 数组，通过 getObjects:andKeys: 枚举
NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary];
id __unsafe_unretained objects[numberOfEntries];
id __unsafe_unretained keys[numberOfEntries];
[randomDict getObjects:objects andKeys:keys];
for (int i = 0; i &lt; numberOfEntries; i++) {
    id obj = objects[i];
    id key = keys[i];
    if (testObj(obj)) {
       mutableDictionary[key] = obj;
    }
 }
```</p>

<table><thead><tr><th style="text-align: left;min-width:22em;">过滤/枚举方法</th><th style="text-align: right;">Time [ms], 50.000 elements</th><th style="text-align: right;">1.000.000 elements</th></tr></thead><tbody><tr><td style="text-align: left;"><code>keysOfEntriesWithOptions:</code>, concurrent</td><td style="text-align: right;">16.65</td><td style="text-align: right;">425.24</td>  
</tr><tr><td style="text-align: left;"><code>getObjects:andKeys:</code></td><td style="text-align: right;">30.33</td><td style="text-align: right;">798.49*</td>  
</tr><tr><td style="text-align: left;"><code>keysOfEntriesWithOptions:</code></td><td style="text-align: right;">30.59</td><td style="text-align: right;">856.93</td>  
</tr><tr><td style="text-align: left;"><code>enumerateKeysAndObjectsUsingBlock:</code></td><td style="text-align: right;">36.33</td><td style="text-align: right;">882.93</td>  
</tr><tr><td style="text-align: left;"><code>NSFastEnumeration</code></td><td style="text-align: right;">41.20</td><td style="text-align: right;">1043.42</td>  
</tr><tr><td style="text-align: left;"><code>NSEnumeration</code></td><td style="text-align: right;">42.21</td><td style="text-align: right;">1113.08</td>  
</tr></tbody></table>

<p>(*)使用 <code>getObjects:andKeys:</code> 时需要注意。在上面的代码例子中，我们使用了<a href="http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html">可变长度数组</a>这一 C99 特性(通常，数组的数量需要是一个固定值)。这将在栈上分配内存，虽然更方便一点，但却有其限制。上面的代码在元素数量很多的时候会崩溃掉，所以我们使用基于 <code>malloc/calloc</code> 的分配 (和 <code>free</code>) 以确保安全。</p>

<p>为什么这次 <code>NSFastEnumeration</code> 这么慢？迭代字典通常需要键和值两者，快速枚举只能枚举键，我们必须每次都自己获取值。使用基于 block 的 <code>enumerateKeysAndObjectsUsingBlock:</code> 更高效，因为两者都可以更高效的被提前获取。</p>

<p>这次测试的胜利者又是通过 <code>keysOfEntriesWithOptions:passingTest:</code> 和 <code>objectsForKeys:notFoundMarker:</code> 的并发迭代。代码稍微多了一点，但是可以用 category 进行漂亮的封装。</p>

<h3 id="dictionarywithcapacity">应该用 dictionaryWithCapacity: 吗?</h3>

<p>到现在你应该已经知道该如何测试了，简单的回答是不，<code>count</code> 参数没有改变任何事情:</p>

<blockquote>
  <p>Adding 10000000 elements to NSDictionary. no count 10786.60[ms] with count: 10798.40[ms].</p>
</blockquote>

<h3>排序</h3>

<p>关于字典排序没有太多可说的。你只能将键数组排序为一个新对象，因此你可以使用任何正规的 <code>NSArray</code> 的排序方法:</p>

<p><code>objc
- (NSArray *)keysSortedByValueUsingSelector:(SEL)comparator;
- (NSArray *)keysSortedByValueUsingComparator:(NSComparator)cmptr;
- (NSArray *)keysSortedByValueWithOptions:(NSSortOptions)opts
                      usingComparator:(NSComparator)cmptr;
</code></p>

<h3>共享键</h3>

<p>从 iOS 6 和 OS X 10.8 开始，新建的字典可以使用一个预先生成好的键集，使用 <code>sharedKeySetForKeys:</code> 从一个数组中创建键集，然后用 <code>dictionaryWithSharedKeySet:</code> 创建字典。共享键集会复用对象，以节省内存。根据 <a href="https://developer.apple.com/library/mac/releasenotes/Foundation/RN-FoundationOlderNotes/">Foundation Release Notes</a>，<code>sharedKeySetForKeys:</code> 中会计算一个最小完美哈希，这个哈希值可以取代字典查找过程中探索循环的需要，因此使键的访问更快。</p>

<p>虽然在我们有限的测试中没有法线苹果在 <code>NSJSONSerialization</code> 中使用这个特性，但毫无疑问，在处理 JSON 的解析工作时这个特性可以发挥得淋漓尽致。(使用共享键集创建的字典是 <code>NSSharedKeyDictionary</code> 的子类；通常的字典是 <code>__NSDictionaryI</code> / <code>__NSDictionaryM</code>，I / M 表明可变性；可变和不可变的的字典在 toll-free 桥接后对应的都是 <code>_NSCFDictionary</code> 类。)</p>

<p><strong>有趣的细节：</strong>共享键字典<strong>始终是可变的</strong>，即使对它们执行了”copy”命令后也是。这个行为文档中并没有说明，但很容易被测试:</p>

<p><code>objc
id sharedKeySet = [NSDictionary sharedKeySetForKeys:@[@1, @2, @3]]; 
// 返回 NSSharedKeySet
NSMutableDictionary *test = [NSMutableDictionary dictionaryWithSharedKeySet:sharedKeySet];
test[@4] = @"First element (not in the shared key set, but will work as well)";
NSDictionary *immutable = [test copy];
NSParameterAssert(immutable.count == 1);
((NSMutableDictionary *)immutable)[@5] = @"Adding objects to an immutable collection should throw an exception.";
NSParameterAssert(immutable.count == 2);
</code></p>

<h2 id="nsset">NSSet</h2>

<p><code>NSSet</code> 和它的可变变体 <code>NSMutableSet</code> 是无序对象集合。检查一个对象是否存在通常是一个 O(1) 的操作，使得比 <code>NSArray</code> 快很多。<code>NSSet</code> 只在被使用的哈希方法平衡的情况下能高效的工作；如果所有的对象都在同一个哈希筐内，<code>NSSet</code> 在查找对象是否存在时并不比 <code>NSArray</code> 快多少。</p>

<p><code>NSSet</code> 还有变体 <code>NSCountedSet</code>，以及非 toll-free 计数变体 <code>CFBag</code> / <code>CFMutableBag</code>。</p>

<p><code>NSSet</code> 会 retain 它其中的对象，但是根据 set 的规定，对象应该是不可变的。添加一个对象到 set 中随后改变它会导致一些奇怪的问题并破坏 set 的状态。</p>

<p><code>NSSet</code> 的方法比 <code>NSArray</code> 少的多。没有排序方法，但有一些方便的枚举方法。重要的方法有 <code>allObjects</code>，将对象转化为 <code>NSArray</code>，<code>anyObject</code> 则返回任意的对象，如果 set 为空，则返回 nil。</p>

<h3 id="set">Set 操作</h3>

<p><code>NSMutableSet</code> 有几个很强大的方法，例如 <code>intersectSet:</code>，<code>minusSet:</code> 和 <code>unionSet:</code>。</p>

<p><img src="http://img.objccn.io/issue-7/set.png" alt="img" /></p>

<h3 id="setwithcapacity">应该用setWithCapacity:吗?</h3>

<p>我们再一次测试当创建 set 时给定容量大小是否会有显著的速度差异:</p>

<blockquote>
  <p>Adding 1.000.000 elements to NSSet. no count 2928.49[ms] with count: 2947.52[ms].</p>
</blockquote>

<p>在统计误差范围内，结果没有显著差异。有一份证据表明<a href="http://www.cocoawithlove.com/2008/08/nsarray-or-nsset-nsdictionary-or.html">至少在上一个 runtime 版本中，有很多的性能上的影响</a>。</p>

<h3 id="nsset">NSSet 性能特征</h3>

<p>苹果在 <a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFSet.h">CFSet 头文件</a>中没有提供任何关于算法复杂度的注释。</p>

<table><thead><tr><th style="text-align: left;">类 / 时间 [ms]</th><th style="text-align: right;">1.000.000 elements</th></tr></thead><tbody><tr><td style="text-align: left;"><code>NSMutableSet</code>, adding</td><td style="text-align: right;">2504.38</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableArray</code>, adding</td><td style="text-align: right;">1413.38</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableSet</code>, random access</td><td style="text-align: right;">4.40</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableArray</code>, random access</td><td style="text-align: right;">7.95</td>  
</tr></tbody></table>

<p>这个检测非常符合我们的预期：<code>NSSet</code> 在每一个被添加的对象上执行 <code>hash</code> 和 <code>isEqual:</code> 方法并管理一系列哈希值，所以在添加元素时耗费了更多的时间。set的随机访问比较难以测试，因为这里执行的都是 <code>anyObject</code>。</p>

<p>这里没有必要包含 <code>containsObject:</code> 的测试，set 要快几个数量级，毕竟这是它的特点。</p>

<h3 id="nsorderedset">NSOrderedSet</h3>

<p><code>NSOrderedSet</code> 在 iOS 5 和 Mac OS X 10.7 中第一次被引入，除了 Core Data，几乎没有直接使用它的 API。看上去它综合了 <code>NSArray</code> 和 <code>NSSet</code> 两者的好处，对象查找，对象唯一性，和快速随机访问。</p>

<p><code>NSOrderedSet</code> 有着优秀的 API 方法，使得它可以很便利的与其他 set 或者有序 set 对象合作。合并，交集，差集，就像 <code>NSSet</code> 支持的那样。它有 <code>NSArray</code> 中除了比较陈旧的基于函数的排序方法和二分查找以外的大多数排序方法。毕竟 <code>containsObject:</code> 非常快，所以没有必要再用二分查找了。</p>

<p><code>NSOrderedSet</code> 的 <code>array</code> 和 <code>set</code> 方法分别返回一个 <code>NSArray</code> 和 <code>NSSet</code>，这些对象表面上是不可变的对象，但实际上在 NSOrderedSet 更新的时候，它们也会更新自己。如果你在不同线程上使用这些对象并发生了诡异异常的时候，知道这一点是非常有好处的。本质上，这些类使用的是 <code>__NSOrderedSetSetProxy</code> 和 <code>__NSOrderedSetArrayProxy</code>。</p>

<p>附注：如果你想知道为什么 <code>NSOrderedSet</code> 不是 <code>NSSet</code> 的子类，<a href="http://nshipster.com/nsorderedset/">NSHipster 上有一篇非常好的文章解释了可变/不可变类簇的缺点</a>。</p>

<h3 id="nsorderedset">NSOrderedSet 性能特征</h3>

<p>如果你看到这份测试，你就会知道 <code>NSOrderedSet</code> 代价高昂了，毕竟天下没有免费的午餐:</p>

<table><thead><tr><th style="text-align: left;">类 / 时间 [ms]</th><th style="text-align: right;">1.000.000 elements</th></tr></thead><tbody><tr><td style="text-align: left;"><code>NSMutableOrderedSet</code>, adding</td><td style="text-align: right;"><strong>3190.52</strong></td>  
</tr><tr><td style="text-align: left;"><code>NSMutableSet</code>, adding</td><td style="text-align: right;">2511.96</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableArray</code>, adding</td><td style="text-align: right;">1423.26</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableOrderedSet</code>, random access</td><td style="text-align: right;"><strong>10.74</strong></td>  
</tr><tr><td style="text-align: left;"><code>NSMutableSet</code>, random access</td><td style="text-align: right;">4.47</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableArray</code>, random access</td><td style="text-align: right;">8.08</td>  
</tr></tbody></table>

<p>这个测试在每一个集合类中添加自定义字符串，随后随机访问它们。</p>

<p><code>NSOrderedSet</code> 比 <code>NSSet</code> 和 <code>NSArray</code> 占用更多的内存，因为它需要同时维护哈希值和索引。</p>

<h3 id="nshashtable">NSHashTable</h3>

<p><code>NSHashTable</code> 效仿了 <code>NSSet</code>，但在对象/内存处理时更加的灵活。可以通过自定义 <code>CFSet</code> 的回调获得 <code>NSHashTable</code> 的一些特性，哈希表可以保持对对象的弱引用并在对象被销毁之后正确的将其移除，有时候如果手动在 NSSet 中添加的话，想做到这个是挺恶心的一件事。它是默认可变的 — 并且这个类没有相应的不可变版本。</p>

<p><code>NSHashTable</code> 有 ObjC 和原始的 C API，C API 可以用来存储任意对象。苹果在 10.5 Leopard 系统中引入了这个类，但是 iOS 的话直到最近的 iOS 6 中才被加入。足够有趣的是它们只移植了 ObjC API；更多强大的 C API 没有包括在 iOS 中。</p>

<p><code>NSHashTable</code> 可以通过 <code>initWithPointerFunctions:capacity:</code> 进行大量的设置 — 我们只选取使用预先定义的 <code>hashTableWithOptions:</code> 这一最普遍的使用场景。其中最有用的选项有利用 <code>weakObjectsHashTable</code> 来使用其自身的构造函数。</p>

<h3 id="nspointerfunctions">NSPointerFunctions</h3>

<p>这些指针函数可以被用在 <code>NSHashTable</code>，<code>NSMapTable</code>和 <code>NSPointerArray</code> 中，定义了对存储在这个集合中的对象的获取和保留行为。这里只介绍最有用的选项。完整列表参见 <code>NSPointerFunctions.h</code>。</p>

<p>有两组选项。内存选项决定了内存管理，个性化定义了哈希和相等。</p>

<p><code>NSPointerFunctionsStrongMemory</code> 创建了一个r etain/release 对象的集合，非常像常规的 <code>NSSet</code> 或 <code>NSArray</code>。</p>

<p><code>NSPointerFunctionsWeakMemory</code> 使用和 <code>__weak</code> 等价的方式来存储对象并自动移除被销毁的对象。</p>

<p><code>NSPointerFunctionsCopyIn</code> 在对象被加入到集合前拷贝它们。</p>

<p><code>NSPointerFunctionsObjectPersonality</code> 使用对象的 <code>hash</code> 和 <code>isEqual:</code> (默认)。</p>

<p><code>NSPointerFunctionsObjectPointerPersonality</code> 对于 <code>isEqual:</code> 和 <code>hash</code> 使用直接的指针比较。</p>

<h3 id="nshashtable">NSHashTable 性能特征</h3>

<table><thead><tr><th style="text-align: left;">类 / 时间 [ms]</th><th style="text-align: right;">1.000.000 elements</th></tr></thead><tbody><tr><td style="text-align: left;"><code>NSHashTable</code>, adding</td><td style="text-align: right;">2511.96</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableSet</code>, adding</td><td style="text-align: right;">1423.26</td>  
</tr><tr><td style="text-align: left;"><code>NSHashTable</code>, random access</td><td style="text-align: right;">3.13</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableSet</code>, random access</td><td style="text-align: right;">4.39</td>  
</tr><tr><td style="text-align: left;"><code>NSHashTable</code>, containsObject</td><td style="text-align: right;">6.56</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableSet</code>, containsObject</td><td style="text-align: right;">6.77</td>  
</tr><tr><td style="text-align: left;"><code>NSHashTable</code>, NSFastEnumeration</td><td style="text-align: right;">39.03</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableSet</code>, NSFastEnumeration</td><td style="text-align: right;">30.43</td>  
</tr></tbody></table>

<p>如果你只是需要 <code>NSSet</code> 的特性，请坚持使用 <code>NSSet</code>。<code>NSHashTable</code> 在添加对象时花费了将近2倍的时间，但是其他方面的效率却非常相近。</p>

<h3 id="nsmaptable">NSMapTable</h3>

<p><code>NSMapTable</code> 和 <code>NSHashTable</code> 相似，但是效仿的是 <code>NSDictionary</code>。因此，我们可以通过 <code>mapTableWithKeyOptions:valueOptions:</code> 分别控制键和值的对象获取/保留行为。存储弱引用是 <code>NSMapTable</code> 最有用的特性，这里有4个方便的构造函数:</p>

<ul>
<li><code>strongToStrongObjectsMapTable</code></li>
<li><code>weakToStrongObjectsMapTable</code></li>
<li><code>strongToWeakObjectsMapTable</code></li>
<li><code>weakToWeakObjectsMapTable</code></li>
</ul>

<p>注意，除了使用 <code>NSPointerFunctionsCopyIn</code>，任何的默认行为都会 retain (或弱引用)键对象而不会拷贝它，这与 <code>CFDictionary</code> 的行为相同而与 <code>NSDictionary</code> 不同。当你需要一个字典，它的键没有实现 <code>NSCopying</code> 协议的时候（比如像 <code>UIView</code>），这会非常有用。</p>

<p>如果你好奇为什么苹果”忘记”为 <code>NSMapTable</code> 增加下标，你现在知道了。下标访问需要一个 <code>id&lt;NSCopying&gt;</code> 作为 key，对 <code>NSMapTable</code> 来说这不是强制的。如果不通过一个非法的 API 协议或者移除 <code>NSCopying</code> 协议来削弱全局下标，是没有办法给它增加下标的。</p>

<p>你可以通过 <code>dictionaryRepresentation</code> 把内容转换为普通的 <code>NSDictionary</code>。不像 <code>NSOrderedSet</code>，这个方法返回的是一个常规的字典而不是一个代理。</p>

<h3 id="nsmaptable">NSMapTable 性能特征</h3>

<table><thead><tr><th style="text-align: left;">类 / 时间 [ms]</th><th style="text-align: right;">1.000.000 elements</th></tr></thead><tbody><tr><td style="text-align: left;"><code>NSMapTable</code>, adding</td><td style="text-align: right;">2958.48</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableDictionary</code>, adding</td><td style="text-align: right;">2522.47</td>  
</tr><tr><td style="text-align: left;"><code>NSMapTable</code>, random access</td><td style="text-align: right;">13.25</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableDictionary</code>, random access</td><td style="text-align: right;">9.18</td>  
</tr></tbody></table>

<p><code>NSMapTable</code> 只比 <code>NSDictionary</code> 略微慢一点。如果你需要一个不 retain 键的字典，放弃 <code>CFDictionary</code> 而使用它吧。</p>

<h3 id="nspointerarray">NSPointerArray</h3>

<p><code>NSPointerArray</code>类是一个稀疏数组，工作起来与 <code>NSMutableArray</code> 相似，但可以存储 <code>NULL</code> 值，并且 <code>count</code> 方法会反应这些空点。可以用 <code>NSPointerFunctions</code> 对其进行各种设置，也有应对常见的使用场景的快捷构造函数 <code>strongObjectsPointerArray</code> 和 <code>weakObjectsPointerArray</code>。</p>

<p>在能使用 <code>insertPointer:atIndex:</code> 之前，我们需要通过直接设置 <code>count</code> 属性来申请空间，否则会产生一个异常。另一种选择是使用 <code>addPointer:</code>，这个方法可以自动根据需要增加数组的大小。</p>

<p>你可以通过 <code>allObjects</code> 将一个 <code>NSPointerArray</code> 转换成常规的 <code>NSArray</code>。这时所有的 <code>NULL</code> 值会被去掉，只有真正存在的对象被加入到数组 — 因此数组的对象索引很有可能会跟指针数组的不同。注意：如果向指针数组中存入任何非对象的东西，试图执行 <code>allObjects</code> 都会造成 <code>EXC_BAD_ACCESS</code> 崩溃，因为它会一个一个地去 retain ”对象”。</p>

<p>从调试的角度讲，<code>NSPointerArray</code>没有受到太多欢迎。<code>description</code>方法只是简单的返回了<code>&lt;NSConcretePointerArray: 0x17015ac50&gt;</code>。为了得到所有的对象需要执行<code>[pointerArray allObjects]</code>，当然，如果存在<code>NULL</code>的话会改变索引。</p>

<h2 id="nspointerarray">NSPointerArray 性能特征</h2>

<p>在性能方面，    <code>NSPointerArray</code> 真的非常非常慢，所以当你打算在一个很大的数据集合上使用它的时候一定要三思。在本测试中我们比较了使用 <code>NSNull</code> 作为空标记的 <code>NSMutableArray</code> ，而对 <code>NSPointerArray</code> 我们用 <code>NSPointerFunctionsStrongMemory</code> 来进行设置 (这样对象会被适当的 retain)。在一个有 10,000 个元素的数组中，我们每隔十个插入一个字符串 ”Entry %d”。此测试包括了用 <code>NSNull.null</code> 填充 <code>NSMutableArray</code> 的总时间。对于 <code>NSPointerArray</code>，我们使用 <code>setCount:</code> 来代替:</p>

<table><thead><tr><th style="text-align: left;">类 / 时间 [ms]</th><th style="text-align: right;">10.000 elements</th></tr></thead><tbody><tr><td style="text-align: left;"><code>NSMutableArray</code>, adding</td><td style="text-align: right;">15.28</td>  
</tr><tr><td style="text-align: left;"><code>NSPointerArray</code>, adding</td><td style="text-align: right;"><strong>3851.51</strong></td>  
</tr><tr><td style="text-align: left;"><code>NSMutableArray</code>, random access</td><td style="text-align: right;">0.23</td>  
</tr><tr><td style="text-align: left;"><code>NSPointerArray</code>, random access</td><td style="text-align: right;">0.34</td>  
</tr></tbody></table>

<p>注意 <code>NSPointerArray</code> 需要的时间比 <code>NSMutableArray</code> 多了超过<em>* 250 倍(!)</em>* 。这非常奇怪和意外。跟踪内存是比较困难的，所以按理说 <code>NSPointerArray</code> 会更高效才对。不过由于我们使用的是同一个 <code>NSNull</code> 来标记空对象，所以除了指针也没有什么更多的消耗。</p>

<h2 id="nscache">NSCache</h2>

<p><code>NSCache</code> 是一个非常奇怪的集合。在 iOS 4 / Snow Leopard 中加入，默认为可变并且线程安全的。这使它很适合缓存那些创建起来代价高昂的对象。它自动对内存警告做出反应并基于可设置的”成本”清理自己。与 <code>NSDictionary</code> 相比，键是被 retain 而不是被 copy 的。</p>

<p><code>NSCache</code> 的回收方法是不确定的，在文档中也没有说明。向里面放一些类似图片那样超大的对象并不是一个好主意，有可能它在能回收之前就更快地把你的 cache 给填满了。(这是在 <a href="http://pspdfkit.com/">PSPDFKit</a> 中很多跟内存有关的 crash 的原因，在使用自定义的基于 LRU 的链表缓存的代码之前，我们起初使用了 <code>NSCache</code> 存储事先渲染的图片。)</p>

<p>可以对 <code>NSCache</code> 进行设置，这样它就能自动回收那些实现了 <code>NSDiscardableContent</code> 协议的对象。实现了该属性的一个比较常用的类是同时间加入的 <code>NSPurgeableData</code>，但是<a href="https://developer.apple.com/library/mac/releasenotes/Foundation/RN-Foundation/index.html#//apple_ref/doc/uid/TP30000742">在 OS X 10.9 之前，它是非完全线程安全的 (也没有信息表明这个变化也影响到了 iOS，或者说在 iOS 7 中被修复了)</a>。</p>

<h3 id="nscache">NSCache 性能</h3>

<p>那么相比起 <code>NSMutableDictionary</code> 来说，<code>NSCache</code> 表现如何呢？加入的线程安全必然会带来一些消耗。处于好奇，我也加入了一个自定义的线程安全的字典的子类 (<a href="https://gist.github.com/steipete/5928916">PSPDFThreadSafeMutableDictionary</a>)，它通过 <code>OSSpinLock</code> 实现同步的访问。</p>

<table><thead><tr><th style="text-align: left;min-width:28em;">类 / 时间 [ms]</th><th style="text-align: right;">1.000.000 elements</th><th style="text-align: right;">iOS 7x64 Simulator</th><th style="text-align: right;">iPad Mini iOS 6</th></tr></thead><tbody><tr><td style="text-align: left;"><code>NSMutableDictionary</code>, adding</td><td style="text-align: right;">195.35</td><td style="text-align: right;">51.90</td><td style="text-align: right;">921.02</td>  
</tr><tr><td style="text-align: left;"><code>PSPDFThreadSafeMutableDictionary</code>, adding</td><td style="text-align: right;">248.95</td><td style="text-align: right;">57.03</td><td style="text-align: right;">1043.79</td>  
</tr><tr><td style="text-align: left;"><code>NSCache</code>, adding</td><td style="text-align: right;">557.68</td><td style="text-align: right;">395.92</td><td style="text-align: right;">1754.59</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableDictionary</code>, random access</td><td style="text-align: right;">6.82</td><td style="text-align: right;">2.31</td><td style="text-align: right;">23.70</td>  
</tr><tr><td style="text-align: left;"><code>PSPDFThreadSafeMutableDictionary</code>, random access</td><td style="text-align: right;">9.09</td><td style="text-align: right;">2.80</td><td style="text-align: right;">32.33</td>  
</tr><tr><td style="text-align: left;"><code>NSCache</code>, random access</td><td style="text-align: right;">9.01</td><td style="text-align: right;"><strong>29.06</strong></td><td style="text-align: right;">53.25</td>  
</tr></tbody></table>

<p><code>NSCache</code> 表现的相当好，随机访问跟我们自定义的线程安全字典一样快。如我们预料的，添加更慢一些，因为 <code>NSCache</code> 要多维护一个决定何时回收对象的成本系数。就这一点来看这不是一个非常公平的比较。有趣的是，在模拟器上运行效率要慢了几乎 10 倍。无论对 32 或 64 位的系统都是这样。而且看起来这个类已经在 iOS 7 中优化过，或者是受益于 64 位 runtime 环境。当在老的设备上测试时，使用 <code>NSCache</code> 的性能消耗就明显得多。</p>

<p>iOS 6(32 bit) 和 iOS 7(64 bit) 的区别也很明显，因为 64 位运行时使用<a href="http://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html">标签指针 (tagged pointer)</a>，因此我们的 <code>@(idx)</code> boxing 要更为高效。</p>

<h2 id="nsindexset">NSIndexSet</h2>

<p>有些使用场景下 <code>NSIndexSet</code> (和它的可变变体，<code>NSMutableIndexSet</code>) 真的非常出色，对它的使用贯穿在 Foundation 中。它可以用一种非常高效的方法存储一组无符号整数的集合，尤其是如果只是一个或少量范围的时候。正如 set 这个名字已经暗示的那样，每一个 <code>NSUInteger</code> 要么在索引 set 中，要么不在。如果你需要存储任意非唯一的数的时候，最好使用 <code>NSArray</code>。</p>

<p>下面是如何把一个整数数组转换为 <code>NSIndexSet</code>:</p>

<p><code>objc
NSIndexSet *PSPDFIndexSetFromArray(NSArray *array) {
    NSMutableIndexSet *indexSet = [NSMutableIndexSet indexSet];
    for (NSNumber *number in array) {
        [indexSet addIndex:[number unsignedIntegerValue]];
    }
    return [indexSet copy];
}   
</code></p>

<p>如果不使用block，从索引set中拿到所有的索引有点麻烦，<code>getIndexes:maxCount:inIndexRange:</code> 是最快的方法，其次是使用 <code>firstIndex</code> 并迭代直到 <code>indexGreaterThanIndex:</code> 返回 <code>NSNotFound</code>。随着 block 的到来，使用 <code>NSIndexSet</code> 工作变得方便的多:</p>

<p><code>objc
NSArray *PSPDFArrayFromIndexSet(NSIndexSet *indexSet) {
    NSMutableArray *indexesArray = [NSMutableArray arrayWithCapacity:indexSet.count];
    [indexSet enumerateIndexesUsingBlock:^(NSUInteger idx, BOOL *stop) {
       [indexesArray addObject:@(idx)];
    }];
    return [indexesArray copy];
}
</code></p>

<h3 id="nsindexset">NSIndexSet性能</h3>

<p>Core Foundation 中没有和 <code>NSIndexSet</code> 相当的类，苹果也没有对性能做出任何承诺。<code>NSIndexSet</code> 和 <code>NSSet</code> 之间的比较也相对的不公平，因为常规的 set 需要对数字进行包装。为了缓解这个影响，这里的测试准备了实现包装好的 <code>NSUintegers</code> ，并且在两个循环中都会执行 <code>unsignedIntegerValue</code>:</p>

<table><thead><tr><th style="text-align: left;min-width:28em;">类 / 时间 [ms]</th><th style="text-align: right;">1.000.000 elements</th><th style="text-align: right;">iOS 7x64 Simulator</th><th style="text-align: right;">iPad Mini iOS 6</th></tr></thead><tbody><tr><td style="text-align: left;"><code>NSMutableDictionary</code>, adding</td><td style="text-align: right;">195.35</td><td style="text-align: right;">51.90</td><td style="text-align: right;">921.02</td>  
</tr><tr><td style="text-align: left;"><code>PSPDFThreadSafeMutableDictionary</code>, adding</td><td style="text-align: right;">248.95</td><td style="text-align: right;">57.03</td><td style="text-align: right;">1043.79</td>  
</tr><tr><td style="text-align: left;"><code>NSCache</code>, adding</td><td style="text-align: right;">557.68</td><td style="text-align: right;">395.92</td><td style="text-align: right;">1754.59</td>  
</tr><tr><td style="text-align: left;"><code>NSMutableDictionary</code>, random access</td><td style="text-align: right;">6.82</td><td style="text-align: right;">2.31</td><td style="text-align: right;">23.70</td>  
</tr><tr><td style="text-align: left;"><code>PSPDFThreadSafeMutableDictionary</code>, random access</td><td style="text-align: right;">9.09</td><td style="text-align: right;">2.80</td><td style="text-align: right;">32.33</td>  
</tr><tr><td style="text-align: left;"><code>NSCache</code>, random access</td><td style="text-align: right;">9.01</td><td style="text-align: right;"><strong>29.06</strong></td><td style="text-align: right;">53.25</td>  
</tr></tbody></table>

<p>我们看到在一百万左右对象的时候，<code>NSIndexSet</code> 开始变得比 <code>NSSet</code> 慢，但只是因为新的运行时和标签指针。在 iOS 6 上运行相同的测试表明，甚至在更高数量级实体的条件下，<code>NSIndexSet</code> 更快。实际上，在大多数应用中，你不会添加太多的整数到索引 set 中。还有一点这里没有测试，就是 <code>NSIndexSet</code> 跟 <code>NSSet</code> 比无疑有更好的内存优化。</p>

<h2>结论</h2>

<p>本文提供了一些真实的测试，使你在使用基础集合类的时候做出有根据的选择。除了上面讨论的类，还有一些不常用但确实有用的类，尤其是 <code>NSCountedSet</code>，<a href="http://nshipster.com/cfbag/"><code>CFBag</code></a>，<a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFTreeRef/Reference/reference.html"><code>CFTree</code></a>，<a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFBitVectorRef/Reference/reference.html"><code>CFBitVector</code></a>和<a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFBinaryHeapRef/Reference/reference.html"><code>CFBinaryHeap</code></a>。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[提高Xcode编译器效率]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/04/10/ti-gao-xcodebian-yi-qi-xiao-lu/"/>
    <updated>2014-04-10T11:21:11+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/04/10/ti-gao-xcodebian-yi-qi-xiao-lu</id>
    <content type="html"><![CDATA[<h2>编译器做些什么？</h2>

<p>本文主要探讨一下编译器主要做些什么，以及如何有效的利用编译器。</p>

<p>简单的说，编译器有两个职责：把 Objective-C 代码转化成低级代码，以及对代码做分析，确保代码中没有任何明显的错误。</p>

<p>现在，Xcode 的默认编译器是 clang。本文中我们提到的编译器都表示 clang。clang 的功能是首先对 Objective-C 代码做分析检查，然后将其转换为低级的类汇编代码：LLVM Intermediate Representation(LLVM 中间表达码)。接着 LLVM 会执行相关指令将 LLVM IR 编译成目标平台上的本地字节码，这个过程的完成方式可以是即时编译 (Just-in-time)，或在编译的时候完成。</p>

<p>LLVM 指令的一个好处就是可以在支持 LLVM 的任意平台上生成和运行 LLVM 指令。例如，你写的一个 iOS app, 它可以自动的运行在两个完全不同的架构(Inter 和 ARM)上，LLVM 会根据不同的平台将 IR 码转换为对应的本地字节码。</p>

<p>LLVM 的优点主要得益于它的三层式架构 -- 第一层支持多种语言作为输入(例如 C, ObjectiveC, C++ 和 Haskell)，第二层是一个共享式的优化器(对 LLVM IR 做优化处理)，第三层是许多不同的目标平台(例如 Intel, ARM 和 PowerPC)。在这三层式的架构中，如果你想要添加一门语言到 LLVM 中，那么可以把重要精力集中到第一层上，如果想要增加另外一个目标平台，那么你没必要过多的考虑输入语言。在书 <em>The Architecture of Open Source Applications</em> 中 LLVM 的创建者 (Chris Lattner) 写了一章很棒的内容：关于 <a href="http://www.aosabook.org/en/llvm.html">LLVM 架构</a>。</p>

<p>在编译一个源文件时，编译器的处理过程分为几个阶段。要想查看编译 <em>hello.m</em> 源文件需要几个不同的阶段，我们可以让通过 clang 命令观察：</p>

<pre><code>% clang -ccc-print-phases hello.m

0: input, "hello.m", objective-c
1: preprocessor, {0}, objective-c-cpp-output
2: compiler, {1}, assembler
3: assembler, {2}, object
4: linker, {3}, image
5: bind-arch, "x86_64", {4}, image
</code></pre>

<p>本文我们将重点关注第一阶段和第二阶段。在文章 <a href="http://objccn.io/issue-6-3/">Mach-O Executables</a> 中，Daniel 会对第三阶段和第四阶段进行阐述。</p>

<h3>预处理</h3>

<p>每当编源译文件的时候，编译器首先做的是一些预处理工作。比如预处理器会处理源文件中的宏定义，将代码中的宏用其对应定义的具体内容进行替换。</p>

<p>例如，如果在源文件中出现下述代码：</p>

<p><code>objc
#import &lt;Foundation/Foundation.h&gt;;
</code></p>

<p>预处理器对这行代码的处理是用 Foundation.h 文件中的内容去替换这行代码，如果 Foundation.h 中也使用了类似的宏引入，则会按照同样的处理方式用各个宏对应的真正代码进行逐级替代。</p>

<p>这也就是为什么人们主张头文件最好尽量少的去引入其他的类或库，因为引入的东西越多，编译器需要做的处理就越多。例如，在头文件中用：</p>

<p><code>objc
@class MyClass;
</code></p>

<p>代替：</p>

<p><code>objc
#import "MyClass.h"
</code></p>

<p>这么写是告诉编译器 MyClass 是一个类，并且在 .m 实现文件中可以通过 import <code>MyClass.h</code> 的方式来使用它。</p>

<p>假设我们写了一个简单的 C 程序 <code>hello.c</code>:</p>

<p>```c
#include <stdio.h /></p>

<p>int main() {
  printf(“hello world\n”);
  return 0;
}
```</p>

<p>然后给上面的代码执行以下预处理命令，看看是什么效果：</p>

<pre><code>clang -E hello.c | less
</code></pre>

<p>接下来看看处理后的代码，一共是 401 行。如果将如下一行代码添加到上面代码的顶部：：</p>

<p><code>objc
#import &lt;Foundation/Foundation.h&gt;
</code></p>

<p>再执行一下上面的预处理命令，处理后的文件代码行数暴增至 89,839 行。这个数字比某些操作系统的总代码行数还要多。</p>

<p>幸好，目前的情况已经改善许多了：引入了<a href="http://clang.llvm.org/docs/Modules.html">模块 - modules</a>功能，这使预处理变得更加的高级。</p>

<h4>自定义宏</h4>

<p>我们来看看另外一种情形定义或者使用自定义宏，比如定义了如下宏：</p>

<p><code>objc
#define MY_CONSTANT 4
</code></p>

<p>那么，凡是在此行宏定义作用域内，输入了 <code>MY_CONSTANT</code>，在预处理过程中 <code>MY_CONSTANT</code> 都会被替换成 <code>4</code>。我们定义的宏也是可以携带参数的， 比如：</p>

<p><code>objc
#define MY_MACRO(x) x
</code></p>

<p>鉴于本文的内容所限，就不对强大的预处理做更多、更全面的展开讨论了。但是还是要强调一点，建议大家不要在需要预处理的代码中加入内联代码逻辑。</p>

<p>例如，下面这段代码，这样用没什么问题：</p>

<p>```c
#define MAX(a,b) a &gt; b ? a : b</p>

<p>int main() {
  printf(“largest: %d\n”, MAX(10,100));
  return 0;
}
```</p>

<p>但是如果换成这么写：</p>

<p>```c
#define MAX(a,b) a &gt; b ? a : b</p>

<p>int main() {
  int i = 200;
  printf(“largest: %d\n”, MAX(i++,100));
  printf(“i: %d\n”, i);
  return 0;
}
```</p>

<p>用clang的max.c编译一下，结果是：</p>

<pre><code>largest: 201
i: 202
</code></pre>

<p>用 <code>clang -E max.c</code> 进行宏展开的预处理结果是如下所示：</p>

<p><code>c
int main() {
  int i = 200;
  printf("largest: %d\n", i++ &gt; 100 ? i++ : 100);
  printf("i: %d\n", i);
  return 0;
}
</code></p>

<p>本例是典型的宏使用不当，而且通常这类问题非常隐蔽且难以 debug 。针对本例这类情况，最好使用 <code>static inline</code>:</p>

<p>```c
#include <stdio.h>
static const int MyConstant = 200;</stdio.h></p>

<p>static inline int max(int l, int r) {
   return l &gt; r ? l : r;
}</p>

<p>int main() {
  int i = MyConstant;
  printf(“largest: %d\n”, max(i++,100));
  printf(“i: %d\n”, i);
  return 0;
}
```</p>

<p>这样改过之后，就可以输出正常的结果 (<code>i:201</code>)。因为这里定义的代码是内联的 (inlined)，所以它的效率和宏变量差不多，但是可靠性比宏定义要好许多。再者，还可以设置断点、类型检查以及避免异常行为。</p>

<p>基本上，宏的最佳使用场景是日志输出，可以使用 <code>__FILE__</code> 和 <code>__LINE__</code> 和 assert 宏。</p>

<h3>词法解析标记</h3>

<p>预处理完成以后，每一个 <code>.m</code> 源文件里都有一堆的声明和定义。这些代码文本都会从 string 转化成特殊的标记流。</p>

<p>例如，下面是一段简单的 Objective-C hello word 程序：</p>

<p><code>objc
int main() {
  NSLog(@"hello, %@", @"world");
  return 0;
}
</code></p>

<p>利用 clang 命令 <code>clang -Xclang -dump-tokens hello.m</code> 来将上面代码的标记流导出：</p>

<pre><code>int 'int'        [StartOfLine]  Loc=&lt;hello.m:4:1&gt;
identifier 'main'        [LeadingSpace] Loc=&lt;hello.m:4:5&gt;
l_paren '('             Loc=&lt;hello.m:4:9&gt;
r_paren ')'             Loc=&lt;hello.m:4:10&gt;
l_brace '{'      [LeadingSpace] Loc=&lt;hello.m:4:12&gt;
identifier 'NSLog'       [StartOfLine] [LeadingSpace]   Loc=&lt;hello.m:5:3&gt;
l_paren '('             Loc=&lt;hello.m:5:8&gt;
at '@'          Loc=&lt;hello.m:5:9&gt;
string_literal '"hello, %@"'            Loc=&lt;hello.m:5:10&gt;
comma ','               Loc=&lt;hello.m:5:21&gt;
at '@'   [LeadingSpace] Loc=&lt;hello.m:5:23&gt;
string_literal '"world"'                Loc=&lt;hello.m:5:24&gt;
r_paren ')'             Loc=&lt;hello.m:5:31&gt;
semi ';'                Loc=&lt;hello.m:5:32&gt;
return 'return'  [StartOfLine] [LeadingSpace]   Loc=&lt;hello.m:6:3&gt;
numeric_constant '0'     [LeadingSpace] Loc=&lt;hello.m:6:10&gt;
semi ';'                Loc=&lt;hello.m:6:11&gt;
r_brace '}'      [StartOfLine]  Loc=&lt;hello.m:7:1&gt;
eof ''          Loc=&lt;hello.m:7:2&gt;
</code></pre>

<p>仔细观察可以发现，每一个标记都包含了对应的源码内容和其在源码中的位置。注意这里的位置是宏展开之前的位置，这样一来，如果编译过程中遇到什么问题，clang 能够在源码中指出出错的具体位置。</p>

<h3>解析</h3>

<p>接下来要说的东西比较有意思：之前生成的标记流将会被解析成一棵抽象语法树 (abstract syntax tree -- AST)。由于 Objective-C 是一门复杂的语言，因此解析的过程不简单。解析过后，源程序变成了一棵抽象语法树：一棵代表源程序的树。假设我们有一个程序 <code>hello.m</code>：</p>

<p>```objc
#import &lt;Foundation/Foundation.h&gt;</p>

<p>@interface World
- (void)hello;
@end</p>

<p>@implementation World
- (void)hello {
  NSLog(@”hello, world”);
}
@end</p>

<p>int main() {
   World* world = [World new];
   [world hello];
}
```</p>

<p>当我们执行 clang 命令 <code>clang -Xclang -ast-dump -fsyntax-only hello.m</code> 之后，命令行中输出的结果如下所示：：</p>

<p>```objc
@interface World- (void) hello;
@end&gt;
@implementation World
- (void) hello (CompoundStmt 0x10372ded0 &lt;hello.m:8:15, line:10:1&gt;
  (CallExpr 0x10372dea0 &lt;line:9:3, col:24&gt; ‘void’
    (ImplicitCastExpr 0x10372de88 <col:3> 'void (*)(NSString *, ...)' <functiontopointerdecay>
      (DeclRefExpr 0x10372ddd8 <col:3> 'void (NSString *, ...)' Function 0x1023510d0 'NSLog' 'void (NSString *, ...)'))
    (ObjCStringLiteral 0x10372de38 &lt;col:9, col:10&gt; 'NSString *'
      (StringLiteral 0x10372de00 <col:10> 'char [13]' lvalue "hello, world"))))</col:10></col:3></functiontopointerdecay></col:3></p>

<p>@end
int main() (CompoundStmt 0x10372e118 &lt;hello.m:13:12, line:16:1&gt;
  (DeclStmt 0x10372e090 &lt;line:14:4, col:30&gt;
    0x10372dfe0 “World *world =
      (ImplicitCastExpr 0x10372e078 &lt;col:19, col:29&gt; ‘World *’ <bitcast>
        (ObjCMessageExpr 0x10372e048 &lt;col:19, col:29&gt; 'id':'id' selector=new class='World'))")
  (ObjCMessageExpr 0x10372e0e8 &lt;line:15:4, col:16&gt; 'void' selector=hello
    (ImplicitCastExpr 0x10372e0d0 <col:5> 'World *' <lvaluetorvalue>
      (DeclRefExpr 0x10372e0a8 &lt;col:5&gt; 'World *' lvalue Var 0x10372dfe0 'world' 'World *'))))
```</lvaluetorvalue></col:5></bitcast></p>

<p>在抽象语法树中的每个节点都标注了其对应源码中的位置，同样的，如果产生了什么问题，clang 可以定位到问题所在处的源码位置。</p>

<h5>延伸阅读</h5>

<ul>
<li><a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html">clang AST 介绍</a></li>
</ul>

<h3>静态分析</h3>

<p>一旦编译器把源码生成了抽象语法树，编译器可以对这棵树做分析处理，以找出代码中的错误，比如类型检查：即检查程序中是否有类型错误。例如：如果代码中给某个对象发送了一个消息，编译器会检查这个对象是否实现了这个消息（函数、方法）。此外，clang 对整个程序还做了其它更高级的一些分析，以确保程序没有错误。</p>

<h4>类型检查</h4>

<p>每当开发人员编写代码的时候，clang 都会帮忙检查错误。其中最常见的就是检查程序是否发送正确的消息给正确的对象，是否在正确的值上调用了正确的函数。如果你给一个单纯的 <code>NSObject*</code> 对象发送了一个 <code>hello</code> 消息，那么 clang 就会报错。同样，如果你创建了 <code>NSObject</code> 的一个子类 <code>Test</code>, 如下所示：</p>

<p><code>objc
@interface Test : NSObject
@end
</code></p>

<p>然后试图给这个子类中某个属性设置一个与其自身类型不相符的对象，编译器会给出一个可能使用不正确的警告。</p>

<p>一般会把类型分为两类：动态的和静态的。动态的在运行时做检查，静态的在编译时做检查。以往，编写代码时可以向任意对象发送任何消息，在运行时，才会检查对象是否能够响应这些消息。由于只是在运行时做此类检查，所以叫做动态类型。</p>

<p>至于静态类型，是在编译时做检查。当在代码中使用 ARC 时，编译器在编译期间，会做许多的类型检查：因为编译器需要知道哪个对象该如何使用。例如，如果 myObject 没有 hello 方法，那么就不能写如下这行代码了：</p>

<p><code>objc
[myObject hello]
</code></p>

<h4>其他分析</h4>

<p>clang 在静态分析阶段，除了类型检查外，还会做许多其它一些分析。如果你把 clang 的代码仓库 clone 到本地，然后进入目录 <code>lib/StaticAnalyzer/Checkers</code>，你会看到所有静态检查内容。比如 <code>ObjCUnusedIVarsChecker.cpp</code> 是用来检查是否有定义了，但是从未使用过的变量。而 <code>ObjCSelfInitChecker.cpp</code> 则是检查在 你的初始化方法中中调用 <code>self</code> 之前，是否已经调用 <code>[self initWith...]</code> 或 <code>[super init]</code> 了。编译器还进行了一些其它的检查，例如在 <code>lib/Sema/SemaExprObjC.cpp</code> 的 2,534 行，有这样一句：</p>

<p><code>objc
Diag(SelLoc, diag::warn_arc_perform_selector_leaks);
</code></p>

<p>这个会生成严重错误的警告 “performSelector may cause a leak because its selector is unknown” 。</p>

<h2>代码生成</h2>

<p>clang 完成代码的标记，解析和分析后，接着就会生成 LLVM 代码。下面继续看看<code>hello.c</code>：</p>

<p>```c
#include <stdio.h /></p>

<p>int main() {
  printf(“hello world\n”);
  return 0;
}
```</p>

<p>要把这段代码编译成 LLVM 字节码（绝大多数情况下是二进制码格式），我们可以执行下面的命令：</p>

<pre><code>clang -O3 -emit-LLVM hello.c -c -o hello.bc
</code></pre>

<p>接着用另一个命令来查看刚刚生成的二进制文件：</p>

<pre><code>llvm-dis &lt; hello.bc | less
</code></pre>

<p>输出如下：</p>

<pre><code>; ModuleID = '&lt;stdin&gt;'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.8.0"

@str = private unnamed_addr constant [12 x i8] c"hello world\00"

; Function Attrs: nounwind ssp uwtable
define i32 @main() #0 {
  %puts = tail call i32 @puts(i8* getelementptr inbounds ([12 x i8]* @str, i64 0, i64 0))
  ret i32 0
}

; Function Attrs: nounwind
declare i32 @puts(i8* nocapture) #1

attributes #0 = { nounwind ssp uwtable }
attributes #1 = { nounwind }
</code></pre>

<p>在上面的代码中，可以看到 <code>main</code> 函数只有两行代码：一行输出string，另一行返回 <code>0</code>。</p>

<p>再换一个程序，拿 <code>five.m</code> 为例，对其做相同的编译，然后执行 <code>LLVM-dis &lt; five.bc | less</code>:</p>

<p>```c
#include <stdio.h>
#import &lt;Foundation/Foundation.h&gt;</stdio.h></p>

<p>int main() {
  NSLog(@”%@”, [@5 description]);
  return 0;
}
```</p>

<p>抛开其他的不说，单看 <code>main</code> 函数：</p>

<pre><code>define i32 @main() #0 {
  %1 = load %struct._class_t** @"\01L_OBJC_CLASSLIST_REFERENCES_$_", align 8
  %2 = load i8** @"\01L_OBJC_SELECTOR_REFERENCES_", align 8, !invariant.load !4
  %3 = bitcast %struct._class_t* %1 to i8*
  %4 = tail call %0* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to %0* (i8*, i8*, i32)*)(i8* %3, i8* %2, i32 5)
  %5 = load i8** @"\01L_OBJC_SELECTOR_REFERENCES_2", align 8, !invariant.load !4
  %6 = bitcast %0* %4 to i8*
  %7 = tail call %1* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to %1* (i8*, i8*)*)(i8* %6, i8* %5)
  tail call void (%1*, ...)* @NSLog(%1* bitcast (%struct.NSConstantString* @_unnamed_cfstring_ to %1*), %1* %7)
  ret i32 0
}
</code></pre>

<p>上面代码中最重要的是第 4 行，它创建了一个 <code>NSNumber</code> 对象。第 7 行，给这个 number 对象发送了一个  <code>description</code> 消息。第 8 行，将 <code>description</code> 消息返回的内容打印出来。</p>

<h3>优化</h3>

<p>要想了解 LLVM 的优化内容，以及 clang 能做哪些优化，我们先看一个略微复杂的 C 程序：这个函数主要是递归计算 <code>阶乘</code>：</p>

<p>```c
#include <stdio.h /></p>

<p>int factorial(int x) {
   if (x &gt; 1) return x * factorial(x-1);
   else return 1;
}</p>

<p>int main() {
  printf(“factorial 10: %d\n”, factorial(10));
}
```</p>

<p>先看看不做优化的编译情况，执行下面命令：</p>

<pre><code>clang -O0 -emit-llvm factorial.c  -c -o factorial.bc &amp;&amp; llvm-dis &lt; factorial.bc
</code></pre>

<p>重点看一下针对 <code>阶乘</code> 部分生成的代码：</p>

<pre><code>define i32 @factorial(i32 %x) #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  store i32 %x, i32* %2, align 4
  %3 = load i32* %2, align 4
  %4 = icmp sgt i32 %3, 1
  br i1 %4, label %5, label %11

; &lt;label&gt;:5                                       ; preds = %0
  %6 = load i32* %2, align 4
  %7 = load i32* %2, align 4
  %8 = sub nsw i32 %7, 1
  %9 = call i32 @factorial(i32 %8)
  %10 = mul nsw i32 %6, %9
  store i32 %10, i32* %1
  br label %12

; &lt;label&gt;:11                                      ; preds = %0
  store i32 1, i32* %1
  br label %12

; &lt;label&gt;:12                                      ; preds = %11, %5
  %13 = load i32* %1
  ret i32 %13
}
</code></pre>

<p>看一下 <code>%9</code> 标注的那一行，这行代码正是递归调用阶乘函数本身，实际上这样调用是非常低效的，因为每次递归调用都要重新压栈。接下来可以看一下优化后的效果，可以通过这样的方式开启优化 -- 将 <code>-03</code> 标志传给 clang：</p>

<pre><code>clang -O3 -emit-llvm factorial.c  -c -o factorial.bc &amp;&amp; llvm-dis &lt; factorial.bc
</code></pre>

<p>现在 <code>阶乘</code> 计算相关代码编译后生成的代码如下：</p>

<pre><code>define i32 @factorial(i32 %x) #0 {
  %1 = icmp sgt i32 %x, 1
  br i1 %1, label %tailrecurse, label %tailrecurse._crit_edge

tailrecurse:                                      ; preds = %tailrecurse, %0
  %x.tr2 = phi i32 [ %2, %tailrecurse ], [ %x, %0 ]
  %accumulator.tr1 = phi i32 [ %3, %tailrecurse ], [ 1, %0 ]
  %2 = add nsw i32 %x.tr2, -1
  %3 = mul nsw i32 %x.tr2, %accumulator.tr1
  %4 = icmp sgt i32 %2, 1
  br i1 %4, label %tailrecurse, label %tailrecurse._crit_edge

tailrecurse._crit_edge:                           ; preds = %tailrecurse, %0
  %accumulator.tr.lcssa = phi i32 [ 1, %0 ], [ %3, %tailrecurse ]
  ret i32 %accumulator.tr.lcssa
}
</code></pre>

<p>即便我们的函数并没有按照<a href="http://en.wikipedia.org/wiki/Tail_call">尾递归</a>的方式编写，clang 仍然能对其做优化处理，让该函数编译的结果中只包含一个循环。当然 clang 能对代码进行的优化还有很多方面。可以看以下这个比较不错的 gcc 的优化例子<a href="http://ridiculousfish.com/blog/posts/will-it-optimize.html">ridiculousfish.com</a>。</p>

<p><strong>延伸阅读</strong></p>

<ul>
<li><a href="http://blog.llvm.org/search/label/optimization">LLVM blog: posts tagged 'optimization'</a></li>
<li><a href="http://blog.llvm.org/2013/05/llvm-33-vectorization-improvements.html">LLVM blog: vectorization improvements</a></li>
<li><a href="http://blog.llvm.org/2011/09/greedy-register-allocation-in-llvm-30.html">LLVM blog: greedy register allocation</a></li>
<li><a href="http://polly.llvm.org/index.html">The Polly project</a></li>
</ul>

<h2>如何在实际中应用这些特性</h2>

<p>刚刚我们探讨了编译的全过程，从标记到解析，从抽象语法树到分析检查，再到汇编。读者不禁要问，为什么要关注这些？</p>

<h3 id="libclangclang">使用 libclan g或 clang 插件</h3>

<p>之所以 clang 很酷：是因为它是一个开源的项目、并且它是一个非常好的工程：几乎可以说全身是宝。使用者可以创建自己的 clang 版本，针对自己的需求对其进行改造。比如说，可以改变 clang 生成代码的方式，增加更强的类型检查，或者按照自己的定义进行代码的检查分析等等。要想达成以上的目标，有很多种方法，其中最简单的就是使用一个名为 <a href="http://clang.llvm.org/doxygen/group__CINDEX.html">libclang</a> 的C类库。libclang 提供的 API 非常简单，可以对 C 和 clang 做桥接，并可以用它对所有的源码做分析处理。不过，根据我的经验，如果使用者的需求更高，那么 libclang 就不怎么行了。针对这种情况，推荐使用 <a href="https://github.com/macmade/ClangKit">Clangkit</a>，它是基于 clang 提供的功能，用 Objective-C 进行封装的一个库。</p>

<p>最后，clang 还提供了一个直接使用 LibTooling 的 C++ 类库。这里要做的事儿比较多，而且涉及到 C++，但是它能够发挥 clang 的强大功能。用它你可以对源码做任意类型的分析，甚至重写程序。如果你想要给 clang 添加一些自定义的分析、创建自己的重构器 (refactorer)、或者需要基于现有代码做出大量修改，甚至想要基于工程生成相关图形或者文档，那么 LibTooling 是很好的选择。</p>

<h3>自定义分析器</h3>

<p>开发者可以按照 <a href="http://clang.LLVM.org/docs/LibASTMatchersTutorial.html">Tutorial for building tools using LibTooling</a> 中的说明去构造 LLVM ，clang 以及 clan g的附加工具。需要注意的是，编译代码是需要花费一些时间的，即时机器已经很快了，但是在编译期间，我还是可以吃顿饭的。</p>

<p>接下来，进入到 LLVM 目录，然后执行命令<code>cd ~/llvm/tools/clang/tools/</code>。在这个目录中，可以创建自己独立的 clang 工具。例如，我们创建一个小工具，用来检查某个库是否正确使用。首先将 <a href="https://github.com/objcio/issue6-compiler-tool">样例工程</a> 克隆到本地，然后输入 <code>make</code>。这样就会生成一个名为 <code>example</code> 的二进制文件。</p>

<p>我们的使用场景是：假如有一个 <code>Observer</code> 类, 代码如下所示：</p>

<p><code>objc
@interface Observer
+ (instancetype)observerWithTarget:(id)target action:(SEL)selector;
@end
</code></p>

<p>接下来，我们想要检查一下每当这个类被调用的时候，在 <code>target</code> 对象中是否都有对应的 <code>action</code> 方法存在。可以写个 C++ 函数来做这件事（注意，这是我第一次写 C++ 程序，可能不那么严谨）：</p>
<p><code>c++
virtual bool VisitObjCMessageExpr(ObjCMessageExpr *E) {
  if (E-&gt;getReceiverKind() == ObjCMessageExpr::Class) {
    QualType ReceiverType = E-&gt;getClassReceiver();
    Selector Sel = E-&gt;getSelector();
    string TypeName = ReceiverType.getAsString();
    string SelName = Sel.getAsString();
    if (TypeName == "Observer" &amp;&amp; SelName == "observerWithTarget:action:") {
      Expr *Receiver = E-&gt;getArg(0)-&gt;IgnoreParenCasts();
      ObjCSelectorExpr* SelExpr = cast&lt;ObjCSelectorExpr&gt;(E-&gt;getArg(1)-&gt;IgnoreParenCasts());
      Selector Sel = SelExpr-&gt;getSelector();
      if (const ObjCObjectPointerType *OT = Receiver-&gt;getType()-&gt;getAs&lt;ObjCObjectPointerType&gt;()) {
        ObjCInterfaceDecl *decl = OT-&gt;getInterfaceDecl();
        if (! decl-&gt;lookupInstanceMethod(Sel)) {
          errs() &lt;&lt; "Warning: class " &lt;&lt; TypeName &lt;&lt; " does not implement selector " &lt;&lt; Sel.getAsString() &lt;&lt; "\n";
          SourceLocation Loc = E-&gt;getExprLoc();
          PresumedLoc PLoc = astContext-&gt;getSourceManager().getPresumedLoc(Loc);
          errs() &lt;&lt; "in " &lt;&lt; PLoc.getFilename() &lt;&lt; " &lt;" &lt;&lt; PLoc.getLine() &lt;&lt; ":" &lt;&lt; PLoc.getColumn() &lt;&lt; "&gt;\n";
        }
      }
    }
  }
  return true;
}
</code></p>

<p>上面的这个方法首先查找消息表达式， 以 <code>Observer</code> 作为接收者， <code>observerWithTarget:action:</code> 作为 selector，然后检查 target 中是否存在相应的方法。虽然这个例子有点儿刻意，但如果你想要利用 AST 对自己的代码库做某些检查，按照上面的例子来就可以了。</p>

<h3 id="clang">clang的其他特性</h3>

<p>clang还有许多其他的用途。比如，可以写编译器插件（例如，类似上面的检查器例子）并且动态的加载到编译器中。虽然我没有亲自实验过，但是我觉得在 Xcode 中应该是可行的。再比如，也可以通过编写 clang 插件来自定义代码样式（具体可以参见 <a href="http://objccn.io/issue-6-1/">编译过程</a>）。</p>

<p>另外，如果想对现有的代码做大规模的重构， 而 Xcode 或 AppCode 本身集成的重构工具无法达你的要求，你完全可以用 clang 自己写个重构工具。听起来有点儿可怕，读读下面的文档和教程，你会发现其实没那么难。</p>

<p>最后，如果是真的有这种需求，你完全可以引导 Xcdoe 使用你自己编译的 clang 。再一次，如果你去尝试，其实这些事儿真的没想象中那么复杂，反而会发现许多个中乐趣。</p>

<h5>延伸阅读</h5>

<ul>
<li><a href="https://github.com/loarabia/Clang-tutorial">Clang Tutorial</a></li>
<li><a href="http://cocoafactory.com/blog/2012/11/23/x86-64-assembly-language-tutorial-part-1/">X86_64 Assembly Language Tutorial</a></li>
<li><a href="http://clang-analyzer.llvm.org/xcode.html">Custom clang Build with Xcode (I)</a> 和 <a href="http://stackoverflow.com/questions/3297986/using-an-external-xcode-clang-static-analyzer-binary-with-additional-checks">(II)</a></li>
<li><a href="http://kevinaboos.wordpress.com/2013/07/23/clang-tutorial-part-i-introduction/">Clang Tutorial (I)</a>, <a href="http://kevinaboos.wordpress.com/2013/07/23/clang-tutorial-part-ii-libtooling-example/">(II)</a> 和 <a href="http://kevinaboos.wordpress.com/2013/07/29/clang-tutorial-part-iii-plugin-example/">(III)</a></li>
<li><a href="http://getoffmylawnentertainment.com/blog/2011/10/01/clang-plugin-development-tutorial/">Clang Plugin Tutorial</a></li>
<li><a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">LLVM blog: What every C programmer should know (I)</a> , <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html">(II)</a> 和 <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html">(III)</a></li>
</ul>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode编译你所不知道的细节]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/04/10/xcodebian-yi-ni-suo-bu-zhi-dao-de-xi-jie/"/>
    <updated>2014-04-10T11:09:26+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/04/10/xcodebian-yi-ni-suo-bu-zhi-dao-de-xi-jie</id>
    <content type="html"><![CDATA[<p>近些日子我们被宠坏了 -- 我们只需要单击 Xcode 中的一个按钮（这个按钮看起来有点像是在播放一些音乐的动作），过几秒钟之后，我们的程序就会运行起来了，直到遇到一些错误，这非常的神奇。</p>

<p>在本文中，我们将从更高级别的角度来解读 Build 过程，并探索一下在 Xcode 界面中暴露出的 project setting 信息与 Build 过程有什么关系。为了更加深入的探索 Build 过程中，每一步实际执行的工作，我都会在本文中引入一些别的文章。</p>

<h2 id="build">解密 Build 日志</h2>

<p>为了了解 Xcode build 过程的内部工作原理，我们首先把突破口瞄准完整的 log 文件上。打开 Log Navigator ，从列表中选择一个 Build ，Xcode 会将 log 文件很完美的展现出来。</p>

<p><img src="http://img.objccn.io/issue-6/build-log.png" alt="Xcode build log navigator" /></p>

<p>默认情况下，上面的 Xcode 界面中隐藏了大量的信息，我们通过选择任务，然后点击右边的展开按钮，就能看到每个任务的详细信息。另外一种可选的方案就是选中列表中的一个或者多个任务，然后选择组合键 Cmd-C，这将会把所有的纯文本信息拷贝至粘贴板。最后，我们还可以选择 Editor 菜单中的 "Copy transcript for shown results"，以此将所有的 log 信息拷贝到粘贴板中。</p>

<p>本文给出的示例中，log 信息将近有 10,000 行（其实大多数的 log 信息是编译 OpenSSL 时生成的，并不是我们自己所写的代码生成的）。下面我们就开始吧！</p>

<p>注意观察输出的 log 信息，首先会发现 log 信息被分为不同的几大块，它们与我们工程中的targets相互对应着：</p>

<pre><code>Build target Pods-SSZipArchive
...
Build target Makefile-openssl
...
Build target Pods-AFNetworking
...
Build target crypto
...
Build target Pods
...
Build target ssl
...
Build target objcio
</code></pre>

<p>本文涉及到的工程有几个依赖项：其中 AFNetworking 和 SSZipArchive 包含在 Pods 中，而 OpenSSL 则以子工程的形式包含在工程中。</p>

<p>针对工程中的每个 target，Xcode 都会执行一系列的操作，将相关的源码，根据所选定的平台，转换为机器可读的二进制文件。下面我们详细的了解一下第一个 target：SSZipArchive。</p>

<p>在针对这个 target 输出的 log 信息中，我们可以看到每个任务被执行的详细情况。例如第一个任务是处理一个预编译头文件（为了增强 log 信息的可读性，我省略了许多细节）：</p>
<pre><code>(1) ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7 objective-c com.apple.compilers.llvm.clang.1_0.compiler
(2) cd /.../Dev/objcio/Pods
	setenv LANG en_US.US-ASCII
	setenv PATH "..."
(3) /.../Xcode.app/.../clang 
(4) -x objective-c-header 
(5) -arch armv7 
... configuration and warning flags ...
(6) -DDEBUG=1 -DCOCOAPODS=1 
... include paths and more ...
(7) -c 
(8) /.../Pods-SSZipArchive-prefix.pch 
(9) -o /.../Pods-SSZipArchive-prefix.pch.pch
</code></pre>

<p>在 build 处理过程中，每个任务都会出现类似上面的这些 log 信息，我们就通过上面的 log 信息进一步了解详情。</p>

<ol>
<li>类似上面的每个 log 信息块都会利用一行 log 信息来描述相关的任务作为起点。  </li>
<li>接着输出带缩进的3行 log 信息，列出了该任务执行的语句。此处，工作目录发生了改变，并对PANG和PATH环境变量进行设置。  </li>
<li>这里是发生奇迹的地方。为了处理一个<code>.pch</code>文件，调用了 clang，并附带了许多可选项。下面跟着输出的 log 信息显示了显示了完整的调用过程，以及所有的参数。我们看看其中的几个参数...  </li>
<li><code>-x</code> 标示符用来指定所使用的语言，此处是 <code>objective-c-header</code>。  </li>
<li>目标架构指定为 <code>armv7</code>。  </li>
<li>暗示 <code>#defines</code> 的内容已经被添加了。  </li>
<li><code>-c</code> 标示符用来告诉 clang 具体该如何做。<code>-c</code> 表示：运行预处理器、词法分析器、类型检查、LLVM 的生成和优化，以及 target 指定汇编代码的生成阶段，最后，运行汇编器以产出一个<code>.o</code>的目标文件。  </li>
<li>输入文件。  </li>
<li>输出文件。</li>
</ol>

<p>虽然有大量的 log 信息，不过我不会对每个任务做详细的介绍。我们的重点是让你全面的了解在整个 build 过程中，哪些工具会被调用，以及背后会使用到了哪些参数。</p>

<p>针对这个 target ，虽然只有一个 <code>.pch</code> 文件，但实际上这里对 <code>objective-c-header</code> 文件的处理有两个任务。通过观察具体输出的 log 信息，我们可以知道详情：</p>

<pre><code>ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7 objective-c ...
ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7s objective-c ...
</code></pre>

<p>从上面的 log 信息中，可以明显的看出 target 针对两种架构做了 build -- armv7 和 armv7s -- 因此 clang 对文件做了两次处理，每次针对一种架构。</p>

<p>在处理预编译头文件之后，可以看到针对 SSZipArchive target 有另外的几个任务类型。</p>

<pre><code>CompileC ...
Libtool ...
CreateUniversalBinary ...
</code></pre>

<p>顾名思义：<code>CompileC</code> 用来编译 <code>.m</code> 和 <code>.c</code> 文件，<code>Libtool</code> 用来从目标文件中构建 library，而 <code>CreateUniversalBinary</code> 则将上一阶段产生的两个 <code>.a</code> 文件（每个文件对应一种架构）合并为一个通用的二进制文件，这样就能同时在 armv7 和 armv7s 上面运行。</p>

<p>接着，在工程中其它一些依赖项也会发生于此类似的步骤。AFNetworking 被编译之后，会与 SSZipArchive 进行链接，以当做 pod library。OpenSSL 编译之后，会接着处理 crypto 和 ssl target。</p>

<p>当所有的依赖项都 build 完成之后，就轮到我们程序的 target 了。Build 该 target 时，输出的 log 信息会包含一些非常有价值，并且之前没有出现过的内容：</p>

<pre><code>PhaseScriptExecution ...
DataModelVersionCompile ...
Ld ...
GenerateDSYMFile ...
CopyStringsFile ...
CpResource ...
CopyPNGFile ...
CompileAssetCatalog ...
ProcessInfoPlistFile ...
ProcessProductPackaging /.../some-hash.mobileprovision ...
ProcessProductPackaging objcio/objcio.entitlements ...
CodeSign ...
</code></pre>

<p>在上面的任务列表中，根据名称不能区分的唯一任务可能就是 <code>Ld</code>，<code>Ld</code> 是一个 linker 工具的名称，与 <code>libtool</code> 非常相似。实际上，<code>libtool</code>也是简单的调用 <code>ld</code> 和 <code>lipo</code>。'ld'被用来构建可执行文件，而<code>libtool</code>则用来构建 library 文件。阅读<a href="http://www.objccn.io/issue-6-3">Daniel</a> 和 <a href="http://www.objccn.io/issue-6-2">Chris</a>两篇文章，可以了解到更多关于编译和链接的工作原理。</p>

<p>上面每一个步骤，实际上都会调用相关的命令行工具来做实际的工作，这跟之前我们看到的的 <code>ProcessPCH</code> 类似。至此，我将不会继续介绍这些 log 信息了，我将带领大家从另外一个不同的角度来继续探索这些任务：Xcode 是如何知道哪些任务需要被执行？</p>

<h2 id="build">Build过程的控制</h2>

<p>当你选择 Xcode 5 中的一个工程时，会在 project editor 顶部显示出 6 个 tabs：General, Capabilities, Info, Build Settings, Build Phases 以及 Build Rules。</p>

<p><img src="http://img.objccn.io/issue-6/project-editor-tabs.png" alt="Xcode project editor tabs" /></p>

<p>对于我们理解 build 过程来说，其中最后 3 项与 build 过程紧密相连。</p>

<h3 id="buildphases">Build Phases</h3>

<p>Build Phases 代表着将代码转变为可执行文件的最高级别规则。里面描述了 build 过程中必须执行的不同类型规则。</p>

<p><img src="http://img.objccn.io/issue-6/build-phases.png" alt="Xcode build phases" /></p>

<p>首先是 target 依赖项的构建。这里会告诉 build 系统，build 当前的 target 之前，必须先对这里的依赖性进行 build。实际上这并不属于真正的 build phase，在这里，Xcode 只不过将其与 build phase 显示到一块罢了。</p>

<p>接着在 build phase中是一个 CocoaPods 相关的脚本 <em>script execution</em> -- 更多 CocoaPods 相关信息和 它的 build 过程可以查看<a href="http://www.objc.io/issue-6-4">Michele的文章</a> -- 接着在 <code>Compile Sources</code> section 中规定了所有必须参与编译的文件。需要留意的是，这里并没有指明这些文件是<em>如何</em>被编译处理的。关于处理这些文件的更多内容，我们将在研究 build rules 和 build settings 时学习到。此处列出的所有文件将根据相关的 rules 和 settings 被处理。</p>

<p>当编译结束之后，接下来就是将编译所生成的目标文件链接到一块。注意观察，Xcode 中的 build phase 之后是："Link Binary with Libraries." 这里面列出了所有的静态库和动态库，这些库会参与上面编译阶段生成的目标文件进行链接。静态库和动态库的处理过程有非常大的区别，相关内容请参考 Daniel的文章 <a href="http://www.objccn.io/issue-6-3">Mach-O 可执行文件</a>。</p>

<p>当链接完成之后，build phase 中最后需要处理的就是将静态资源（例如图片和字体）拷贝到 app bundle 中。需要注意的是，如果图片资源是PNG格式，那么不仅仅对其进行拷贝，还会做一些优化（如果 build settings 中的 PNG 优化是打开的话）。</p>

<p>虽然静态资源的拷贝是 build phase 中的最后一步，但 build 还没有完成。例如，还没有进行 code signing （这并不是 build phase 考虑的范畴），code signing 属于 build 步骤中的最后一步 "Packaging"。</p>

<h3 id="buildphases">定制Build Phases</h3>

<p>至此，如果不考虑默认设置的话，你已经可以完全掌握了上面介绍的 build phases。例如，你可以在 build phases 中添加运行自定义脚本，就像<a href="http://www.objccn.io/issue-6-4/">CocoaPods</a>使用的一样，来做额外的工作。当然也可以添加一些资源的拷贝任务，当你需要将某些确定的资源拷贝到指定的 target 目录中，这非常有用。</p>

<p>另外定制 build phases 有一个非常好用的功能：添加带有水印（包括版本号和 commit hash）的 app icon -- 只需要在 build phase 中添加一个 "Run Script"，并用下面的命令来获取版本号和 commit hash：</p>

<pre><code>version=`/usr/libexec/PlistBuddy -c "Print CFBundleVersion" "${INFOPLIST_FILE}"`
commit=`git rev-parse --short HEAD`
</code></pre>

<p>然后使用 ImageMagick 来修改 app icon。这里有一个<a href="https://github.com/krzysztofzablocki/IconOverlaying">完整的示例</a>，可以参考。</p>

<p>如果你希望自己或者别人编写的代码看起来比较简洁点，可以添加一个 "Run Script"：如果一个源文件超过指定行数，就发出警告。如下代码所示，设置的行数为 200。</p>

<pre><code>find "${SRCROOT}" \( -name "*.h" -or -name "*.m" \) -print0 | xargs -0 wc -l | awk '$1 &gt; 200 &amp;&amp; $2 != "total" { print $2 ":1: warning: file more than 200 lines" }'
</code></pre>

<h3 id="buildrules">Build Rules</h3>

<p>Build rules 指定了不同的文件类型该如何编译。一般来说，开发者并不需要修改这里面的内容。如果你需要对特定类型的文件添加处理方法，那么可以在此处添加一条新的规则。</p>

<p>一条 build rule 指定了其应用于哪种类型文件，该类型文件是如何被处理的，以及输出的内容该如何处置。比方说，我们创建了一条预处理规则，该规则将 Objective-C 的实现文件当做输入，解析文件中的注释内容，最后再输出一个 <code>.m</code> 文件，文件中包含了生成的代码。由于我们不能将 <code>.m</code> 文件既当做输入又当做输出，所以我使用了 <code>.mal</code> 后缀，定制的 build rule 如下所示：</p>

<p><img src="http://img.objccn.io/issue-6/custom-build-rule.png" alt="Custom build rule" /></p>

<p>上面的规则应用于所有后缀为 <code>*.mal</code> 的文件，这些文件会被自定义的脚本处理（调用我们的预处理器，并附带上输入和输出参数）。最后，该规则告诉 build system 在哪里可以找到此规则的输出文件。</p>

<p>在脚本中，我使用了少量的变量来指定正确的路径和文件名。在苹果的 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html#//apple_ref/doc/uid/TP40003931-CH3-SW105">Build Setting Reference</a> 文档中可以找到所有可用的变量。build 过程中，要想观察所有已存在的环境变量，你可以在 build phase 中添加一个 "Run Script"，并勾选上 "Show environment variables in build log"。</p>

<h3 id="buildsettings">Build Settings</h3>

<p>至此，我们已经了解到在 build phases 中是如何定义 build 处理的过程，以及 build rules 是如何指定哪些文件类型在编译阶段需要被预处理。在 build settings 中，我们可以配置每个任务（之前在 build log 输出中看到的任务）的详细内容。</p>

<p>你会发现 build 过程的每一个阶段，都有许多选项：从编译、链接一直到 code signing 和 packaging。注意，settings 是如何被分割为不同的部分 -- 其实这大部分会与 build phases 有关联，有时候也会指定编译的文件类型。</p>

<p>这些选项基本都有很好的文档介绍，你可以在右边面板中的 quick help inspector 或者 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html#//apple_ref/doc/uid/TP40003931-CH3-SW105">Build Setting Reference</a> 中查看到。</p>

<h2>工程文件</h2>

<p>上面我们介绍的所有内容都被保存在工程文件（<code>.pbxproj</code>）中，除了其它一些工程相关信息（例如 file groups），我们很少会深入该文件内部，除非在代码 merge 时发生冲突，或许会进去看看。</p>

<p>建议你用文本编辑器打开一个工程文件，从头到尾看一遍里面的内容。它的可读性非常高，里面的许多内容一看就知道什么意思了，不会存在太大的问题。通过阅读并完全理解工程文件，这对于合并工程文件的冲突非常有帮助。</p>

<p>首先，我们来看看文件中叫做 <code>rootObject</code> 的条目。在我的工程中，如下所示：</p>

<pre><code>rootObject = 1793817C17A9421F0078255E /* Project object */;
</code></pre>

<p>根据这个 ID（<code>1793817C17A9421F0078255E</code>），我们可以找到 main 工程的定义：</p>

<pre><code>/* Begin PBXProject section */
    1793817C17A9421F0078255E /* Project object */ = {
        isa = PBXProject;
...
</code></pre>

<p>在这部分中有一些 keys，顺从这些 key，我们可以了解到更多关于这个工程文件的组成。例如，<code>mainGroup</code> 指向了 root file group。如果你按照这个思路，你可以快速了解到在 <code>.pbxproj</code> 文件中工程的结构。下面我要来介绍一些与 build 过程相关的内容。其中 <code>target</code> key 指向了 build target 的定义：</p>

<pre><code>targets = (
    1793818317A9421F0078255E /* objcio */,
    170E83CE17ABF256006E716E /* objcio Tests */,
);
</code></pre>

<p>根据第一个内容，我们找到一个 target 的定义：</p>

<pre><code>1793818317A9421F0078255E /* objcio */ = {
    isa = PBXNativeTarget;
    buildConfigurationList = 179381B617A9421F0078255E /* Build configuration list for PBXNativeTarget "objcio" */;
    buildPhases = (
        F3EB8576A1C24900A8F9CBB6 /* Check Pods Manifest.lock */,
        1793818017A9421F0078255E /* Sources */,
        1793818117A9421F0078255E /* Frameworks */,
        1793818217A9421F0078255E /* Resources */,
        FF25BB7F4B7D4F87AC7A4265 /* Copy Pods Resources */,
    );
    buildRules = (
    );
    dependencies = (
        1769BED917CA8239008B6F5D /* PBXTargetDependency */,
        1769BED717CA8236008B6F5D /* PBXTargetDependency */,
    );
    name = objcio;
    productName = objcio;
    productReference = 1793818417A9421F0078255E /* objcio.app */;
    productType = "com.apple.product-type.application";
};
</code></pre>

<p>其中 <code>buildConfigurationList</code> 指向了可用的配置项，一般是 <code>Debug</code> 和 <code>Release</code>。根据 debug 对应的 id，我们可以找到 build setting tab 中所有选项存储的位置：</p>

<pre><code>179381B717A9421F0078255E /* Debug */ = {
    isa = XCBuildConfiguration;
    baseConfigurationReference = 05D234D6F5E146E9937E8997 /* Pods.xcconfig */;
    buildSettings = {
        ALWAYS_SEARCH_USER_PATHS = YES;
        ASSETCATALOG_COMPILER_LAUNCHIMAGE_NAME = LaunchImage;
        CODE_SIGN_ENTITLEMENTS = objcio/objcio.entitlements;
...
</code></pre>

<p><code>buildPhases</code> 属性则简单的列出了在 Xcode 中定义的所有 build phases。这非常容易识别出来（Xcode 中的参数使用了它们原本真正的名字，并以 C 风格进行注释）。<code>buildRules</code> 属性是空的：因为在该工程中，我没有自定义 build rules。<code>dependencies</code> 列出了在 Xcode build phase tab 中列出的 target 依赖项。</p>

<p>没那么吓人，不是吗？工程中剩下的内容就留给你去当做练习来了解吧。只需要顺着对象的 ID 走，即可，一旦你找到了敲门，理解了Xcode中工程设置的不同 section ，那么对于 merge 工程文件的冲突时，将变得非常简单。甚至可以在 GitHub 中就能阅读工程文件，而不用将工程文件 clone 到本地，并用 Xcode 打开。</p>

<h2>小结</h2>

<p>当今的软件是都用其它复杂的一些软件和资源开发出来的，例如 library 和 build 工具等。反过来，这些工具是构建于底层架构的，这犹如剥洋葱一样，一层包着一层。虽然这样一层一层的，给人感觉太复杂，但是你完全可以去深入了解它们，这非常有助于你对软件的深入理解，实际上当你了解之后，这并没有想象中的那么神奇，只不过它是一层一层堆砌起来的，每一层都是基于下一层构建起来的。</p>

<p>本文所探索 build system 的内部机制犹如剥掉洋葱的一层。其实当我们点击 Xcode 中的运行按钮时，我们并没必要理解这个动作涉及到的所有内容。我们只是深入理解某一层，然后找到一个有组织的、并且可控的调用其它工具的顺序，如果我们愿意的话，可以做进一步的探索。我建议你阅读本期中的其它文章，以进一步了解这个洋葱的下一层内容！</p>

<hr />

]]></content>
  </entry>
  
</feed>
