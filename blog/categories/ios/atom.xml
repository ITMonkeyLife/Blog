<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | IT Monkey Life]]></title>
  <link href="http://ITMonkeyLife.github.io/Blog/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://ITMonkeyLife.github.io/Blog/"/>
  <updated>2014-06-18T09:32:29+08:00</updated>
  <id>http://ITMonkeyLife.github.io/Blog/</id>
  <author>
    <name><![CDATA[Rick]]></name>
    <email><![CDATA[382542165@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OC的子类]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/06/18/ocde-zi-lei/"/>
    <updated>2014-06-18T09:23:01+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/06/18/ocde-zi-lei</id>
    <content type="html"><![CDATA[<p>这篇文章跟我以往的文章有点不一样。它主要是一些思想与模式的汇集，而不是一篇指南。下面我所写的模式几乎全都来之不易，都是我犯了错之后才学到的。我并不认为自己是子类方面的权威，但我确实想把我学到的一些东西分享出来。别把本文当做权威指南，它只是一些例子的汇集。</p>

<p>在被问到 OOP（面向对象编程）的时候，Alan Kay（OOP 的发明人）写到：它跟类无关，但跟消息有关。<a href="http://c2.com/cgi/wiki?AlanKayOnMessaging">^1</a>然而，很多人的关注点仍然还在类层次上。在本文中，我们会看几个我们可能会把注意力放在创建复杂的类结构上的例子，并给出更有用的替代方案。根据经验，这样会让代码更简单，更易维护。关于这个话题，在 <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code</a>（中文版：<a href="http://www.amazon.cn/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E9%A9%AC%E4%B8%81/dp/B0031M9GHC/ref=pd_bxgy_b_img_y">代码整洁之道</a>）和 <a href="http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670">Code Complete</a>（中文版：<a href="http://www.amazon.cn/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E5%8F%B2%E8%92%82%E5%A4%AB%E2%80%A2%E8%BF%88%E5%85%8B%E5%BA%B7%E5%A5%88%E5%B0%94/dp/B0061XKRXA/ref=pd_bxgy_b_img_z">代码大全</a>）中已经有大量讨论。推荐你阅读这两本书。</p>

<h2>何时用子类</h2>

<p>首先，我们讨论几种使用子类比较合适的场景。如果你要写一个自定义布局的 <code>UITableViewCell</code> ，那就创建一个子类。这同样适用于几乎每个视图。一旦你开始布局，把这块代码放入子类就更合理一些，不光代码得到了更好的封装，你也能得到一个可在工程之间重用的组件。</p>

<p>假设你的代码是针对多平台多版本的，并且你需要针对每个平台每个版本写一些代码。这时候更合理的做法可能是创建一个 <code>OBJDevice</code> 类，让一些子类如 <code>OBJIPhoneDevice</code> 和 <code>OBJIPadDevice</code> ，甚至更深层的子类如 <code>OBJIPhone5Device</code> 来继承，并让这些子类重写特定的方法。例如，你的 OBJDevice 类可能包含了函数 <code>applyRoundedCornersToView:withRadius</code> ，它有一个默认的实现，但是也能被特定的子类重写。</p>

<p>另一个子类化可能很有用的场景是模型对象（model object）。绝大多数情况下，我的模型对象继承自一个实现了 <code>isEqual:</code> 、 <code>hash</code> 、 <code>copyWithZone:</code> 和 <code>description</code> 等方法的类。这些方法只被实现一次，并且迭代循环遍历所有属性，所以极不容易出错。（如果你也想找一个这样的基类，可以考虑使用 <a href="https://github.com/mantle/mantle">Mantle</a> ，它就是这么做的，并且做得更多。）</p>

<h2>何时不使用子类</h2>

<p>在以往工作过的很多工程中，我见到过很多继承层次很深的子类。当我也这么干的时候，总会感到内疚。除非继承的层次非常浅，否则你会很快发现它的局限性。<a href="http://c2.com/cgi/wiki?LimitsOfHierarchies">^2</a></p>

<p>幸运的是，如果你发现自己正在使用深层次的继承，还有很多替代方案可选。在下面的章节中，我们会逐个进行更详细地描述。如果你的子类只是使用相同的接口，协议会是个非常好的替代方案。如果你知道某个对象需要大量的修改，你可能会使用代理来动态改变和配置它。当你想给已有对象增加一些简单功能时，类别可能是个选择。当你有一堆重写了相同方法的子类时，你可以使用配置对象（configuration object）来代替。最后，当你想重用某些功能时，组合多个对象而不是扩展它们可能会更好。</p>

<h2>替代方案</h2>

<h3 id="protocols">替代方案：协议（Protocols）</h3>

<p>很多时候，使用子类的原因是你想保证某个对象可以响应某些消息。假设在 app 里你有一个播放器对象，它可以播放视频。现在你想添加对 YouTube 的支持，使用相同的接口，但是具体实现不同。你可以使像这样用子类来实现：</p>

<p>```
@class Player : NSObject</p>

<ul>
  <li>(void)play;</li>
  <li>(void)pause;</li>
</ul>

<p>@end</p>

<p>@class YouTubePlayer : Player</p>

<p>@end
```</p>

<p>事实上可能这两个类并没有太多共用的代码，它们只不过具有相同的接口。如果这样的话，使用协议可能会是更好的方案。可以这样用协议来写你的代码：</p>

<p>```objc
@protocol VideoPlayer <nsobject /></p>

<ul>
  <li>(void)play;</li>
  <li>(void)pause;</li>
</ul>

<p>@end</p>

<p>@class Player : NSObject <videoplayer /></p>

<p>@end</p>

<p>@class YouTubePlayer : NSObject <videoplayer /></p>

<p>@end
```</p>

<p>这样，<code>YouTubePlayer</code> 类就不必知道 <code>Player</code> 类的内部实现了。</p>

<h3 id="delegation">替代方案：代理（Delegation）</h3>

<p>再一次假设你有一个像上面例子中的 <code>Player</code> 类。现在，你想在开始播放的时候在某个地方执行一个自定义的函数。这么做相对容易一些：创建一个自定义的子类，重写 <code>play</code> 方法，调用 <code>[super play ]</code>，然后开始做你自定义的工作。这么做是一种方法。另外一种方法是，改动你的 <code>Player</code> 对象，然后给它设置一个代理。如下：</p>

<p>```objc
@class Player;</p>

<p>@protocol PlayerDelegate</p>

<ul>
  <li>(void)playerDidStartPlaying:(Player *)player;</li>
</ul>

<p>@end</p>

<p>@class Player : NSObject</p>

<p>@property (nonatomic,weak) id<playerdelegate> delegate;</playerdelegate></p>

<ul>
  <li>(void)play;</li>
  <li>(void)pause;</li>
</ul>

<p>@end
```</p>

<p>现在，在播放器的 <code>play</code> 方法里，就可以给代理发送 <code>playerDidStartPlaying:</code> 消息了。这个 <code>Player</code> 类的任何使用者都可以仅仅实现这个代理协议，而不用继承该该类， <code>Player</code> 类也能够保持通用性。这是个强大有效的技术，苹果在自己的框架里大量地使用它。你想想像 <code>UITextField</code> 这样的类，还有 <code>NSLayoutManager</code>。有时候你还会想把几个不同的方法打包分组到几个单独的协议里，比如 <code>UITableView</code> —— 它不仅有一个代理（delegate），还有一个数据源（dataSource）。</p>

<h3 id="categories">替代方案：类别（Categories）</h3>

<p>有时候，你可能会想给一个对象增加一点点额外的功能。比如你想给 <code>NSArray</code> 增加一个方法 <code>arrayByRemovingFirstObject</code>。不用子类，你可以把这个函数放到一个类别里。像这样：</p>

<p>```objc
@interface NSArray (OBJExtras)</p>

<ul>
  <li>(void)obj_arrayByRemovingFirstObject;</li>
</ul>

<p>@end
```</p>

<p>在用类别扩展一个不是你自己的类的时候，在方法前添加前缀是个比较好的习惯做法。如果不这么做，有可能别人也用类别对此类添加了相同名字的函数。那时候程序的行为可能跟你想要的并不一样，未预期的事情可能会发生。</p>

<p>使用类别还有另外一个风险，那就是，到最后你可能会使用一大堆的类别，连你自己都会失去对代码全局的认识。假如那样的话，创建自定义的类可能更简单一些。</p>

<h3 id="configurationobjects">替代方案：配置对象（Configuration Objects）</h3>

<p>在我经常会犯的错误中（现在很快就能发现了），其中有一条是：使用一个含有几个抽象方法的类并让很多子类来重写某个方法。例如，在一个幻灯片应用里，你有一个主题类 <code>Theme</code> ，它有几个属性，比如 <code>backgroundColor</code> 和 <code>font</code> ，还有一些在一张幻灯片上如何布局的逻辑函数。</p>

<p>然后，对每种主题，你都创建一个 <code>Theme</code> 的子类，重写某个函数（例如 <code>setup</code> ）并配置其属性。直接使用父类对此做不了什么事。在这种情况下，你可以使用配置对象来让代码更简单些。你可以把共有的逻辑（比如幻灯片布局）放在 <code>Theme</code> 类中，把属性的配置放到较简单的对象中，这些对象中只含有这些属性。</p>

<p>例如，类 <code>ThemeConfiguration</code> 具有 <code>backgroundColor</code> 和 <code>font</code> 属性，而类 <code>Theme</code> 在其初始化函数中获取一个配置类 <code>ThemeConfiguration</code> 的值。</p>

<h3>替代方案：组合</h3>

<p>组合是代替子类化的最强大有效的方案。如果你想重用已有代码而不想共享同样的接口，组合就是你的首选武器。例如，假设你要设计一个缓存类：</p>

<p>```objc
@interface OBJCache : NSObject</p>

<ul>
  <li>(void)cacheValue:(id)value forKey:(NSString *)key;</li>
  <li>(void)removeCachedValueForKey:(NSString *)key;</li>
</ul>

<p>@end
```</p>

<p>简单点的做法是直接继承 <code>NSDictionary</code>，通过调用字典的函数来实现上面的两个方法。</p>

<p><code>objc
@interface OBJCache : NSDictionary
</code></p>

<p>但是这么做有几个弊端。它本来是应该被详细实现的，但只是通过字典来实现。现在，在任何需要一个 <code>NSDictionary</code> 参数的时候，你可以直接提供一个 <code>OBJCache</code> 值。但如果你想把它转为其它完全不同的东西（例如你自己的库），你就可能需要重构很多代码了。</p>

<p>更好的方式是，将这个字典存在一个私有属性（或者实例变量）中，对外仅仅暴露这两个 <code>cache</code> 方法。现在，当你有了更深入想法的时候，你可以在灵活地修改其实现，而该类的使用者们不用进行重构。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVVM介绍]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/06/17/mvvmjie-shao/"/>
    <updated>2014-06-17T11:48:19+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/06/17/mvvmjie-shao</id>
    <content type="html"><![CDATA[<p>有时我感觉就像我不知道在做什么。虽然我知道自己的设计模式——就像任何好的编程人员那样 —— 但我太接近我在做的产品以至于不能客观地衡量我的架构决策的有效性。当队伍中来了另外一位开发者时，我意识到我们陷入困境了。</p>

<p>从没听过 MVC ？有人称之为 Massive View Controller（重量级视图控制器），这就是我们那时候的感觉。我不打算介绍令人汗颜的细节，但说实在的，如果我不得不再次重来一次，我绝对会做出不同的决策。</p>

<p>我会修改一个关键架构，并将其带入我从那时起就在开发的各种应用，即使用一种叫做 Model-View-ViewModel 的架构替换 Model-View-Controller。</p>

<p>所以，MVVM 到底是什么？与其专注于说明 MVVM 的来历，不如让我们看一个典型的 iOS 是如何构建的，并从那里了解 MVVM：</p>

<p><img src="http://img.objccn.io/issue-13/mvvm1.png" alt="Typical Model-View-Controller setup" /></p>

<p>我们看到的是一个典型的 MVC 设置。Model 呈现数据，View 呈现用户界面，而 View Controller 调节它两者之间的交互。Cool！</p>

<p>稍微考虑一下，虽然 View 和 View Controller 是技术上不同的组件，但它们几乎总是手牵手在一起，成对的。你什么时候看到一个 View 能够与不同 View Controller 配对？或者反过来？所以，为什么不正规化它们的连接呢？</p>

<p><img src="http://img.objccn.io//issue-13/intermediate.png" alt="Intermediate" /></p>

<p>这更准确地描述了你可能已经编写的 MVC 代码。但它并没有做太多事情来解决 iOS 应用中日益增长的重量级视图控制器的问题。在典型的 MVC 应用里，<em>许多</em>逻辑被放在 View Controller 里。它们中的一些确实属于 View Controller，但更多的是所谓的“表示逻辑（presentation logic）”，以 MVVM 属术语来说，就是那些将 Model 数据转换为 View 可以呈现的东西的事情，例如将一个 <code>NSDate</code> 转换为一个格式化过的 <code>NSString</code>。</p>

<p>我们的图解里缺少某些东西，那些使我们可以把所有表示逻辑放进去的东西。我们打算将其称为 “View Model” —— 它位于 View/Controller 与 Model 之间：</p>

<p><img src="http://img.objccn.io//issue-13/mvvm.png" alt="Model-View-ViewModel" /></p>

<p>看起好多了！这个图解准确地描述了什么是 MVVM：一个 MVC 的增强版，我们正式连接了视图和控制器，并将表示逻辑从 Controller 移出放到一个新的对象里，即 View Model。MVVM 听起来很复杂，但它本质上就是一个精心优化的 MVC 架构，而 MVC 你早已熟悉。</p>

<p>现在我们知道了<em>什么</em>是 MVVM，但<em>为什么</em>我们会想要去使用它呢？在 iOS 上使用 MVVM 的动机，对我来说，无论如何，就是它能减少 View Controller 的复杂性并使得表示逻辑更易于测试。通过一些例子，我们将看到它如何达到这些目标。</p>

<p>此处有三个重点是我希望你看完本文能带走的：</p>

<ul>
<li>MVVM 可以兼容你当下使用的 MVC 架构。</li>
<li>MVVM 增加你的应用的可测试性。</li>
<li>MVVM 配合一个绑定机制效果最好。</li>
</ul>

<p>如我们之前所见，MVVM 基本上就是 MVC 的改进版，所以很容易就能看到它如何被整合到现有使用典型 MVC 架构的应用中。让我们看一个简单的 <code>Person</code> Model 以及相应的 View Controller：</p>

<p>```objc
@interface Person : NSObject</p>

<ul>
  <li>(instancetype)initwithSalutation:(NSString *)salutation firstName:(NSString *)firstName lastName:(NSString *)lastName birthdate:(NSDate *)birthdate;</li>
</ul>

<p>@property (nonatomic, readonly) NSString *salutation;
@property (nonatomic, readonly) NSString *firstName;
@property (nonatomic, readonly) NSString *lastName;
@property (nonatomic, readonly) NSDate *birthdate;</p>

<p>@end
```</p>

<p>Cool！现在我们假设我们有一个 <code>PersonViewController</code> ，在 <code>viewDidLoad</code> 里，只需要基于它的 <code>model</code> 属性设置一些 Label 即可。</p>

<p>```objc
- (void)viewDidLoad {
    [super viewDidLoad];</p>

<pre><code>if (self.model.salutation.length &amp;gt; 0) {
    self.nameLabel.text = [NSString stringWithFormat:@"%@ %@ %@", self.model.salutation, self.model.firstName, self.model.lastName];
} else {
    self.nameLabel.text = [NSString stringWithFormat:@"%@ %@", self.model.firstName, self.model.lastName];
}

NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
[dateFormatter setDateFormat:@"EEEE MMMM d, yyyy"];
self.birthdateLabel.text = [dateFormatter stringFromDate:model.birthdate]; } ```
</code></pre>

<p>这全都直截了当，标准的 MVC。现在来看看我们如何用一个 View Model 来增强它。</p>

<p>```objc
@interface PersonViewModel : NSObject</p>

<ul>
  <li>(instancetype)initWithPerson:(Person *)person;</li>
</ul>

<p>@property (nonatomic, readonly) Person *person;</p>

<p>@property (nonatomic, readonly) NSString *nameText;
@property (nonatomic, readonly) NSString *birthdateText;</p>

<p>@end
```</p>

<p>我们的 View Model 的实现大概如下：</p>

<p>```objc
@implementation PersonViewModel</p>

<ul>
  <li>
    <p>(instancetype)initWithPerson:(Person *)person {
  self = [super init];
  if (!self) return nil;</p>

    <p>_person = person;
  if (person.salutation.length &gt; 0) {
      _nameText = [NSString stringWithFormat:@”%@ %@ %@”, self.person.salutation, self.person.firstName, self.person.lastName];
  } else {
      _nameText = [NSString stringWithFormat:@”%@ %@”, self.person.firstName, self.person.lastName];
  }</p>

    <p>NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
  [dateFormatter setDateFormat:@”EEEE MMMM d, yyyy”];
  _birthdateText = [dateFormatter stringFromDate:person.birthdate];</p>

    <p>return self;
}</p>
  </li>
</ul>

<p>@end
```</p>

<p>Cool！我们已经将 <code>viewDidLoad</code> 中的表示逻辑放入我们的 View Model 里了。此时，我们新的 <code>viewDidLoad</code> 就会非常轻量：</p>

<p>```objc
- (void)viewDidLoad {
    [super viewDidLoad];</p>

<pre><code>self.nameLabel.text = self.viewModel.nameText;
self.birthdateLabel.text = self.viewModel.birthdateText; } ```
</code></pre>

<p>所以，如你所见，并没有对我们的 MVC 架构做太多改变。还是同样的代码，只不过移动了位置。它与 MVC 兼容，带来<a href="http://objccn.io/issue-1/">更轻量的 View Controllers</a>。</p>

<p>可测试，嗯？是怎样？好吧，View Controller 是出了名的难以测试，因为它们做了太多事情。在 MVVM 里，我们试着尽可能多的将代码移入 View Model 里。测试 View Controller 就变得容易多了，因为它们不再做一大堆事情，并且 View Model 也非常易于测试。让我们来看看：</p>

<p>```objc
SpecBegin(Person)
    NSString *salutation = @”Dr.”;
    NSString *firstName = @”first”;
    NSString *lastName = @”last”;
    NSDate *birthdate = [NSDate dateWithTimeIntervalSince1970:0];</p>

<pre><code>it (@"should use the salutation available. ", ^{
    Person *person = [[Person alloc] initWithSalutation:salutation firstName:firstName lastName:lastName birthdate:birthdate];
    PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person];
    expect(viewModel.nameText).to.equal(@"Dr. first last");
});

it (@"should not use an unavailable salutation. ", ^{
    Person *person = [[Person alloc] initWithSalutation:nil firstName:firstName lastName:lastName birthdate:birthdate];
    PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person];
    expect(viewModel.nameText).to.equal(@"first last");
});

it (@"should use the correct date format. ", ^{
    Person *person = [[Person alloc] initWithSalutation:nil firstName:firstName lastName:lastName birthdate:birthdate];
    PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person];
    expect(viewModel.birthdateText).to.equal(@"Thursday January 1, 1970");
}); SpecEnd ```
</code></pre>

<p>如果我们没有将这个逻辑移入 View Model，我们将不得不实例化一个完整的 View Controller 以及伴随的 View，然后去比较我们 View 中 Lable 的值。这样做不只是会变成一个麻烦的间接层，而且它只代表了一个十分脆弱的测试。现在，我们可以按意愿自由地修改视图层级而不必担心破坏我们的单元测试。使用 MVVM 带来的对于测试的好处非常清晰，甚至从这个简单的例子来看也可见一斑，而在有更复杂的表示逻辑的情况下，这个好处会更加明显。</p>

<p>注意到在这个简单的例子中， Model 是不可变的，所以我们可以只在初始化的时候指定我们 View Model 的属性。对于可变 Model，我们还需要使用一些绑定机制，这样 View Model 就能在背后的 Model 改变时更新自身的属性。此外，一旦 View Model 上的 Model 发生改变，那 View 的属性也需要更新。Model 的改变应该级联向下通过 View Model 进入 View。</p>

<p>在 OS X 上，我们可以使用 Cocoa 绑定，但在 iOS 上我们并没有这样好的配置可用。我们想到了 KVO（Key-Value Observation），而且它确实做了很伟大的工作。然而，对于一个简单的绑定都需要很大的样板代码，更不用说有许多属性需要绑定了。作为替代，我个人喜欢使用 ReactiveCocoa，但 MVVM 并未强制我们使用 ReactiveCocoa。MVVM 是一个伟大的典范，它自身独立，只是在有一个良好的绑定框架时做得更好。</p>

<p>我们覆盖了不少内容：从普通的 MVC 派生出 MVVM，看它们是如何相兼容的范式，从一个可测试的例子观察 MVVM，并看到 MVVM 在有一个配对的绑定机制时工作得更好。如果你有兴趣学习更多关于 MVVM 的知识，你可以看看<a href="http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/">这篇博客</a>，它用更多细节解释了 MVVM 的好处，或者<a href="http://www.teehanlax.com/blog/krush-ios-architecture/">这一篇</a>关于我们如何在最近的项目里使用 MVVM 获得巨大的成功的文章。我同样还有一个经过完整测试，基于 MVVM 的应用，叫做 <a href="https://github.com/AshFurrow/C-41">C-41</a> ，它是开源的。去看看吧，如果你有任何疑问，请<a href="http://weibo.com/u/1651400041">告诉我</a>。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[交互式动画]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/23/jiao-hu-shi-dong-hua/"/>
    <updated>2014-05-23T10:11:17+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/23/jiao-hu-shi-dong-hua</id>
    <content type="html"><![CDATA[<p>在2007年，乔布斯在第一次介绍 iPhone 的时候，iPhone 的触摸屏交互简直就像是一种魔法。最好的例子就是在他<a href="https://www.youtube.com/watch?v=t4OEsI0Sc_s&amp;t=16m9s">第一次滑动 TableView 的展示上</a>。你可以感受到当时观众的反应是多么惊讶，但是对于现在的我们来说早已习以为常。在展示的后面一部分，他特别指出当他给别人看了这个滑动例子，别人说的一句话: <a href="https://www.youtube.com/watch?v=t4OEsI0Sc_s&amp;t=16m9s">“当这个界面滑动的时候我就已经被征服了”</a>.</p>

<p>是什么样的滑动能让人有‘哇哦’的效果呢？</p>

<p>滑动是最完美地展示了通过触摸屏直接操作的例子。滚动视图遵从于你的手指，当你的手指离开屏幕的时，视图会自然地继续滑动直到该停止的时候停止。它用自然的方式减速，甚至在快到界限的时候也能表现出细腻的弹力效果。滑动在任何时候都保持相应，并且看上去非常真实。</p>

<h2>动画的状态</h2>

<p>在 iOS 中的大部分动画仍然没有按照最初 iPhone 指定的滑动标准实现。这里有很多动画一旦它们运行就不能交互（比如说解锁动画，主界面中打开文件夹和关闭文件夹的动画，和导航栏切换的动画，还有很多）。</p>

<p>然而现在有一些应用给我一种始终在控制动画的体验，我们可以直接操作那些我在用的动画。当我们将这些应用和其他的应用相比较之后，我们就能感觉到明显的区别。这些应用中最优秀的有最初的 Twitter iPad app， 和现在的 Facebook Paper。但目前，使用直接操作为主并且可以中断动画的应用仍然很少。这就给我们做出更好的应用提供了机会，让我们的应用有更不同的，更高质量的体验。</p>

<h2>真实交互式动画的挑战</h2>

<p>当我们用 UIView 或者 CAAnimation 来实现交互式动画时会有两个大问题: 这些动画会将你在屏幕上的内容和 layer 上的实际的特定属性分离开来，并且他们直接操作这些特定属性。</p>

<h3 id="modelpresentation">模型 (Model) 和显示 (Presentation) 的分离</h3>

<p>Core Animation 是通过分离 layer 的模型属性和你在屏幕上看到的界面 (显示层) 的方式来设计的，这就导致我们很难去创建一个可以在任何时候能交互的动画，因为在动画时，模型和界面已经不能匹配了。这时，我们不得不通过手动的方式来同步这两个的状态，来达到改变动画的效果：</p>

<p><code>objc
view.layer.center = view.layer.presentationLayer.center;
[view.layer removeAnimationForKey:@"animation"];
// 添加新动画
</code></p>

<h3 id="vs">直接控制 vs 间接控制</h3>

<p><code>CAAnimation</code> 动画的更大的问题是它们是直接在 layer 上对属性进行操作的。这意味着什么呢？比如我们想指定一个 layer 从坐标为 (100, 100) 的位置运动到 (300, 300) 的位置，但是在它运动到中间的时候，我们想它停下来并且让它回到它原来的位置，事情就变得非常复杂了。如果你只是简单地删除当前的动画然后再添加一个新的，那么这个 layer 的速率就会不连续。</p>

<p><img src="http://img.objccn.io/issue-12/abrupt.png" width="600" /></p>

<p>然而，我们想要的是一个漂亮的，流畅地减速和加速的动画。</p>

<p><img src="http://img.objccn.io/issue-12/smooth.png" width="600" /></p>

<p>只有通过<em>间接</em>操作动画才能达到上面的效果，比如通过模拟力在界面上的表现。新的动画需要用 layer 的当前<em>速度矢量</em>作为参数传入来达到流畅的效果。</p>

<p>看一下 UIView 中关于弹簧动画的 API </p>
<p>animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:</p>
<p>，你会注意到速率是个 CGFloat。所以当我们给一个移动 view 的动画在其运动的方向上加一个初始的速率时，你没法告知动画这个 view 现在的运动状态，比如我们不知道要添加的动画的方向是不是和原来的 view 的速度方向垂直。为了使其成为可能，这个速度需要用向量来表示。</p>

<h2>解决方案</h2>

<p>让我们看一下我们怎样来正确实现一个可交互并且可以中断的动画。我们来做一个类似于控制中心板的东西来实现这个效果：</p>

<p><video controls="1" style="display:block;max-width:100%;height:auto;border:0;"> <br />
  <source src="http://www.objc.io/images/issue-12/interactive-animation.mov" />
</video></p>

<p>这个控制板有两个状态：打开和关闭。你可以通过点击来切换这两个状态，或者通过上下拖动来调调整它向上或向下。我要将这个控制面板的所有状态都做到可以交互，甚至是在动画的过程中也可以，这是一个很大的挑战。比如，当你在这个控制板还没有切换到打开状态的动画过程中，你点击了它，那么它应该从现在这个点的位置马上回到关闭状态的位置。在现在很多的应用中，大部分都是用默认的动画 API，你必须要等一个动画结束之后你才能做自己想做的事情。或者，如果你不等待的话，就会看到一个不连续的速度曲线。我们要解决这个问题。</p>

<h3 id="uikit">UIKit 力学</h3>

<p>随着 iOS7 的发布，苹果向我们展示了一个叫 UIKit 力学的动画框架 (可以参见 WWDC 2013 sessions <a href="https://developer.apple.com/videos/wwdc/2013/index.php?id=206">206</a> 和 <a href="https://developer.apple.com/videos/wwdc/2013/index.php?id=221">221</a>)。UIKit 力学是一个基于模拟物理引擎的框架，只要你添加指定的行为到动画对象上来实现 <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIDynamicItem_Protocol/Reference/Reference.html">UIDynamicItem</a> 协议就能实现很多动画。这个框架非常强大，并且它能够在多个物体间启用像是附着和碰撞这样的复杂行为。请看一下 <a href="https://developer.apple.com/library/ios/samplecode/DynamicsCatalog/Introduction/Intro.html">UIKit Dynamics Catalog</a>，确认一下什么是可用的。</p>

<p>因为 UIKit 力学中的的动画是被间接驱动的，就像我在上面提到的，这使我们实现真实的交互式动画成为可能，它能在任何时候被中断并且拥有连续的加速度。同时，UIKit 力学在物理层的抽象上能完全胜任我们一般情况下在用户界面中的所需要的所有动画。其实在大部分情况下，我们只会用到其中的一小部分功能。</p>

<h4>定义行为</h4>

<p>为了实现我们的控制板的行为，我们将使用 UIkit 力学中的两个不同行为：<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIAttachmentBehavior_Class/Reference/Reference.html">UIAttachmentBehavior</a> 和 <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIDynamicItemBehavior_Class/Reference/Reference.html">UIDynamicItemBehavior</a>。附着行为用来扮演弹簧的角色，它将界面向目标点拉动。另一方面，我们用动态 item behvaior 定义了比如摩擦系数这样的界面的内置属性。</p>

<p>我创建了一个我们自己的行为子类，以将这两个行为封装到我们的控制板上:</p>

<p>```objc
@interface PaneBehavior : UIDynamicBehavior</p>

<p>@property (nonatomic) CGPoint targetPoint;
@property (nonatomic) CGPoint velocity;</p>

<ul>
  <li>(instancetype)initWithItem:(id <uidynamicitem>)item;</uidynamicitem></li>
</ul>

<p>@end
```</p>

<p>我们通过一个 dynamic item 来初始化这个行为，然后就可以设置它的目标点和我们想要的任何速度。在内部，我们创建了附着行为和 dynamic item 行为，并且将这些行为添加到我们自定义的行为中:</p>

<p>```objc
- (void)setup
{
    UIAttachmentBehavior *attachmentBehavior = [[UIAttachmentBehavior alloc] initWithItem:self.item attachedToAnchor:CGPointZero];
    attachmentBehavior.frequency = 3.5;
    attachmentBehavior.damping = .4;
    attachmentBehavior.length = 0;
    [self addChildBehavior:attachmentBehavior];
    self.attachmentBehavior = attachmentBehavior;</p>

<pre><code>UIDynamicItemBehavior *itemBehavior = [[UIDynamicItemBehavior alloc] initWithItems:@[self.item]];
itemBehavior.density = 100;
itemBehavior.resistance = 10;
[self addChildBehavior:itemBehavior];
self.itemBehavior = itemBehavior; } ```
</code></pre>

<p>为了用 <code>targetPoint</code> 和 <code>velocity</code> 属性来影响 item 的 behavior，我们需要重写它们的 setter 方法，并且分别修改在附着行为和 item behaviors 中的对应的属性。我们对目标点的 setter 方法来说，这个改动很简单：</p>

<p><code>objc
- (void)setTargetPoint:(CGPoint)targetPoint
{
    _targetPoint = targetPoint;
    self.attachmentBehavior.anchorPoint = targetPoint;
}
</code></p>

<p>对于 <code>velocity</code> 属性，我们需要多做一些工作，因为 dynamic item behavior 只允许相对地改变速度。这就意味如果我们要将 <code>velocity</code> 设置为绝对值，首先我们就需要得到当前的速度，然后再加上速度差才能得到我们的目标速度。</p>

<p><code>objc
- (void)setVelocity:(CGPoint)velocity
{
    _velocity = velocity;
    CGPoint currentVelocity = [self.itemBehavior linearVelocityForItem:self.item];
    CGPoint velocityDelta = CGPointMake(velocity.x - currentVelocity.x, velocity.y - currentVelocity.y);
    [self.itemBehavior addLinearVelocity:velocityDelta forItem:self.item];
}
</code></p>

<h3 id="behavior">将Behavior投入使用</h3>

<p>我们的控制板有三个不同状态：在开始或结束位置的静止状态，正在被用户拖动的状态，以及在没有用户控制时运动到结束位置的动画状态。</p>

<p>为了将从直接操作状态 (用户拖动这个滑动板) 过渡到动画状态这个过程做的流畅，我们还有很多其他的事要做。当用户停止拖动控制板时，它会发送一个消息到它的 delegate。根据这个方法，我们可以知道这个板应该朝哪个方向运动，然后在我们自定义的 <code>PaneBehavior</code> 上设置结束点，以及初始速度 (这非常重要)，并将行为添加到动画器中去，以此确保从拖动操作到动画状态这个过程能够非常流畅。</p>

<p>```objc
- (void)draggableView:(DraggableView *)view draggingEndedWithVelocity:(CGPoint)velocity
{
    PaneState targetState = velocity.y &gt;= 0 ? PaneStateClosed : PaneStateOpen;
    [self animatePaneToState:targetState initialVelocity:velocity];
}</p>

<ul>
  <li>(void)animatePaneToState:(PaneState)targetState initialVelocity:(CGPoint)velocity
{
  if (!self.paneBehavior) {
      PaneBehavior *behavior = [[PaneBehavior alloc] initWithItem:self.pane];
      self.paneBehavior = behavior;
  }
  self.paneBehavior.targetPoint = [self targetPointForState:targetState];
  if (!CGPointEqualToPoint(velocity, CGPointZero)) {
      self.paneBehavior.velocity = velocity;
  }
  [self.animator addBehavior:self.paneBehavior];
  self.paneState = targetState;
}
```</li>
</ul>

<p>一旦用户用他的手指再次触动控制板时，我必须要将所有的 dynamic behavior 从 animator 删除，这样才不会影响控制板对拖动手势的响应：</p>

<p><code>objc
- (void)draggableViewBeganDragging:(DraggableView *)view
{
    [self.animator removeAllBehaviors];
}
</code></p>

<p>我们不仅仅允许控制板可以被拖动，还要允许它可以被点击，让它可以从一个位置跳转到另一个位置以达到开关的效果。一旦点击事件发生，我们就会立即调整这个滑动板的目标位置。因为我们不能直接控制动画，但是通过弹力和摩擦力，我们的动画可以非常流畅地执行这个动作：</p>

<p><code>objc
- (void)didTap:(UITapGestureRecognizer *)tapRecognizer
{
    PaneState targetState = self.paneState == PaneStateOpen ? PaneStateClosed : PaneStateOpen;
    [self animatePaneToState:targetState initialVelocity:CGPointZero];
}
</code></p>

<p>这样就实现了我们的大部分功能了。你可以在 <a href="https://github.com/objcio/issue-12-interactive-animations-uidynamics">GitHub</a> 上查看完整的例子。</p>

<p>重申一点：UIKit 力学可以通过在界面上模拟力来间接地驱动动画（我们的例子中，使用的是弹力和摩擦力）。这间接地使我们在任何时候都能以连续的速度曲线来与界面进行交互。</p>

<p>现在我们已经通过 UIKit 力学实现了整个交互，让我们回顾一下这个场景。这个例子的动画中我们只用了 UIKit 力学中一小部分功能，并且它的实现方式也非常简单。对于我们来说这是一个去理解它其中的过程的很好的例子，但是如果我们使用的环境中没有 UIKit  力学 (比如说在 Mac 上)，或者你的使用场景中不能很好的适用 UIKit 力学呢。</p>

<h2>自己操作动画</h2>

<p>至于在你的应用中大部分时间会用的动画，比如简单的弹力动画，我们控制它真的不难。我们可以做一个练习，来看看如何抛弃 UIKit 力学这个巨大的黑盒子，看要如何“手动”来实现一个简单的交互。想法非常简单：我们只要每秒修改这个 view 的 frame 60 次。每一帧我们都基于当前速度和作用在 view 上的力来调整 view 的 frame 就可以了。</p>

<h3>物理原理</h3>

<p>首先让我们看一下我们需要知道的基础物理知识，这样我们才能实现出刚才使用 UIKit 力学实现的那种弹簧动画效果。为了简化问题，虽然引入第二个维度也是很直接的，但我们在这里只关注一维的情况 (在我们的例子中就是这样的情况)。</p>

<p>我们的目标是依据控制面板当前的位置和上一次动画后到现在为止经过的时间，来计算它的新位置。我们可以把它表示成这样：</p>

<pre><code>y = y0 + Δy
</code></pre>

<p>位置的偏移量可以通过速度和时间的函数来表达：</p>

<pre><code>Δy = v ⋅ Δt
</code></pre>

<p>这个速度可以通过前一次的速度加上速度偏移量算出来，这个速度偏移量是由力在 view 上的作用引起的。</p>

<pre><code>v = v0 + Δv
</code></pre>

<p>速度的变化可以通过作用在这个 view 上的冲量计算出来：</p>

<pre><code>Δv = (F ⋅ Δt) / m
</code></pre>

<p>现在，让我们看一下作用在这个界面上的力。为了得到弹簧效果，我们必须要将摩擦力和弹力结合起来：</p>

<pre><code>F = F_spring + F_friction
</code></pre>

<p>弹力的计算方法我们可以从任何一本教科书中得到 (编者注：简单的胡克定律)：</p>

<pre><code>F_spring = k ⋅ x
</code></pre>

<p><code>k</code> 是弹簧的劲度系数，<code>x</code> 是 view 到目标结束位置的距离 (也就是弹簧的长度)。因此，我们可以把它写成这样：</p>

<pre><code>F_spring = k ⋅ abs(y_target - y0)
</code></pre>

<p>摩擦力和 view 的速度成正比：</p>

<pre><code>F_friction = μ ⋅ v
</code></pre>

<p><code>μ</code> 是一个简单的摩擦系数。你可以通过别的方式来计算摩擦力，但是这个方法能很好地做出我们想要的动画效果。</p>

<p>将上面的表达式放在一起，我们就可以算出作用在界面上的力：</p>

<p><code>objc
F = k ⋅ abs(y_target - y0) + μ ⋅ v
</code></p>

<p>为了实现起来更简单点些，我们将 view 的质量设为 1，这样我们就能计算在位置上的变化：</p>

<p><code>objc
Δy = (v0 + (k ⋅ abs(y_target - y0) + μ ⋅ v) ⋅ Δt) ⋅ Δt
</code></p>

<h3>实现动画</h3>

<p>为了实现这个动画，我们首先需要创建我们自己的 <code>Animator</code> 类，它将扮演驱动动画的角色。这个类使用了 <code>CADisplayLink</code>，<code>CADisplayLink</code> 是专门用来将绘图与屏幕刷新频率相同步的定时器。换句话说，如果你的动画是流畅的，这个定时器就会每秒调用你的方法60次。接下来，我们需要实现 <code>Animation</code> 协议来和我们的 <code>Animator</code> 一起工作。这个协议只有一个方法，<code>animationTick:finished:</code>。屏幕每次被刷新时都会调用这个方法，并且在方法中会得到两个参数：第一个参数是前一个 frame 的持续时间，第二个参数是一个指向 <code>BOOL</code> 的指针。当我们设置这个指针的值为 <code>YES</code> 时，我们就可以与 <code>Animator</code> 取得通讯并汇报动画完成；</p>

<p><code>objc
@protocol Animation &lt;NSObject&gt;
- (void)animationTick:(CFTimeInterval)dt finished:(BOOL *)finished;
@end
</code></p>

<p>我们会在下面实现这个方法。首先，根据时间间隔我们来计算由弹力和摩擦力的合力。然后根据这个力来更新速度，并调整 view 的中心位置。最后，当这个速度降低并且 view 到达结束位置时，我们就停止这个动画：</p>

<p>```objc
- (void)animationTick:(CFTimeInterval)dt finished:(BOOL *)finished
{
    static const float frictionConstant = 20;
    static const float springConstant = 300;
    CGFloat time = (CGFloat) dt;</p>

<pre><code>//摩擦力 = 速度 * 摩擦系数
CGPoint frictionForce = CGPointMultiply(self.velocity, frictionConstant);
//弹力 = (目标位置 - 当前位置) * 弹簧劲度系数
CGPoint springForce = CGPointMultiply(CGPointSubtract(self.targetPoint, self.view.center), springConstant);
//力 = 弹力 - 摩擦力
CGPoint force = CGPointSubtract(springForce, frictionForce);

//速度 = 当前速度 + 力 * 时间 / 质量
self.velocity = CGPointAdd(self.velocity, CGPointMultiply(force, time));
//位置 = 当前位置 + 速度 * 时间
self.view.center = CGPointAdd(self.view.center, CGPointMultiply(self.velocity, time));

CGFloat speed = CGPointLength(self.velocity);
CGFloat distanceToGoal = CGPointLength(CGPointSubtract(self.targetPoint, self.view.center));
if (speed &lt; 0.05 &amp;&amp; distanceToGoal &gt; 1) {
    self.view.center = self.targetPoint;
    *finished = YES;
} } ```
</code></pre>

<p>这就是这个方法里的全部内容。我们把这个方法封装到一个 <code>SpringAnimation</code> 对象中。除了这个方法之外，这个对象中还有一个初始化方法，它指定了 view 中心的目标位置 (在我们的例子中，就是打开状态时界面的中心位置，或者关闭状态时界面的中心位置) 和初始的速度。</p>

<h3 id="view">将动画添加到 view 上</h3>

<p>我们的 view 类刚好和使用 UIDynamic 的例子一样：它有一个拖动手势，并且根据拖动手势来更新中心位置。它也有两个同样的 delegate 方法，这两个方法会实现动画的初始化。首先，一旦用户开始拖动控制板时，我们就取消所有动画：</p>

<p><code>objc
- (void)draggableViewBeganDragging:(DraggableView *)view
{
    [self cancelSpringAnimation];
}
</code></p>

<p>一旦停止拖动，我们就根据从拖动手势中得到的最后一个速率值来开始我们的动画。我们根据拖动状态 <code>paneState</code> 计算出动画的结束位置：</p>

<p>```objc
- (void)draggableView:(DraggableView *)view draggingEndedWithVelocity:(CGPoint)velocity
{
    PaneState targetState = velocity.y &gt;= 0 ? PaneStateClosed : PaneStateOpen;
    self.paneState = targetState;
    [self startAnimatingView:view initialVelocity:velocity];
}</p>

<ul>
  <li>(void)startAnimatingView:(DraggableView *)view initialVelocity:(CGPoint)velocity
{
  [self cancelSpringAnimation];
  self.springAnimation = [UINTSpringAnimation animationWithView:view target:self.targetPoint velocity:velocity];
  [view.animator addAnimation:self.springAnimation];
}
```</li>
</ul>

<p>剩下来要做的就是添加点击动画了，这很简单。一旦我们触发这个状态，就开始动画。如果这里正在进行弹簧动画，我们就用当时的速度作为开始。如果这个弹簧动画是 nil，那么这个开始速度就是 CGPointZero。想要知道为什么依然可以进行动画，可以看看 <code>animationTick:finished:</code> 里的代码。当这个起始速度为 0 的时候，弹力就会使速度缓慢地增长，直到面板到达目标位置：</p>

<p><code>objc
- (void)didTap:(UITapGestureRecognizer *)tapRecognizer
{
    PaneState targetState = self.paneState == PaneStateOpen ? PaneStateClosed : PaneStateOpen;
    self.paneState = targetState;
    [self startAnimatingView:self.pane initialVelocity:self.springAnimation.velocity];
}
</code></p>

<h3>动画驱动</h3>

<p>最后，我们需要一个 <code>Animator</code>，也就是动画的驱动者。Animator 封装了 display link。因为每个 display link 都链接一个指定的 <code>UIScreen</code>，所以我们根据这个指定的 UIScreen 来初始化我们的 animator。我们初始化一个 display link，并且将它加入到 run loop 中。因为现在还没有动画，所以我们是从暂停状态开始的：</p>

<p><code>objc
- (instancetype)initWithScreen:(UIScreen *)screen
{
    self = [super init];
    if (self) {
        self.displayLink = [screen displayLinkWithTarget:self selector:@selector(animationTick:)];
        self.displayLink.paused = YES;
        [self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
        self.animations = [NSMutableSet new];
    }
    return self;
}
</code></p>

<p>一旦我们添加了这个动画，我们要确保这个 display link 不再是停止状态：</p>

<p><code>objc
- (void)addAnimation:(id&lt;Animation&gt;)animation
{
    [self.animations addObject:animation];
    if (self.animations.count == 1) {
        self.displayLink.paused = NO;
    }
}
</code></p>

<p>我们设置这个 display link 来调用 <code>animationTick:</code> 方法，在每个 Tick 中，我们都遍历它的动画数组，并且给这些动画数组中的每个动画发送一个消息。如果这个动画数组中已经没有动画了，我们就暂停这个 display link。</p>

<p><code>objc
 - (void)animationTick:(CADisplayLink *)displayLink
 {
     CFTimeInterval dt = displayLink.duration;
     for (id&lt;Animation&gt; a in [self.animations copy]) {
         BOOL finished = NO;
         [a animationTick:dt finished:&amp;finished];
         if (finished) {
             [self.animations removeObject:a];
         }
     }
     if (self.animations.count == 0) {
         self.displayLink.paused = YES;
     }
 }
</code></p>

<p>完整的项目在 <a href="https://github.com/objcio/issue-12-interactive-animations">GitHub</a> 上。</p>

<h3>权衡</h3>

<p>我们必须记住，通过 display link 来驱动动画 (就像我们刚才演示的例子，或者我们使用UIkit力学来做的例子，又或者是使用 Facebook 的 Pop 框架) 是有代价需要进行权衡的。就像 <a href="https://twitter.com/andy_matuschak/status/464790108072206337">Andy Matuschar 指出的</a>那样，UIView 和 CAAnimation 动画比其他任务更少受系统的影响，因为比起你的应用来说，渲染处于更高的优先级。</p>

<h2 id="mac">回到 Mac</h2>

<p>现在 Mac 中还没有 UIKit 力学。如果你想在 Mac 中创建一个真实的交互式动画，你必须自己去实现这些动画。我们已经向你展示了如何在 iOS 中实现这些动画，所以在 OS X 中实现相似的功能也是非常简单的。你可以查看在 GitHub 中的<a href="https://github.com/objcio/issue-12-interactive-animations-osx">完整项目</a>，如果你想要应用到 OS X 中，这里还有一些地方需要修改：</p>

<ul>
<li>第一个要修改的就是 <code>Animator</code>。在Mac中没有 <code>CADisplayLink</code>，但是取而代之的有 <code>CVDisplayLink</code>，它是以 C 语言为基础的 API。创建它需要做更多的工作，但也是很直接。</li>
<li>iOS 中的弹簧动画是基于调整 view 的中心位置来实现的。而 OS X 中的 <code>NSView</code> 类没有 center 这个属性，所以我们用为 frame 中的 origin 做动画来代替。</li>
<li>在 Mac 中是没有手势识别，所以我要在我们自定义的 view 子类中实现 <code>mouseDown:</code>，<code>mouseUp:</code> 和 <code>mouseDragged:</code> 方法。</li>
</ul>

<p>上面就是我们需要在 Mac 中使用我们的动画效果在代码所需要做的修改。对于像这样的简单 view，它能很好的胜任。但对于更复杂的动画，你可能就不会想通过为 frame 做动画来实现了，我们可以用 <code>transform</code> 来代替，浏览 Jonathan Willing 写的关于 <a href="http://jwilling.com/osx-animations">OS X 动画</a>的博客，你会获益良多。</p>

<h3 id="facebookpop">Facebook 的 POP 框架</h3>

<p>上个星期围绕着 Facebook 的 <a href="https://github.com/facebook/pop">POP 框架</a>的讨论络绎不绝。POP 框架是 Paper 应用背后支持的动画引擎。它的操作非常像我们上面讲的驱动动画的例子，但是它以非常灵活的方式巧妙地封装到了一个程序包中。</p>

<p>让我们动手用 POP 来驱动我们的动画吧。因为我们自己的类中已经封装了弹簧动画，这些改变就非常简单了。我们所要做的就是初始化一个 POP 动画来代替我们刚才自己做的动画，并将下面这段代码加入到 view
 中：</p>

<p><code>objc
- (void)animatePaneWithInitialVelocity:(CGPoint)initialVelocity
{
    [self.pane pop_removeAllAnimations];
    POPSpringAnimation *animation = [POPSpringAnimation animationWithPropertyNamed:kPOPViewCenter];
    animation.velocity = [NSValue valueWithCGPoint:initialVelocity];
    animation.toValue = [NSValue valueWithCGPoint:self.targetPoint];
    animation.springSpeed = 15;
    animation.springBounciness = 6;
    [self.pane pop_addAnimation:animation forKey:@"animation"];
    self.animation = animation;
}
</code></p>

<p>你可以在 <a href="https://github.com/objcio/issue-12-interactive-animations-pop">GitHub</a> 中找到使用 POP 框架的完整例子。</p>

<p>让其工作非常简单，并且通过它我们可以实现很多更复杂的动画。但是它真正强大的地方在于它能够实现真正的可交互和可中断的动画，就像我们上面提到的那样，因为它直接支持以速度作为输入参数。如果你打算从一开始到被中断这过程中的任何时候都能交互，像 POP 这样的框架就能帮你实现这些动画，并且它能始终保证动画一直很平滑。</p>

<p>如果你不满足于用 <code>POPSpringAnimation</code> 和 <code>POPDecayAnimation</code> 的开箱即用的处理方式的话，POP 还提供了 <code>POPCustomAnimation</code> 类，它基本上是一个 display link 的方便的转换，来在动画的每一个 tick 的回调 block 中驱动你自己的动画。</p>

<h2>展望未来</h2>

<p>随着 iOS7 中从对拟物化的视觉效果的远离，以及对 UI 行为的关注，真实的交互式动画通向未来的大道变得越来越明显。它们也是将初代 iPhone 中滑动行为的魔力延续到交互的各个方面的一条康庄大道。为了让这些魔力成为现实，我们就不能在开发过程中才想到这些动画，而是应该在设计时就要考虑这些交互，这一点非常重要。</p>

<p>非常感谢 <a href="https://twitter.com/lorenb">Loren Brichter</a> 给这篇文章提出的一些意见。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义Formatters]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/16/zi-ding-yi-formatters/"/>
    <updated>2014-05-16T14:09:57+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/16/zi-ding-yi-formatters</id>
    <content type="html"><![CDATA[<p>我们希望有一种快速的一次性的解决方案，可以把数据格式化为一种易读的格式。Foundation 框架中的就有 <code>NSFormatter</code> 可以很好地胜任这个工作。另外，在 Mac 上，Appkit 已经内建了 <code>NSFormatter</code> 的支持。</p>

<h2>内建格式器</h2>

<p>Foundation 框架中的 <code>NSFormatter</code> 是一个抽象类，它有两个已经实现的子类：<code>NSNumberFormatter</code> 与 <code>NSDateFormatter</code>。现在我们先跳过这些，来实现我们自己的子类。</p>

<p>如果你想了解更多的相关知识，我推荐阅读 <a href="http://nshipster.com/nsformatter/">NSHipster</a>。</p>

<h2>介绍</h2>

<p><code>NSFormatter</code> 除了抛出错误，其它什么事也不做。我还不知道有人想要用这个，当然如果它对你有用，就去用它吧。</p>

<p>因为我们不喜欢错误，我们在此实现一个 <code>NSFormatter</code> 的子类，它可以把 <code>UIColor</code> 实例转换成可读的名字。例如，以下代码可以返回字符串“Blue”:</p>

<pre><code>KPAColorFormatter *colorFormatter = [[KPAColorFormatter alloc] init];
[colorFormatter stringForObjectValue:[UIColor blueColor]] // Blue
</code></pre>

<p><code>NSFormatter</code> 的子类化有两个方法需要实现：<code>stringForObjectValue:</code> 与 <code>getObjectValue:ForString:errorDescription:</code>。我们先开始介绍第一个方法，因为这个方法更常用。第二个方法，就我所知，经常用于 OS X 上，并且通常不是很有用，我们将稍后介绍。</p>

<h2>初始化</h2>

<p>首先，我们需要做些初始化的工作。由于没有事先定义好的字典可以把颜色映射至名字，这些工作将由我们来完成。为了简化，这些工作将在初始化方法中完成：</p>

<p><code>objc
- (id)init;
{
    return [self initWithColors:@{
        [UIColor redColor]: @"Red",
        [UIColor blueColor]: @"Blue",
        [UIColor greenColor]: @"Green"
    }];
}
</code></p>

<p>这里的 colors 是一个以 <code>UIColor</code> 实例为键，英语名为值的字典。大家可以自行地去实现 <code>initWithColors:</code> 方法。当然你也可以自行实现，或者直接前往 <a href="https://github.com/klaaspieter/KPAColorFormatter">Github repo</a> 获得答案。</p>

<h2>格式化对象值</h2>

<p>由于我们这里只可以格式化 <code>UIColor</code> 实例对象，于是在方法 <code>stringForObjectValue:</code> 中的第一件事就是判断传入的参数类型是否是 <code>UIColor</code> 类。</p>

<p>```
- (NSString *)stringForObjectValue:(id)value;
{
    if (![value isKindOfClass:[UIColor class]]) {
        return nil;
    }</p>

<pre><code>// To be continued... } ```
</code></pre>

<p>在判断参数合法后，我们可以实现真正的逻辑了。我们的格式器中包含一个 <code>UIColor</code> 对象为键，颜色名为值的字典。因此，我们只需要以 <code>UIColor</code> 对象为键找到对应的值：</p>

<p>```objc
- (NSString *)stringForObjectValue:(id)value;
{
    // Previously on KPAColorFormatter</p>

<pre><code>return [self.colors objectForKey:value]; } ```
</code></pre>

<p>以上代码是一个尽可能简单的实现。一个更高级（有用）的格式器应该是在我们的颜色字典中没有找到匹配的颜色时，返回一个最接近的颜色。大家可以自行实现，或是你不想花费太多功夫，可以前往 <a href="https://github.com/klaaspieter/KPAColorFormatter">Github repo</a>。</p>

<h2>反向格式化</h2>

<p>我们的格式器也应该支持反向格式化，即把字符串转成实例对象。这是通过 <code>getObjectValue:forString:errorDescription:</code> 方法实现。在 OS X 上，在使用 <code>NSCell</code> 时会经常用到这个方法。</p>

<p><code>NSCell</code> 有一个 <code>objectValue</code> 属性。默认情况下，<code>NSCell</code> 会用 <code>objectValue</code> 的描述，但是它也可以选择用一个格式器。在用 <code>NSTextFieldCell</code> 时，用户可以输入值，作为程序员，我们可能期望 <code>objedctValue</code> 可以根据根据输入的字符串转成一个 <code>UIColor</code> 实例。例如，用户如果输入“Blue”，我们需要返回一个 <code>[UIColor blueColor]</code> 实例的引用。</p>

<p>实现反向格式化分为两部分：一部分为当格式器可以成功地把字符串转成 <code>UIColor</code> 实例，另一部分当其不能成功转换。第一部分代码如下：</p>

<p>```objc
- (BOOL)getObjectValue:(out __autoreleasing id *)obj 
             forString:(NSString *)string 
      errorDescription:(out NSString *__autoreleasing *)error;
{
    __block UIColor *matchingColor = nil;
    [self.colors enumerateKeysAndObjectsUsingBlock:^(UIColor *color, NSString *name, BOOL *stop) {
        if([name isEqualToString:string]) {
            matchingColor = color;
            *stop = YES;
        }
    }];</p>

<pre><code>if (matchingColor) {
    *obj = matchingColor;
    return YES;
} // Snip ```
</code></pre>

<p>这里可以做一些优化，但是我们先不去做这些。以上方法会遍历我们颜色字典里的每一个对象 ，当一个颜色名字找到时，则会返回其对应关联的 <code>UIColor</code> 实例对象的引用，同时返回 YES 告知调用者我们已经成功地把字符串转成了一个 <code>UIColor</code> 实例对象。</p>

<p>现在处理第二部分：</p>

<p>```objc
if (matchingColor) {
    // snap
} else if (error) {
    *error = [NSString stringWithFormat:@”No known color for name: %@”, string];
}</p>

<p>return NO;
```</p>

<p>这里，我们如果不能找到一个匹配的颜色，我们会检测调用者是否需要错误信息，如果需要，则把错误通过引用返回。这里检查错误很重要。如果你不这样做，程序就会 crash。同时，我们也会返回 NO，告知调用者这次转换失败。</p>

<h2>本地化</h2>

<p>到现在，我们已经建立了一个完全功能的 <code>NSFormatter</code> 的子类，当然这只是对于生活在美国的英语使用者而言有用。</p>

<p>但相比全世界 71.3 亿人，那才 3.19 亿。或者说，你还有 96% 的潜在用户。当然你可以说：这些潜在用户绝大部分都不是 iPhone 或 Mac 使用者，这么做有什么意思呢？这么想你就太扫兴了。</p>

<p><code>NSNumberFormatter</code> 与 <code>NSDateFormatter</code> 都有一个 locale 属性，它是 <code>NSLocale</code> 实例对象。我们现在来扩展格式器以支持本地化，让它可以根据 local 属性来返回对应翻译的名字。</p>

<h3>翻译</h3>

<p>首先，我们需要翻译颜色名字字符串。有关 genstring 与 *.lprojs 超出了本文的范围。有<a href="http://www.getlocalization.com/library/get-localization-mac/">很多文章</a>讨论这点。好了，不需要其它工作了，快要结束了。</p>

<h3>本地化的格式化</h3>

<p>接下来是本地化功能的实现。在获取翻译的字符串后，我们需要更新 <code>stringForObejectValue:</code> 方法。以前已经使用过 <code>NSLocalizedString</code> 的人可能已经早早的把每一个字符串都用 <code>NSLocalizedString</code> 替换了。但是我们不会这么做。</p>

<p>我们现在处理的是一个动态的 local，而 <code>NSLocalizedString</code> 只会查找当前默认的语言的翻译。在99%的情况下，这种默认的行为是你所想要的，但是我们会用格式化器的 locale 属性来动态查询语言。</p>

<p>以下是 <code>stringForObjectValue:</code> 的新的实现：</p>

<p>```objc
- (NSString *)stringForObjectValue:(id)value;
{
    // Previously on… don’t you hate these? I just watched that 20 seconds ago!</p>

<pre><code>NSString *languageCode = [self.locale objectForKey:NSLocaleLanguageCode];
NSURL *bundleURL = [[NSBundle bundleForClass:self.class] URLForResource:languageCode 
                                                          withExtension:@"lproj"];
NSBundle *languageBundle = [NSBundle bundleWithURL:bundleURL];
return [languageBundle localizedStringForKey:name value:name table:nil]; } ```
</code></pre>

<p>上面的代码还有可以重构改进的地方，但因为把代码都放在同一个地方可以方便阅读，所以请大家多多包涵了。</p>

<p>首先，我们通过 locale 属性查找相应的语言，之后通过 NSBundle 找到对应的语言代码。最后，我们会让 bundle 对英语名称进行翻译。如果找不到对应的翻译，则会返回 name: 方法的参数（即英语名称）。如上即是 <code>NSLocalizedString</code> 的具体实现。</p>

<h3>本地化的反向格式化</h3>

<p>同样，我们也可以把颜色名称转成 <code>UIColor</code> 实例对象，当然，我认为这样做是不值得的。我们当前的实现适用于99%的情况。另外1%的情况是在 Mac 的 <code>NSCell</code> 上使用，而且你允许用户输入一个你试图解析的颜色的名字，这所需要做的要比简单的 子类化 NSFormatter 复杂很多。或许，你不应该允许你的用户通过文本输入颜色值。<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSColorPanel_Class/">NSColorPanel</a> 在这里是一个更好的解决方案。</p>

<h2>属性化字符串</h2>

<p>到目前为止，我们的格式器都按我们预期的工作。接下来让我们做一个完全没用的功能，只是示范一下我们可以这么做，你懂的。</p>

<p>格式器同时支持属性化字符串。要不要支持它取决于你特定的应用与其用户界面。因此，你最好把这个功能做成可配置。</p>

<p>以下代码就是将文本颜色设置为当前正在格式化的颜色：</p>

<p>```objc
- (NSAttributedString *)attributedStringForObjectValue:(id)value 
                                 withDefaultAttributes:(NSDictionary *)defaultAttributes;
{
    NSString *string = [self stringForObjectValue:value];</p>

<pre><code>if  (!string) {
    return nil;
}

NSMutableDictionary *attributes = [NSMutableDictionary dictionaryWithDictionary:defaultAttributes];
attributes[NSForegroundColorAttributeName] = value;
return [[NSAttributedString alloc] initWithString:string attributes:attributes]; } ```
</code></pre>

<p>首先，我们如之前一样处理字符串，然后检查格式化是否成功。然后我们把默认的属性值与前面设置的颜色属性结合后，最终返回属性化字符串。很容易，是吗？</p>

<h2>便捷</h2>

<p>因为初始化内建的格式器<a href="https://twitter.com/ID_AA_Carmack/status/28939697453">太慢了</a>，所以通常需要对外给你的格式器提供一个便利的类方法。这个格式器应该用默认值与当前的本地化环境。以下是格式器的实现：</p>

<pre><code>+ (NSString *)localizedStringFromColor:(UIColor *)color;
{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        KPAColorFormatterReusableInstance = [[KPAColorFormatter alloc] init];
    });

    return [KPAColorFormatterReusableInstance stringForObjectValue:color];
}
</code></pre>

<p>除非你的格式器像 <code>NSNumberFormatter</code> 与 <code>NSDateFormatter</code> 一样做一些疯狂的事情 ，你可能不需要因为性能问题这么做。但是这样做也可以让使用格式器简单许多。</p>

<h2>总结</h2>

<p>我们的颜色格式器现在可以把一个 <code>UIColor</code> 实例格式成一个可读的名字或是反过来也行。当然还有放多有关 <code>NSFormatter</code> 的事情没有涉及。特别是在 Mac 上，因为它跟 <code>NSCell</code> 相关，你可以用更多高级的特性。例如当用户在编辑的时，你可以对字符串做一些检测。</p>

<p>我们的格式器还可以做更多自定义的事情。例如，在没查找到一个你需要的颜色名字时，我们可以返回给你最相近的颜色名字。有时，你可能需要我们的格式器有一个 Boolean 属性来控制该功能。或许我们的属性化字符串的格式化不是你想要的，并且应该支持更多自定义操作。</p>

<p>就此，我们完成了一个非常可靠的格式器。所有的代码（伴有 OS X 示例）都放在了 <a href="https://github.com/klaaspieter/KPAColorFormatter">Github</a> 上， 并且你也可以在 <a href="http://cocoapods.org/">CocoaPods</a> 上看到。如果你应用需要此功能，可以将 "KPAColorFormatter" 放在你的 Podfile 中，开始使用它吧。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[消息传递机制]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/05/14/xiao-xi-chuan-di-ji-zhi/"/>
    <updated>2014-05-14T21:31:58+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/05/14/xiao-xi-chuan-di-ji-zhi</id>
    <content type="html"><![CDATA[<p>每个应用或多或少都由一些需要相互传递消息的对象结合起来以完成任务。在这篇文章里，我们将介绍所有可用的消息传递机制，并通过例子来介绍怎样在苹果的框架里使用。我们还会选择一些最佳范例来介绍什么时候该用什么机制。</p>

<p>虽然这一期的主题是关于 Foundation 框架的，但是我们会超出 Foundation 的消息传递机制 (KVO 和 通知) 来讲一讲 delegation，block 和 target-action 几种机制。</p>

<p>当然，有些情况下该使用什么机制没有唯一的答案，所以应该按照自己的喜好去试试。另外大多数情况下该使用什么机制应该是很清楚的。</p>

<p>本文中，我们会常常提及“接收者”和“发送者”。它们在消息传递中的意思可以通过以下的例子解释：一个 table view 是发送者，它的 delegate 就是接收者。Core Data managed object context 是它所发出的 notification 的发送者，获取 notification 的就是接收者。一个滑块 (slider) 是 action 消息的发送者，而实现这个 action （方法）的是它的接收者。任何修改一个支持 KVO 的对象的对象是发送者，这个 KVO 对象的观察者就是接收者。明白精髓了吗？</p>

<h2>几种消息传递机制</h2>

<p>首先我们来看看每种机制的具体特点。在这个基础上，下一节我们会画一个流程图来帮我们在具体情况下正确选择应该使用的机制。最后，我们会介绍一些苹果框架里的例子并且解释为什么在那些用例中会选择这样的机制。</p>

<h3 id="kvo">KVO</h3>

<p>KVO 是提供对象属性被改变时的通知的机制。KVO 的实现在 Foundation 中，很多基于 Foundation 的框架都依赖它。想要了解更多有关 KVO 的最佳实践，请阅读本期 Daniel 写的 <a href="http://objccn.io/issue-7-3">KVO 和 KVC 文章</a>。</p>

<p>如果只对某个对象的值的改变感兴趣的话，就可以使用 KVO 消息传递。不过有一些前提：第一，接收者（接收对象改变的通知的对象）需要知道发送者 （值会改变的对象）；第二，接收者需要知道发送者的生命周期，因为它需要在发送者被销毁前注销观察者身份。如果这两个要去符合的话，这个消息传递机制可以一对多（多个观察者可以注册观察同一个对象的变化）</p>

<p>If you plan to use KVO on Core Data objects, you have to know that things work a bit differently here. This has to do with Core Data's faulting mechanism. Once a managed object turns into a fault, it will fire the observers on its properties although their values haven't changed.</p>

<p>如果要在 Core Data 上使用 KVO 的话，方法会有些许差别。这和 Core Data 的 faulting 机制有关。一旦一个 managed object 被 faulting 处理的话，即使它的属性没有被改变，它还是会触发相应的观察者。</p>

<blockquote>
  <span class="secondary radius label">编者注</span> 把属性值先取入缓存中，在对象需要的时候再进行一次访问，这在 Core Data 中是默认行为，这种技术称为 Faulting。这么做可以避免降低内存开销，但是如果你确定将访问结果对象的具体属性值时，可以禁用 Faults 以提高获取性能。关于这个技术更多的情况，请移步<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdFaultingUniquing.html">官方文档</a>
</blockquote>

<h3>通知</h3>

<p>要在代码中的两个不相关的模块中传递消息时，通知机制是非常好的工具。通知机制广播消息，当消息内容丰富而且无需指望接收者一定要关注的话这一招特别有用。</p>

<p>通知可以用来发送任意消息，甚至可以包含一个 <code>userInfo</code> 字典。你也可以继承 <code>NSNotification</code> 写一个自己的通知类来自定义行为。通知的独特之处在于，发送者和接收者不需要相互知道对方，所以通知可以被用来在不同的相隔很远的模块之间传递消息。这就意味着这种消息传递是单向的，我们不能回复一个通知。</p>

<h3 id="delegation">委托 (Delegation)</h3>

<p>Delegation 在苹果的框架中广泛存在。它让我们能自定义对象的行为，并收到一些触发的事件。要使用 delegation 模式的话，发送者需要知道接收者，但是反过来没有要求。因为发送者只需要知道接收者符合一定的协议，所以它们两者结合的很松。</p>

<p>因为 delegate 协议可以定义任何的方法，我们可以照着自己的需求来传递消息。可以用方法参数来传递消息内容，delegate 可以通过返回值的形式来给发送者作出回应。如果只要在相对接近的两个模块间传递消息，delgation 是很灵活很直接的消息传递机制。</p>

<p>过度使用 delegation 也会带来风险。如果两个对象结合得很紧密，任何其中一个对象都不能单独运转，那么就不需要用 delegate 协议了。这些情况下，对象已经知道各自的类型，可以直接交流。两个比较新的例子是 <code>UICollectionViewLayout</code> 和 <code>NSURLSessionConfiguration</code>。</p>

<p><a name="blocks"> </a>  </p>

<h3 id="block">Block</h3>

<p>Block 是最近才加入 Objective-C 的，首次出现在 OS X 10.6 和 iOS 4 平台上。Block 通常可以完全替代 delegation 消息传递机制的角色。不过这两种机制都有它们自己的独特需求和优势。</p>

<p>一个不使用 block 的理由通常是 block 会存在导致 retain 环 (<a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/memorymgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-1000810">retain cycles</a>) 的风险。如果发送者需要 retain block 但又不能确保引用在什么时候被赋值为 <code>nil</code>， 那么所有在 block 内对 <code>self</code> 的引用就会发生潜在的 retain 环。</p>

<p>假设我们要实现一个用 block 回调而不是 delegate 机制的 table view 里的选择方法，如下所示：</p>

<pre><code>self.myTableView.selectionHandler = ^void(NSIndexPath *selectedIndexPath) {
    // 处理选择
};
</code></pre>

<p>这儿的问题是，<code>self</code> 会 retain table view，table view 为了让 block 之后可以使用而又需要 retain 这个 block。然而 table view 不能把这个引用设为 nil，因为它不知道什么时候不需要这个 block 了。如果我们不能保证打破 retain 环并且我们需要 retain 发送者，那么 block 就不是一个的好选择。</p>

<p><code>NSOperation</code> 是使用 block 的一个好范例。因为它在一定的地方打破了 retain 环，解决了上述的问题。</p>

<p><code>objc
self.queue = [[NSOperationQueue alloc] init];
MyOperation *operation = [[MyOperation alloc] init];
operation.completionBlock = ^{
    [self finishedOperation];
};
[self.queue addOperation:operation];
</code></p>

<p>一眼看来好像上面的代码有一个 retain 环：<code>self</code> retain 了 queue，queue retain 了 operation， operation retain 了 completionBlock， 而 completionBlock retain 了 <code>self</code>。然而，把 operation 加入 queue 中会使 operation 在某个时间被执行，然后被从 queue 中移除。（如果没被执行，问题就大了。）一旦 queue 把 operation 移除，retain 环就被打破了。</p>

<p>另一个例子是：我们在写一个视频编码器的类，在类里面我们会调用一个 <code>encodeWithCompletionHandler:</code> 的方法。为了不出问题，我们需要保证编码器对象在某个时间点会释放对 block 的引用。其代码如下所示：</p>

<p>```objc
@interface Encoder ()
@property (nonatomic, copy) void (^completionHandler)();
@end</p>

<p>@implementation Encoder</p>

<ul>
  <li>(void)encodeWithCompletionHandler:(void (^)())handler
{
  self.completionHandler = handler;
  // 进行异步处理…
}</li>
</ul>

<p>// 这个方法会在完成后被调用一次
- (void)finishedEncoding
{
    self.completionHandler();
    self.completionHandler = nil; // &lt;- 不要忘了这个!
}</p>

<p>@end
```</p>

<p>一旦任务完成，completion block 调用过了以后，我们就应该把它设为 <code>nil</code>。</p>

<p>如果一个被调用的方法需要发送一个一次性的消息作为回复，那么使用 block 是很好的选择， 因为这样做我们可以打破潜在的 retain 环。另外，如果将处理的消息和对消息的调用放在一起可以增强可读性的话，我们也很难拒绝使用 block 来进行处理。在用例之中，使用 block 来做完成的回调，错误的回调，或者类似的事情，是很常见的情况。</p>

<h3 id="targetaction">Target-Action</h3>

<p>Target-Action 是回应 UI 事件时典型的消息传递方式。iOS 上的 <code>UIControl</code> 和 Mac 上的 <code>NSControl</code>/<code>NSCell</code> 都支持这个机制。Target-Action 在消息的发送者和接收者之间建立了一个松散的关系。消息的接收者不知道发送者，甚至消息的发送者也不知道消息的接收者会是什么。如果 target 是 <code>nil</code>，action 会在<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/Devpedia-CocoaApp/Responder.html">响应链 (responder chain)</a> 中被传递下去，直到找到一个响应它的对象。在 iOS 中，每个控件甚至可以和多个 target-action 关联。</p>

<p>基于 target-action 传递机制的一个局限是，发送的消息不能携带自定义的信息。在 Mac 平台上 action 方法的第一个参数永远接收者。iOS 中，可以选择性的把发送者和触发 action 的事件作为参数。除此之外就没有别的控制 action 消息内容的方法了。</p>

<h2>做出正确的选择</h2>

<p>基于上述对不同消息传递机制的特点，我们画了一个流程图来帮助我们在不同情境下做出不同的选择。一句忠告：流程图的建议不代表最终答案。有些时候别的选择依然能达到应有的效果。只不过大多数情况下这张图能引导你做出正确的决定。</p>

<p><img src="http://img.objccn.io/issue-7/communication-patterns-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="688" /></p>

<p>图中有些细节值得深究：</p>

<p>有个框中说到： <em>发送者支持 KVO</em>。这不仅仅是说发送者会在值改变的时候发送 KVO 通知，而且说明观察者需要知道发送者的生命周期。如果发送者被存在一个 weak 属性中，那么发送者有可能会自己变成 nil，那时观察者会导致内存泄露。</p>

<p>一个在最后一行的框里说，<em>消息直接响应方法调用</em>。也就是说方法调用的接收者需要给调用者一个消息作为方法调用的直接反馈。这也就是说处理消息的代码和调用方法的代码必须在同一个地方。</p>

<p>最后在右下角的地方，一个选择分支这样说：<em>发送者能确保释放对 block 的引用吗？</em>这涉及到了我们<a href="#block">之前</a>讨论 block 的 API 存在潜在的 retain 环的问题。如果发送者不能保证在某个时间点会释放对 block 的引用，那么你会惹上 retain 环的麻烦。</p>

<h2 id="framework">Framework 示例</h2>

<p>本节我们通过一些苹果框架里的例子来验证流程图的选择是否有道理，同时解释为什么苹果会选择用这些机制。</p>

<h3 id="kvo">KVO</h3>

<p><code>NSOperationQueue</code> 用了 KVO 观察队列中的 operation 状态属性的改变情况 (<code>isFinished</code>，<code>isExecuting</code>，<code>isCancelled</code>)。当状态改变的时候，队列会收到 KVO 通知。为什么 operation 队列要用 KVO 呢？</p>

<p>消息的接收者（operation 队列）知道消息的发送者（operation），并 retain 它并控制后者的生命周期。另外，在这种情况下只需要单向的消息传递机制。当然如果考虑到 oepration 队列只关心那些改变 operation 的值的改变情况的话，就还不足以说服大家使用 KVO 了。但我们可以这么理解：被传递的消息可以被当成值的改变来处理。因为 state 属性在 operation 队列以外也是有用的，所以这里适合用 KVO。</p>

<p><img src="http://img.objccn.io/issue-7/kvo-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="678" /></p>

<p>当然 KVO 不是唯一的选择。我们也可以将 operation 队列作为 operation 的 delegate 来使用，operation 会调用类似 <code>operationDidFinish:</code> 或者 <code>operationDidBeginExecuting:</code> 等方法把它的 state 传递给 queue。这样就不太方便了，因为 operation 要保存 state 属性，以便于调用这些 delegate 方法。另外，由于 queue 不能主动获取 state 信息，所以 queue 也必须保存所有 operation 的 state。</p>

<h3 id="notifications">Notifications</h3>

<p>Core Data 使用 notification 传递事件（例如一个 managed object context 中的改变————<code>NSManagedObjectContextObjectsDidChangeNotification</code>）</p>

<p>发生改变时触发的 notification 是由 managed object contexts 发出的，所以我们不能假定消息的接收者知道消息的发送者。因为消息的源头不是一个 UI 事件，很多接收者可能在关注着此消息，并且消息传递是单向的，所以 notification 是唯一可行的选择。</p>

<p><img src="http://img.objccn.io/issue-7/notification-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="687" /></p>

<h3 id="delegation">Delegation</h3>

<p>Table view 的 delegate 有多重功能，它可以从管理 accessory view，直到追踪在屏幕上显示的 cell。例如我们可以看看 <code>tableView:didSelectRowAtIndexPath:</code> 方法。为什么用 delegate 实现而不是 target-action 机制？</p>

<p>正如我们在上述流程图中看到的，用 target-action 时，不能传递自定义的数据。而选中 table view 的某个 cell 时，collection view 不仅需要告诉我们一个 cell 被选中了，也要通过 index path 告诉我们哪个 cell 被选中了。如果我们照着这个思路，流程图会引导我们使用 delegation 机制。</p>

<p><img src="http://img.objccn.io/issue-7/delegation-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="687" /></p>

<p>如果不在消息传递中包含选中 cell 的 index path，而是让选中项改变时我们像 table view 主动询问并获取选中 cell 的相关信息，会怎样呢？这会非常不方便，因为我们必须记住当前选中项的数据，这样才能在多选择中知道哪些 cell 是被新选中的。</p>

<p>同理，我们可以想象通过观察 table view 选中项的 index path 属性，当该值发生改变的时候，获得一个选中项改变的通知。不过我们会遇到上述相似问题：不做记录的话我们就不能分辨哪一个 cell 被选择或取消选择了。</p>

<h3 id="block">Block</h3>

<p>我们用 <code>-[NSURLSession dataTaskWithURL:completionHandler:]</code> 来作为一个 block API 的介绍。那么从 URL 加载部分返回给调用者是怎么传递消息的呢？首先，作为 API 的调用者，我们知道消息的发送者，但是我们并没有 retain 它。另外，这是个单向的消息传递————它直接调用 <code>dataTaskWithURL:</code> 的方法。如果我们对照流程图，会发现这属于 block 消息传递机制。</p>

<p><img src="http://img.objccn.io/issue-7/block-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="688" /></p>

<p>有其他的选项吗？当然，苹果自己的 <code>NSURLConnection</code> 就是最好的例子。<code>NSURLConnection</code>在 block 问世之前就存在了，所以它并没有用 block 来实现消息传递，而是使用 delegation 来完成。当 block 出现以后，苹果就在 OS X 10.7 和 iOS 5 平台上的 <code>NSURLConnection</code> 中加了 <code>sendAsynchronousRequest:queue:completionHandler:</code>，所以我们不再在简单的任务中使用 delegate 了。</p>

<p>因为 <code>NSURLSession</code> 是个最近在 OS X 10.9 和 iOS 7 才出现的 API，所以它们使用 block 来实现消息传递机制（<code>NSURLSession</code> 有一个 delegate，但是是用于其他目的）。</p>

<h3 id="targetaction">Target-Action</h3>

<p>一个明显的 target-action 用例是按钮。按钮在不被按下的时候不需要发送任何的信息。为了这个目的，target-action 是 UI 中消息传递的最佳选择。</p>

<p><img src="http://img.objccn.io/issue-7/target-action-flow-chart.png" title="Decision flow chart for communication patterns in Cocoa" width="585" height="678" /></p>

<p>如果 target 是明确指定的，那么 action 消息会发送给指定的对象。如果 target 是 <code>nil</code>， action 消息会一直在响应链中被传递下去，直到找到一个能处理它的对象。在这种情况下，我们有一个完全解耦的消息传递机制：发送者不需要知道接收者，反之亦然。</p>

<p>Target-action 机制非常适合响应 UI 的事件。没有其他的消息传递机制能够提供相同的功能。虽然 notification 在发送者和接收者的松散关系上最接近它，但是 target-action 可以用于响应链——只有一个对象获得 action 并响应，action 在响应链中传递，直到能遇到响应这个 action 的对象。</p>

<h2>总结</h2>

<p>一开始接触这么多的消息传递机制的时候，我们可能有些无所适从，觉得所有的机制都可以被选用。不过一旦我们仔细分析每个机制的时候，它们各自都有特殊的要求和能力。</p>

<p>文中的选择流程图是帮助你清楚认识这些机制的好的开始，当然它不是所有问题的答案。如果你觉得这和你自己选择机制的方式相似或是有任何缺漏，欢迎来信指正。</p>

<hr />

]]></content>
  </entry>
  
</feed>
