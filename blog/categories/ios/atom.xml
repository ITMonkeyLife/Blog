<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | IT Monkey Life]]></title>
  <link href="http://ITMonkeyLife.github.io/Blog/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://ITMonkeyLife.github.io/Blog/"/>
  <updated>2014-04-09T17:22:59+08:00</updated>
  <id>http://ITMonkeyLife.github.io/Blog/</id>
  <author>
    <name><![CDATA[Rick]]></name>
    <email><![CDATA[382542165@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS7.0:隐藏技巧和变通之道]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/ios7-dot-0-yin-cang-ji-qiao-he-bian-tong-zhi-dao/"/>
    <updated>2014-04-09T17:16:22+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/ios7-dot-0-yin-cang-ji-qiao-he-bian-tong-zhi-dao</id>
    <content type="html"><![CDATA[<p>当 iOS 7 刚发布的时候，全世界的苹果开发人员都立马尝试着去编译他们的 app，接着再花上数月的时间来修复任何出现的错误，甚至从头开始重建这个 app。这样的结果，使得人们根本无暇去探究 iOS 7 所带来的新思想。除开一些明显而细微的更新，比如说 NSArray 的 <code>firstObject</code> 方法——这个方法可追溯到 iOS 4 时代，现在被提为公有 API——还有很多隐藏的技巧等着我们去挖掘。</p>

<h2>平滑淡入淡出动画</h2>

<p>我在这里要讨论的并非新的弹性动画 API 或者 UIDynamics，而是一些更细微的东西。CALayer 增加了两个新方法：<code>allowsGroupOpacity</code> 和 <code>allowsEdgeAntialiasing</code>。现在，组不透明度（group opacity）不再是什么新鲜的东西了。iOS 会多次使用存在于 Info.plist 中的键 <code>UIViewGroupOpacity</code> 并可在应用程序范围内启用或禁用它。对于大多数 app 而言，这（译注：启用）并非所期望的，因为它会降低整体性能。在 iOS 7 中，用 SDK 7 所链接的程序，这项属性默认是启用的。当它被启用时，一些动画将会变得不流畅，它也可以在 layer 层上被控制。</p>

<p>一个有趣的细节，如果 <code>allowsGroupOpacity</code> 启用的话，<code>_UIBackdropView</code>（被用作 <code>UIToolbar</code> 或者 <code>UIPopoverView</code> 的背景视图）不能对其模糊进行动画处理，所以当你做一个 alpha 转换时，你可能会临时禁用这项属性。因为这会降低动画体验，你可以回到旧的方式然后在动画期间临时启用 <code>shouldRasterize</code>。别忘了设置适当的 <code>rasterizationScale</code>，否则在 retina 的设备上这些视图会成锯齿状（pixelerated）。</p>

<p>如果你想要复制 Safari 显示所有选项卡时的动画，那么边缘抗锯齿属性将变得非常有用。</p>

<h2>阻塞动画</h2>

<p>有一个小但是非常有用的新方法 <code>[UIView performWithoutAnimation:]</code>。它是一个简单的封装，先检查动画当前是否启用，如果是则停用动画，执行块语句，然后重新启用动画。一个需要说明的地方是，它并 <em>不会</em> 阻塞基于 CoreAnimation 的动画。因此，不用急于将你的方法调用从：</p>

<p><code>objc
    [CATransaction begin];
    [CATransaction setDisableActions:YES];
    view.frame = CGRectMake(...);
    [CATransaction commit];
</code></p>

<p>替换成:</p>

<p><code>objc
    [UIView performWithoutAnimation:^{
        view.frame = CGRectMake(...);
    }];
</code></p>

<p>但是，绝大多数情况下这样也能工作得很好，只要你不直接跟 CALayer 打交道。</p>

<p>iOS 7 中，我有很多代码路径（主要是 <code>UITableViewCells</code>）需要额外保护以防止意外的动画，例如，如果一个弹窗（popover）的大小调整了，与此同时其中的表视图将因为高度的变化而加载新的 cell。我通常的做法是将整个 <code>layoutSubviews</code> 的代码包扎到一个动画块中：</p>

<p><code>objc
- (void)layoutSubviews 
{
    // 否则在 iOS 7 的传统模式下弹窗动画会渗入我们的单元格
    [UIView performWithoutAnimation:^{
        [super layoutSubviews];
        _renderView.frame = self.bounds;
    }];
}
</code></p>

<h2>处理长的表视图</h2>

<p><code>UITableView</code> 非常快速高效，除非你开始使用 <code>tableView:heightForRowAtIndexPath:</code>，它会开始为你表中 <em>每一个</em> 元素调用此方法，即便没有可视对象——这是为了让其下层的 <code>UIScrollView</code> 能获取正确的 <code>contentSize</code>。此前有一些变通方法，但都不好用。iOS 7 中，苹果公司终于承认这一问题，并添加了  <code>tableView:estimatedHeightForRowAtIndexPath:</code>，这个方法把绝大部分计算成本推迟到实际滚动的时候。如果你完全不知道一个 cell 的大小，返回 <code>UITableViewAutomaticDimension</code> 就行了。</p>

<p>对于段头/尾（section headers/footers），现在也有类似的 API 了。</p>

<h2 id="uisearchdisplaycontroller">UISearchDisplayController</h2>

<p>苹果的 search controller 使用了新的技巧来简化移动 search bar 到 navigation bar 的过程。启用 <code>displaysSearchBarInNavigationBar</code> 就可以了（除非你还在用 scope bar，那你就太不幸了）。我倒是很喜欢这么做，但遗憾的是，iOS 7 上的 <code>UISearchDisplayController</code> 貌似被破坏得相当严重，尤其在 iPad 上。苹果公司看上去像是没时间处理这个问题，对于显示的搜索结果并不会隐藏实际的表视图。在 iOS 7 之前，这不算问题，但是现在 <code>searchResultsTableView</code> 有一个透明的背景色，使它看上去相当糟糕。作为一种变通方法，你可以设置不透明背景色或者采取一些<a href="http://petersteinberger.com/blog/2013/fixing-uisearchdisplaycontroller-on-ios-7/">更富于技巧的手段</a>来获得你期望的效果。关于这个控件我碰到过各种各样的结果，当使用 <code>displaysSearchBarInNavigationBar</code> 时甚至 <em>根本</em> 不会显示搜索表视图。</p>

<p>你的结果可能有所不同，但我依赖于一些手段（severe hacks）来让 <code>displaysSearchBarInNavigationBar</code> 工作：</p>

<p>```objc
- (void)restoreOriginalTableView 
{
    if (PSPDFIsUIKitFlatMode() &amp;&amp; self.originalTableView) {
        self.view = self.originalTableView;
    }
}</p>

<ul>
  <li>
    <p>(UITableView *)tableView 
{
  return self.originalTableView ?: [super tableView];
}</p>
  </li>
  <li>
    <p>(void)searchDisplayController:(UISearchDisplayController *)controller 
didShowSearchResultsTableView:(UITableView *)tableView 
{
  // HACK: iOS 7 依赖于重度的变通来显示搜索表视图
  if (PSPDFIsUIKitFlatMode()) {
      if (!self.originalTableView) self.originalTableView = self.tableView;
      self.view = controller.searchResultsTableView;
      controller.searchResultsTableView.contentInset = UIEdgeInsetsZero; // 移除 64 像素的空白
  }
}</p>
  </li>
  <li>
    <p>(void)searchDisplayController:(UISearchDisplayController *)controller 
didHideSearchResultsTableView:(UITableView *)tableView 
{
  [self restoreOriginalTableView];
}
```</p>
  </li>
</ul>

<p>另外，别忘了在 <code>viewWillDisappear</code> 中调用 <code>restoreOriginalTableView</code>，否则程序会 crash。
记住这只是一种解决办法；可能还有不那么激进的方法，不用替换视图本身，但这个问题确实应该由苹果公司来修复。（TODO: RADAR!）</p>

<h2>分页</h2>

<p><code>UIWebView</code> 现在可以对带有 <code>paginationMode</code> 的网站进行自动分页。有一大堆与此功能相关的新属性：</p>

<p><code>objc
@property (nonatomic) UIWebPaginationMode paginationMode NS_AVAILABLE_IOS(7_0);
@property (nonatomic) UIWebPaginationBreakingMode paginationBreakingMode NS_AVAILABLE_IOS(7_0);
@property (nonatomic) CGFloat pageLength NS_AVAILABLE_IOS(7_0);
@property (nonatomic) CGFloat gapBetweenPages NS_AVAILABLE_IOS(7_0);
@property (nonatomic, readonly) NSUInteger pageCount NS_AVAILABLE_IOS(7_0);
</code></p>

<p>目前而言，虽然这不一定对大多数网站都有用，但它肯定是生成简单的电子书阅读器或者显示文本的一种更好的方式。加点乐子的话，请尝试将它设置为 <code>UIWebPaginationModeBottomToTop</code>。</p>

<h2 id="popover">会飞的 Popover</h2>

<p>想知道为什么你的 popover 疯了一样到处乱飞？在 <code>UIPopoverControllerDelegate</code> 协议中有一个新的代理方法让你能控制它：</p>

<p><code>objc
-  (void)popoverController:(UIPopoverController *)popoverController
  willRepositionPopoverToRect:(inout CGRect *)rect 
                       inView:(inout UIView **)view
</code></p>

<p>当 popover 锚点是指向一个 <code>UIBarButtonItem</code> 时，<code>UIPopoverController</code> 会做出合适的展现，但是如果你让它在一个 view 或者 rect 中显示，你可能就需要实现此方法并正常返回。一个花费了我相当长时间来验证的问题——如果你通过改变 <code>preferredContentSize</code> 来动态调整你的 popover，那么这个方法就尤其需要实现。苹果公司现在对改变 popover 大小的请求更严格，如果没有预留足够的空间，popover 将会到处移动。</p>

<h2>键盘支持</h2>

<p>苹果公司不只为我们提供了<a href="https://developer.apple.com/library/ios/documentation/ServicesDiscovery/Conceptual/GameControllerPG/Introduction/Introduction.html">全新的 framework 用于游戏控制器</a>，它也给了我们这些键盘爱好者一些关注！你会发现新定义的公用键，比如  <code>UIKeyInputEscape</code> 或 <code>UIKeyInputUpArrow</code>，可以使用全新的 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKeyCommand_class/Reference/Reference.html#//apple_ref/occ/instp/UIKeyCommand/input"><code>UIKeyCommand</code></a> 类截查。在 iOS 7 之前，只能通过一些<a href="http://petersteinberger.com/blog/2013/adding-keyboard-shortcuts-to-uialertview/">难以言表的手段来处理键盘命令</a>，现在，就让我们操起蓝牙键盘试试看我们能用这个做什么！</p>

<p>开始之前，你需要对响应链（responder chain）有个了解。你的 <code>UIApplication</code> 继承自  <code>UIResponder</code>，<code>UIView</code> 和 <code>UIViewController</code> 也是如此。如果你曾经处理过 <code>UIMenuItem</code>  并且没有使用<a href="https://github.com/steipete/PSMenuItem">我的基于块的包装</a>的话，那么你对此已经有所了解。事件先被发送到最上层的响应者，然后一级级往下传递直到 UIApplication。为了捕获按键命令，你需要告诉系统你关心哪些按键命令（而不是全捕获）。为了完成这个，你需要重写 <code>keyCommands</code> 这个新属性：</p>

<p>```objc
- (NSArray *)keyCommands 
{
    return @[[UIKeyCommand keyCommandWithInput:@”f”
                                 modifierFlags:UIKeyModifierCommand<br />
                                        action:@selector(searchKeyPressed:)]];
}</p>

<ul>
  <li>(void)searchKeyPressed:(UIKeyCommand *)keyCommand 
{
  // 响应事件
}
```</li>
</ul>

<p><img src="http://img.objccn.io/issue-5/responder-chain.png" name="工作中的响应者链" width="472" height="548" /></p>

<p>现在可别太激动，需要注意的是，这个方法只在键盘可见时有效（比如有类似 <code>UITextView</code> 这样的对象作为第一响应者时）。对于全局热键，你仍然需要用上面提到的 hack 方法。除去那些，这个解决途径还是很优雅的。不要覆盖类似 cmd-V 这种系统的快捷键，它会被自动映射到 <code>paste:</code> 方法。</p>

<p>还有一些新的预定义的响应者行为：</p>

<p><code>objc
- (void)increaseSize:(id)sender NS_AVAILABLE_IOS(7_0);
- (void)decreaseSize:(id)sender NS_AVAILABLE_IOS(7_0);
</code></p>

<p>它们分别对应 cmd+ 和 cmd- 命令，用来放大/缩小内容。</p>

<h2>匹配键盘背景</h2>

<p>苹果公司终于公开了 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIInputView_class/Reference/Reference.html"><code>UIInputView</code></a>，其中提供了一种方式——使用 <code>UIInputViewStyleKeyboard</code> 来匹配键盘样式。这使得你能编写自定义的键盘或者适应默认样式的默认键盘的扩展（工具条）。这个类<a href="https://github.com/nst/iOS-Runtime-Headers/commits/master/Frameworks/UIKit.framework/UIInputView.h">一开始</a>就存在了，不过现在我们终于可以绕过私有API的方式来使用它了。</p>

<p>如果 <code>UIInputView</code> 是一个 <code>inputView</code> 或者 <code>inputAccessoryView</code> 的<em>根视图</em>，它将只显示一个背景，否则它将是透明的。遗憾的是，这并不能让你实现一个未填充的分离态的键盘，但它仍然比用一个简单的 UIToolbar 要好。我还没看到苹果在何处使用这个新 API，看上去 Safari 里仍然使用着 <code>UIToolbar</code>。</p>

<h2>了解你的无线电通信</h2>

<p>虽然早在 iOS 4 的时候，大部分的运营商信息已经在 CTTelephony 暴露了，但它通常只用于特定场景并非十分有用。iOS 7 中，苹果公司为其添加了一个方法，其中最有用的：<code>currentRadioAccessTechnology</code>。这个方法能告诉你手机是处于较慢的 GPRS 还是高速的 LTE 或者介于其中。目前还没有方法得到连接速度（当然手机本身也无法获取这个），但是这足以用来优化一个下载管理器，让其在 EDGE 下不用尝试 <em>同时</em> 去下载6张图片了。</p>

<p>现在还没有 <code>currentRadioAccessTechnology</code> 的相关文档，为了让它工作，会遇到一些麻烦和错误。当你想要获取当前网络信号值，你应当注册一个 <code>CTRadioAccessTechnologyDidChangeNotification</code> 通知而不是去轮询这个属性。为了确切的使 iOS 发送这些通知，你需要持有一个 <code>CTTelephonyNetworkInfo</code> 的实例，但不要在通知中创建  <code>CTTelephonyNetworkInfo</code> 的实例，否则会 crash。</p>

<p>在这个简单的例子中，因为在 block 中捕获 <code>telephonyInfo</code> 将会持有它，所以我就这么用了：</p>

<p><code>objc
CTTelephonyNetworkInfo *telephonyInfo = [CTTelephonyNetworkInfo new];
NSLog(@"Current Radio Access Technology: %@", telephonyInfo.currentRadioAccessTechnology);
[NSNotificationCenter.defaultCenter addObserverForName:CTRadioAccessTechnologyDidChangeNotification 
                                                object:nil 
                                                 queue:nil 
                                            usingBlock:^(NSNotification *note) 
{
    NSLog(@"New Radio Access Technology: %@", telephonyInfo.currentRadioAccessTechnology);
}];
</code></p>

<p>当手机从 Edge 环境切换到 3G，日志输出应该像这样：</p>

<pre><code>iOS7Tests[612:60b] Current Radio Access Technology: CTRadioAccessTechnologyEdge
iOS7Tests[612:1803] New Radio Access Technology: (null)
iOS7Tests[612:1803] New Radio Access Technology: CTRadioAccessTechnologyHSDPA
</code></pre>

<p>苹果导出了所有字符串符号，因此可以很简单的比较和检测当前的网络信息。</p>

<h2 id="corefoundationautorelease">Core Foundation，Autorelease 和你</h2>

<p>Core Foundation 中出现了一个新的辅助方法，它被用于私有调用已有数年时间：</p>

<p><code>objc
CFTypeRef CFAutorelease(CFTypeRef CF_RELEASES_ARGUMENT arg)
</code></p>

<p>它的确做了你所期望的事，让人费解的是苹果花了这么长时间才把它公开。ARC 下，大多数人在处理返回 Core Foundation 对象时是通过转换成对等的 NS 对象来完成的，如返回一个  <code>NSDictionary</code>，虽然它是一个 <code>CFDictionaryRef</code>，简单地使用 <code>CFBridgingRelease()</code> 就行了。这样通常没问题，除非你返回的没有可用的对等 NS 对象，如 <code>CFBagRef</code>。你要么使用 id，这样会失去类型安全性，要么你将你的方法重命名为 <code>createMethod</code> 并考虑所有的内存语义，最后使用 CFRelease。还有一些手段，比如<a href="http://favstar.fm/users/AndrePang/status/18099774996">这个</a>，使用 non-ARC-file 参数你才能编译它，但终归得使用 CFAutorelease()。另外：不要编写使用苹果公司命名空间的代码，所有这些自定义的 CF-宏将来都会被打破的。</p>

<h2>图片解压缩</h2>

<p>当通过 <code>UIImage</code> 展示一张图片时，在显示之前需要解压缩（除非图片源已经像素缓存了）。对于 JPG/PNG 文件这会占用相当可观的时间并会造成卡顿。iOS 6 以前，通常是通过创建一个位图上下文，然后在其中画图来解决。<a href="https://github.com/AFNetworking/AFNetworking/blob/09658b352a496875c91cc33dd52c3f47b9369945/AFNetworking/AFURLResponseSerialization.m#L442-518">（参见 AFNetworking 如何处理这个问题）</a>。</p>

<p>从 iOS 7 开始，你可以使用 <code>kCGImageSourceShouldCacheImmediately</code>: 强制图片在创建时直接解压缩：</p>

<p>```objc
+ (UIImage *)decompressedImageWithData:(NSData *)data 
{
    CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);
    CGImageRef cgImage = CGImageSourceCreateImageAtIndex(source, 0, (__bridge CFDictionaryRef)@{(id)kCGImageSourceShouldCacheImmediately: @YES});</p>

<pre><code>UIImage *image = [UIImage imageWithCGImage:cgImage];
CGImageRelease(cgImage);
CFRelease(source);
return image; } ```
</code></pre>

<p>刚发现这一点时我很很兴奋，但不要高兴得太早。在我的测试中，开启即时缓存后性能实际上有所 <em>降低</em>。要么这个方法最终是在主线程中被调用的（好像不太可能），要么感官上的性能下降是因为其在方法 <code>copyImageBlockSetJPEG</code> 中锁住了，因为这个方法也被用在主线程显示非加密的图片时。在我的 app 中，我在主线程中加载小的预览图，在后台线程中加载大型图，使用了 <code>kCGImageSourceShouldCacheImmediately</code> 后小小的解压缩阻塞了主线程，同时在后台处理大量开销昂贵的操作。    </p>

<p><img src="http://img.objccn.io/issue-5/image-decompression.png" name="Image Decompression Stack Trace" width="662" height="1008" /></p>

<p>还有更多关于图片解压缩的却不是 iOS 7 中的新东西，像 <code>kCGImageSourceShouldCache</code>，它用来控制系统自动卸载解压缩图片数据的能力。确保你将它设置为 YES，否则所有的工作都将没有意义。有趣的是，苹果在 64-bit 运行时的系统中将 <code>kCGImageSourceShouldCache</code> 的 <em>默认值</em> 从 NO 改为了 YES。</p>

<h2>盗版检查</h2>

<p>苹果添加了一个方式，通过 NSBunble 上的新方法 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSBundle_Class/Reference/Reference.html#//apple_ref/occ/instm/NSBundle/appStoreReceiptURL"><code>appStoreReceiptURL</code></a> 来获取和验证 Lion 系统上 App Store 的收据，现在终于也移植到了 iOS 上了。这使得你可以检查你的应用是合法购买的还是被破解了的。检查收据还有另一个重要的原因，它包含了 <em>初始购买日期</em>，这点对于把你的应用从付费模式迁移到免费+应用内付费模式很有帮助。你可以根据这个初始购买日期来决定额外内容对于你的用户是免费（因为他们已经付过费了）还是收费的。</p>

<p>收据还允许你检查应用程序是否通过批量购买计划购买以及该许可证是否仍有效，有一个名为  <code>SKReceiptPropertyIsVolumePurchase</code> 的属性标示了该值。</p>

<p>当你调用 <code>appStoreReceiptURL</code> 时，你需要特别注意，因为在 iOS 6 上，它还是一个私有 API，你应该在用户代码中先调用 <code>doesNotRecognizeSelector:</code>，在调用前检查运行（基础）版本。在开发期间，这个方法返回的 URL 不会指向一个文件。你可能需要使用 StoreKit 的 <a href="https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKReceiptRefreshRequest_ClassRef/SKReceiptRefreshRequest.html"><code>SKReceiptRefreshRequest</code></a>，这也是 iOS 7 中的新东西，用它来下载证书。使用一个至少有过一次购买的测试用户，否则它将没法工作：</p>

<p><code>objc
// 刷新收据
SKReceiptRefreshRequest *request = [[SKReceiptRefreshRequest alloc] init];
[request setDelegate:self];
[request start];
</code></p>

<p>验证收据需要大量的代码。你需要使用 OpenSSL 和内嵌的<a href="http://www.apple.com/certificateauthority/">苹果根证书</a>，并且你还要了解一些基本的东西像是证书、<a href="http://en.wikipedia.org/wiki/PKCS">PCKS 容器</a>以及 <a href="http://de.wikipedia.org/wiki/Abstract_Syntax_Notation_One">ASN.1</a>。这里有一些<a href="https://github.com/rmaddy/VerifyStoreReceiptiOS">样例代码</a>，但是你不应该让它这么简单——尤其是对那些有“高尚意图”的人，别只是拷贝现有的验证方法，至少做点修改或者编写你自己的，你应该不希望一个普通的补丁程序就能在数秒内瓦解你的努力吧。</p>

<p>你绝对应该读读苹果的指南——<a href="https://developer.apple.com/library/mac/releasenotes/General/ValidateAppStoreReceipt/index.html#//apple_ref/doc/uid/TP40010573-CH1-SW6">验证 Mac App 商店收据</a>，这里面的大多数都适用于 iOS。苹果在 <a href="https://developer.apple.com/wwdc/videos/">WWDC 2013 的 Session 308 “Using Receipts to Protect Your Digital Sales”</a> 中详述了通过新加入的“Grand Unified Receipt”而带来的变动。</p>

<h2 id="comicsansms">Comic Sans MS</h2>

<p>承认吧，你是怀念 Comic Sans MS 的。在 iOS 7 中，Comic Sans MS 终于回来了。iOS 6 中添加了可下载字体，但那时的字体列表很少也不见得有趣。在 iOS 7 中苹果添加了不少字体，包括 “famous”，它和 <a href="http://www.fontsquirrel.com/fonts/PT-Sans">PT Sans</a> 或 <a href="http://sixrevisions.com/graphics-design/comic-sans-the-font-everyone-loves-to-hate/">Comic Sans MS</a> 有些类似。<code>kCTFontDownloadableAttribute</code> 并没有在 iOS 6 中声明，所以 iOS 7 之前它并不真正可用，但苹果确是在 iOS 6 的时候就已经做了私有声明了。</p>

<p><img src="http://img.objccn.io/issue-5/comic-sans-ms.png" name="Who doesn't love Comic Sans MS" width="414" height="559" /></p>

<p>字体列表是<a href="http://mesu.apple.com/assets/com_apple_MobileAsset_Font/com_apple_MobileAsset_Font.xml">动态变化</a>的，以后可能就会发生变动。苹果在 <a href="http://support.apple.com/kb/HT5484">Tech Note HT5484</a> 中罗列了一些可用的字体，但这个文档已经过时了，并不能反映 iOS 7 的变化。</p>

<p>这里显示了你该如何获取一个用 <code>CTFontDescriptorRef</code> 标示的可下载的字体数组：</p>

<p><code>objc
CFDictionary *descriptorOptions = @{(id)kCTFontDownloadableAttribute : @YES};
CTFontDescriptorRef descriptor = CTFontDescriptorCreateWithAttributes((CFDictionaryRef)descriptorOptions);
CFArrayRef fontDescriptors = CTFontDescriptorCreateMatchingFontDescriptors(descriptor, NULL);
</code></p>

<p>系统不会检查字体是否已存在于磁盘上而将直接返回同样的列表。另外，这个方法可能会启用网络并造成阻塞，你不应该在主线程中使用它。</p>

<p>使用如下基于块的 API 来下载字体：    </p>

<p><code>objc
bool CTFontDescriptorMatchFontDescriptorsWithProgressHandler(
         CFArrayRef                          descriptors,
         CFSetRef                            mandatoryAttributes,
         CTFontDescriptorProgressHandler     progressBlock)
</code></p>

<p>这个方法能操作网络并传递下载进度信息来调用你的 <code>progressBlock</code> 方法直到下载成功或者失败。参考苹果的 <a href="https://developer.apple.com/library/ios/samplecode/DownloadFont/Listings/DownloadFont_ViewController_m.html">DownloadFont 样例</a>看看如何使用它。    </p>

<p>有一些值得注意的地方，这里的字体只在当前程序运行时有效，下次运行将被重新载入内存。因为字体存放在共享空间中，你不能依赖于它们是否可用。很有可能但不能保证地说，系统会清理这个目录，或者你的程序被拷贝到没有这个字体的新设备中，同时你又没有网络。在 Mac 或是模拟器上，你能根据 <code>kCTFontURLAttribute</code> 获得字体的绝对路径，加载速度也会提升，但是在 iOS 上是不行的，因为这个目录在你的程序之外，你需要再次调用 <code>CTFontDescriptorMatchFontDescriptorsWithProgressHandler</code>。</p>

<p>你也可以注册新的 <code>kCTFontManagerRegisteredFontsChangedNotification</code> 通知来跟踪新字体在何时被载入到了字体注册表中。你可以在 <a href="https://developer.apple.com/wwdc/videos/">WWDC 2013 的 Session 223 “Using Fonts with TextKit”</a>中查找更多信息。</p>

<h2>这还不够?</h2>

<p>没关系，iOS 7 的新东西远不止如此！了解一下 <a href="http://nshipster.com/ios7/">NSHipster</a> 你将明白语音合成相关的东西，base64、全新的 <code>NSURLComponents</code>、<code>NSProgress</code>、条形码扫描、阅读列表以及 <code>CIDetectorEyeBlink</code>。还有很多我们没有涵盖到的，比如苹果的 <a href="https://developer.apple.com/library/ios/releasenotes/General/iOS70APIDiffs/index.html#//apple_ref/doc/uid/TP40013203">iOS 7 API 变化</a>，<a href="https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS7.html">What's new in iOS</a>指南以及 <a href="https://developer.apple.com/library/prerelease/mac/releasenotes/Foundation/RN-Foundation/index.html#//apple_ref/doc/uid/TP30000742">Foundation Release Notes</a>（这些都是基于 OS X的，但是代码都是共享的，很多也同样适用于 iOS）。很多新方法都还没形成文档，等着你来探究和写成博客。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ScrollView的前世今生]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/scrollviewde-qian-shi-jin-sheng/"/>
    <updated>2014-04-09T17:04:49+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/scrollviewde-qian-shi-jin-sheng</id>
    <content type="html"><![CDATA[<p>可能你很难相信 <a href="http://developer.apple.com/library/ios/#documentation/uikit/reference/UIScrollView_Class/Reference/UIScrollView.html">UIScrollView</a> 和一个标准的 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/UIView/UIView.html">UIView</a> 差异并不大，scroll view 确实会多出一些方法，但这些方法只是和 UIView 的属性很好的结合到一起了。因此，在要想弄懂 UIScrollView 是怎么工作之前，你需要先了解一下 UIView，特别是视图渲染的两步过程。</p>

<h2>光栅化和组合</h2>

<p>渲染过程的第一部分是众所周知的光栅化(<code>rasterization</code>)，光栅化简单的说就是产生一组绘图指令并且生成一张图片。比如绘制一个圆角矩形、带图片、标题居中的 UIButtons。这些图片并没有被绘制到屏幕上去；取而代之的是，他们被自己的视图保持着留到下一个步骤使用。</p>

<p>一旦每个视图都产生了自己的光栅化图片，这些图片便被一个接一个的绘制，并产生一个屏幕大小的图片，这便是上文所说的组合。视图层级(view hierarchy)对于组合如何进行扮演了很重要的角色：一个视图的图片被组合在它父视图的图片上面。然后，组合好的图片被组合到父视图的父视图图片上面。视图层级最顶端是窗口(window)，它组合好的图片便是我们看到的东西了。</p>

<p>概念上，依次在每个视图上放置独立分层的图片并最终产生一个图片，单调的图像更容易被理解，特别是如果你以前使用过像 Photoshop 这样的工具。我们还有另外一篇文章详细解释了<a href="http://objccn.io/issue-3-1/">像素是如何绘制到屏幕上去的</a>。</p>

<p>现在，回想一下，每个视图都有一个 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instp/UIView/bounds">bounds</a> 和 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instp/UIView/frame">frame</a>。当布局一个界面时，我们需要处理视图的 frame。这允许我们放置并设置视图的大小。视图的 frame 和 bounds 的大小总是一样的，但是他们的 origin 有可能不同。弄懂这两个工作原理是理解 UIScrollView 的关键。</p>

<p>在光栅化步骤中，视图并不关心即将发生的组合步骤。也就是说，它并不关心自己的 frame (这是用来放置视图的图像)或自己在视图层级中的位置(这是决定组合的顺序)。这时视图只关心一件事就是绘制它自己的 content。这个绘制发生在每个视图的 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instm/UIView/drawRect:"><code>drawRect:</code></a> 方法中。</p>

<p>在 <code>drawRect:</code> 方法被调用前，会为视图创建一个空白的图片来绘制 content。这个图片的坐标系统是视图的 bounds。几乎每个视图 bounds 的 origin 都是 {0，0}。因此，当在光栅化图片左上角绘制一些东西的时候，你都会在 bounds 的 origin {x:0, y:0} 处绘制。在一个图片右下角的地方绘制东西的时候，你都会绘制在 {x:width, y:height} 处。如果你的绘制超出了视图的 bounds，那么超出的部分就不属于光栅化图片的部分了，并且会被丢弃。</p>

<p><img src="http://img.objccn.io/issue-3/SV2.png" alt="" title="" /></p>

<p>在组合的步骤中，每个视图将自己光栅化图片组合到自己父视图的光栅化图片上面。视图的 frame 决定了自己在父视图中绘制的位置，frame 的 origin 表明了视图光栅化图片左上角相对父视图光栅化图片左上角的偏移量。所以，一个 origin 为 {x:20, y:15} 的 frame 所绘制的图片左边距其父视图 20 点，上边距父视图 15 点。因为视图的 frame 和 bounds 矩形的大小总是一样的，所以光栅化图片组合的时候是像素对齐的。这确保了光栅化图片不会被拉伸或缩小。</p>

<p><img src="http://img.objccn.io/issue-3/SV1.png" alt="" title="" /></p>

<p>记住，我们才仅仅讨论了一个视图和它父视图之间的组合操作。一旦这两个视图被组合到一起，组合的结果图片将会和父视图的父视图进行组合，这是一个雪球效应。</p>

<p>考虑一下组合图片背后的公式。视图图片的左上角会根据它 frame 的 origin 进行偏移，并绘制到父视图的图片上：</p>

<p>```objc
CompositedPosition.x = View.frame.origin.x - Superview.bounds.origin.x;</p>

<p>CompositedPosition.y = View.frame.origin.y - Superview.bounds.origin.y;
```</p>

<p>正如之前所说的，如果一个视图 bounds 的 origin 是 {0,0}。那么，我们得到这个公式：</p>

<p>```objc
CompositedPosition.x = View.frame.origin.x;</p>

<p>CompositedPosition.y = View.frame.origin.y;
```</p>

<p>我们可以通过几个不同的 frames 看一下：</p>

<p><img src="http://img.objccn.io/issue-3/SV3.png" alt="" title="" /></p>

<p>这样做是有道理的，我们改变 button 的 <code>frame.origin</code>后，它会改变自己相对紫色父视图的位置。注意，如果我们移动 button 直到它的一部分已经在紫色父视图 bounds 的外面，当光栅化图片被截去时这部分也将会通过同样的绘制方式被截去。然而，技术上讲，因为 iOS 处理组合方法的原因，你可以将一个子视图渲染在其父视图的 bounds 之外，但是光栅化期间的绘制不可能超出一个视图的 bounds。</p>

<h2 id="scrollviewcontentoffset">Scroll View的Content Offset</h2>

<p>现在我们所讲的跟 UIScrollView 有什么关系呢？一切都和它有关！考虑一种我们可以实现的滚动：我们有一个拖动时 frame 不断改变的视图。这达到了相同的效果，对吗？如果我拖动我的手指到右边，那么拖动的同时我增大视图的 <code>origin.x</code> ，瞧，这货就是 scroll view。</p>

<p>当然，在 scroll view 中有很多具有代表性的视图。为了实现这个平移功能，当用户移动手指时，你需要时刻改变每个视图的 frames。当我们提到组合一个 view 的光栅化图片到它父视图什么地方时，记住这个公式：</p>

<p>```objc
CompositedPosition.x = View.frame.origin.x - Superview.bounds.origin.x;</p>

<p>CompositedPosition.y = View.frame.origin.y - Superview.bounds.origin.y;
```</p>

<p>我们减少 <code>Superview.bounds.origin</code> 的值(因为他们总是0)。但是如果他们不为0呢？我们用和前一个图例相同的 frames，但是我们改变了紫色视图 bounds 的 origin 为 {-30, -30}。得到下图：</p>

<p><img src="http://img.objccn.io/issue-3/SV4.png" alt="" title="" /></p>

<p>现在，巧妙的是通过改变这个紫色视图的 bounds，它每一个单独的子视图都被移动了。事实上，这正是 scroll view 工作的原理。当你设置它的 <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIScrollView_Class/Reference/UIScrollView.html#//apple_ref/occ/instp/UIScrollView/contentOffset">contentOffset</a> 属性时它改变 <code>scroll view.bounds</code> 的 origin。事实上，contentOffset 甚至不是实际存在的。代码看起来像这样：</p>

<p><code>objc
- (void)setContentOffset:(CGPoint)offset
{
    CGRect bounds = [self bounds];
    bounds.origin = offset;
    [self setBounds:bounds];
}
</code></p>

<p>注意前一个图例，只要足够的改变 bounds 的 origin，button 将会超出紫色视图和 button 组合成的图片的范围。这也是当你足够的移动 scroll view 时，一个视图会消失！</p>

<h2 id="contentsize">世界之窗：Content Size</h2>

<p>现在，最难的部分已经过去了，我们再看看 UIScrollView 另一个属性：<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIScrollView_Class/Reference/UIScrollView.html#//apple_ref/occ/instp/UIScrollView/contentSize">contentSize</a>。
scroll view 的 content size 并不会改变其 bounds 的任何东西，所以这并不会影响 scroll view 如何组合自己的子视图。反而，content size 定义了可滚动区域。scroll view 的默认 content size 为 {w:0, h:0}。既然没有可滚动区域，用户是不可以滚动的，但是 scroll view 任然会显示其 bounds 范围内所有的子视图。 <br />
当 content size 设置为比 bounds 大的时候，用户就可以滚动视图了。你可以认为 scroll view 的 bounds 为可滚动区域上的一个窗口：</p>

<p><img src="http://img.objccn.io/issue-3/SV5.png" alt="" title="" /></p>

<p>当 content offset 为 {x:0, y:0} 时，可见窗口的左上角在可滚动区域的左上角处。这也是 content offset 的最小值；用户不能再往可滚动区域的左边或上边移动了。那儿没啥，别滚了！</p>

<p>content offset 的最大值是 content size 和 scroll view size 的差(不同于 content size 和scroll view的 bounds 大小)。这也在情理之中：从左上角一直滚动到右下角，用户停止时，滚动区域右下角边缘和滚动视图 bounds 的右下角边缘是齐平的。你可以像这样记下 content offset 的最大值：</p>

<p>```objc
contentOffset.x = contentSize.width - bounds.size.width;</p>

<p>contentOffset.y = contentSize.height - bounds.size.height;
```</p>

<h2 id="contentinsets">用Content Insets对窗口稍作调整</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIScrollView_Class/Reference/UIScrollView.html#//apple_ref/occ/instp/UIScrollView/contentInset">contentInset</a> 属性可以改变 content offset 的最大和最小值，这样便可以滚动出可滚动区域。它的类型为 <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIKitDataTypesReference/Reference/reference.html#//apple_ref/doc/c_ref/UIEdgeInsets">UIEdgeInsets</a>，包含四个值：{top，left，bottom，right}。当你引进一个 inset 时，你改变了 content offset 的范围。比如，设置 content inset 顶部值为 10，则允许 content offset 的 y 值达到 10。这介绍了可滚动区域周围的填充。</p>

<p><img src="http://img.objccn.io/issue-3/SV6.png" alt="" title="" /></p>

<p>这咋一看好像没什么用。实际上，为什么不仅仅增加 content size 呢？除非没办法，否则你需要避免改变scroll view 的 content size。想要知道为什么？想想一个 table view（UItableView是UIScrollView 的子类，所以它有所有相同的属性），table view 为了适应每一个cell，它的可滚动区域是通过精心计算的。当你滚动经过 table view 的第一个或最后一个 cell 的边界时，table view将 content offset 弹回并复位，所以 cells 又一次恰到好处的紧贴 scroll view 的 bounds。</p>

<p>当你想要使用 <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIRefreshControl_class/Reference/Reference.html">UIRefreshControl</a> 实现拉动刷新时发生了什么？你不能在 table view 的可滚动区域内放置 UIRefreshControl，否则，table view 将会允许用户通过 refresh control 中途停止滚动，并且将 refresh control 的顶部弹回到视图的顶部。因此，你必须将 refresh control 放在可滚动区域上方。这将允许首先将 content offset 弹回第一行，而不是 refresh control。</p>

<p>但是等等，如果你通过滚动足够多的距离初始化 pull-to-refresh 机制，因为 table view 设置了 content inset，这将允许 content offset 将 refresh control 弹回到可滚动区域。当刷新动作被初始化时，content inset 已经被校正过，所以 content offset 的最小值包含了完整的 refresh control。当刷新完成后，content inset 恢复正常，content offset 也跟着适应大小，这里并不需要为content size 做数学计算。(这里可能比较难理解，建议看看 EGOTableViewPullRefresh 这样的类库就应该明白了)</p>

<p>如何在自己的代码中使用 content inset？当键盘在屏幕上时，有一个很好的用途：你想要设置一个紧贴屏幕的用户界面。当键盘出现在屏幕上时，你损失了几百个像素的空间，键盘下面的东西全都被挡住了。</p>

<p>现在，scroll view 的 bounds 并没有改变，content size 也并没有改变(也不需要改变)。但是用户不能滚动 scroll view。考虑一下之前一个公式：content offset 的最大值是 content size 和 bounds 的差。如果他们相等，现在 content offset 的最大值是 {x:0, y:0}.</p>

<p>现在开始出绝招，将界面放入一个 scroll view。scroll view 的 content size 仍然和 scroll view 的 bounds 一样大。当键盘出现在屏幕上时，你设置 content inset 的底部等于键盘的高度。</p>

<p><img src="http://img.objccn.io/issue-3/SV7.png" alt="" title="" /></p>

<p>这允许在 content offset 的最大值下显示滚动区域外的区域。可视区域的顶部在 scroll view bounds 的外面，因此被截取了(虽然它在屏幕之外了，但这并没有什么)。</p>

<p>但愿这能让你理解一些滚动视图内部工作的原理，你对缩放感兴趣？好吧，我们今天不会谈论它，但是这儿有一个有趣的小窍门：检查 <a href="http://developer.apple.com/library/ios/#documentation/uikit/reference/UIScrollViewDelegate_Protocol/Reference/UIScrollViewDelegate.html#//apple_ref/doc/uid/TP40006923-CH3-SW7"><code>viewForZoomingInScrollView:</code></a> 方法返回视图的 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instp/UIView/transform">transform</a> 属性。你将再次发现 scroll view 只是聪明的利用了 UIView 已经存在的属性。</p>

<p>相关链接(强烈推荐)：</p>

<p><a href="http://bbs.weiphone.com/read-htm-tid-6880069.html">计算机图形渲染的流程</a></p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS之玩转字符串]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/ioszhi-wan-zhuan-zi-fu-chuan/"/>
    <updated>2014-04-09T16:40:06+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/ioszhi-wan-zhuan-zi-fu-chuan</id>
    <content type="html"><![CDATA[<p>在每个应用里我们都大量使用字符串。下面我们将快速看看一些常见的操作字符串的方法，过一遍常见操作的最佳实践。</p>

<h2>字符串的比较、搜索和排序</h2>

<p>排序和比较字符串比第一眼看上去要复杂得多。不只是因为字符串可以包含<strong>代理对（surrogate pairs ）</strong>(详见 <a href="http://objccn.io/issue-9-1/#peculiar-unicode-features">Ole 写的这篇关于 Unicode 的文章</a>) ，而且比较还与字符串的本地化相关。在某些极端情况下相当棘手。</p>

<p>苹果文档中 <em>String Programming Guide</em> 里有一节叫做 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html"><strong>“字符与字形集群（Characters and Grapheme Clusters）”</strong></a>，里面提到一些陷阱。例如对于排序来说，一些欧洲语言将序列“ch”当作单个字母。在一些语言里，“ä”被认为等同于 ‘a’ ，而在其它语言里它却被排在 ‘z’ 后面。</p>

<p>而 <code>NSString</code> 有一些方法来帮助我们处理这种复杂性。首先看下面的方法：</p>

<pre><code>- (NSComparisonResult)compare:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)range locale:(id)locale
</code></pre>

<p>它带给我们充分的灵活性。另外，还有很多<strong>便捷函数（convenience functions）</strong>都使用了这个方法。</p>

<p>与比较有关的可用参数如下：</p>

<p><code>objc
NSCaseInsensitiveSearch
NSLiteralSearch
NSNumericSearch
NSDiacriticInsensitiveSearch
NSWidthInsensitiveSearch
NSForcedOrderingSearch
</code></p>

<p>它们都可以用逻辑“或”运算符组合在一起。</p>

<p><code>NSCaseInsensitiveSearch</code>：“A”等同于“a”，然而在某些地方还有更复杂的情况。例如，在德国，“ß” 和 “SS”是等价的。</p>

<p><code>NSLiteralSearch</code>：Unicode 的点对点比较。它只在所有字符都用相同的方式组成的情况下才会返回相等（即 <code>NSOrderedSame</code>）。LATIN CAPITAL LETTER A 加上 COMBINING RING ABOVE 并不等同于 LATIN CAPITAL LETTER A WITH RING ABOVE.</p>

<blockquote>
  <p><span class="secondary radius label">编者注</span> 这里要解释一下，首先，每一个Unicode都是有官方名字的！LATIN CAPITAL LETTER A是一个大写“A”，COMBINING RING ABOVE是一个  ̊，LATIN CAPITAL LETTER A WITH RING ABOVE，这是Å。前两者的组合不等同于后者。</p>
</blockquote>

<p><code>NSNumericSearch</code>：它对字符串里的数字排序，所以 “Section 9” &lt; “Section 20” &lt; “Section 100.”</p>

<p><code>NSDiacriticInsensitiveSearch</code>：“A” 等同于 “Å” 等同于 “Ä.”</p>

<p><code>NSWidthInsensitiveSearch</code>：一些东亚文字（平假名和片假名）有全宽与半宽两种形式。</p>

<p>很值得一提的是<code>-localizedStandardCompare:</code>，它排序的方式和 Finder 一样。它对应的选项是 <code>NSCaseInsensitiveSearch</code>、<code>NSNumericSearch</code>、<code>NSWidthInsensitiveSearch</code> 以及 <code>NSForcedOrderingSearch</code>。如果我们要在 UI 上显示一个文件列表，用它就最合适不过了。</p>

<p>大小写不敏感的比较和音调符号不敏感的比较都是相对复杂和昂贵的操作。如果我们需要比较很多次字符串那这就会成为一个性能上的瓶颈（例如对一个大的数据集进行排序），一个常见的解决方法是同时存储原始字符串和折叠字符串。例如，我们的 <code>Contact</code> 类有一个正常的 <code>name</code> 属性，在内部它还有一个 <code>foldedName</code> 属性，它将自动在 name 变化时更新。那么我们就可以使用 <code>NSLiteralSearch</code> 来比较 name 的折叠版本。 <code>NSString</code> 有一个方法来创建折叠版本：</p>

<p><code>objc
- (NSString *)stringByFoldingWithOptions:(NSStringCompareOptions)options locale:(NSLocale *)locale
</code></p>

<h3>搜索</h3>

<p>要在一个字符串中搜索子字符串，最灵活性的方法是:</p>

<p><code>objc
- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)searchRange locale:(NSLocale *)locale
</code></p>

<p>同时，还有一些便捷方法，它们在最终都会调用上面这个方法，我们可以传入上面列出的参数，以及以下这些额外的参数：</p>

<p><code>objc
NSBackwardsSearch
NSAnchoredSearch
NSRegularExpressionSearch
</code></p>

<p><code>NSBackwardsSearch</code>：在字符串的末尾开始反向搜索。</p>

<p><code>NSAnchoredSearch</code>：只考虑搜索的起始点（单独使用）或终止点（当与 <code>NSBackwardsSearch</code> 结合使用时）。这个方法可以用来检查前缀或者后缀，以及<strong>大小写不敏感（case-insensitive）</strong>或者<strong>音调不敏感（diacritic-insensitive）</strong>的比较。</p>

<p><code>NSRegularExpressionSearch</code>：使用正则表达式搜索，要了解更多与使用正则表达式有关的信息，请关注 Chris 写的字符串解析这篇文章。</p>

<p>另外，还有一个方法：</p>

<p><code>objc
- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet options:(NSStringCompareOptions)mask range:(NSRange)aRange
</code></p>

<p>与前面搜索字符串不同的是，它只搜索给定字符集的第一个字符。即使只搜索一个字符，但如果由于此字符是<strong>由元字符组成的序列（composed character sequence）</strong>，所以返回范围的长度也可能大于1。</p>

<h2>大写与小写</h2>

<p>一定不要使用 <code>NSString</code> 的 <code>-uppercaseString</code> 或者 <code>-lowercaseString</code> 的方法来处理 UI 显示的字符串，而应该使用 <code>-uppercaseStringWithLocale</code> 来代替， 比如：</p>

<p><code>objc
NSString *name = @"Tómas";
cell.text = [name uppercaseStringWithLocale:[NSLocale currentLocale]];
</code></p>

<h2>格式化字符串</h2>

<p>同 C 语言中的 <code>sprintf</code> 函数（ANSI C89 中的一个函数）类似，Objective C 中的 <code>NSString</code> 类也有如下的 3 个方法：</p>

<p><code>objc
-initWithFormat:
-initWithFormat:arguments:
+stringWithFormat:
</code></p>

<p>需要注意这些格式化方法都是<em>非本地化</em>的。所以这些方法得到的字符串是不能直接拿来显示在用户界面上的。如果需要本地化，那我们需要使用下面这些方法:</p>

<p><code>objc
-initWithFormat:locale:
-initWithFormat:locale:arguments:
+localizedStringWithFormat:
</code></p>

<p>Florian 有一篇关于<a href="http://objccn.io/issue-9-3/#localized-format-strings">字符串的本地化</a>的文章更详细地讨论了这个问题。</p>

<p><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/printf.3.html">printf(3)</a> 的 man 页面有关于它如何格式化字符串的全部细节。除了以 <code>%</code> 字符开始的所谓<strong>格式转换符（conversion specification）</strong>，格式化字符串会被逐字复制：</p>

<p><code>objc
double a = 25812.8074434;
float b = 376.730313461;
NSString *s = [NSString stringWithFormat:@"%g :: %g", a, b];
// "25812.8 :: 376.73"
</code></p>

<p>我们格式化了两个浮点数。注意单精度浮点数 <code>float</code> 和双精度浮点数 <code>double</code> 共同了一个格式转换符。</p>

<h3>对象</h3>

<p>除了来自 <code>printf(3)</code> 的转换规范，我们还可以使用 <code>%@</code> 来输出一个对象。在<a href="#object-description">对象描述</a>那一节中有述，如果对象响应 <code>-descriptionWithLocale:</code> 方法，则调用它，否则调用 <code>-description</code>。<code>%@</code> 被结果替换。</p>

<h3>整数</h3>

<p>使用整形数字时，有些需要注意的细节。首先，有符号数（<code>d</code> 和 <code>i</code>）和无符号数（<code>o</code>、<code>u</code>、<code>x</code>和<code>X</code>）的格式转换符是不一样的，需要使用者根据具体情况来选择。</p>

<p>如果我们使用 printf 支持的类型列表之外的类型，就必须要做类型转换。<code>NSUInteger</code> 正是这样一个例子，它在 64 位和 32 位平台上是不一样的。下面的例子可以同时工作在 32 位和 64 位平台上：</p>

<p><code>objc
uint64_t p = 2305843009213693951;
NSString *s = [NSString stringWithFormat:@"The ninth Mersenne prime is %llu", (unsigned long long) p];
// "The ninth Mersenne prime is 2305843009213693951"
</code></p>

<table>  
  <thead>
  <tr><th style="text-align: left">Modifier          </th><th style="text-align: left">d, i           </th><th style="text-align: left">o, u, x, X</th></tr>
  </thead>
  <tbody>
  <tr><td>hh                </td><td>signed char    </td><td>unsigned char</td></tr>
  <tr><td>h                 </td><td>short          </td><td>unsigned short</td></tr>
  <tr><td>(none)            </td><td>int            </td><td>unsigned int</td></tr>
  <tr><td>l (ell)           </td><td>long           </td><td>unsigned long</td></tr>
  <tr><td>ll (ell ell)      </td><td>long long      </td><td>unsigned long long</td></tr>
  <tr><td>j                 </td><td>intmax_t       </td><td>uintmax_t</td></tr>
  <tr><td>t                 </td><td>ptrdiff_t      </td><td /></tr>
  <tr><td>z                 </td><td>               </td><td>size_t</td></tr>
  </tbody>
</table>

<p>适用于整数的转换规则有：</p>

<p><code>objc
int m = -150004021;
uint n = 150004021U;
NSString *s = [NSString stringWithFormat:@"d:%d i:%i o:%o u:%u x:%x X:%X", m, m, n, n, n, n];
// "d:-150004021 i:-150004021 o:1074160465 u:150004021 x:8f0e135 X:8F0E135"
</code></p>

<p><code>%d</code> 和 <code>%i</code> 具有一样的功能，它们都打印出有符号十进制数。<code>%o</code> 就较为晦涩了：它使用<a href="https://en.wikipedia.org/wiki/Octal">八进制</a>表示。<code>%u</code> 输出无符号十进制数——它是我们常用的。最后 <code>%x</code> 和 <code>%X</code> 使用十六进制表示——后者使用大写字母。</p>

<p>对于 <code>x%</code> 和 <code>X%</code>，我们可以在 <code>0x</code> 前面添加 <code>#</code> 前缀，增加可读性。</p>

<p>我们可以传入特定参数，来设置最小字段宽度和最小数字位数（默认两者都是 0），以及左/右对齐。请查看 man 页面获取详细信息。下面是一些例子：</p>

<p><code>objc
int m = 42;
NSString *s = [NSString stringWithFormat:@"'%4d' '%-4d' '%+4d' '%4.3d' '%04d'", m, m, m, m, m];
// "[  42] [42  ] [ +42] [ 042] [0042]"
m = -42;
NSString *s = [NSString stringWithFormat:@"'%4d' '%-4d' '%+4d' '%4.3d' '%04d'", m, m, m, m, m];
// "[ -42] [-42 ] [ -42] [-042] [-042]"
</code></p>

<p><code>%p</code> 可用于打印出指针——它和 <code>%#x</code> 相似但可同时在 32 位和 64 位平台上正常工作。</p>

<h3>浮点数</h3>

<p>浮点数的格式转符有8个：<code>eEfFgGaA</code>。但除了 <code>%f</code> 和 <code>%g</code> 外我们很少使用其它的。对于指数部分，小写的版本使用小写 <code>e</code>，大写的版本就使用大写 <code>E</code>。</p>

<p>通常 <code>%g</code> 是浮点数的全能转换符 ，它与 <code>%f</code> 的不同在下面的例子里显示得很清楚：</p>

<p><code>objc
double v[5] = {12345, 12, 0.12, 0.12345678901234, 0.0000012345678901234};
NSString *s = [NSString stringWithFormat:@"%g %g %g %g %g", v[0], v[1], v[2], v[3], v[4]];
// "12345 12 0.12 0.123457 1.23457e-06"
NSString *s = [NSString stringWithFormat:@"%f %f %f %f %f", v[0], v[1], v[2], v[3], v[4]];
// "12345.000000 12.000000 0.120000 0.123457 0.000001"
</code></p>

<p>和整数一样，我们依然可以指定最小字段宽度和最小数字数。</p>

<h3>指定位置</h3>

<p>格式化字符串允许使用参数来改变顺序：</p>

<p>[NSString stringWithFormat:@"%2$@ %1$@", @"1st", @"2nd"];</p>

<p>// "2nd 1st"</p>

<p>我们只需将从 1 开始的参数与一个 <code>$</code> 接在 <code>%</code> 后面。这种写法在进行本地化的时候极其常见，因为在不同语言中，各个参数所处的顺序位置可能不尽相同。</p>

<h3 id="nslog">NSLog()</h3>

<p><code>NSLog()</code> 函数与 <code>+stringWithFormat:</code> 的工作方式一样。我们可以调用：</p>

<p><code>objc
int magic = 42;
NSLog(@"The answer is %d", magic);
</code></p>

<p>下面的代码可以用同样的方式构造字符串：</p>

<p><code>objc
int magic = 42;
NSString *output = [NSString stringWithFormat:@"The answer is %d", magic];
</code></p>

<p>显然 <code>NSLog()</code> 会输出字符串，并且它会加上时间戳、进程名、进程 ID 以及线程 ID 作为前缀。</p>

<h3>实现能接受格式化字符串的方法</h3>

<p>有时在我们自己的类中提供一个能接受格式化字符串的方法会很方便使用。假设我们要实现的是一个 To Do 类的应用，它包含一个  <code>Item</code> 类。我们想要提供：</p>

<p><code>objc
+ (instancetype)itemWithTitleFormat:(NSString *)format, ...
</code></p>

<p>如此我们就可以使用：</p>

<p><code>objc
Item *item = [Item itemWithFormat:@"Need to buy %@ for %@", food, pet];
</code></p>

<p>这种类型的方法接受可变数量的参数，所以被称为可变参数方法。我们必须使用一个定义在 <code>stdarg.h</code> 里的宏来使用可变参数。上面方法的实现代码可能会像下面这样：</p>

<p><code>objc
+ (instancetype)itemWithTitleFormat:(NSString *)format, ...;
{
    va_list ap;
    va_start(ap, format);
    NSString *title = [[NSString alloc] initWithFormat:format locale:[NSLocale currentLocale] arguments:ap];
    va_end(ap);
    return [self itemWithTitle:title];
}
</code></p>

<p>进一步，我们要添加 <code>NS_FORMAT_FUNCTION</code> 到方法的定义里（即头文件中），如下所示：</p>

<p><code>objc
+ (instancetype)itemWithTitleFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(1,2);
</code></p>

<p><code>NS_FORMAT_FUNCTION</code> 展开为一个方法 <code>__attribute__</code>，它会告诉编译器在索引 <strong>1</strong> 处的参数是一个格式化字符串，而实际参数从索引 <strong>2</strong> 开始。这将允许编译器检查格式化字符串而且会像 <code>NSLog()</code> 和 <code>-[NSString stringWithFormat:]</code> 一样输出警告信息。</p>

<h2>字符与字符串组件</h2>

<p>如有一个字符串 “bird” ，找出组成它的独立字母是很简单的。第二个字母是“i”（Unicode: LATIN SMALL LETTER I）。而对于像<a href="https://en.wikipedia.org/wiki/Åse">Åse</a>这样的字符串就没那么简单了。看起来像三个字母的组合可有多种方式，例如：</p>

<pre><code>A    LATIN CAPITAL LETTER A
 ̊    COMBINING RING ABOVE
s    LATIN SMALL LETTER S
e    LATIN SMALL LETTER E
</code></pre>

<p>或者</p>

<pre><code>Å    LATIN CAPITAL LETTER A WITH RING ABOVE
s    LATIN SMALL LETTER S
e    LATIN SMALL LETTER E
</code></pre>

<p>从 <a href="http://objccn.io/issue-9-1/#peculiar-unicode-features">Ole 写的这篇关于 Unicode 的文章</a> 里可以读到更多关于<strong>联合标记（combining marks）</strong>的信息，其他语言文字有更多复杂的<strong>代理对（complicated surrogate pairs）</strong>。</p>

<p>如果我们要在字符层面处理一个字符串，那我们就要小心翼翼。苹果的文档中 String Programming Guide 里有一节叫做 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html">“Characters and Grapheme Clusters”</a>，里面有更多关于这一点的细节。</p>

<p><code>NSString</code> 有两个方法：</p>

<p><code>objc
-rangeOfComposedCharacterSequencesForRange:
-rangeOfComposedCharacterSequenceAtIndex:
</code></p>

<p>上面这两个方法在有的时候很有帮助，例如，拆分一个字符串时保证我们不会把所谓的<strong>代理对（surrogate pairs）</strong>拆散。</p>

<p>如果我们要针对字符串中的字符做文章， NSString 提供了下面这个方法：</p>

<p><code>objc
-enumerateSubstringsInRange:options:usingBlock:
</code></p>

<p>options 这里传入 <code>NSStringEnumerationByComposedCharacterSequences</code> 这个参数，就可以扫描所有的字符。例如，用下面的方法，我们可将字符串 “International Business Machines” 变成 “IBM”：</p>

<p><code>objc
- (NSString *)initials;
{
    NSMutableString *result = [NSMutableString string];
    [self enumerateSubstringsInRange:NSMakeRange(0, self.length) options:NSStringEnumerationByWords | NSStringEnumerationLocalized usingBlock:^(NSString *word, NSRange wordRange, NSRange enclosingWordRange, BOOL *stop1) {
        __block NSString *firstLetter = nil;
          [self enumerateSubstringsInRange:NSMakeRange(0, word.length) options:NSStringEnumerationByComposedCharacterSequences usingBlock:^(NSString *letter, NSRange letterRange, NSRange enclosingLetterRange, BOOL *stop2) {
              firstLetter = letter;
              *stop2 = YES;
          }];
          if (firstLetter != nil) {
              [result appendString:firstLetter];
        };
    }];
    return result;
}
</code></p>

<p>如文档所示，词和句的分界可能基于地区的变化而变化。因此有 <code>NSStringEnumerationLocalized</code> 这个选项。</p>

<h2>多行文字字面量</h2>

<p>编译器的确有一个隐蔽的特性：把空格分隔开的字符串衔接到一起。这是什么意思呢？这段代码：</p>

<p><code>objc
NSString *limerick = @"A lively young damsel named Menzies\n"
@"Inquired: «Do you know what this thenzies?»\n"
@"Her aunt, with a gasp,\n"
@"Replied: "It's a wasp,\n"
@"And you're holding the end where the stenzies.\n";
</code></p>

<p>与下面这段代码是完全等价的：</p>

<p><code>objc
NSString *limerick = @"A lively young damsel named Menzies\nInquired: «Do you know what this thenzies?»\nHer aunt, with a gasp,\nReplied: "It's a wasp,\nAnd you're holding the end where the stenzies.\n";
</code></p>

<p>前者看起来更舒服，但是有一点要注意：千万不要在任意一行末尾加入逗号或者分号。</p>

<p>你也可以这样做：</p>

<p><code>objc
NSString * string = @"The man " @"who knows everything " @"learns nothing" @".";
</code></p>

<p>编译器只是为我们提供了一个便捷的方式，将多个字符串在编译期组合在了一起。</p>

<h2>可变字符串</h2>

<p>可变字符串有两个常见的使用场景：（1）拼接字符串（2）替换子字符串</p>

<h3>拼接字符串</h3>

<p>可变字符串可以很轻易地把多个字符串按照你的需要组合起来。</p>

<p><code>objc
- (NSString *)magicToken
{
    NSMutableString *string = [NSMutableString string];
    if (usePrefix) {
        [string appendString:@"&amp;gt;&amp;gt;&amp;gt;"];
    }
    [string appendFormat:@"%d--%d", self.foo, self.bar];
    if (useSuffix) {
        [string appendString:@"&amp;gt;&amp;gt;&amp;gt;"];
    }
    return string;
}
</code></p>

<p>这里要注意的是，虽然原本返回值应该是一个 <code>NSString</code> 类型的对象，我们在这里只是简单地返回一个 <code>NSMutableString</code> 类型的对象。</p>

<h3>替换子字符串</h3>

<p>除了追加组合之外，<code>NSMutableString</code> 还提供了以下4个方法：</p>

<p><code>objc
-deleteCharactersInRange:
-insertString:atIndex:
-replaceCharactersInRange:withString:
-replaceOccurrencesOfString:withString:options:range:
</code></p>

<p><code>NSString</code> 也有类似的方法：</p>

<p><code>objc
-stringByReplacingOccurrencesOfString:withString:
-stringByReplacingOccurrencesOfString:withString:options:range:
-stringByReplacingCharactersInRange:withString:
</code></p>

<p>但是 <code>NSMutableString</code> 的那些方法不会创建新的字符串，而仅仅改变当前字符串。这样会让代码更容易阅读，有时也会提升一些性能。</p>

<p><code>objc
NSMutableString *string; // 假设我们已经有了一个名为 string 的字符串
// 现在要去掉它的一个前缀，做法如下:
NSString *prefix = @"WeDon’tWantThisPrefix"
NSRange r = [string rangeOfString:prefix options:NSAnchoredSearch range:NSMakeRange(0, string.length) locale:nil];
if (r.location != NSNotFound) {
    [string deleteCharactersInRange:r];
}
</code></p>

<h2>连接组件</h2>

<p>一个看似微不足道但很常见的情况是字符串连接。比如现在有这样几个字符串：</p>

<pre><code>Hildr
Heidrun
Gerd
Guðrún
Freya
Nanna
Siv
Skaði
Gróa
</code></pre>

<p>我们想用它们来创建下面这样的一个字符串：</p>

<pre><code>Hildr, Heidrun, Gerd, Guðrún, Freya, Nanna, Siv, Skaði, Gróa
</code></pre>

<p>那么就可以这样做：</p>

<p><code>objc
NSArray *names = @["Hildr", @"Heidrun", @"Gerd", @"Guðrún", @"Freya", @"Nanna", @"Siv", @"Skaði", @"Gróa"];
NSString *result = [names componentsJoinedByString:@", "];
</code></p>

<p>如果我们将其显示给用户，我们就要使用本地化表达，确保将最后一部分替换相应语言的 “, and” ：</p>

<p>```
@implementation NSArray (ObjcIO_GroupedComponents)</p>

<ul>
  <li>
    <p>(NSString *)groupedComponentsWithLocale:(NSLocale *)locale;
{
  if (self.count &lt; 1) {
      return @””;
  } else if (self.count &lt; 2) {
      return self[0];
  } else if (self.count &lt; 3) {
      NSString *joiner = NSLocalizedString(@”joiner.2components”, @””);
      return [NSString stringWithFormat:@”%@%@%@”, self[0], joiner, self[1]];
  } else {
      NSString *joiner = [NSString stringWithFormat:@”%@ “, [locale objectForKey:NSLocaleGroupingSeparator]];
      NSArray *first = [self subarrayWithRange:NSMakeRange(0, self.count - 1)];
      NSMutableString *result = [NSMutableString stringWithString:[first componentsJoinedByString:joiner]];</p>

    <pre><code>  NSString *lastJoiner = NSLocalizedString(@"joiner.3components", @"");
  [result appendString:lastJoiner];
  [result appendString:self.lastObject];
  return result;   } }
</code></pre>
  </li>
</ul>

<p>@end
```</p>

<p>那么在本地化的时候，如果是英语，应该是：</p>

<pre><code>"joiner.2components" = " and ";
"joiner.3components" = ", and ";
</code></pre>

<p>如果是德语，则应该是：</p>

<pre><code>"joiner.2components" = " und ";
"joiner.3components" = " und ";
</code></pre>

<p>结合组件的逆过程可以用 <code>-componentsSeparatedByString:</code>，这个方法会将字符串变成一个数组。例如，将 “12|5|3” 变成 “12”、“5” 和 “3”。</p>

<p><a name="object-description"> </a>  </p>

<h2>对象描述</h2>

<p>在许多面向对象编程语言里，对象有一个叫做 <code>toString()</code> 或类似的方法。在 Objective C 里，这个方法是：</p>

<p><code>objc
- (NSString *)description
</code></p>

<p>以及它的兄弟方法:</p>

<p><code>objc
- (NSString *)debugDescription
</code></p>

<p>当自定义模型对象时，覆写 <code>-description</code> 方法是一个好习惯，在 UI 上显示该对象时调用的就是该方法的返回值。假定我们有一个 <code>Contact</code> 类，下面是它的 <code>-description</code> 方法的实现：</p>

<p><code>objc
- (NSString *)description
{
    return self.name;
}
</code></p>

<p>我们可以像下面代码这样格式化字符串：</p>

<p><code>objc
label.text = [NSString stringWithFormat:NSLocalizedString(@"%@ has been added to the group “%@”.", @""), contact, group];
</code></p>

<p>因为该字符串是用来做 UI 显示的，我们可能需要做本地化，那么我们就需要覆写下面这个方法：</p>

<p><code>objc
- (NSString *)descriptionWithLocale:(NSLocale *)locale;
</code></p>

<p>格式转换符 <code>%@</code> 会首先调用 <code>-descriptionWithLocale</code>，如果没有返回值，再调用 <code>-description</code>。</p>

<p>在调试时，打印一个对象，我们用 <code>po</code> 这个命令（它是 print object 的缩写）：</p>

<pre><code>(lldb) po contact
</code></pre>

<p>它会调用对象的 <code>debugDescription</code> 方法。默认情况下 <code>debugDescription</code> 是直接调用 <code>description</code>。如果你希望输出不同的信息，那么就分别覆写两个方法。大多数情况下，尤其是对于非数据模型的对象，你只需要覆写 <code>-description</code> 就能满足需求了。</p>

<p>实际上对象的标准格式化输出是这样的：</p>

<p><code>objc
- (NSString *)description;
{
    return [NSString stringWithFormat:@"&amp;lt;%@: %p&amp;gt;", self.class, self];
}
</code></p>

<p><code>NSObject</code> 这个类内部就是这么实现的。当你覆写该方法时，也可以像这样写。假定我们有一个 <code>DetailViewController</code>，在它的UI上要显示一个 <code>contact</code>，我们可能会这样覆写该方法：</p>

<p><code>objc
- (NSString *)description;
{
    return [NSString stringWithFormat:@"&amp;lt;%@: %p&amp;gt; contact = %@", self.class, self, self.contact.debugDescription];
}
</code></p>

<h3 id="nsmanagedobject"><code>NSManagedObject</code> 子类的描述</h3>

<p>我们将特别注意向 <code>NSManagedObject</code> 的子类添加 <code>-description</code>/<code>-debugDescription</code> 的情况。由于 Core Data 的<strong>惰性加载机制（faulting mechanism）</strong>允许未加载数据的对象存在，所以当我们调用 <code>-debugDescription</code> 时我们并不希望改变应用程序的状态，因此需要检查 <code>isFault</code> 这个属性。例如，我们可如下这样实现它：</p>

<p><code>objc
- (NSString *)debugDescription;
{
    NSMutableString *description = [NSMutableString stringWithFormat:@"&amp;lt;%@: %p&amp;gt;", self.class, self];
    if (! self.isFault) {
        [description appendFormat:@" %@ \"%@\" %gL", self.identifier, self.name, self.metricVolume];
    }
    return description;
}
</code></p>

<p>再次，因为它们是模型对象，重载 <code>-description</code> 简单地返回描述实例的属性名就可以了。</p>

<h3>文件路径</h3>

<p>简单来说就是我们不应该使用 <code>NSString</code> 来描述文件路径。对于 OS X 10.7 和 iOS 5，<code>NSURL</code> 更便于使用，而且更有效率，它还能缓存文件系统的属性。</p>

<p>再者，<code>NSURL</code> 有八个方法来访问被称为 <em>resource values</em> 的东西。这些方法提供了一个稳定的接口，使我们可以用来获取和设置文件与目录的各种属性，例如本地化文件名（<code>NSURLLocalizedNameKey</code>）、文件大小（<code>NSURLFileSizeKey</code>），以及创建日期（<code>NSURLCreationDateKey</code>），等等。</p>

<p>尤其是在遍历目录内容时，使用 
<code>-[NSFileManager enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:]</code>，并传入一个<strong>关键词（keys）</strong>列表，然后用 <code>-getResourceValue:forKey:error:</code> 检索它们，能带来显著的性能提升。

<p>下面是一个简短的例子展示了如何将它们组合在一起：</p>

```objc
NSError *error = nil;
NSFileManager *fm = [[NSFileManager alloc] init];
NSURL *documents = [fm URLForDirectory:NSDocumentationDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:&amp;error];
NSArray *properties = @[NSURLLocalizedNameKey, NSURLCreationDateKey];
NSDirectoryEnumerator *dirEnumerator = [fm enumeratorAtURL:documents
                                includingPropertiesForKeys:properties
                                                   options:0
                                              errorHandler:nil];
for (NSURL *fileURL in dirEnumerator) {
    NSString *name = nil;
    NSDate *creationDate = nil;
    if ([fileURL getResourceValue:&amp;name forKey:NSURLLocalizedNameKey error:NULL] &amp;&amp;
        [fileURL getResourceValue:&amp;creationDate forKey:NSURLCreationDateKey error:NULL])
    {
        NSLog(@"'%@' was created at %@", name, creationDate);
    }
}
```

<p>我们把属性的键传给 <code>-enumeratorAtURL:...</code> 方法中，在遍历目录内容时，这个方法能确保用非常高效的方式获取它们。在循环中，调用 <code>-getResourceValue:...</code> 能简单地从 <code>NSURL</code> 得到已缓存的值，而不用去访问文件系统。</p>

<h2 id="unixapi">传递路径到 UNIX API</h2>

<p>因为 Unicode 非常复杂，同一个字母有多种表示方式，所以我们在传递路径给 UNIX API 时需要非常小心。在这些情况里，一定不能使用 <code>UTF8String</code>，正确的做法是使用 <code>-fileSystemRepresentation</code> 这个方法，如下：</p>

```objc
NSURL *documentURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:NULL];
documentURL = [documentURL URLByAppendingPathComponent:name];
int fd = open(documentURL.fileSystemRepresentation, O_RDONLY);
```

<p>与 <code>NSURL</code> 类似，同样的情况也发生在 <code>NSString</code> 上。如果我们不这么做，在打开一个文件名或路径名包含合成字符的文件时我们将看到随机错误。在 OS X 上，当用户的短名刚好包含合成字符时就会显得特别糟糕，比如 <code>tómas</code>。</p>

<p>有时我们可能需要路径是一个不可变的常量，即 <code>char const *</code>，一个常见的例子就是 UNIX 的 <code>open()</code> 和 <code>close()</code> 指令。但这种需求也可能发生在使用 GCD / libdispatch 的 I/O API 上。</p>

```objc
dispatch_io_t
dispatch_io_create_with_path(dispatch_io_type_t type,
    const char *path, int oflag, mode_t mode,
    dispatch_queue_t queue,
    void (^cleanup_handler)(int error));
```

<p>如果我们要使用 <code>NSString</code> 来做这件事，那我们要保证像下面这样做：</p>

```objc
NSString *path = ... // 假设这个字符串已经存在
io = dispatch_io_create_with_path(DISPATCH_IO_STREAM,
    path.fileSystemRepresentation,
    O_RDONLY, 0, queue, cleanupHandler);
```

<p><code>-fileSystemRepresentation</code> 所做的是它首先将这个字符串转换成文件系统的<a href="http://objccn.io/issue-9-1/#normalization-forms">规范形式</a>然后用 UTF-8 编码。</p>

<hr />
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[整洁的TableView代码]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/zheng-ji-de-tableviewdai-ma/"/>
    <updated>2014-04-09T16:33:17+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/zheng-ji-de-tableviewdai-ma</id>
    <content type="html"><![CDATA[<p>Table view 是 iOS 应用程序中非常通用的组件。许多代码和 table view 都有直接或间接的关系，随便举几个例子，比如提供数据、更新 table view，控制它的行为以及响应选择事件。在这篇文章中，我们将会展示保持 table view 相关代码的整洁和良好组织的技术。</p>

<h2 id="uitableviewcontrollervsuiviewcontroller">UITableViewController vs. UIViewController</h2>

<p>Apple 提供了 <code>UITableViewController</code> 作为 table views 专属的 view controller 类。Table view controllers 实现了一些非常有用的特性，来帮你避免一遍又一遍地写那些死板的代码！但是话又说回来，table view controller 只限于管理一个全屏展示的 table view。大多数情况下，这就是你想要的，但如果不是，还有其他方法来解决这个问题，就像下面我们展示的那样。</p>

<h3 id="tableviewcontrollers">Table View Controllers 的特性</h3>

<p>Table view controllers 会在第一次显示 table view 的时候帮你加载其数据。另外，它还会帮你切换 table view 的编辑模式、响应键盘通知、以及一些小任务，比如闪现侧边的滑动提示条和清除选中时的背景色。为了让这些特性生效，当你在子类中覆写类似 <code>viewWillAppear:</code> 或者 <code>viewDidAppear:</code> 等事件方法时，需要调用 super 版本。</p>

<p>Table view controllers 相对于标准 view controllers 的一个特别的好处是它支持 Apple 实现的“下拉刷新”。目前，文档中唯一的使用 <code>UIRefreshControl</code> 的方式就是通过 table view controller ，虽然通过努力在其他地方也能让它工作（<a href="http://stackoverflow.com/questions/12805003/uirefreshcontrol-issues">见此处</a>），但很可能在下一次 iOS 更新的时候就不行了。</p>

<p>这些要素加一起，为我们提供了大部分 Apple 所定义的标准 table view 交互行为，如果你的应用恰好符合这些标准，那么直接使用 table view controllers 来避免写那些死板的代码是个很好的方法。</p>

<h3 id="tableviewcontrollers">Table View Controllers 的限制</h3>

<p>Table view controllers 的 view 属性永远都是一个 table view。如果你稍后决定在 table view 旁边显示一些东西（比如一个地图），如果不依赖于那些奇怪的 hacks，估计就没什么办法了。</p>

<p>如果你是用代码或 .xib 文件来定义的界面，那么迁移到一个标准 view controller 将会非常简单。但是如果你使用了 storyboards，那么这个过程要多包含几个步骤。除非重新创建，否则你并不能在 storyboards 中将 table view controller 改成一个标准的 view controller。这意味着你必须将所有内容拷贝到新的 view controller，然后再重新连接一遍。</p>

<p>最后，你需要把迁移后丢失的 table view controller 的特性给补回来。大多数都是 <code>viewWillAppear:</code> 或 <code>viewDidAppear:</code> 中简单的一条语句。切换编辑模式需要实现一个 action 方法，用来切换 table view 的 <code>editing</code> 属性。大多数工作来自重新创建对键盘的支持。</p>

<p>在选择条路之前，其实还有一个更轻松的选择，它可以通过分离我们需要关心的功能（关注点分离），让你获得额外的好处：</p>

<h3 id="childviewcontrollers">使用Child View Controllers</h3>

<p>和完全抛弃 table view controller 不同，你还可以将它作为 child view controller 添加到其他 view controller 中（<a href="http://objccn.io/issue-1-4">关于此话题的文章</a>）。这样，parent view controller 在管理其他的你需要的新加的界面元素的同时，table view controller 还可以继续管理它的 table view。</p>

<p><code>objc
- (void)addPhotoDetailsTableView
{
    DetailsViewController *details = [[DetailsViewController alloc] init];
    details.photo = self.photo;
    details.delegate = self;
    [self addChildViewController:details];
    CGRect frame = self.view.bounds;
    frame.origin.y = 110;
    details.view.frame = frame;
    [self.view addSubview:details.view];
    [details didMoveToParentViewController:self];
}
</code></p>

<p>如果你使用这个解决方案，你就必须在 child view controller 和 parent view controller 之间建立消息传递的渠道。比如，如果用户选择了一个 table view 中的 cell，parent view controller 需要知道这个事件来推入其他 view controller。根据使用习惯，通常最清晰的方式是为这个 table view controller 定义一个 delegate protocol，然后到 parent view controller 中去实现。</p>

<p>```objc
@protocol DetailsViewControllerDelegate
- (void)didSelectPhotoAttributeWithKey:(NSString *)key;
@end</p>

<p>@interface PhotoViewController () 
@end</p>

<p>@implementation PhotoViewController
// …
- (void)didSelectPhotoAttributeWithKey:(NSString *)key
{
    DetailViewController *controller = [[DetailViewController alloc] init];
    controller.key = key;
    [self.navigationController pushViewController:controller animated:YES];
}
@end
```</p>

<p>就像你看到的那样，这种结构为 view controller 之间的消息传递带来了额外的开销，但是作为回报，代码封装和分离非常清晰，有更好的复用性。根据实际情况的不同，这既可能让事情变得更简单，也可能会更复杂，需要读者自行斟酌和决定。</p>

<h2 id="separatingconcerns">分离关注点（Separating Concerns）</h2>

<p>当处理 table views 的时候，有许多各种各样的任务，这些任务穿梭于 models，controllers 和 views 之间。为了避免让 view controllers 做所有的事，我们将尽可能地把这些任务划分到合适的地方，这样有利于阅读、维护和测试。</p>

<p>这里描述的技术是文章<a href="http://objccn.io/issue-1-1">更轻量的 View Controllers</a> 中的概念的延伸，请参考这篇文章来理解如何重构 data source 和 model 的逻辑。结合 table views，我们来具体看看如何在 view controllers 和 views 之间分离关注点。</p>

<h3 id="modelcells">搭建 Model 对象和 Cells 之间的桥梁</h3>

<p>有时我们需要将想显示的 model 层中的数据传到 view 层中去显示。由于我们同时也希望让 model 和 view 之间明确分离，所以通常把这个任务转移到 table view 的 data source 中去处理：</p>

<p><code>objc
- (UITableViewCell *)tableView:(UITableView *)tableView
         cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    PhotoCell *cell = [tableView dequeueReusableCellWithIdentifier:@"PhotoCell"];
    Photo *photo = [self itemAtIndexPath:indexPath];
    cell.photoTitleLabel.text = photo.name;
    NSString* date = [self.dateFormatter stringFromDate:photo.creationDate];
    cell.photoDateLabel.text = date;
}
</code></p>

<p>但是这样的代码会让 data source 变得混乱，因为它向 data source 暴露了 cell 的设计。最好分解出来，放到 cell 类的一个 category 中。</p>

<p>```
@implementation PhotoCell (ConfigureForPhoto)</p>

<ul>
  <li>(void)configureForPhoto:(Photo <em>)photo
{
  self.photoTitleLabel.text = photo.name;
  NSString</em> date = [self.dateFormatter stringFromDate:photo.creationDate];
  self.photoDateLabel.text = date;
}</li>
</ul>

<p>@end
```</p>

<p>有了上述代码后，我们的 data source 方法就变得简单了。</p>

<p><code>objc
- (UITableViewCell *)tableView:(UITableView *)tableView
         cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    PhotoCell *cell = [tableView dequeueReusableCellWithIdentifier:PhotoCellIdentifier];
    [cell configureForPhoto:[self itemAtIndexPath:indexPath]];
    return cell;
}
</code></p>

<p>在我们的示例代码中，table view 的 data source 已经<a href="http://objccn.io/issue-1-1">分解到单独的类中了</a>，它用一个设置 cell 的 block 来初始化。这时，这个 block 就变得这样简单了：</p>

<p><code>objc
TableViewCellConfigureBlock block = ^(PhotoCell *cell, Photo *photo) {
    [cell configureForPhoto:photo];
};
</code></p>

<h3 id="cells">让 Cells 可复用</h3>

<p>有时多种 model 对象需要用同一类型的 cell 来表示，这种情况下，我们可以进一步让 cell 可以复用。首先，我们给 cell 定义一个 protocol，需要用这个 cell 显示的对象必须遵循这个 protocol。然后简单修改 category 中的设置方法，让它可以接受遵循这个 protocol 的任何对象。这些简单的步骤让 cell 和任何特殊的 model 对象之间得以解耦，让它可适应不同的数据类型。</p>

<h3 id="cellcell">在 Cell 内部控制 Cell 的状态</h3>

<p>如果你想自定义 table views 默认的高亮或选择行为，你可以实现两个 delegate 方法，把点击的 cell 修改成我们想要的样子。例如：</p>

<p>```objc
- (void)tableView:(UITableView *)tableView
        didHighlightRowAtIndexPath:(NSIndexPath *)indexPath
{
    PhotoCell *cell = [tableView cellForRowAtIndexPath:indexPath];
    cell.photoTitleLabel.shadowColor = [UIColor darkGrayColor];
    cell.photoTitleLabel.shadowOffset = CGSizeMake(3, 3);
}</p>

<ul>
  <li>(void)tableView:(UITableView *)tableView
      didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath
{
  PhotoCell *cell = [tableView cellForRowAtIndexPath:indexPath];
  cell.photoTitleLabel.shadowColor = nil;
}
```</li>
</ul>

<p>然而，这两个 delegate 方法的实现又基于了 view controller 知晓 cell 实现的具体细节。如果我们想替换或重新设计 cell，我们必须改写 delegate 代码。View 的实现细节和 delegate 的实现交织在一起了。我们应该把这些细节移到 cell 自身中去。</p>

<p><code>objc
@implementation PhotoCell
// ...
- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated
{
    [super setHighlighted:highlighted animated:animated];
    if (highlighted) {
        self.photoTitleLabel.shadowColor = [UIColor darkGrayColor];
        self.photoTitleLabel.shadowOffset = CGSizeMake(3, 3);
    } else {
        self.photoTitleLabel.shadowColor = nil;
    }
}
@end
</code></p>

<p>总的来说，我们在努力把 view 层和 controller 层的实现细节分离开。delegate 肯定得清楚一个 view 该显示什么状态，但是它不应该了解如何修改 view 结构或者给某些 subviews 设置某些属性以获得正确的状态。所有这些逻辑都应该封装到 view 内部，然后给外部提供一个简单地 API。</p>

<h3 id="cell">控制多个 Cell 类型</h3>

<p>如果一个 table view 里面有多种类型的 cell，data source 方法很快就难以控制了。在我们示例程序中，photo details table 有两种不同类型的 cell：一种用于显示几个星，另一种用来显示一个键值对。为了划分处理不同 cell 类型的代码，data source 方法简单地通过判断 cell 的类型，把任务派发给其他指定的方法。</p>

<p>```objc
- (UITableViewCell *)tableView:(UITableView *)tableView
         cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    NSString *key = self.keys[(NSUInteger) indexPath.row];
    id value = [self.photo valueForKey:key];
    UITableViewCell *cell;
    if ([key isEqual:PhotoRatingKey]) {
        cell = [self cellForRating:value indexPath:indexPath];
    } else {
        cell = [self detailCellForKey:key value:value];
    }
    return cell;
}</p>

<ul>
  <li>
    <p>(RatingCell *)cellForRating:(NSNumber *)rating
                  indexPath:(NSIndexPath *)indexPath
{
  // …
}</p>
  </li>
  <li>
    <p>(UITableViewCell *)detailCellForKey:(NSString *)key
                              value:(id)value
{
  // …
}
```</p>
  </li>
</ul>

<h3 id="tableview">编辑 Table View</h3>

<p>Table view 提供了易于使用的编辑特性，允许你对 cell 进行删除或重新排序。这些事件都可以让 table view 的 data source 通过 <a href="http://developer.apple.com/library/ios/#documentation/uikit/reference/UITableViewDataSource_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UITableViewDataSource/tableView:commitEditingStyle:forRowAtIndexPath:">delegate 方法</a>得到通知。因此，通常我们能在这些 delegate 方法中看到对数据的进行修改的操作。</p>

<p>修改数据很明显是属于 model 层的任务。Model 应该为诸如删除或重新排序等操作暴露一个 API，然后我们可以在 data source 方法中调用它。这样，controller 就可以扮演 view 和 model 之间的协调者，而不需要知道 model 层的实现细节。并且还有额外的好处，model 的逻辑也变得更容易测试，因为它不再和 view controllers 的任务混杂在一起了。</p>

<h2>总结</h2>

<p>Table view controllers（以及其他的 controller 对象！）应该在 model 和 view 对象之间扮演<a href="http://developer.apple.com/library/mac/#documentation/General/Conceptual/DevPedia-CocoaCore/ControllerObject.html">协调者和调解者的角色</a>。它不应该关心明显属于 view 层或 model 层的任务。你应该始终记住这点，这样 delegate 和 data source 方法会变得更小巧，最多包含一些简单地样板代码。</p>

<p>这不仅减少了 table view controllers 那样的大小和复杂性，而且还把业务逻辑和 view 的逻辑放到了更合适的地方。Controller 层的里里外外的实现细节都被封装成了简单地 API，最终，它变得更加容易理解，也更利于团队协作。</p>

<h3>扩展阅读</h3>

<ul>
<li><a href="http://www.sebastianrehnby.com/blog/2013/01/01/skinnier-controllers-using-view-categories/">Blog: Skinnier Controllers using View Categories</a></li>
<li><a href="http://developer.apple.com/library/ios/#documentation/userexperience/conceptual/tableview_iphone/AboutTableViewsiPhone/AboutTableViewsiPhone.html">Table View Programming Guide</a></li>
<li><a href="http://developer.apple.com/library/mac/#documentation/General/Conceptual/DevPedia-CocoaCore/ControllerObject.html">Cocoa Core Competencies: Controller Object</a></li>
</ul>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[并发程序开发测试]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/bing-fa-cheng-xu-kai-fa-ce-shi/"/>
    <updated>2014-04-09T16:15:22+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/bing-fa-cheng-xu-kai-fa-ce-shi</id>
    <content type="html"><![CDATA[<p>在开发高质量应用程序的过程中，测试是一个很重要的工具。在过去，当并发并不是应用程序架构中重要组成部分的时候，测试就相对简单。随着这几年的发展，使用并发设计模式已愈发重要了，想要测试好并发应用程序，已成了一个不小的挑战。</p>

<p>测试并发代码最主要的困难在于程序或信息流不是反映在调用堆栈上。函数并不会立即返回结果给调用者，而是通过回调函数，Block，通知或者一些类似的机制，这些使得测试变得更加困难。</p>

<p>然而，测试异步代码也会带来一些好处，比如可以揭露较差的程序设计，让最终的实现变得更加清晰。</p>

<h2>异步测试的问题</h2>

<p>首先，我们来看一个简单的同步单元测试例子。两个数求和的方法：</p>

<p><code>objc
+ (int)add:(int)a to:(int)b {
    return a + b;
}
</code></p>

<p>测试这个方法很简单，只需要比较该方法返回的值是否与期望的值相同，如果不相同，则测试失败。</p>

<p><code>objc
- (void)testAddition {
    int result = [Calculator add:2 to:2];
    STAssertEquals(result, 4, nil);
}
</code></p>

<p>接下来，我们利用 Block 将该方法改成异步返回结果。为了模拟测试失败，我们会在方法实现中故意添加一个 bug。</p>

<p><code>objc
+ (int)add:(int)a to:(int)b block:(void(^)(int))block {
    [[NSOperationQueue mainQueue] addOperationWithBlock:^{
        block(a - b); // 带有bug的实现
    }];
}
</code></p>

<p>显然这是一个人为的例子，但是它却真实的反应了在编程中可能经常遇到的问题，只不过实际过程更复杂罢了。</p>

<p>测试上面的方法最简单的做法就是把断言放到 Block 中。尽管我们的方法实现中存在 bug，但是这种测试永远不会失败的:</p>

<p><code>objc
// 千万不要使用这些代码！
- (void)testAdditionAsync {
    [Calculator add:2 to:2 block:^(int result) {
        STAssertEquals(result, 4, nil); // 永远不会被调用到
    }];
}
</code></p>

<p>这里的断言为什么没失败呢?</p>

<h2 id="sentestingkit">关于SenTestingKit</h2>

<p>XCode4 所使用的测试框架是基于 <a href="http://www.sente.ch/software/ocunit/" title="OCUnit">OCUnit</a>。为了理解之前所提到的异步测试问题，我们需要了解一下测试包中的各个部分之间的执行顺序。下图展示了一个简化的流程。</p>

<p><img src="http://img.objccn.io/issue-2/SenTestingKit-call-stack.png" style="width:698px" alt="SenTestingKit call stack" /></p>

<p>在测试框架在主 run loop 开始运行之后，主要执行了以下几个步骤：</p>

<ol>
<li>配置一个包含所有相关测试的测试包 (比如可以在工程的 scheme 中配置)。  </li>
<li>运行测试包，内部会调用所有以 <em>test</em> 开头测试用例的方法。运行结束后会返回一个包含单个测试结果的对象。  </li>
<li>调用 <code>exit()</code> 退出测试。</li>
</ol>

<p>这其中我们最感兴趣的是单个测试是如何被调用的。在异步测试中，包含断言的 Block 会被加到主 run loop。当所有的测试执行完毕后，测试框架就会退出，而 block 却从来没有被执行，因此不会引起测试失败。</p>

<p>当然我们有很多种方发来解决这个问题。但是所有的方法都必须在主 run loop 中运行，而且在测试方法返回和比较结果之前需要处理已入队所有操作。</p>

<p><a href="https://github.com/allending/Kiwi" title="Kiwi">Kiwi</a> 使用探测轮询 (probe poller)，它可以在测试方法中被调用。 <a href="https://github.com/gabriel/gh-unit/" title="GHUnit">GHUnit</a> 编写了一个单独的测试类，它必须在测试的方法内初始化，并在结束时接收一个通知。以上两种方式都是通过编写相应的代码来确保异步测试方法在测试结束之前都不会返回。</p>

<h2 id="sentestingkit">SenTestingKit的异步扩展</h2>

<p>我们对这个问题的解决方案是对 SenTestingKit 添加一个<a href="https://github.com/nxtbgthng/SenTestingKitAsync" title="SenTestingKitAsync">扩展</a>，它在栈上使用同步执行，并把每个部分加入到主队列上。正如下图所见，在验证整个测试框架结果之前，报告异步测试成功或者失败的 Block 就被加入到队列。这种执行顺序允许我们开启一个测试并等待它的测试结果。</p>

<p><img src="http://img.objccn.io/issue-2/SenTestingKitAsync-call-stack.png" style="width:531px" alt="SenTestingKitAsync call stack" /></p>

<p>如果测试方法以 <strong>Async</strong> 结尾，框架就会认为该方法是异步测试。此外，在异步测试中，我们必须手动地报告测试成功，同时为了防止 Block 永远不会被调用，我们还需添加了一个超时方法。之前的错误的测试方法修改后如下所示：</p>

<p><code>objc
- (void)testAdditionAsync {
    [Calculator add:2 to:2 block^(int result) {
        STAssertEquals(result, 4, nil);
        STSuccess(); // 通过调用这个宏来判断是否测试成功
    }];
    STFailAfter(2.0, @"Timeout");
}
</code></p>

<h2>设计异步测试</h2>

<p>就像同步测试一样，异步测试也应该比被测试的功能简单许多。复杂的测试并不会改进代码的质量，反而会给测试本身带来更多的 Bug。在以测试驱动开发的情况下，简单的测试会让我们对组件，接口以及架构的行为有更清醒的认识。</p>

<h3>示例工程</h3>

<p>为了运用到实际中，我们创建了一个示例框架：<a href="https://github.com/objcio/issue-2-async-testing" title="Pinacoteca Core: Cocoa Framework for an Imaginary Image Service">PinacotecaCore</a>，它从一个虚拟的服务器获取图像信息。框架中包含一个资源管理器，它对外提供一个可以根据图像 Id 获取图像对象的接口。该接口的工作原理是资源管理器从虚拟服务器获取图片对象的信息，并更新到数据库。</p>

<p>虽然这个示例框架只是为了演示，但在我们自己开发的许多应用中也使用了这种模式。</p>

<p><img src="http://img.objccn.io/issue-2/PinacotecaCore.png" style="width:699px" alt="PinacotecaCore architecture" /></p>

<p>从上图我们可以知道，示例框架有三个组件我们需要测试：</p>

<ol>
<li>模型层  </li>
<li>模拟服务器请求的服务器接口控制器（API Controller）  </li>
<li>管理 core data 堆栈以及连接模型层和服务接口控制器的资源管理器</li>
</ol>

<h3>模型层</h3>

<p>测试应该尽量使用同步的方式进行，而模型层就是一个很好的实例。只要不同的被托管对象上下文 (managed object contexts) 之间没有复杂的依赖关系，测试用例都应该根据上下文在主线程上设置它自己的 core data 堆栈，并在其中执行各自的操作。</p>

<p>在这个<a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCModelLayerTests.m" title="Pinacoteca Core Model Layer Tests">测试实例</a>中，我们就是在 <code>setUp</code> 方法中设置 core data 堆栈，然后检查 <code>PCImage</code> 实体的描述是否存在，如果不存在就构造一个，并更新它的值。当然这和异步测试没有关系，我们就不深入细说了。</p>

<h3>服务器接口控制器</h3>

<p>框架中的第二个组件就是服务器接口控制器。它主要处理服务器请求以及服务器 API 到模型的映射关系。让我们来看一下下面这个方法：</p>

<p><code>objc
- [PCServerAPIController fetchImageWithId:queue:completionHandler:]
</code></p>

<p>调用它需要三个形参：一个图片对象 Id，所在的执行队列以及一个完成后的回调方法。</p>

<p>因为服务器根本不存在，一个比较好的做法就是伪造一个代理服务器，正好 <a href="https://github.com/AliSoftware/OHHTTPStubs" title="OHHTTPStubs">OHHTTPStubs</a> 可以解决这个问题。在它的最新版本中，可以在示例的请求响应中包含一个 bundle，发送给客户端。</p>

<p>为了能 stub 请求，OHHTTPStubs 需要在测试类初始化时或者 setUp 方法中进行配置。首先，我们需要加载一个包含请求响应对象（response）的 bundle：</p>

<p>```objc
NSURL *url = [[NSBundle bundleForClass:[self class]]
                        URLForResource:@”ServerAPIResponses”
                         withExtension:@”bundle”];</p>

<p>NSBundle *bundle = [NSBundle url];
```</p>

<p>然后我们从 bundle 加载 response 对象，作为请求的响应值：</p>

<p>```objc
OHHTTPStubsResponse *response;
response = [OHHTTPStubsResponse responseNamed:@”images/123”
                                   fromBundle:responsesBundle
                                 responseTime:0.1];</p>

<p>[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest <em>request) {
    return YES /</em> 如果所返回的request是我们所期望的，就返回YES */;
} withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {
    return response;
}];
```</p>

<p>通过如上的设置之后，简化版的<a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCServerAPIControllerTests.m" title="Pinacoteca Core Server API Controller Tests">测试服务器接口控制器</a>如下：</p>

<p>```objc
- (void)testFetchImageAsync
{
    [self.server
        fetchImageWithId:@”123”
                   queue:[NSOperationQueue mainQueue]
       completionHandler:^(id imageData, NSError *error) {
          STAssertEqualObjects([NSOperationQueue currentQueue], queue, nil);
          STAssertNil(error, [error localizedDescription]);
          STAssertTrue([imageData isKindOfClass:[NSDictionary class]], nil);</p>

<pre><code>      // 检查返回的字典中的值.

      STSuccess();
   }];
STFailAfter(2.0, nil);     } ```
</code></pre>

<h3>资源管理器</h3>

<p>最后一个部分是资源管理器，它不但把服务器接口控制器和模型层联系起来, 还管理着 core data 堆栈。下面我们想测试获取一个图片对象的方法：</p>

<p><code>objc
-[PCResourceManager imageWithId:usingManagedObjectContext:queue:updateHandler:]
</code></p>

<p>该方法根据 id 返回一个图片对象。如果图片在数据库中不存在，它会创建一个只包含 id 的新对象，然后通过服务器接口控制器获取图片对象的详细信息。</p>

<p>由于资源管理器的测试不应该依赖于服务器接口控制器，所以我们可以用 <a href="http://ocmock.org" title="OCMock">OCMock</a> 来模拟，如果要做方法的部分 stub，它是一个理想的框架。如以下的 <a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCResourceManagerTests.m" title="Pinacoteca Core Resource Manager Tests">资源管理器测试</a> :</p>

<p>```objc
OCMockObject *mo;
mo = [OCMockObject partialMockForObject:self.resourceManager.server];</p>

<p>id exp = [[serverMock expect] 
             andCall:@selector(fetchImageWithId:queue:completionHandler:)
            onObject:self];
[exp fetchImageWithId:OCMOCK_ANY queue:OCMOCK_ANY completionHandler:OCMOCK_ANY];
```</p>

<p>上面的代码实际上它并没有真正调用服务器接口控制器的方法，而是调用我们写在测试类中的方法。</p>

<p>用上面的做法，对资源管理的测试就变得很直观。当我们调用资源管理器获取资源时，实际上调用的是我们模拟的服务器接口控制器的方法。这样我们也能检查调用服务器接口控制器时参数是否正确。在调用了获取图像对象的方法后，资源管理器会更新模型，然后调用验证测试成功与否的宏。</p>

<p><code>objc
- (void)testGetImageAsync
{
    NSManagedObjectContext *ctx = self.resourceManager.mainManagedObjectContext;
    __block PCImage *img;
    img = [self.resourceManager imageWithId:@"123"
                  usingManagedObjectContext:ctx
                                      queue:[NSOperationQueue mainQueue]
                              updateHandler:^(NSError *error) {
                                       // 检查error是否为空以及image是否已经被更新 
                                       STSuccess();
                                   }];    
    STAssertNotNil(img, nil);
    STFailAfter(2.0, @"Timeout");
}
</code></p>

<h2>总结</h2>

<p>刚开始时候，使用并发设计模式测试应用程序是具有一定的挑战性，但是一旦你理解了它们的不同，并建立最佳实践，一切都会变得简单而有趣。</p>

<p>在 <a href="http://nxtbgthng.com" title="nxtbgthng">nxtbgthng</a> 项目中，我们用 <a href="https://github.com/nxtbgthng/SenTestingKitAsync" title="SenTestingKitAsync">SenTestingKitAsync</a> 框架来测试。但是像 <a href="https://github.com/allending/Kiwi" title="Kiwi">Kiwi</a> 和 <a href="https://github.com/gabriel/gh-unit/" title="GHUnit">GHUnit</a>  也都是不错的异步测试框架。建议你都可以尝试下，然后找到合适自己的测试工具并开始使用它。</p>

<hr />

]]></content>
  </entry>
  
</feed>
