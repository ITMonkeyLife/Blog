<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | IT Monkey Life]]></title>
  <link href="http://ITMonkeyLife.github.io/Blog/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://ITMonkeyLife.github.io/Blog/"/>
  <updated>2014-04-09T16:58:54+08:00</updated>
  <id>http://ITMonkeyLife.github.io/Blog/</id>
  <author>
    <name><![CDATA[Rick]]></name>
    <email><![CDATA[382542165@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS之玩转字符串]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/ioszhi-wan-zhuan-zi-fu-chuan/"/>
    <updated>2014-04-09T16:40:06+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/ioszhi-wan-zhuan-zi-fu-chuan</id>
    <content type="html"><![CDATA[<p>在每个应用里我们都大量使用字符串。下面我们将快速看看一些常见的操作字符串的方法，过一遍常见操作的最佳实践。</p>

<h2>字符串的比较、搜索和排序</h2>

<p>排序和比较字符串比第一眼看上去要复杂得多。不只是因为字符串可以包含<strong>代理对（surrogate pairs ）</strong>(详见 <a href="http://objccn.io/issue-9-1/#peculiar-unicode-features">Ole 写的这篇关于 Unicode 的文章</a>) ，而且比较还与字符串的本地化相关。在某些极端情况下相当棘手。</p>

<p>苹果文档中 <em>String Programming Guide</em> 里有一节叫做 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html"><strong>“字符与字形集群（Characters and Grapheme Clusters）”</strong></a>，里面提到一些陷阱。例如对于排序来说，一些欧洲语言将序列“ch”当作单个字母。在一些语言里，“ä”被认为等同于 ‘a’ ，而在其它语言里它却被排在 ‘z’ 后面。</p>

<p>而 <code>NSString</code> 有一些方法来帮助我们处理这种复杂性。首先看下面的方法：</p>

<pre><code>- (NSComparisonResult)compare:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)range locale:(id)locale
</code></pre>

<p>它带给我们充分的灵活性。另外，还有很多<strong>便捷函数（convenience functions）</strong>都使用了这个方法。</p>

<p>与比较有关的可用参数如下：</p>

<p><code>objc
NSCaseInsensitiveSearch
NSLiteralSearch
NSNumericSearch
NSDiacriticInsensitiveSearch
NSWidthInsensitiveSearch
NSForcedOrderingSearch
</code></p>

<p>它们都可以用逻辑“或”运算符组合在一起。</p>

<p><code>NSCaseInsensitiveSearch</code>：“A”等同于“a”，然而在某些地方还有更复杂的情况。例如，在德国，“ß” 和 “SS”是等价的。</p>

<p><code>NSLiteralSearch</code>：Unicode 的点对点比较。它只在所有字符都用相同的方式组成的情况下才会返回相等（即 <code>NSOrderedSame</code>）。LATIN CAPITAL LETTER A 加上 COMBINING RING ABOVE 并不等同于 LATIN CAPITAL LETTER A WITH RING ABOVE.</p>

<blockquote>
  <p><span class="secondary radius label">编者注</span> 这里要解释一下，首先，每一个Unicode都是有官方名字的！LATIN CAPITAL LETTER A是一个大写“A”，COMBINING RING ABOVE是一个  ̊，LATIN CAPITAL LETTER A WITH RING ABOVE，这是Å。前两者的组合不等同于后者。</p>
</blockquote>

<p><code>NSNumericSearch</code>：它对字符串里的数字排序，所以 “Section 9” &lt; “Section 20” &lt; “Section 100.”</p>

<p><code>NSDiacriticInsensitiveSearch</code>：“A” 等同于 “Å” 等同于 “Ä.”</p>

<p><code>NSWidthInsensitiveSearch</code>：一些东亚文字（平假名和片假名）有全宽与半宽两种形式。</p>

<p>很值得一提的是<code>-localizedStandardCompare:</code>，它排序的方式和 Finder 一样。它对应的选项是 <code>NSCaseInsensitiveSearch</code>、<code>NSNumericSearch</code>、<code>NSWidthInsensitiveSearch</code> 以及 <code>NSForcedOrderingSearch</code>。如果我们要在 UI 上显示一个文件列表，用它就最合适不过了。</p>

<p>大小写不敏感的比较和音调符号不敏感的比较都是相对复杂和昂贵的操作。如果我们需要比较很多次字符串那这就会成为一个性能上的瓶颈（例如对一个大的数据集进行排序），一个常见的解决方法是同时存储原始字符串和折叠字符串。例如，我们的 <code>Contact</code> 类有一个正常的 <code>name</code> 属性，在内部它还有一个 <code>foldedName</code> 属性，它将自动在 name 变化时更新。那么我们就可以使用 <code>NSLiteralSearch</code> 来比较 name 的折叠版本。 <code>NSString</code> 有一个方法来创建折叠版本：</p>

<p><code>objc
- (NSString *)stringByFoldingWithOptions:(NSStringCompareOptions)options locale:(NSLocale *)locale
</code></p>

<h3>搜索</h3>

<p>要在一个字符串中搜索子字符串，最灵活性的方法是:</p>

<p><code>objc
- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)searchRange locale:(NSLocale *)locale
</code></p>

<p>同时，还有一些便捷方法，它们在最终都会调用上面这个方法，我们可以传入上面列出的参数，以及以下这些额外的参数：</p>

<p><code>objc
NSBackwardsSearch
NSAnchoredSearch
NSRegularExpressionSearch
</code></p>

<p><code>NSBackwardsSearch</code>：在字符串的末尾开始反向搜索。</p>

<p><code>NSAnchoredSearch</code>：只考虑搜索的起始点（单独使用）或终止点（当与 <code>NSBackwardsSearch</code> 结合使用时）。这个方法可以用来检查前缀或者后缀，以及<strong>大小写不敏感（case-insensitive）</strong>或者<strong>音调不敏感（diacritic-insensitive）</strong>的比较。</p>

<p><code>NSRegularExpressionSearch</code>：使用正则表达式搜索，要了解更多与使用正则表达式有关的信息，请关注 Chris 写的字符串解析这篇文章。</p>

<p>另外，还有一个方法：</p>

<p><code>objc
- (NSRange)rangeOfCharacterFromSet:(NSCharacterSet *)aSet options:(NSStringCompareOptions)mask range:(NSRange)aRange
</code></p>

<p>与前面搜索字符串不同的是，它只搜索给定字符集的第一个字符。即使只搜索一个字符，但如果由于此字符是<strong>由元字符组成的序列（composed character sequence）</strong>，所以返回范围的长度也可能大于1。</p>

<h2>大写与小写</h2>

<p>一定不要使用 <code>NSString</code> 的 <code>-uppercaseString</code> 或者 <code>-lowercaseString</code> 的方法来处理 UI 显示的字符串，而应该使用 <code>-uppercaseStringWithLocale</code> 来代替， 比如：</p>

<p><code>objc
NSString *name = @"Tómas";
cell.text = [name uppercaseStringWithLocale:[NSLocale currentLocale]];
</code></p>

<h2>格式化字符串</h2>

<p>同 C 语言中的 <code>sprintf</code> 函数（ANSI C89 中的一个函数）类似，Objective C 中的 <code>NSString</code> 类也有如下的 3 个方法：</p>

<p><code>objc
-initWithFormat:
-initWithFormat:arguments:
+stringWithFormat:
</code></p>

<p>需要注意这些格式化方法都是<em>非本地化</em>的。所以这些方法得到的字符串是不能直接拿来显示在用户界面上的。如果需要本地化，那我们需要使用下面这些方法:</p>

<p><code>objc
-initWithFormat:locale:
-initWithFormat:locale:arguments:
+localizedStringWithFormat:
</code></p>

<p>Florian 有一篇关于<a href="http://objccn.io/issue-9-3/#localized-format-strings">字符串的本地化</a>的文章更详细地讨论了这个问题。</p>

<p><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/printf.3.html">printf(3)</a> 的 man 页面有关于它如何格式化字符串的全部细节。除了以 <code>%</code> 字符开始的所谓<strong>格式转换符（conversion specification）</strong>，格式化字符串会被逐字复制：</p>

<p><code>objc
double a = 25812.8074434;
float b = 376.730313461;
NSString *s = [NSString stringWithFormat:@"%g :: %g", a, b];
// "25812.8 :: 376.73"
</code></p>

<p>我们格式化了两个浮点数。注意单精度浮点数 <code>float</code> 和双精度浮点数 <code>double</code> 共同了一个格式转换符。</p>

<h3>对象</h3>

<p>除了来自 <code>printf(3)</code> 的转换规范，我们还可以使用 <code>%@</code> 来输出一个对象。在<a href="#object-description">对象描述</a>那一节中有述，如果对象响应 <code>-descriptionWithLocale:</code> 方法，则调用它，否则调用 <code>-description</code>。<code>%@</code> 被结果替换。</p>

<h3>整数</h3>

<p>使用整形数字时，有些需要注意的细节。首先，有符号数（<code>d</code> 和 <code>i</code>）和无符号数（<code>o</code>、<code>u</code>、<code>x</code>和<code>X</code>）的格式转换符是不一样的，需要使用者根据具体情况来选择。</p>

<p>如果我们使用 printf 支持的类型列表之外的类型，就必须要做类型转换。<code>NSUInteger</code> 正是这样一个例子，它在 64 位和 32 位平台上是不一样的。下面的例子可以同时工作在 32 位和 64 位平台上：</p>

<p><code>objc
uint64_t p = 2305843009213693951;
NSString *s = [NSString stringWithFormat:@"The ninth Mersenne prime is %llu", (unsigned long long) p];
// "The ninth Mersenne prime is 2305843009213693951"
</code></p>

<table>  
  <thead>
  <tr><th style="text-align: left">Modifier          </th><th style="text-align: left">d, i           </th><th style="text-align: left">o, u, x, X</th></tr>
  </thead>
  <tbody>
  <tr><td>hh                </td><td>signed char    </td><td>unsigned char</td></tr>
  <tr><td>h                 </td><td>short          </td><td>unsigned short</td></tr>
  <tr><td>(none)            </td><td>int            </td><td>unsigned int</td></tr>
  <tr><td>l (ell)           </td><td>long           </td><td>unsigned long</td></tr>
  <tr><td>ll (ell ell)      </td><td>long long      </td><td>unsigned long long</td></tr>
  <tr><td>j                 </td><td>intmax_t       </td><td>uintmax_t</td></tr>
  <tr><td>t                 </td><td>ptrdiff_t      </td><td /></tr>
  <tr><td>z                 </td><td>               </td><td>size_t</td></tr>
  </tbody>
</table>

<p>适用于整数的转换规则有：</p>

<p><code>objc
int m = -150004021;
uint n = 150004021U;
NSString *s = [NSString stringWithFormat:@"d:%d i:%i o:%o u:%u x:%x X:%X", m, m, n, n, n, n];
// "d:-150004021 i:-150004021 o:1074160465 u:150004021 x:8f0e135 X:8F0E135"
</code></p>

<p><code>%d</code> 和 <code>%i</code> 具有一样的功能，它们都打印出有符号十进制数。<code>%o</code> 就较为晦涩了：它使用<a href="https://en.wikipedia.org/wiki/Octal">八进制</a>表示。<code>%u</code> 输出无符号十进制数——它是我们常用的。最后 <code>%x</code> 和 <code>%X</code> 使用十六进制表示——后者使用大写字母。</p>

<p>对于 <code>x%</code> 和 <code>X%</code>，我们可以在 <code>0x</code> 前面添加 <code>#</code> 前缀，增加可读性。</p>

<p>我们可以传入特定参数，来设置最小字段宽度和最小数字位数（默认两者都是 0），以及左/右对齐。请查看 man 页面获取详细信息。下面是一些例子：</p>

<p><code>objc
int m = 42;
NSString *s = [NSString stringWithFormat:@"'%4d' '%-4d' '%+4d' '%4.3d' '%04d'", m, m, m, m, m];
// "[  42] [42  ] [ +42] [ 042] [0042]"
m = -42;
NSString *s = [NSString stringWithFormat:@"'%4d' '%-4d' '%+4d' '%4.3d' '%04d'", m, m, m, m, m];
// "[ -42] [-42 ] [ -42] [-042] [-042]"
</code></p>

<p><code>%p</code> 可用于打印出指针——它和 <code>%#x</code> 相似但可同时在 32 位和 64 位平台上正常工作。</p>

<h3>浮点数</h3>

<p>浮点数的格式转符有8个：<code>eEfFgGaA</code>。但除了 <code>%f</code> 和 <code>%g</code> 外我们很少使用其它的。对于指数部分，小写的版本使用小写 <code>e</code>，大写的版本就使用大写 <code>E</code>。</p>

<p>通常 <code>%g</code> 是浮点数的全能转换符 ，它与 <code>%f</code> 的不同在下面的例子里显示得很清楚：</p>

<p><code>objc
double v[5] = {12345, 12, 0.12, 0.12345678901234, 0.0000012345678901234};
NSString *s = [NSString stringWithFormat:@"%g %g %g %g %g", v[0], v[1], v[2], v[3], v[4]];
// "12345 12 0.12 0.123457 1.23457e-06"
NSString *s = [NSString stringWithFormat:@"%f %f %f %f %f", v[0], v[1], v[2], v[3], v[4]];
// "12345.000000 12.000000 0.120000 0.123457 0.000001"
</code></p>

<p>和整数一样，我们依然可以指定最小字段宽度和最小数字数。</p>

<h3>指定位置</h3>

<p>格式化字符串允许使用参数来改变顺序：</p>

<p>[NSString stringWithFormat:@"%2$@ %1$@", @"1st", @"2nd"];</p>

<p>// "2nd 1st"</p>

<p>我们只需将从 1 开始的参数与一个 <code>$</code> 接在 <code>%</code> 后面。这种写法在进行本地化的时候极其常见，因为在不同语言中，各个参数所处的顺序位置可能不尽相同。</p>

<h3 id="nslog">NSLog()</h3>

<p><code>NSLog()</code> 函数与 <code>+stringWithFormat:</code> 的工作方式一样。我们可以调用：</p>

<p><code>objc
int magic = 42;
NSLog(@"The answer is %d", magic);
</code></p>

<p>下面的代码可以用同样的方式构造字符串：</p>

<p><code>objc
int magic = 42;
NSString *output = [NSString stringWithFormat:@"The answer is %d", magic];
</code></p>

<p>显然 <code>NSLog()</code> 会输出字符串，并且它会加上时间戳、进程名、进程 ID 以及线程 ID 作为前缀。</p>

<h3>实现能接受格式化字符串的方法</h3>

<p>有时在我们自己的类中提供一个能接受格式化字符串的方法会很方便使用。假设我们要实现的是一个 To Do 类的应用，它包含一个  <code>Item</code> 类。我们想要提供：</p>

<p><code>objc
+ (instancetype)itemWithTitleFormat:(NSString *)format, ...
</code></p>

<p>如此我们就可以使用：</p>

<p><code>objc
Item *item = [Item itemWithFormat:@"Need to buy %@ for %@", food, pet];
</code></p>

<p>这种类型的方法接受可变数量的参数，所以被称为可变参数方法。我们必须使用一个定义在 <code>stdarg.h</code> 里的宏来使用可变参数。上面方法的实现代码可能会像下面这样：</p>

<p><code>objc
+ (instancetype)itemWithTitleFormat:(NSString *)format, ...;
{
    va_list ap;
    va_start(ap, format);
    NSString *title = [[NSString alloc] initWithFormat:format locale:[NSLocale currentLocale] arguments:ap];
    va_end(ap);
    return [self itemWithTitle:title];
}
</code></p>

<p>进一步，我们要添加 <code>NS_FORMAT_FUNCTION</code> 到方法的定义里（即头文件中），如下所示：</p>

<p><code>objc
+ (instancetype)itemWithTitleFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(1,2);
</code></p>

<p><code>NS_FORMAT_FUNCTION</code> 展开为一个方法 <code>__attribute__</code>，它会告诉编译器在索引 <strong>1</strong> 处的参数是一个格式化字符串，而实际参数从索引 <strong>2</strong> 开始。这将允许编译器检查格式化字符串而且会像 <code>NSLog()</code> 和 <code>-[NSString stringWithFormat:]</code> 一样输出警告信息。</p>

<h2>字符与字符串组件</h2>

<p>如有一个字符串 “bird” ，找出组成它的独立字母是很简单的。第二个字母是“i”（Unicode: LATIN SMALL LETTER I）。而对于像<a href="https://en.wikipedia.org/wiki/Åse">Åse</a>这样的字符串就没那么简单了。看起来像三个字母的组合可有多种方式，例如：</p>

<pre><code>A    LATIN CAPITAL LETTER A
 ̊    COMBINING RING ABOVE
s    LATIN SMALL LETTER S
e    LATIN SMALL LETTER E
</code></pre>

<p>或者</p>

<pre><code>Å    LATIN CAPITAL LETTER A WITH RING ABOVE
s    LATIN SMALL LETTER S
e    LATIN SMALL LETTER E
</code></pre>

<p>从 <a href="http://objccn.io/issue-9-1/#peculiar-unicode-features">Ole 写的这篇关于 Unicode 的文章</a> 里可以读到更多关于<strong>联合标记（combining marks）</strong>的信息，其他语言文字有更多复杂的<strong>代理对（complicated surrogate pairs）</strong>。</p>

<p>如果我们要在字符层面处理一个字符串，那我们就要小心翼翼。苹果的文档中 String Programming Guide 里有一节叫做 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html">“Characters and Grapheme Clusters”</a>，里面有更多关于这一点的细节。</p>

<p><code>NSString</code> 有两个方法：</p>

<p><code>objc
-rangeOfComposedCharacterSequencesForRange:
-rangeOfComposedCharacterSequenceAtIndex:
</code></p>

<p>上面这两个方法在有的时候很有帮助，例如，拆分一个字符串时保证我们不会把所谓的<strong>代理对（surrogate pairs）</strong>拆散。</p>

<p>如果我们要针对字符串中的字符做文章， NSString 提供了下面这个方法：</p>

<p><code>objc
-enumerateSubstringsInRange:options:usingBlock:
</code></p>

<p>options 这里传入 <code>NSStringEnumerationByComposedCharacterSequences</code> 这个参数，就可以扫描所有的字符。例如，用下面的方法，我们可将字符串 “International Business Machines” 变成 “IBM”：</p>

<p><code>objc
- (NSString *)initials;
{
    NSMutableString *result = [NSMutableString string];
    [self enumerateSubstringsInRange:NSMakeRange(0, self.length) options:NSStringEnumerationByWords | NSStringEnumerationLocalized usingBlock:^(NSString *word, NSRange wordRange, NSRange enclosingWordRange, BOOL *stop1) {
        __block NSString *firstLetter = nil;
          [self enumerateSubstringsInRange:NSMakeRange(0, word.length) options:NSStringEnumerationByComposedCharacterSequences usingBlock:^(NSString *letter, NSRange letterRange, NSRange enclosingLetterRange, BOOL *stop2) {
              firstLetter = letter;
              *stop2 = YES;
          }];
          if (firstLetter != nil) {
              [result appendString:firstLetter];
        };
    }];
    return result;
}
</code></p>

<p>如文档所示，词和句的分界可能基于地区的变化而变化。因此有 <code>NSStringEnumerationLocalized</code> 这个选项。</p>

<h2>多行文字字面量</h2>

<p>编译器的确有一个隐蔽的特性：把空格分隔开的字符串衔接到一起。这是什么意思呢？这段代码：</p>

<p><code>objc
NSString *limerick = @"A lively young damsel named Menzies\n"
@"Inquired: «Do you know what this thenzies?»\n"
@"Her aunt, with a gasp,\n"
@"Replied: "It's a wasp,\n"
@"And you're holding the end where the stenzies.\n";
</code></p>

<p>与下面这段代码是完全等价的：</p>

<p><code>objc
NSString *limerick = @"A lively young damsel named Menzies\nInquired: «Do you know what this thenzies?»\nHer aunt, with a gasp,\nReplied: "It's a wasp,\nAnd you're holding the end where the stenzies.\n";
</code></p>

<p>前者看起来更舒服，但是有一点要注意：千万不要在任意一行末尾加入逗号或者分号。</p>

<p>你也可以这样做：</p>

<p><code>objc
NSString * string = @"The man " @"who knows everything " @"learns nothing" @".";
</code></p>

<p>编译器只是为我们提供了一个便捷的方式，将多个字符串在编译期组合在了一起。</p>

<h2>可变字符串</h2>

<p>可变字符串有两个常见的使用场景：（1）拼接字符串（2）替换子字符串</p>

<h3>拼接字符串</h3>

<p>可变字符串可以很轻易地把多个字符串按照你的需要组合起来。</p>

<p><code>objc
- (NSString *)magicToken
{
    NSMutableString *string = [NSMutableString string];
    if (usePrefix) {
        [string appendString:@"&amp;gt;&amp;gt;&amp;gt;"];
    }
    [string appendFormat:@"%d--%d", self.foo, self.bar];
    if (useSuffix) {
        [string appendString:@"&amp;gt;&amp;gt;&amp;gt;"];
    }
    return string;
}
</code></p>

<p>这里要注意的是，虽然原本返回值应该是一个 <code>NSString</code> 类型的对象，我们在这里只是简单地返回一个 <code>NSMutableString</code> 类型的对象。</p>

<h3>替换子字符串</h3>

<p>除了追加组合之外，<code>NSMutableString</code> 还提供了以下4个方法：</p>

<p><code>objc
-deleteCharactersInRange:
-insertString:atIndex:
-replaceCharactersInRange:withString:
-replaceOccurrencesOfString:withString:options:range:
</code></p>

<p><code>NSString</code> 也有类似的方法：</p>

<p><code>objc
-stringByReplacingOccurrencesOfString:withString:
-stringByReplacingOccurrencesOfString:withString:options:range:
-stringByReplacingCharactersInRange:withString:
</code></p>

<p>但是 <code>NSMutableString</code> 的那些方法不会创建新的字符串，而仅仅改变当前字符串。这样会让代码更容易阅读，有时也会提升一些性能。</p>

<p><code>objc
NSMutableString *string; // 假设我们已经有了一个名为 string 的字符串
// 现在要去掉它的一个前缀，做法如下:
NSString *prefix = @"WeDon’tWantThisPrefix"
NSRange r = [string rangeOfString:prefix options:NSAnchoredSearch range:NSMakeRange(0, string.length) locale:nil];
if (r.location != NSNotFound) {
    [string deleteCharactersInRange:r];
}
</code></p>

<h2>连接组件</h2>

<p>一个看似微不足道但很常见的情况是字符串连接。比如现在有这样几个字符串：</p>

<pre><code>Hildr
Heidrun
Gerd
Guðrún
Freya
Nanna
Siv
Skaði
Gróa
</code></pre>

<p>我们想用它们来创建下面这样的一个字符串：</p>

<pre><code>Hildr, Heidrun, Gerd, Guðrún, Freya, Nanna, Siv, Skaði, Gróa
</code></pre>

<p>那么就可以这样做：</p>

<p><code>objc
NSArray *names = @["Hildr", @"Heidrun", @"Gerd", @"Guðrún", @"Freya", @"Nanna", @"Siv", @"Skaði", @"Gróa"];
NSString *result = [names componentsJoinedByString:@", "];
</code></p>

<p>如果我们将其显示给用户，我们就要使用本地化表达，确保将最后一部分替换相应语言的 “, and” ：</p>

<p>```
@implementation NSArray (ObjcIO_GroupedComponents)</p>

<ul>
  <li>
    <p>(NSString *)groupedComponentsWithLocale:(NSLocale *)locale;
{
  if (self.count &lt; 1) {
      return @””;
  } else if (self.count &lt; 2) {
      return self[0];
  } else if (self.count &lt; 3) {
      NSString *joiner = NSLocalizedString(@”joiner.2components”, @””);
      return [NSString stringWithFormat:@”%@%@%@”, self[0], joiner, self[1]];
  } else {
      NSString *joiner = [NSString stringWithFormat:@”%@ “, [locale objectForKey:NSLocaleGroupingSeparator]];
      NSArray *first = [self subarrayWithRange:NSMakeRange(0, self.count - 1)];
      NSMutableString *result = [NSMutableString stringWithString:[first componentsJoinedByString:joiner]];</p>

    <pre><code>  NSString *lastJoiner = NSLocalizedString(@"joiner.3components", @"");
  [result appendString:lastJoiner];
  [result appendString:self.lastObject];
  return result;   } }
</code></pre>
  </li>
</ul>

<p>@end
```</p>

<p>那么在本地化的时候，如果是英语，应该是：</p>

<pre><code>"joiner.2components" = " and ";
"joiner.3components" = ", and ";
</code></pre>

<p>如果是德语，则应该是：</p>

<pre><code>"joiner.2components" = " und ";
"joiner.3components" = " und ";
</code></pre>

<p>结合组件的逆过程可以用 <code>-componentsSeparatedByString:</code>，这个方法会将字符串变成一个数组。例如，将 “12|5|3” 变成 “12”、“5” 和 “3”。</p>

<p><a name="object-description"> </a>  </p>

<h2>对象描述</h2>

<p>在许多面向对象编程语言里，对象有一个叫做 <code>toString()</code> 或类似的方法。在 Objective C 里，这个方法是：</p>

<p><code>objc
- (NSString *)description
</code></p>

<p>以及它的兄弟方法:</p>

<p><code>objc
- (NSString *)debugDescription
</code></p>

<p>当自定义模型对象时，覆写 <code>-description</code> 方法是一个好习惯，在 UI 上显示该对象时调用的就是该方法的返回值。假定我们有一个 <code>Contact</code> 类，下面是它的 <code>-description</code> 方法的实现：</p>

<p><code>objc
- (NSString *)description
{
    return self.name;
}
</code></p>

<p>我们可以像下面代码这样格式化字符串：</p>

<p><code>objc
label.text = [NSString stringWithFormat:NSLocalizedString(@"%@ has been added to the group “%@”.", @""), contact, group];
</code></p>

<p>因为该字符串是用来做 UI 显示的，我们可能需要做本地化，那么我们就需要覆写下面这个方法：</p>

<p><code>objc
- (NSString *)descriptionWithLocale:(NSLocale *)locale;
</code></p>

<p>格式转换符 <code>%@</code> 会首先调用 <code>-descriptionWithLocale</code>，如果没有返回值，再调用 <code>-description</code>。</p>

<p>在调试时，打印一个对象，我们用 <code>po</code> 这个命令（它是 print object 的缩写）：</p>

<pre><code>(lldb) po contact
</code></pre>

<p>它会调用对象的 <code>debugDescription</code> 方法。默认情况下 <code>debugDescription</code> 是直接调用 <code>description</code>。如果你希望输出不同的信息，那么就分别覆写两个方法。大多数情况下，尤其是对于非数据模型的对象，你只需要覆写 <code>-description</code> 就能满足需求了。</p>

<p>实际上对象的标准格式化输出是这样的：</p>

<p><code>objc
- (NSString *)description;
{
    return [NSString stringWithFormat:@"&amp;lt;%@: %p&amp;gt;", self.class, self];
}
</code></p>

<p><code>NSObject</code> 这个类内部就是这么实现的。当你覆写该方法时，也可以像这样写。假定我们有一个 <code>DetailViewController</code>，在它的UI上要显示一个 <code>contact</code>，我们可能会这样覆写该方法：</p>

<p><code>objc
- (NSString *)description;
{
    return [NSString stringWithFormat:@"&amp;lt;%@: %p&amp;gt; contact = %@", self.class, self, self.contact.debugDescription];
}
</code></p>

<h3 id="nsmanagedobject"><code>NSManagedObject</code> 子类的描述</h3>

<p>我们将特别注意向 <code>NSManagedObject</code> 的子类添加 <code>-description</code>/<code>-debugDescription</code> 的情况。由于 Core Data 的<strong>惰性加载机制（faulting mechanism）</strong>允许未加载数据的对象存在，所以当我们调用 <code>-debugDescription</code> 时我们并不希望改变应用程序的状态，因此需要检查 <code>isFault</code> 这个属性。例如，我们可如下这样实现它：</p>

<p><code>objc
- (NSString *)debugDescription;
{
    NSMutableString *description = [NSMutableString stringWithFormat:@"&amp;lt;%@: %p&amp;gt;", self.class, self];
    if (! self.isFault) {
        [description appendFormat:@" %@ \"%@\" %gL", self.identifier, self.name, self.metricVolume];
    }
    return description;
}
</code></p>

<p>再次，因为它们是模型对象，重载 <code>-description</code> 简单地返回描述实例的属性名就可以了。</p>

<h3>文件路径</h3>

<p>简单来说就是我们不应该使用 <code>NSString</code> 来描述文件路径。对于 OS X 10.7 和 iOS 5，<code>NSURL</code> 更便于使用，而且更有效率，它还能缓存文件系统的属性。</p>

<p>再者，<code>NSURL</code> 有八个方法来访问被称为 <em>resource values</em> 的东西。这些方法提供了一个稳定的接口，使我们可以用来获取和设置文件与目录的各种属性，例如本地化文件名（<code>NSURLLocalizedNameKey</code>）、文件大小（<code>NSURLFileSizeKey</code>），以及创建日期（<code>NSURLCreationDateKey</code>），等等。</p>

<p>尤其是在遍历目录内容时，使用 
<code>-[NSFileManager enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:]</code>，并传入一个<strong>关键词（keys）</strong>列表，然后用 <code>-getResourceValue:forKey:error:</code> 检索它们，能带来显著的性能提升。

<p>下面是一个简短的例子展示了如何将它们组合在一起：</p>

```objc
NSError *error = nil;
NSFileManager *fm = [[NSFileManager alloc] init];
NSURL *documents = [fm URLForDirectory:NSDocumentationDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:&amp;error];
NSArray *properties = @[NSURLLocalizedNameKey, NSURLCreationDateKey];
NSDirectoryEnumerator *dirEnumerator = [fm enumeratorAtURL:documents
                                includingPropertiesForKeys:properties
                                                   options:0
                                              errorHandler:nil];
for (NSURL *fileURL in dirEnumerator) {
    NSString *name = nil;
    NSDate *creationDate = nil;
    if ([fileURL getResourceValue:&amp;name forKey:NSURLLocalizedNameKey error:NULL] &amp;&amp;
        [fileURL getResourceValue:&amp;creationDate forKey:NSURLCreationDateKey error:NULL])
    {
        NSLog(@"'%@' was created at %@", name, creationDate);
    }
}
```

<p>我们把属性的键传给 <code>-enumeratorAtURL:...</code> 方法中，在遍历目录内容时，这个方法能确保用非常高效的方式获取它们。在循环中，调用 <code>-getResourceValue:...</code> 能简单地从 <code>NSURL</code> 得到已缓存的值，而不用去访问文件系统。</p>

<h2 id="unixapi">传递路径到 UNIX API</h2>

<p>因为 Unicode 非常复杂，同一个字母有多种表示方式，所以我们在传递路径给 UNIX API 时需要非常小心。在这些情况里，一定不能使用 <code>UTF8String</code>，正确的做法是使用 <code>-fileSystemRepresentation</code> 这个方法，如下：</p>

```objc
NSURL *documentURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:NULL];
documentURL = [documentURL URLByAppendingPathComponent:name];
int fd = open(documentURL.fileSystemRepresentation, O_RDONLY);
```

<p>与 <code>NSURL</code> 类似，同样的情况也发生在 <code>NSString</code> 上。如果我们不这么做，在打开一个文件名或路径名包含合成字符的文件时我们将看到随机错误。在 OS X 上，当用户的短名刚好包含合成字符时就会显得特别糟糕，比如 <code>tómas</code>。</p>

<p>有时我们可能需要路径是一个不可变的常量，即 <code>char const *</code>，一个常见的例子就是 UNIX 的 <code>open()</code> 和 <code>close()</code> 指令。但这种需求也可能发生在使用 GCD / libdispatch 的 I/O API 上。</p>

```objc
dispatch_io_t
dispatch_io_create_with_path(dispatch_io_type_t type,
    const char *path, int oflag, mode_t mode,
    dispatch_queue_t queue,
    void (^cleanup_handler)(int error));
```

<p>如果我们要使用 <code>NSString</code> 来做这件事，那我们要保证像下面这样做：</p>

```objc
NSString *path = ... // 假设这个字符串已经存在
io = dispatch_io_create_with_path(DISPATCH_IO_STREAM,
    path.fileSystemRepresentation,
    O_RDONLY, 0, queue, cleanupHandler);
```

<p><code>-fileSystemRepresentation</code> 所做的是它首先将这个字符串转换成文件系统的<a href="http://objccn.io/issue-9-1/#normalization-forms">规范形式</a>然后用 UTF-8 编码。</p>

<hr />
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[整洁的TableView代码]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/zheng-ji-de-tableviewdai-ma/"/>
    <updated>2014-04-09T16:33:17+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/zheng-ji-de-tableviewdai-ma</id>
    <content type="html"><![CDATA[<p>Table view 是 iOS 应用程序中非常通用的组件。许多代码和 table view 都有直接或间接的关系，随便举几个例子，比如提供数据、更新 table view，控制它的行为以及响应选择事件。在这篇文章中，我们将会展示保持 table view 相关代码的整洁和良好组织的技术。</p>

<h2 id="uitableviewcontrollervsuiviewcontroller">UITableViewController vs. UIViewController</h2>

<p>Apple 提供了 <code>UITableViewController</code> 作为 table views 专属的 view controller 类。Table view controllers 实现了一些非常有用的特性，来帮你避免一遍又一遍地写那些死板的代码！但是话又说回来，table view controller 只限于管理一个全屏展示的 table view。大多数情况下，这就是你想要的，但如果不是，还有其他方法来解决这个问题，就像下面我们展示的那样。</p>

<h3 id="tableviewcontrollers">Table View Controllers 的特性</h3>

<p>Table view controllers 会在第一次显示 table view 的时候帮你加载其数据。另外，它还会帮你切换 table view 的编辑模式、响应键盘通知、以及一些小任务，比如闪现侧边的滑动提示条和清除选中时的背景色。为了让这些特性生效，当你在子类中覆写类似 <code>viewWillAppear:</code> 或者 <code>viewDidAppear:</code> 等事件方法时，需要调用 super 版本。</p>

<p>Table view controllers 相对于标准 view controllers 的一个特别的好处是它支持 Apple 实现的“下拉刷新”。目前，文档中唯一的使用 <code>UIRefreshControl</code> 的方式就是通过 table view controller ，虽然通过努力在其他地方也能让它工作（<a href="http://stackoverflow.com/questions/12805003/uirefreshcontrol-issues">见此处</a>），但很可能在下一次 iOS 更新的时候就不行了。</p>

<p>这些要素加一起，为我们提供了大部分 Apple 所定义的标准 table view 交互行为，如果你的应用恰好符合这些标准，那么直接使用 table view controllers 来避免写那些死板的代码是个很好的方法。</p>

<h3 id="tableviewcontrollers">Table View Controllers 的限制</h3>

<p>Table view controllers 的 view 属性永远都是一个 table view。如果你稍后决定在 table view 旁边显示一些东西（比如一个地图），如果不依赖于那些奇怪的 hacks，估计就没什么办法了。</p>

<p>如果你是用代码或 .xib 文件来定义的界面，那么迁移到一个标准 view controller 将会非常简单。但是如果你使用了 storyboards，那么这个过程要多包含几个步骤。除非重新创建，否则你并不能在 storyboards 中将 table view controller 改成一个标准的 view controller。这意味着你必须将所有内容拷贝到新的 view controller，然后再重新连接一遍。</p>

<p>最后，你需要把迁移后丢失的 table view controller 的特性给补回来。大多数都是 <code>viewWillAppear:</code> 或 <code>viewDidAppear:</code> 中简单的一条语句。切换编辑模式需要实现一个 action 方法，用来切换 table view 的 <code>editing</code> 属性。大多数工作来自重新创建对键盘的支持。</p>

<p>在选择条路之前，其实还有一个更轻松的选择，它可以通过分离我们需要关心的功能（关注点分离），让你获得额外的好处：</p>

<h3 id="childviewcontrollers">使用Child View Controllers</h3>

<p>和完全抛弃 table view controller 不同，你还可以将它作为 child view controller 添加到其他 view controller 中（<a href="http://objccn.io/issue-1-4">关于此话题的文章</a>）。这样，parent view controller 在管理其他的你需要的新加的界面元素的同时，table view controller 还可以继续管理它的 table view。</p>

<p><code>objc
- (void)addPhotoDetailsTableView
{
    DetailsViewController *details = [[DetailsViewController alloc] init];
    details.photo = self.photo;
    details.delegate = self;
    [self addChildViewController:details];
    CGRect frame = self.view.bounds;
    frame.origin.y = 110;
    details.view.frame = frame;
    [self.view addSubview:details.view];
    [details didMoveToParentViewController:self];
}
</code></p>

<p>如果你使用这个解决方案，你就必须在 child view controller 和 parent view controller 之间建立消息传递的渠道。比如，如果用户选择了一个 table view 中的 cell，parent view controller 需要知道这个事件来推入其他 view controller。根据使用习惯，通常最清晰的方式是为这个 table view controller 定义一个 delegate protocol，然后到 parent view controller 中去实现。</p>

<p>```objc
@protocol DetailsViewControllerDelegate
- (void)didSelectPhotoAttributeWithKey:(NSString *)key;
@end</p>

<p>@interface PhotoViewController () 
@end</p>

<p>@implementation PhotoViewController
// …
- (void)didSelectPhotoAttributeWithKey:(NSString *)key
{
    DetailViewController *controller = [[DetailViewController alloc] init];
    controller.key = key;
    [self.navigationController pushViewController:controller animated:YES];
}
@end
```</p>

<p>就像你看到的那样，这种结构为 view controller 之间的消息传递带来了额外的开销，但是作为回报，代码封装和分离非常清晰，有更好的复用性。根据实际情况的不同，这既可能让事情变得更简单，也可能会更复杂，需要读者自行斟酌和决定。</p>

<h2 id="separatingconcerns">分离关注点（Separating Concerns）</h2>

<p>当处理 table views 的时候，有许多各种各样的任务，这些任务穿梭于 models，controllers 和 views 之间。为了避免让 view controllers 做所有的事，我们将尽可能地把这些任务划分到合适的地方，这样有利于阅读、维护和测试。</p>

<p>这里描述的技术是文章<a href="http://objccn.io/issue-1-1">更轻量的 View Controllers</a> 中的概念的延伸，请参考这篇文章来理解如何重构 data source 和 model 的逻辑。结合 table views，我们来具体看看如何在 view controllers 和 views 之间分离关注点。</p>

<h3 id="modelcells">搭建 Model 对象和 Cells 之间的桥梁</h3>

<p>有时我们需要将想显示的 model 层中的数据传到 view 层中去显示。由于我们同时也希望让 model 和 view 之间明确分离，所以通常把这个任务转移到 table view 的 data source 中去处理：</p>

<p><code>objc
- (UITableViewCell *)tableView:(UITableView *)tableView
         cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    PhotoCell *cell = [tableView dequeueReusableCellWithIdentifier:@"PhotoCell"];
    Photo *photo = [self itemAtIndexPath:indexPath];
    cell.photoTitleLabel.text = photo.name;
    NSString* date = [self.dateFormatter stringFromDate:photo.creationDate];
    cell.photoDateLabel.text = date;
}
</code></p>

<p>但是这样的代码会让 data source 变得混乱，因为它向 data source 暴露了 cell 的设计。最好分解出来，放到 cell 类的一个 category 中。</p>

<p>```
@implementation PhotoCell (ConfigureForPhoto)</p>

<ul>
  <li>(void)configureForPhoto:(Photo <em>)photo
{
  self.photoTitleLabel.text = photo.name;
  NSString</em> date = [self.dateFormatter stringFromDate:photo.creationDate];
  self.photoDateLabel.text = date;
}</li>
</ul>

<p>@end
```</p>

<p>有了上述代码后，我们的 data source 方法就变得简单了。</p>

<p><code>objc
- (UITableViewCell *)tableView:(UITableView *)tableView
         cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    PhotoCell *cell = [tableView dequeueReusableCellWithIdentifier:PhotoCellIdentifier];
    [cell configureForPhoto:[self itemAtIndexPath:indexPath]];
    return cell;
}
</code></p>

<p>在我们的示例代码中，table view 的 data source 已经<a href="http://objccn.io/issue-1-1">分解到单独的类中了</a>，它用一个设置 cell 的 block 来初始化。这时，这个 block 就变得这样简单了：</p>

<p><code>objc
TableViewCellConfigureBlock block = ^(PhotoCell *cell, Photo *photo) {
    [cell configureForPhoto:photo];
};
</code></p>

<h3 id="cells">让 Cells 可复用</h3>

<p>有时多种 model 对象需要用同一类型的 cell 来表示，这种情况下，我们可以进一步让 cell 可以复用。首先，我们给 cell 定义一个 protocol，需要用这个 cell 显示的对象必须遵循这个 protocol。然后简单修改 category 中的设置方法，让它可以接受遵循这个 protocol 的任何对象。这些简单的步骤让 cell 和任何特殊的 model 对象之间得以解耦，让它可适应不同的数据类型。</p>

<h3 id="cellcell">在 Cell 内部控制 Cell 的状态</h3>

<p>如果你想自定义 table views 默认的高亮或选择行为，你可以实现两个 delegate 方法，把点击的 cell 修改成我们想要的样子。例如：</p>

<p>```objc
- (void)tableView:(UITableView *)tableView
        didHighlightRowAtIndexPath:(NSIndexPath *)indexPath
{
    PhotoCell *cell = [tableView cellForRowAtIndexPath:indexPath];
    cell.photoTitleLabel.shadowColor = [UIColor darkGrayColor];
    cell.photoTitleLabel.shadowOffset = CGSizeMake(3, 3);
}</p>

<ul>
  <li>(void)tableView:(UITableView *)tableView
      didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath
{
  PhotoCell *cell = [tableView cellForRowAtIndexPath:indexPath];
  cell.photoTitleLabel.shadowColor = nil;
}
```</li>
</ul>

<p>然而，这两个 delegate 方法的实现又基于了 view controller 知晓 cell 实现的具体细节。如果我们想替换或重新设计 cell，我们必须改写 delegate 代码。View 的实现细节和 delegate 的实现交织在一起了。我们应该把这些细节移到 cell 自身中去。</p>

<p><code>objc
@implementation PhotoCell
// ...
- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated
{
    [super setHighlighted:highlighted animated:animated];
    if (highlighted) {
        self.photoTitleLabel.shadowColor = [UIColor darkGrayColor];
        self.photoTitleLabel.shadowOffset = CGSizeMake(3, 3);
    } else {
        self.photoTitleLabel.shadowColor = nil;
    }
}
@end
</code></p>

<p>总的来说，我们在努力把 view 层和 controller 层的实现细节分离开。delegate 肯定得清楚一个 view 该显示什么状态，但是它不应该了解如何修改 view 结构或者给某些 subviews 设置某些属性以获得正确的状态。所有这些逻辑都应该封装到 view 内部，然后给外部提供一个简单地 API。</p>

<h3 id="cell">控制多个 Cell 类型</h3>

<p>如果一个 table view 里面有多种类型的 cell，data source 方法很快就难以控制了。在我们示例程序中，photo details table 有两种不同类型的 cell：一种用于显示几个星，另一种用来显示一个键值对。为了划分处理不同 cell 类型的代码，data source 方法简单地通过判断 cell 的类型，把任务派发给其他指定的方法。</p>

<p>```objc
- (UITableViewCell *)tableView:(UITableView *)tableView
         cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    NSString *key = self.keys[(NSUInteger) indexPath.row];
    id value = [self.photo valueForKey:key];
    UITableViewCell *cell;
    if ([key isEqual:PhotoRatingKey]) {
        cell = [self cellForRating:value indexPath:indexPath];
    } else {
        cell = [self detailCellForKey:key value:value];
    }
    return cell;
}</p>

<ul>
  <li>
    <p>(RatingCell *)cellForRating:(NSNumber *)rating
                  indexPath:(NSIndexPath *)indexPath
{
  // …
}</p>
  </li>
  <li>
    <p>(UITableViewCell *)detailCellForKey:(NSString *)key
                              value:(id)value
{
  // …
}
```</p>
  </li>
</ul>

<h3 id="tableview">编辑 Table View</h3>

<p>Table view 提供了易于使用的编辑特性，允许你对 cell 进行删除或重新排序。这些事件都可以让 table view 的 data source 通过 <a href="http://developer.apple.com/library/ios/#documentation/uikit/reference/UITableViewDataSource_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UITableViewDataSource/tableView:commitEditingStyle:forRowAtIndexPath:">delegate 方法</a>得到通知。因此，通常我们能在这些 delegate 方法中看到对数据的进行修改的操作。</p>

<p>修改数据很明显是属于 model 层的任务。Model 应该为诸如删除或重新排序等操作暴露一个 API，然后我们可以在 data source 方法中调用它。这样，controller 就可以扮演 view 和 model 之间的协调者，而不需要知道 model 层的实现细节。并且还有额外的好处，model 的逻辑也变得更容易测试，因为它不再和 view controllers 的任务混杂在一起了。</p>

<h2>总结</h2>

<p>Table view controllers（以及其他的 controller 对象！）应该在 model 和 view 对象之间扮演<a href="http://developer.apple.com/library/mac/#documentation/General/Conceptual/DevPedia-CocoaCore/ControllerObject.html">协调者和调解者的角色</a>。它不应该关心明显属于 view 层或 model 层的任务。你应该始终记住这点，这样 delegate 和 data source 方法会变得更小巧，最多包含一些简单地样板代码。</p>

<p>这不仅减少了 table view controllers 那样的大小和复杂性，而且还把业务逻辑和 view 的逻辑放到了更合适的地方。Controller 层的里里外外的实现细节都被封装成了简单地 API，最终，它变得更加容易理解，也更利于团队协作。</p>

<h3>扩展阅读</h3>

<ul>
<li><a href="http://www.sebastianrehnby.com/blog/2013/01/01/skinnier-controllers-using-view-categories/">Blog: Skinnier Controllers using View Categories</a></li>
<li><a href="http://developer.apple.com/library/ios/#documentation/userexperience/conceptual/tableview_iphone/AboutTableViewsiPhone/AboutTableViewsiPhone.html">Table View Programming Guide</a></li>
<li><a href="http://developer.apple.com/library/mac/#documentation/General/Conceptual/DevPedia-CocoaCore/ControllerObject.html">Cocoa Core Competencies: Controller Object</a></li>
</ul>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[并发程序开发测试]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/bing-fa-cheng-xu-kai-fa-ce-shi/"/>
    <updated>2014-04-09T16:15:22+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/bing-fa-cheng-xu-kai-fa-ce-shi</id>
    <content type="html"><![CDATA[<p>在开发高质量应用程序的过程中，测试是一个很重要的工具。在过去，当并发并不是应用程序架构中重要组成部分的时候，测试就相对简单。随着这几年的发展，使用并发设计模式已愈发重要了，想要测试好并发应用程序，已成了一个不小的挑战。</p>

<p>测试并发代码最主要的困难在于程序或信息流不是反映在调用堆栈上。函数并不会立即返回结果给调用者，而是通过回调函数，Block，通知或者一些类似的机制，这些使得测试变得更加困难。</p>

<p>然而，测试异步代码也会带来一些好处，比如可以揭露较差的程序设计，让最终的实现变得更加清晰。</p>

<h2>异步测试的问题</h2>

<p>首先，我们来看一个简单的同步单元测试例子。两个数求和的方法：</p>

<p><code>objc
+ (int)add:(int)a to:(int)b {
    return a + b;
}
</code></p>

<p>测试这个方法很简单，只需要比较该方法返回的值是否与期望的值相同，如果不相同，则测试失败。</p>

<p><code>objc
- (void)testAddition {
    int result = [Calculator add:2 to:2];
    STAssertEquals(result, 4, nil);
}
</code></p>

<p>接下来，我们利用 Block 将该方法改成异步返回结果。为了模拟测试失败，我们会在方法实现中故意添加一个 bug。</p>

<p><code>objc
+ (int)add:(int)a to:(int)b block:(void(^)(int))block {
    [[NSOperationQueue mainQueue] addOperationWithBlock:^{
        block(a - b); // 带有bug的实现
    }];
}
</code></p>

<p>显然这是一个人为的例子，但是它却真实的反应了在编程中可能经常遇到的问题，只不过实际过程更复杂罢了。</p>

<p>测试上面的方法最简单的做法就是把断言放到 Block 中。尽管我们的方法实现中存在 bug，但是这种测试永远不会失败的:</p>

<p><code>objc
// 千万不要使用这些代码！
- (void)testAdditionAsync {
    [Calculator add:2 to:2 block:^(int result) {
        STAssertEquals(result, 4, nil); // 永远不会被调用到
    }];
}
</code></p>

<p>这里的断言为什么没失败呢?</p>

<h2 id="sentestingkit">关于SenTestingKit</h2>

<p>XCode4 所使用的测试框架是基于 <a href="http://www.sente.ch/software/ocunit/" title="OCUnit">OCUnit</a>。为了理解之前所提到的异步测试问题，我们需要了解一下测试包中的各个部分之间的执行顺序。下图展示了一个简化的流程。</p>

<p><img src="http://img.objccn.io/issue-2/SenTestingKit-call-stack.png" style="width:698px" alt="SenTestingKit call stack" /></p>

<p>在测试框架在主 run loop 开始运行之后，主要执行了以下几个步骤：</p>

<ol>
<li>配置一个包含所有相关测试的测试包 (比如可以在工程的 scheme 中配置)。  </li>
<li>运行测试包，内部会调用所有以 <em>test</em> 开头测试用例的方法。运行结束后会返回一个包含单个测试结果的对象。  </li>
<li>调用 <code>exit()</code> 退出测试。</li>
</ol>

<p>这其中我们最感兴趣的是单个测试是如何被调用的。在异步测试中，包含断言的 Block 会被加到主 run loop。当所有的测试执行完毕后，测试框架就会退出，而 block 却从来没有被执行，因此不会引起测试失败。</p>

<p>当然我们有很多种方发来解决这个问题。但是所有的方法都必须在主 run loop 中运行，而且在测试方法返回和比较结果之前需要处理已入队所有操作。</p>

<p><a href="https://github.com/allending/Kiwi" title="Kiwi">Kiwi</a> 使用探测轮询 (probe poller)，它可以在测试方法中被调用。 <a href="https://github.com/gabriel/gh-unit/" title="GHUnit">GHUnit</a> 编写了一个单独的测试类，它必须在测试的方法内初始化，并在结束时接收一个通知。以上两种方式都是通过编写相应的代码来确保异步测试方法在测试结束之前都不会返回。</p>

<h2 id="sentestingkit">SenTestingKit的异步扩展</h2>

<p>我们对这个问题的解决方案是对 SenTestingKit 添加一个<a href="https://github.com/nxtbgthng/SenTestingKitAsync" title="SenTestingKitAsync">扩展</a>，它在栈上使用同步执行，并把每个部分加入到主队列上。正如下图所见，在验证整个测试框架结果之前，报告异步测试成功或者失败的 Block 就被加入到队列。这种执行顺序允许我们开启一个测试并等待它的测试结果。</p>

<p><img src="http://img.objccn.io/issue-2/SenTestingKitAsync-call-stack.png" style="width:531px" alt="SenTestingKitAsync call stack" /></p>

<p>如果测试方法以 <strong>Async</strong> 结尾，框架就会认为该方法是异步测试。此外，在异步测试中，我们必须手动地报告测试成功，同时为了防止 Block 永远不会被调用，我们还需添加了一个超时方法。之前的错误的测试方法修改后如下所示：</p>

<p><code>objc
- (void)testAdditionAsync {
    [Calculator add:2 to:2 block^(int result) {
        STAssertEquals(result, 4, nil);
        STSuccess(); // 通过调用这个宏来判断是否测试成功
    }];
    STFailAfter(2.0, @"Timeout");
}
</code></p>

<h2>设计异步测试</h2>

<p>就像同步测试一样，异步测试也应该比被测试的功能简单许多。复杂的测试并不会改进代码的质量，反而会给测试本身带来更多的 Bug。在以测试驱动开发的情况下，简单的测试会让我们对组件，接口以及架构的行为有更清醒的认识。</p>

<h3>示例工程</h3>

<p>为了运用到实际中，我们创建了一个示例框架：<a href="https://github.com/objcio/issue-2-async-testing" title="Pinacoteca Core: Cocoa Framework for an Imaginary Image Service">PinacotecaCore</a>，它从一个虚拟的服务器获取图像信息。框架中包含一个资源管理器，它对外提供一个可以根据图像 Id 获取图像对象的接口。该接口的工作原理是资源管理器从虚拟服务器获取图片对象的信息，并更新到数据库。</p>

<p>虽然这个示例框架只是为了演示，但在我们自己开发的许多应用中也使用了这种模式。</p>

<p><img src="http://img.objccn.io/issue-2/PinacotecaCore.png" style="width:699px" alt="PinacotecaCore architecture" /></p>

<p>从上图我们可以知道，示例框架有三个组件我们需要测试：</p>

<ol>
<li>模型层  </li>
<li>模拟服务器请求的服务器接口控制器（API Controller）  </li>
<li>管理 core data 堆栈以及连接模型层和服务接口控制器的资源管理器</li>
</ol>

<h3>模型层</h3>

<p>测试应该尽量使用同步的方式进行，而模型层就是一个很好的实例。只要不同的被托管对象上下文 (managed object contexts) 之间没有复杂的依赖关系，测试用例都应该根据上下文在主线程上设置它自己的 core data 堆栈，并在其中执行各自的操作。</p>

<p>在这个<a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCModelLayerTests.m" title="Pinacoteca Core Model Layer Tests">测试实例</a>中，我们就是在 <code>setUp</code> 方法中设置 core data 堆栈，然后检查 <code>PCImage</code> 实体的描述是否存在，如果不存在就构造一个，并更新它的值。当然这和异步测试没有关系，我们就不深入细说了。</p>

<h3>服务器接口控制器</h3>

<p>框架中的第二个组件就是服务器接口控制器。它主要处理服务器请求以及服务器 API 到模型的映射关系。让我们来看一下下面这个方法：</p>

<p><code>objc
- [PCServerAPIController fetchImageWithId:queue:completionHandler:]
</code></p>

<p>调用它需要三个形参：一个图片对象 Id，所在的执行队列以及一个完成后的回调方法。</p>

<p>因为服务器根本不存在，一个比较好的做法就是伪造一个代理服务器，正好 <a href="https://github.com/AliSoftware/OHHTTPStubs" title="OHHTTPStubs">OHHTTPStubs</a> 可以解决这个问题。在它的最新版本中，可以在示例的请求响应中包含一个 bundle，发送给客户端。</p>

<p>为了能 stub 请求，OHHTTPStubs 需要在测试类初始化时或者 setUp 方法中进行配置。首先，我们需要加载一个包含请求响应对象（response）的 bundle：</p>

<p>```objc
NSURL *url = [[NSBundle bundleForClass:[self class]]
                        URLForResource:@”ServerAPIResponses”
                         withExtension:@”bundle”];</p>

<p>NSBundle *bundle = [NSBundle url];
```</p>

<p>然后我们从 bundle 加载 response 对象，作为请求的响应值：</p>

<p>```objc
OHHTTPStubsResponse *response;
response = [OHHTTPStubsResponse responseNamed:@”images/123”
                                   fromBundle:responsesBundle
                                 responseTime:0.1];</p>

<p>[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest <em>request) {
    return YES /</em> 如果所返回的request是我们所期望的，就返回YES */;
} withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {
    return response;
}];
```</p>

<p>通过如上的设置之后，简化版的<a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCServerAPIControllerTests.m" title="Pinacoteca Core Server API Controller Tests">测试服务器接口控制器</a>如下：</p>

<p>```objc
- (void)testFetchImageAsync
{
    [self.server
        fetchImageWithId:@”123”
                   queue:[NSOperationQueue mainQueue]
       completionHandler:^(id imageData, NSError *error) {
          STAssertEqualObjects([NSOperationQueue currentQueue], queue, nil);
          STAssertNil(error, [error localizedDescription]);
          STAssertTrue([imageData isKindOfClass:[NSDictionary class]], nil);</p>

<pre><code>      // 检查返回的字典中的值.

      STSuccess();
   }];
STFailAfter(2.0, nil);     } ```
</code></pre>

<h3>资源管理器</h3>

<p>最后一个部分是资源管理器，它不但把服务器接口控制器和模型层联系起来, 还管理着 core data 堆栈。下面我们想测试获取一个图片对象的方法：</p>

<p><code>objc
-[PCResourceManager imageWithId:usingManagedObjectContext:queue:updateHandler:]
</code></p>

<p>该方法根据 id 返回一个图片对象。如果图片在数据库中不存在，它会创建一个只包含 id 的新对象，然后通过服务器接口控制器获取图片对象的详细信息。</p>

<p>由于资源管理器的测试不应该依赖于服务器接口控制器，所以我们可以用 <a href="http://ocmock.org" title="OCMock">OCMock</a> 来模拟，如果要做方法的部分 stub，它是一个理想的框架。如以下的 <a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCResourceManagerTests.m" title="Pinacoteca Core Resource Manager Tests">资源管理器测试</a> :</p>

<p>```objc
OCMockObject *mo;
mo = [OCMockObject partialMockForObject:self.resourceManager.server];</p>

<p>id exp = [[serverMock expect] 
             andCall:@selector(fetchImageWithId:queue:completionHandler:)
            onObject:self];
[exp fetchImageWithId:OCMOCK_ANY queue:OCMOCK_ANY completionHandler:OCMOCK_ANY];
```</p>

<p>上面的代码实际上它并没有真正调用服务器接口控制器的方法，而是调用我们写在测试类中的方法。</p>

<p>用上面的做法，对资源管理的测试就变得很直观。当我们调用资源管理器获取资源时，实际上调用的是我们模拟的服务器接口控制器的方法。这样我们也能检查调用服务器接口控制器时参数是否正确。在调用了获取图像对象的方法后，资源管理器会更新模型，然后调用验证测试成功与否的宏。</p>

<p><code>objc
- (void)testGetImageAsync
{
    NSManagedObjectContext *ctx = self.resourceManager.mainManagedObjectContext;
    __block PCImage *img;
    img = [self.resourceManager imageWithId:@"123"
                  usingManagedObjectContext:ctx
                                      queue:[NSOperationQueue mainQueue]
                              updateHandler:^(NSError *error) {
                                       // 检查error是否为空以及image是否已经被更新 
                                       STSuccess();
                                   }];    
    STAssertNotNil(img, nil);
    STFailAfter(2.0, @"Timeout");
}
</code></p>

<h2>总结</h2>

<p>刚开始时候，使用并发设计模式测试应用程序是具有一定的挑战性，但是一旦你理解了它们的不同，并建立最佳实践，一切都会变得简单而有趣。</p>

<p>在 <a href="http://nxtbgthng.com" title="nxtbgthng">nxtbgthng</a> 项目中，我们用 <a href="https://github.com/nxtbgthng/SenTestingKitAsync" title="SenTestingKitAsync">SenTestingKitAsync</a> 框架来测试。但是像 <a href="https://github.com/allending/Kiwi" title="Kiwi">Kiwi</a> 和 <a href="https://github.com/gabriel/gh-unit/" title="GHUnit">GHUnit</a>  也都是不错的异步测试框架。建议你都可以尝试下，然后找到合适自己的测试工具并开始使用它。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线程安全]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/xian-cheng-an-quan/"/>
    <updated>2014-04-09T16:08:45+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/xian-cheng-an-quan</id>
    <content type="html"><![CDATA[<p>这篇文章将专注于实用技巧，设计模式，以及对于写出线程安全类和使用 GCD 来说所特别需要注意的一些<a href="http://zh.wikipedia.org/wiki/反面模式">反面模式</a>。</p>

<h2>线程安全</h2>

<h3 id="apple">Apple 的框架</h3>

<p>首先让我们来看看 Apple 的框架。一般来说除非特别声明，大多数的类默认都不是线程安全的。对于其中的一些类来说，这是很合理的，但是对于另外一些来说就很有趣了。</p>

<p>就算是在经验丰富的 iOS/Mac 开发者，也难免会犯从后台线程去访问 UIKit/AppKit 这种错误。比如因为图片的内容本身就是从后台的网络请求中获取的话，顺手就在后台线程中设置了 <code>image</code> 之类的属性，这样的错误其实是屡见不鲜的。Apple 的代码都经过了性能的优化，所以即使你从别的线程设置了属性的时候，也不会产生什么警告。</p>

<p>在设置图片这个例子中，症结其实是你的改变通常要过一会儿才能生效。但是如果有两个线程在同时对图片进行了设定，那么很可能因为当前的图片被释放两次，而导致应用崩溃。这种行为是和时机有关系的，所以很可能在开发阶段没有崩溃，但是你的用户使用时却不断 crash。</p>

<p>现在没有<strong>官方</strong>的用来寻找类似错误的工具，但我们确实有一些技巧来避免这个问题。<a href="https://gist.github.com/steipete/5664345">UIKit Main Thread Guard</a> 是一段用来监视每一次对 <code>setNeedsLayout</code> 和 <code>setNeedsDisplay</code> 的调用代码，并检查它们是否是在主线程被调用的。因为这两个方法在 UIKit 的 setter （包括 image 属性）中广泛使用，所以它可以捕获到很多线程相关的错误。虽然这个小技巧并不包含任何私有 API， 但我们还是不建议将它是用在发布产品中，不过在开发过程中使用的话还是相当赞的。</p>

<p>Apple没有把 UIKit 设计为线程安全的类是有意为之的，将其打造为线程安全的话会使很多操作变慢。而事实上 UIKit 是和主线程绑定的，这一特点使得编写并发程序以及使用 UIKit 十分容易的，你唯一需要确保的就是对于 UIKit 的调用总是在主线程中来进行。</p>

<h4 id="uikit">为什么 UIKit 不是线程安全的？</h4>

<p>对于一个像 UIKit 这样的大型框架，确保它的线程安全将会带来巨大的工作量和成本。将 non-atomic 的属性变为 atomic 的属性只不过是需要做的变化里的微不足道的一小部分。通常来说，你需要同时改变若干个属性，才能看到它所带来的结果。为了解决这个问题，苹果可能不得不提供像 Core Data 中的 <code>performBlock:</code> 和 <code>performBlockAndWait:</code> 那样类似的方法来同步变更。另外你想想看，绝大多数对 UIKit 类的调用其实都是以<strong>配置</strong>为目的的，这使得将 UIKit 改为线程安全这件事情更显得毫无意义了。</p>

<p>然而即使是那些与配置共享的内部状态之类事情无关的调用，其实也不是线程安全的。如果你做过 iOS 3.2 或之前的黑暗年代的 app 开发的话，你肯定有过一边在后台准备图像时一边使用 NSString 的 <code>drawInRect:withFont:</code> 时的随机崩溃的经历。值得庆幸的事，在 iOS 4 中 <a href="http://developer.apple.com/library/ios/#releasenotes/General/WhatsNewIniOS/Articles/iPhoneOS4.html">苹果将大部分绘图的方法和诸如 <code>UIColor</code> 和 <code>UIFont</code> 这样的类改写为了后台线程可用</a>。</p>

<p>但不幸的是 Apple 在线程安全方面的文档是极度匮乏的。他们推荐只访问主线程，并且甚至是绘图方法他们都没有明确地表示保证线程安全。因此在阅读文档的同时，去读读 <a href="http://developer.apple.com/library/ios/#releasenotes/General/WhatsNewIniOS/Articles/iPhoneOS4.html">iOS 版本更新说明</a>会是一个很好的选择。</p>

<p>对于大多数情况来说，UIKit 类确实只应该用在应用的主线程中。这对于那些继承自 UIResponder 的类以及那些操作你的应用的用户界面的类来说，不管如何都是很正确的。</p>

<h4 id="deallocation">内存回收 (deallocation) 问题</h4>

<p>另一个在后台使用 UIKit 对象的的危险之处在于“内存回收问题”。Apple 在技术笔记 <a href="ttp://developer.apple.com/library/ios/#technotes/tn2109/_index.html">TN2109</a> 中概述了这个问题，并提供了多种解决方案。这个问题其实是要求 UI 对象应该在主线程中被回收，因为在它们的 <code>dealloc</code> 方法被调用回收的时候，可能会去改变 view 的结构关系，而如我们所知，这种操作应该放在主线程来进行。</p>

<p>因为调用者被其他线程持有是非常常见的（不管是由于 operation 还是 block 所导致的），这也是很容易犯错并且难以被修正的问题。在 <a href="https://github.com/AFNetworking/AFNetworking/issues/56">AFNetworking 中也一直长久存在这样的 bug</a>，但是由于其自身的隐蔽性而鲜为人知，也很难重现其所造成的崩溃。在异步的 block 或者操作中一致使用 <code>__weak</code>，并且不去直接访问局部变量会对避开这类问题有所帮助。</p>

<h4 id="collection">Collection 类</h4>

<p>Apple 有一个<a href="ttps://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1">针对 iOS 和 Mac 的很好的总览性文档</a>，为大多数基本的 foundation 类列举了其线程安全特性。总的来说，比如 <code>NSArry</code> 这样不可变类是线程安全的。然而它们的可变版本，比如 <code>NSMutableArray</code> 是线程不安全的。事实上，如果是在一个队列中串行地进行访问的话，在不同线程中使用它们也是没有问题的。要记住的是即使你申明了返回类型是不可变的，方法里还是有可能返回的其实是一个可变版本的 collection 类。一个好习惯是写类似于 <code>return [array copy]</code> 这样的代码来确保返回的对象事实上是不可变对象。</p>

<p>与和<a href="">Java</a>这样的语言不一样，Foundation 框架并不提供直接可用的 collection 类，这是有其道理的，因为大多数情况下，你想要的是在更高层级上的锁，以避免太多的加解锁操作。但缓存是一个值得注意的例外，iOS 4 中 Apple 添加的 <code>NSCache</code> 使用一个可变的字典来存储不可变数据，它不仅会对访问加锁，更甚至在低内存情况下会清空自己的内容。</p>

<p>也就是说，在你的应用中存在可变的且线程安全的字典是可以做到的。借助于 class cluster 的方式，我们也很容易<a href="https://gist.github.com/steipete/5928916">写出这样的代码</a>。</p>

<h3 id="atomicproperties">原子属性 (Atomic Properties)</h3>

<p>你曾经好奇过 Apple 是怎么处理 atomic 的设置/读取属性的么？至今为止，你可能听说过自旋锁 (spinlocks)，信标 (semaphores)，锁 (locks)，@synchronized 等，Apple 用的是什么呢？因为 <a href="http://www.opensource.apple.com/source/objc4/">Objctive-C 的 runtime 是开源</a>的，所以我们可以一探究竟。</p>

<p>一个非原子的 setter 看起来是这个样子的：</p>

<p><code>objc
- (void)setUserName:(NSString *)userName {
      if (userName != _userName) {
          [userName retain];
          [_userName release];
          _userName = userName;
      }
}
</code></p>

<p>这是一个手动 retain/release 的版本，ARC 生成的代码和这个看起来也是类似的。当我们看这段代码时，显而易见要是 <code>setUserName:</code> 被并发调用的话会造成麻烦。我们可能会释放 <code>_userName</code> 两次，这回使内存错误，并且导致难以发现的 bug。</p>

<p>对于任何没有手动实现的属性，编译器都会生成一个 <a href="https://github.com/opensource-apple/objc4/blob/master/runtime/Accessors.subproj/objc-accessors.mm#L127"><code>objc_setProperty_non_gc(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy)</code></a> 的调用。在我们的例子中，这个调用的参数是这样的：</p>

<p><code>objc
objc_setProperty_non_gc(self, _cmd, 
  (ptrdiff_t)(&amp;amp;_userName) - (ptrdiff_t)(self), userName, NO, NO);`
</code></p>

<p><code>ptrdiff_t</code> 可能会吓到你，但是实际上这就是一个简单的指针算术，因为其实 Objective-C 的类仅仅只是 C 结构体而已。</p>

<p><code>objc_setrProperty</code> 调用的是如下方法：</p>

<p>```objc
static inline void reallySetProperty(id self, SEL _cmd, id newValue, 
  ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy) 
{
    id oldValue;
    id <em>slot = (id</em>) ((char*)self + offset);</p>

<pre><code>if (copy) {
    newValue = [newValue copyWithZone:NULL];
} else if (mutableCopy) {
    newValue = [newValue mutableCopyWithZone:NULL];
} else {
    if (*slot == newValue) return;
    newValue = objc_retain(newValue);
}

if (!atomic) {
    oldValue = *slot;
    *slot = newValue;
} else {
    spin_lock_t *slotlock = &amp;amp;PropertyLocks[GOODHASH(slot)];
    _spin_lock(slotlock);
    oldValue = *slot;
    *slot = newValue;        
    _spin_unlock(slotlock);
}

objc_release(oldValue); } ```
</code></pre>

<p>除开方法名字很有趣以外，其实方法实际做的事情非常直接，它使用了在 <code>PropertyLocks</code> 中的 128 个自旋锁中的 1 个来给操作上锁。这是一种务实和快速的方式，最糟糕的情况下，如果遇到了哈希碰撞，那么 setter 需要等待另一个和它无关的 setter 完成之后再进行工作。</p>

<p>虽然这些方法没有定义在任何公开的头文件中，但我们还是可用手动调用他们。我不是说这是一个好的做法，但是知道这个还是蛮有趣的，而且如果你想要同时实现原子属性<strong>和</strong>自定义的 setter 的话，这个技巧就非常有用了。</p>

<p>```objc
// 手动声明运行时的方法
extern void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, 
  id newValue, BOOL atomic, BOOL shouldCopy);
extern id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, 
  BOOL atomic);</p>

<h1 id="define-pstatomicretainedsetdest-src-objcsetpropertyself-cmd">define PSTAtomicRetainedSet(dest, src) objc_setProperty(self, _cmd,</h1>
<p>(ptrdiff_t)(&amp;dest) - (ptrdiff_t)(self), src, YES, NO) 
#define PSTAtomicAutoreleasedGet(src) objc_getProperty(self, _cmd, 
  (ptrdiff_t)(&amp;src) - (ptrdiff_t)(self), YES)
```</p>

<p><a href="https://gist.github.com/steipete/5928690">参考这个 gist</a> 来获取包含处理结构体的完整的代码，但是我们其实并不推荐使用它。</p>

<h4 id="synchronized">为何不用 @synchronized ？</h4>

<p>你也许会想问为什么苹果不用 <code>@synchronized(self)</code> 这样一个已经存在的运行时特性来锁定属？？你可以看看<a href="https://github.com/opensource-apple/objc4/blob/master/runtime/objc-sync.mm#L291">这里的源码</a>，就会发现其实发生了很多的事情。Apple 使用了<a href="http://googlemac.blogspot.co.at/2006/10/synchronized-swimming.html">最多三个加/解锁序列</a>，还有一部分原因是他们也添加了<a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW3">异常开解(exception unwinding)</a>机制。相比于更快的自旋锁方式，这种实现要慢得多。由于设置某个属性一般来说会相当快，因此自旋锁更适合用来完成这项工作。<code>@synchonized(self)</code> 更适合使用在你
需要确保在发生错误时代码不会死锁，而是抛出异常的时候。</p>

<h3>你自己的类</h3>

<p>单独使用原子属性并不会是你的类变成线程安全。它不能保护你应用的逻辑，只能保护你免于在 setter 中遭遇到<a href="http://objccn.io/issue-3-1">竞态条件</a>的困扰。看看下面的代码片段：</p>

<p><code>objc
if (self.contents) {
    CFAttributedStringRef stringRef = CFAttributedStringCreate(NULL, 
      (__bridge CFStringRef)self.contents, NULL);
    // 渲染字符串
}
</code></p>

<p>我之前在 <a href="http://pspdfkit.com">PSPDFKit</a> 中就犯了这个错误。时不时地应用就会因为 <code>contents</code> 属性在通过检查之后却又被设成了 nil 而导致 EXC<em>BAD</em>ACCESS 崩溃。捕获这个变量就可以简单修复这个问题；</p>

<p><code>objc
NSString *contents = self.contents;
if (contents) {
    CFAttributedStringRef stringRef = CFAttributedStringCreate(NULL, 
      (__bridge CFStringRef)contents, NULL);
    // 渲染字符串
}
</code></p>

<p>在这里这样就能解决问题，但是大多数情况下不会这么简单。想象一下我们还有一个 <code>textColor</code> 的属性，我们在一个线程中将两个属性都做了改变。我们的渲染线程有可能使用了新的内容，但是依旧保持了旧的颜色，于是我们得到了一组奇怪的组合。这其实也是为什么 Core Data 要将 model 对象都绑定在一个线程或者队列中的原因。</p>

<p>对于这个问题，其实没有万用解法。使用 <a href="http://www.cocoawithlove.com/2008/04/value-of-immutable-values.html">不可变模型</a>是一个可能的方案，但是它也有自己的问题。另一种途径是限制对存在在主线程或者某个特定队列中的既存对象的改变，而是先进行一次拷贝之后再在工作线程中使用。对于这个问题的更多对应方法，我推荐阅读 Jonathan Sterling 的关于 <a href="http://www.jonmsterling.com/posts/2012-12-27-a-pattern-for-immutability.html">Objective-C 中轻量化不可变对象</a>的文章。</p>

<p>一个简单的解决办法是使用 <code>@synchronize</code>。其他的方式都非常非常可能使你误入歧途，已经有太多聪明人在这种尝试上一次又一次地以失败告终。</p>

<h4>可行的线程安全设计</h4>

<p>在尝试写一些线程安全的东西之前，应该先想清楚是不是真的需要。确保你要做的事情不会是过早优化。如果要写的东西是一个类似配置类 (configuration class) 的话，去考虑线程安全这种事情就毫无意义了。更正确的做法是扔一个断言上去，以保证它被正确地使用：</p>

<p><code>objc
void PSPDFAssertIfNotMainThread(void) {
    NSAssert(NSThread.isMainThread, 
      @"Error: Method needs to be called on the main thread. %@", 
      [NSThread callStackSymbols]);
}
</code></p>

<p>对于那些肯定应该线程安全的代码（一个好例子是负责缓存的类）来说，一个不错的设计是使用并发的 <code>dispatch_queue</code> 作为读/写锁，并且确保只锁着那些真的需要被锁住的部分，以此来最大化性能。一旦你使用多个队列来给不同的部分上锁的话，整件事情很快就会变得难以控制了。</p>

<p>于是你也可以重新组织你的代码，这样某些特定的锁就不再需要了。看看下面这段实现了一种多委托的代码（其实在大多数情况下，用 NSNotifications 会更好，但是其实也还是有<a href="https://code.google.com/r/riky-adsfasfasf/source/browse/Utilities/GCDMulticastDelegate.h">多委托的实用例子</a>）的</p>

<p>```objc
// 头文件
@property (nonatomic, strong) NSMutableSet *delegates;</p>

<p>// init方法中
_delegateQueue = dispatch_queue_create(“com.PSPDFKit.cacheDelegateQueue”, 
  DISPATCH_QUEUE_CONCURRENT);</p>

<ul>
  <li>
    <p>(void)addDelegate:(id&lt;PSPDFCacheDelegate&gt;)delegate {
  dispatch_barrier_async(_delegateQueue, ^{
      [self.delegates addObject:delegate];
  });
}</p>
  </li>
  <li>
    <p>(void)removeAllDelegates {
  dispatch_barrier_async(_delegateQueue, ^{
      self.delegates removeAllObjects];
  });
}</p>
  </li>
  <li>
    <p>(void)callDelegateForX {
  dispatch_sync(_delegateQueue, ^{
      [self.delegates enumerateObjectsUsingBlock:^(id&lt;PSPDFCacheDelegate&gt; delegate, NSUInteger idx, BOOL *stop) {
          // 调用delegate
      }];
  });
}
```</p>
  </li>
</ul>

<p>除非 <code>addDelegate:</code> 或者 <code>removeDelegate:</code> 每秒要被调用上千次，否则我们可以使用一个相对简洁的实现方式：</p>

<p>```objc
// 头文件
@property (atomic, copy) NSSet *delegates;</p>

<ul>
  <li>
    <p>(void)addDelegate:(id&lt;PSPDFCacheDelegate&gt;)delegate {
  @synchronized(self) {
      self.delegates = [self.delegates setByAddingObject:delegate];
  }
}</p>
  </li>
  <li>
    <p>(void)removeAllDelegates {
  self.delegates = nil;
}</p>
  </li>
  <li>
    <p>(void)callDelegateForX {
  [self.delegates enumerateObjectsUsingBlock:^(id&lt;PSPDFCacheDelegate&gt; delegate, NSUInteger idx, BOOL *stop) {
      // 调用delegate
  }];
}
```</p>
  </li>
</ul>

<p>当然啦，这个例子有点过于人为编造，其实我们很容易可以把变化限制在主线程中来避免问题。但是对于很多数据结构来说，可以在进行变更操作的方法中创建不可变的拷贝，这样 app 的整体逻辑就不需要处理很多锁的情况。请注意我们还是需要给 <code>addDelegate:</code> 加上锁，否则在其他线程进行异步调用的时候可能遭遇委托对象丢失的问题。</p>

<h2 id="gcd">GCD 的陷阱</h2>

<p>对于大多数上锁的需求来说，GCD 就足够好了。它简单迅速，并且基于 block 的 API 使得粗心大意造成非平衡锁操作的概率下降了不少。然后，GCD 中还是有不少陷阱，我们在这里探索一下其中的一些。</p>

<h3 id="gcd">将 GCD 当作递归锁使用</h3>

<p>GCD 是一个对共享资源的访问进行串行化的队列。这个特性可以被当作锁来使用，但实际上它和 <code>@synchronized</code> 有很大区别。 GCD队列并非是<a href="http://zh.wikipedia.org/w/index.php?title=可重入&amp;variant=zh-cn">可重入</a>的，因为这将破坏队列的特性。很多有试图使用 <code>dispatch_get_current_queue()</code> 来绕开这个限制，但是这是一个<a href="https://gist.github.com/steipete/3713233">糟糕的做法</a>，Apple 在 iOS6 中将这个方法标记为废弃，自然也是有自己的理由。</p>

<p><code>objc
// This is a bad idea.
inline void pst_dispatch_sync_reentrant(dispatch_queue_t queue, 
  dispatch_block_t block) 
{
    dispatch_get_current_queue() == queue ? block() 
                                          : dispatch_sync(queue, block);
}
</code></p>

<p>对当前的队列进行测试也许在简单情况下可以行得通，但是一旦你的代码变得复杂一些，并且你可能有多个队列在同时被锁住的情况下，这种方法很快就悲剧了。一旦这种情况发生，几乎可以肯定的是你会遇到<a href="http://objccn.io/issue-2-1/#dead_locks">死锁</a>。当然，你可以使用 <code>dispatch_get_specific()</code>，这将截断整个队列结构，从而对某个特定的队列进行测试。要这么做的话，你还得为了在队列中附加标志队列的元数据，而去写自定义的队列构造函数。嘛，最好别这么做。其实在实用中，使用 <code>NSRecursiveLock</code> 会是一个更好的选择。</p>

<h3 id="dispatch_async">用 dispatch_async 修复时序问题</h3>

<p>在使用 UIKit 的时候遇到了一些时序上的麻烦？很多时候，这样进行“修正”看来非常完美：</p>

<p><code>objc
dispatch_async(dispatch_get_main_queue(), ^{
    // Some UIKit call that had timing issues but works fine 
    // in the next runloop.
    [self updatePopoverSize];
});
</code></p>

<p>千万别这么做！相信我，这种做法将会在之后你的 app 规模大一些的时候让你找不着北。这种代码非常难以调试，并且你很快就会陷入用更多的 dispatch 来修复所谓的莫名其妙的"时序问题"。审视你的代码，并且找到合适的地方来进行调用（比如在 viewWillAppear 里调用，而不是 viewDidLoad 之类的）才是解决这个问题的正确做法。我在自己的代码中也还留有一些这样的 hack，但是我为它们基本都做了正确的文档工作，并且对应的 issue 也被一一记录过。</p>

<p>记住这不是真正的 GCD 特性，而只是一个在 GCD 下很容易实现的常见反面模式。事实上你可以使用 <code>performSelector:afterDelay:</code> 方法来实现同样的操作，其中 delay 是在对应时间后的 runloop。</p>

<h3 id="dispatch_syncdispatch_async">在性能关键的代码中混用 dispatch<em>sync 和 dispatch</em>async</h3>

<p>这个问题我花了好久来研究。在 <a href="http://pspdfkit.com">PSPDFKit</a> 中有一个使用了 LRU（最久未使用）算法列表的缓存类来记录对图片的访问。当你在页面中滚动时，这个方法将被调用<strong>非常多次</strong>。最初的实现使用了 <code>dispatch_sync</code> 来进行实际有效的访问，使用 <code>dispatch_async</code> 来更新 LRU 列表的位置。这导致了帧数远低于原来的 60 帧的目标。</p>

<p>当你的 app 中的其他运行的代码阻挡了 GCD 线程的时候，dispatch manager 需要花时间去寻找能够执行 dispatch_async 代码的线程，这有时候会花费一点时间。在找到合适的执行线程之前，你的同步调用就会被 block 住了。其实在这个例子中，异步情况的执行顺序并不是很重要，但没有能将这件事情告诉 GCD 的好办法。读/写锁这里并不能起到什么作用，因为在异步操作中基本上一定会需要进行顺序写入，而在此过程中读操作将被阻塞住。如果误用了 <code>dispatch_async</code> 代价将会是非常惨重的。在将它用作锁的时候，一定要非常小心。</p>

<h3 id="dispatch_async">使用 dispatch_async 来派发内存敏感的操作</h3>

<p>我们已经谈论了很多关于 NSOperations 的话题了，一般情况下，使用这个更高层级的 API 会是一个好主意。当你要处理一段内存敏感的操作的代码块时，这个优势尤为突出、</p>

<p>在 PSPDFKit 的老版本中，我用了 GCD 队列来将已缓存的 JPG 图片写到磁盘中。当 retina 的 iPad 问世之后，这个操作出现了问题。ß因为分辨率翻倍了，相比渲染这张图片，将它编码花费的时间要长得多。所以，操作堆积在了队列中，当系统繁忙时，甚至有可能因为内存耗尽而崩溃。</p>

<p>我们没有办法追踪有多少个操作在队列中等待运行（除非你手动添加了追踪这个的代码），我们也没有现成的方法来在接收到低内存通告的时候来取消操作、这时候，切换到 NSOperations 可以使代码变得容易调试得多，并且允许我们在不添加手动管理的代码的情况下，做到对操作的追踪和取消。</p>

<p>当然也有一些不好的地方，比如你不能在你的 <code>NSOperationQueue</code> 中设置目标队列（就像 <code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code> 之于 缓速 I/O 那样）。但这只是为了可调试性的一点小代价，而事实上这也帮助你避免遇到<a href="http://objccn.io/issue-2-1/#priority_inversion">优先级反转</a>的问题。我甚至不推荐直接使用已经包装好的 <code>NSBlockOperation</code> 的 API，而是建议使用一个 NSOperation 的真正的子类，包括实现其 description。诚然，这样做工作量会大一些，但是能输出所有运行中/准备运行的操作是及其有用的。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[底层并发API]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/di-ceng-bing-fa-api/"/>
    <updated>2014-04-09T15:56:29+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2014/04/09/di-ceng-bing-fa-api</id>
    <content type="html"><![CDATA[<p>这篇文章里，我们将会讨论一些 iOS 和 OS X 都可以使用的底层 API。除了 <code>dispatch_once</code> ，我们一般不鼓励使用其中的任何一种技术。</p>

<p>但是我们想要揭示出表面之下深层次的一些可利用的方面。这些底层的 API 提供了大量的灵活性，随之而来的是大量的复杂度和更多的责任。在我们的文章<a href="http:/objccn.io/issue-2-2/">常见的后台实践</a>中提到的高层的 API 和模式能够让你专注于手头的任务并且免于大量的问题。通常来说，高层的 API 会提供更好的性能，除非你能承受起使用底层 API 带来的纠结于调试代码的时间和努力。</p>

<p>尽管如此，了解深层次下的软件堆栈工作原理还是有很有帮助的。我们希望这篇文章能够让你更好的了解这个平台，同时，让你更加感谢这些高层的 API。</p>

<p>首先，我们将会分析大多数组成 <em>Grand Central Dispatch</em> 的部分。它已经存在了好几年，并且苹果公司持续添加功能并且改善它。现在苹果已经将其开源，这意味着它对其他平台也是可用的了。最后，我们将会看一下<a href="#atomic_operations">原子操作</a>——另外的一种底层代码块的集合。</p>

<p>或许关于并发编程最好的书是 <em>M. Ben-Ari</em> 写的《Principles of Concurrent Programming》,<a href="https://en.wikipedia.org/wiki/Special:BookSources/0-13-701078-8">ISBN 0-13-701078-8</a>。如果你正在做任何与并发编程有关的事情，你需要读一下这本书。这本书已经30多年了，仍然非常卓越。书中简洁的写法，优秀的例子和练习，带你领略并发编程中代码块的基本原理。这本书现在已经绝版了，但是它的一些复印版依然广为流传。有一个新版书，名字叫《Principles of Concurrent and Distributed Programming》,<a href="https://en.wikipedia.org/wiki/Special:BookSources/0-321-31283-X">ISBN 0-321-31283-X</a>,好像有很多相同的地方，不过我还没有读过。</p>

<h2>从前...</h2>

<p>或许GCD中使用最多并且被滥用功能的就是 <code>dispatch_once</code> 了。正确的用法看起来是这样的：</p>
<p><code>objc
+ (UIColor *)boringColor;
{
    static UIColor *color;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        color = [UIColor colorWithRed:0.380f green:0.376f blue:0.376f alpha:1.000f];
    });
    return color;
}
</code></p>

<p>上面的 block 只会运行一次。并且在连续的调用中，这种检查是很高效的。你能使用它来初始化全局数据比如单例。要注意的是，使用 <code>dispatch_once_t</code> 会使得测试变得非常困难（单例和测试不是很好配合）。</p>

<p>要确保 <code>onceToken</code> 被声明为 <code>static</code> ，或者有全局作用域。任何其他的情况都会导致无法预知的行为。换句话说，<strong>不要</strong>把 <code>dispatch_once_t</code> 作为一个对象的成员变量，或者类似的情形。</p>

<p>退回到远古时代（其实也就是几年前），人们会使用 <code>pthread_once</code> ，因为 <code>dispatch_once_t</code> 更容易使用并且不易出错，所以你永远都不会再用到 <code>pthread_once</code> 了。</p>

<h2>延后执行</h2>

<p>另一个常见的小伙伴就是 <code>dispatch_after</code> 了。它使工作延后执行。它是很强大的，但是要注意：你很容易就陷入到一堆麻烦中。一般用法是这样的：</p>
<p><code>objc
- (void)foo
{
    double delayInSeconds = 2.0;
    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC));
    dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
        [self bar];
    });
}
</code></p>

<p>第一眼看上去这段代码是极好的。但是这里存在一些缺点。我们不能（直接）取消我们已经提交到 <code>dispatch_after</code> 的代码，它将会运行。</p>

<p>另外一个需要注意的事情就是，当人们使用 <code>dispatch_after</code> 去处理他们代码中存在的时序 bug 时，会存在一些有问题的倾向。一些代码执行的过早而你很可能不知道为什么会这样，所以你把这段代码放到了 <code>dispatch_after</code> 中，现在一切运行正常了。但是几周以后，之前的工作不起作用了。由于你并不十分清楚你自己代码的执行次序，调试代码就变成了一场噩梦。所以不要像上面这样做。大多数的情况下，你最好把代码放到正确的位置。如果代码放到 <code>-viewWillAppear</code> 太早，那么或许 <code>-viewDidAppear</code> 就是正确的地方。</p>

<p>通过在自己代码中建立直接调用（类似 <code>-viewDidAppear</code> ）而不是依赖于  <code>dispatch_after</code> ，你会为自己省去很多麻烦。</p>

<p>如果你需要一些事情在某个特定的时刻运行，那么 <code>dispatch_after</code> 或许会是个好的选择。确保同时考虑了 <code>NSTimer</code>，这个API虽然有点笨重，但是它允许你取消定时器的触发。</p>

<h2>队列</h2>

<p>GCD 中一个基本的代码块就是队列。下面我们会给出一些如何使用它的例子。当使用队列的时候，给它们一个明显的标签会帮自己不少忙。在调试时，这个标签会在 Xcode (和 lldb)中显示，这会帮助你了解你的 app 是由什么决定的：</p>

<p>```objc
- (id)init;
{
    self = [super init];
    if (self != nil) {
        NSString *label = [NSString stringWithFormat:@”%@.isolation.%p”, [self class], self];
        self.isolationQueue = dispatch_queue_create([label UTF8String], 0);</p>

<pre><code>    label = [NSString stringWithFormat:@"%@.work.%p", [self class], self];
    self.workQueue = dispatch_queue_create([label UTF8String], 0);
}
return self; } ```
</code></pre>

<p>队列可以是并行也可以是串行的。默认情况下，它们是串行的，也就是说，任何给定的时间内，只能有一个单独的 block 运行。这就是隔离队列（原文：isolation queues。译注）的运行方式。队列也可以是并行的，也就是同一时间内允许多个 block 一起执行。</p>

<p>GCD 队列的内部使用的是线程。GCD 管理这些线程，并且使用 GCD 的时候，你不需要自己创建线程。但是重要的外在部分 GCD 会呈现给你，也就是用户 API，一个很大不同的抽象层级。当使用 GCD 来完成并发的工作时，你不必考虑线程方面的问题，取而代之的，只需考虑队列和功能点（提交给队列的 block）。虽然往下深究，依然都是线程，但是 GCD 的抽象层级为你惯用的编码提供了更好的方式。</p>

<p>队列和功能点同时解决了一个连续不断的扇出的问题：如果我们直接使用线程，并且想要做一些并发的事情，我们很可能将我们的工作分成 100 个小的功能点，然后基于可用的 CPU 内核数量来创建线程，假设是 8。我们把这些功能点送到这 8 个线程中。当我们处理这些功能点时，可能会调用一些函数作为功能的一部分。写那个函数的人也想要使用并发，因此当你调用这个函数的时候，这个函数也会创建 8 个线程。现在，你有了 8 × 8 = 64 个线程，尽管你只有 8 个CPU内核——也就是说任何时候只有12%的线程实际在运行而另外88%的线程什么事情都没做。使用 GCD 你就不会遇到这种问题，当系统关闭 CPU 内核以省电时，GCD 甚至能够相应地调整线程数量。</p>

<p>GCD 通过创建所谓的<a href="http://en.wikipedia.org/wiki/Thread_pool_pattern">线程池</a>来大致匹配 CPU 内核数量。要记住，线程的创建并不是无代价的。每个线程都需要占用内存和内核资源。这里也有一个问题：如果你提交了一个 block 给 GCD，但是这段代码阻塞了这个线程，那么这个线程在这段时间内就不能用来完成其他工作——它被阻塞了。为了确保功能点在队列上一直是执行的，GCD 不得不创建一个新的线程，并把它添加到线程池。</p>

<p>如果你的代码阻塞了许多线程，这会带来很大的问题。首先，线程消耗资源，此外，创建线程会变得代价高昂。创建过程需要一些时间。并且在这段时间中，GCD 无法以全速来完成功能点。有不少能够导致线程阻塞的情况，但是最常见的情况与 I/O 有关，也就是从文件或者网络中读写数据。正是因为这些原因，你不应该在GCD队列中以阻塞的方式来做这些操作。看一下下面的<a href="#input_output">输入输出</a>段落去了解一些关于如何以 GCD 运行良好的方式来做 I/O 操作的信息。</p>

<h3>目标队列</h3>

<p>你能够为你创建的任何一个队列设置一个<strong>目标队列</strong>。这会是很强大的，并且有助于调试。</p>

<p>为一个类创建它自己的队列而不是使用全局的队列被普遍认为是一种好的风格。这种方式下，你可以设置队列的名字，这让调试变得轻松许多—— Xcode 可以让你在 Debug Navigator 中看到所有的队列名字，如果你直接使用 <code>lldb</code>。<code>(lldb) thread list</code> 命令将会在控制台打印出所有队列的名字。一旦你使用大量的异步内容，这会是非常有用的帮助。</p>

<p>使用私有队列同样强调封装性。这时你自己的队列，你要自己决定如何使用它。</p>

<p>默认情况下，一个新创建的队列转发到默认优先级的全局队列中。我们就将会讨论一些有关优先级的东西。</p>

<p>你可以改变你队列转发到的队列——你可以设置自己队列的目标队列。以这种方式，你可以将不同队列链接在一起。你的 <code>Foo</code> 类有一个队列，该队列转发到 <code>Bar</code> 类的队列，<code>Bar</code> 类的队列又转发到全局队列。</p>

<p>当你为了隔离目的而使用一个队列时，这会非常有用。<code>Foo</code> 有一个隔离队列，并且转发到 <code>Bar</code> 的隔离队列，与 <code>Bar</code> 的隔离队列所保护的有关的资源，会自动成为线程安全的。 </p>

<p>如果你希望多个 block 同时运行，那要确保你自己的队列是并发的。同时需要注意，如果一个队列的目标队列是串行的（也就是非并发），那么实际上这个队列也会转换为一个串行队列。</p>

<h3>优先级</h3>

<p>你可以通过设置目标队列为一个全局队列来改变自己队列的优先级，但是你应该克制这么做的冲动。</p>

<p>在大多数情况下，改变优先级不会使事情照你预想的方向运行。一些看起简单的事情实际上是一个非常复杂的问题。你很容易会碰到一个叫做<a href="http://en.wikipedia.org/wiki/Priority_inversion">优先级反转</a>的情况。我们的文章<a href="http://www.objc.io/issue-2/concurrency-apis-and-pitfalls.html#priority_inversion">《Concurrent Programming: APIs and Challenges》</a>（译注：参见objccn的译文<a href="http://objccn.io/issue-2-1">《并发编程：API 及挑战》</a>）有更多关于这个问题的信息，这个问题几乎导致了NASA的探路者火星漫游器变成砖头。</p>

<p>此外，使用 <code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code> 队列时，你需要格外小心。除非你理解了 <em>throttled I/O</em> 和 <em>background status as per setpriority(2)</em> 的意义，否则不要使用它。不然，系统可能会以难以忍受的方式终止你的 app 的运行。打算以不干扰系统其他正在做 I/O 操作的方式去做 I/O 操作时，一旦和优先级反转情况结合起来，这会变成一种危险的情况。</p>

<h2>隔离</h2>

<p>隔离队列是 GCD 队列使用中非常普遍的一种模式。这里有两个变种。</p>

<h3>资源保护</h3>

<p>多线程编程中，最常见的情形是你有一个资源，每次只有一个线程被允许访问这个资源。</p>

<p>我们在<a href="http://www.objc.io/issue-2/concurrency-apis-and-pitfalls.html#shared_resources">有关多线程技术的文章</a>（译注：参见 objccn <a href="http://objccn.io/issue-2-1">译文</a>）中讨论了<em>资源</em>在并发编程中意味着什么，它通常就是一块内存或者一个对象，每次只有一个线程可以访问它。</p>

<p>举例来说，我们需要以多线程（或者多个队列）方式访问 <code>NSMutableDictionary</code> 。我们可能会照下面的代码来做：</p>

<p>```objc
- (void)setCount:(NSUInteger)count forKey:(NSString *)key
{
    key = [key copy];
    dispatch_async(self.isolationQueue, ^(){
        if (count == 0) {
            [self.counts removeObjectForKey:key];
        } else {
            self.counts[key] = @(count);
        }
    });
}</p>

<ul>
  <li>(NSUInteger)countForKey:(NSString *)key;
{
  __block NSUInteger count;
  dispatch_sync(self.isolationQueue, ^(){
      NSNumber *n = self.counts[key];
      count = [n unsignedIntegerValue];
  });
  return count;
}
```</li>
</ul>

<p>通过以上代码，只有一个线程可以访问 <code>NSMutableDictionary</code> 的实例。</p>

<p>注意以下四点：</p>

<ol>
<li>不要使用上面的代码，请先阅读<a href="#multiple_readers_single_writer">多读单写</a>和<a href="#contention">锁竞争</a>  </li>
<li>我们使用 <code>async</code> 方式来保存值，这很重要。我们不想也不必阻塞当前线程只是为了等待<em>写操作</em>完成。当读操作时，我们使用 <code>sync</code> 因为我们需要返回值。  </li>
<li>从函数接口可以看出，<code>-setCount:forKey:</code> 需要一个 <code>NSString</code> 参数，用来传递给 <code>dispatch_async</code>。函数调用者可以自由传递一个 <code>NSMutableString</code> 值并且能够在函数返回后修改它。因此我们<em>必须</em>对传入的字符串使用 <em>copy</em> 操作以确保函数能够正确地工作。如果传入的字符串不是可变的（也就是正常的 <code>NSString</code> 类型），调用<em>copy</em>基本上是个空操作。  </li>
<li><code>isolationQueue</code> 创建时，参数 <code>dispatch_queue_attr_t</code> 的值必须是<em>DISPATCH_QUEUE_SERIAL</em>（或者0）。</li>
</ol>

<p><a id="multiple_readers_single_writer" name="multiple_readers_single_writer"> </a>  </p>

<h3>单一资源的多读单写</h3>

<p>我们能够改善上面的那个例子。GCD 有可以让多线程运行的并发队列。我们能够安全地使用多线程来从 <code>NSMutableDictionary</code> 中读取只要我们不同时修改它。当我们需要改变这个字典时，我们使用 <em>barrier</em> 来分发这个 block。这样的一个 block 的运行时机是，在它之前所有计划好的 block 完成之后，并且在所有它后面的 block 运行之前。</p>

<p>以如下方式创建队列：</p>

<p><code>objc
self.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT);
</code></p>

<p>并且用以下代码来改变setter函数：</p>

<p><code>objc
- (void)setCount:(NSUInteger)count forKey:(NSString *)key
{
    key = [key copy];
    dispatch_barrier_async(self.isolationQueue, ^(){
        if (count == 0) {
            [self.counts removeObjectForKey:key];
        } else {
            self.counts[key] = @(count);
        }
    });
}
</code></p>

<p>当使用并发队列时，要确保所有的 <em>barrier</em> 调用都是 <em>async</em> 的。如果你使用 <code>dispatch_barrier_sync</code> ，那么你很可能会使你自己（更确切的说是，你的代码）产生死锁。写操作<em>需要</em>  barrier，并且<em>可以</em>是 async 的。</p>

<p><a id="contention" name="contention"> </a>  </p>

<h3>锁竞争</h3>

<p>首先，这里有一个警告：上面这个例子中我们保护的资源是一个  <code>NSMutableDictionary</code>，出于这样的目的，这段代码运行地相当不错。但是在真实的代码中，把隔离放到正确的复杂度层级下是很重要的。</p>

<p>如果你对 <code>NSMutableDictionary</code> 的访问操作变得非常频繁，你会碰到一个已知的叫做锁竞争的问题。锁竞争并不是只是在 GCD 和队列下才变得特殊，任何使用了锁机制的程序都会碰到同样的问题——只不过不同的锁机制会以不同的方式碰到。</p>

<p>所有对  <code>dispatch_async</code>，<code>dispatch_sync</code> 等等的调用都需要完成某种形式的锁——以确保仅有一个线程或者特定的线程运行指定的代码。GCD 某些程序上可以使用时序(译注：原词为 scheduling)来避免使用锁，但在最后，问题只是稍有变化。根本问题仍然存在：如果你有<strong>大量</strong>的线程在相同时间去访问同一个锁或者队列，你就会看到性能的变化。性能会严重下降。</p>

<p>你应该从直接复杂层次中隔离开。当你发现了性能下降，这明显表明代码中存在设计问题。这里有两个开销需要你来平衡。第一个是独占临界区资源太久的开销，以至于别的线程都因为进入临界区的操作而阻塞。第二个是太频繁出入临界区的开销。在 GCD 的世界里，第一种开销的情况就是一个 block 在隔离队列中运行，它可能潜在的阻塞了其他将要在这个隔离队列中运行的代码。第二种开销对应的就是调用 <code>dispatch_async</code> 和 <code>dispatch_sync</code> 。无论再怎么优化，这两个操作都不是无代价的。</p>

<p>令人忧伤的，不存在通用的标准来指导如何正确的平衡，你需要自己评测和调整。启动 Instruments 观察你的 app 忙于什么操作。</p>

<p>如果你看上面例子中的代码，我们的临界区代码仅仅做了很简单的事情。这可能是也可能不是好的方式，依赖于它怎么被使用。</p>

<p>在你自己的代码中，要考虑自己是否在更高的层次保护了隔离队列。举个例子，类 <code>Foo</code> 有一个隔离队列并且它本身保护着对 <code>NSMutableDictionary</code> 的访问，代替的，可以有一个用到了 <code>Foo</code> 类的 <code>Bar</code> 类有一个隔离队列保护所有对类 <code>Foo</code> 的使用。换句话说，你可以把类 <code>Foo</code> 变为非线程安全的（没有隔离队列），并在 <code>Bar</code> 中，使用一个隔离队列来确保任何时刻只能有一个线程使用 <code>Foo</code> 。</p>

<p><a name="async" id="async"> </a>  </p>

<h3>全都使用异步分发</h3>

<p>我们在这稍稍转变以下话题。正如你在上面看到的，你可以同步和异步地分发一个  block，一个工作单元。我们在[《article about concurrency APIs and pitfalls》[http://www.objc.io/issue-2/concurrency-apis-and-pitfalls.html#dead_locks]（译注：参见 objccn 的<a href="http://objccn.io/issue-2-1">译文</a>）中讨论的一个非常普遍的问题就是死锁。在 GCD 中，以同步分发的方式非常容易出现这种情况。见下面的代码：</p>

<p><code>objc
dispatch_queue_t queueA; // assume we have this
dispatch_sync(queueA, ^(){
    dispatch_sync(queueA, ^(){
        foo();
    });
});
</code></p>

<p>一旦我们进入到第二个 <code>dispatch_sync</code> 就会发生死锁。我们不能分发到queueA，因为有人（当前线程）正在队列中并且永远不会离开。但是有更隐晦的产生死锁方式：</p>

<p>```objc
dispatch_queue_t queueA; // assume we have this
dispatch_queue_t queueB; // assume we have this</p>

<p>dispatch_sync(queueA, ^(){
    foo();
});</p>

<p>void foo(void)
{
    dispatch_sync(queueB, ^(){
        bar();
    });
}</p>

<p>void bar(void)
{
    dispatch_sync(queueA, ^(){
        baz();
    });
}
```</p>

<p>单独的每次调用 <code>dispatch_sync()</code> 看起来都没有问题，但是一旦组合起来，就会发生死锁。</p>

<p>这是使用同步分发存在的固有问题，如果我们使用异步分发，比如：</p>

<p><code>objc
dispatch_queue_t queueA; // assume we have this
dispatch_async(queueA, ^(){
    dispatch_async(queueA, ^(){
        foo();
    });
});
</code></p>

<p>一切运行正常。<em>异步调用不会产生死锁</em>。因此值得我们在任何可能的时候都使用异步分发。我们使用一个异步调用结果 block 的函数，来代替编写一个返回值（必须要用同步）的方法或者函数。这种方式，我们会有更少发生死锁的可能性。</p>

<p>异步调用的副作用就是它们很难调试。当我们在调试器里中止代码运行，回溯并查看已经变得没有意义了。</p>

<p>要牢记这些。死锁通常是最难处理的问题。</p>

<h3 id="api">如何写出好的异步 API</h3>

<p>如果你正在给设计一个给别人（或者是给自己）使用的 API，你需要记住几种好的实践。</p>

<p>正如我们刚刚提到的，你需要倾向于异步 API。当你创建一个 API，它会在你的控制之外以各种方式调用，如果你的代码能产生死锁，那么死锁就会发生。</p>

<p>如果你需要写的函数或者方法，那么让它们调用 <code>dispatch_async()</code> 。不要让你的函数调用者来这么做，这个调用应该在你的方法或者函数中来做。</p>

<p>如果你的方法或函数有一个返回值，异步地将其传递给一个回调处理程序。这个 API 应该是这样的，你的方法或函数同时持有一个结果 block 和一个将结果传递过去的队列。你函数的调用者不需要自己来做分发。这么做的原因很简单：几乎所有时间，函数调用都应该在一个适当的队列中，而且以这种方式编写的代码是很容易阅读的。总之，你的函数将会（必须）调用 <code>dispatch_async()</code> 去运行回调处理程序，所以它同时也可能在需要调用的队列上做这些工作。</p>

<p>如果你写一个类，让你类的使用者设置一个回调处理队列或许会是一个好的选择。你的代码可能像这样：</p>

<p><code>objc
- (void)processImage:(UIImage *)image completionHandler:(void(^)(BOOL success))handler;
{
    dispatch_async(self.isolationQueue, ^(void){
        // do actual processing here
        dispatch_async(self.resultQueue, ^(void){
            handler(YES);
        });
    });
}
</code></p>

<p>如果你以这种方式来写你的类，让类之间协同工作就会变得容易。如果类 A 使用了类 B，它会把自己的隔离队列设置为 B 的回调队列。</p>

<h2>迭代执行</h2>

<p>如果你正在倒弄一些数字，并且手头上的问题可以拆分出同样性质的部分，那么 <code>dispatch_apply</code> 会很有用。</p>

<p>如果你的代码看起来是这样的：</p>

<p><code>objc
for (size_t y = 0; y &amp;lt; height; ++y) {
    for (size_t x = 0; x &amp;lt; width; ++x) {
        // Do something with x and y here
    }
}
</code></p>

<p>小小的改动或许就可以让它运行的更快：</p>

<p><code>objc
dispatch_apply(height, dispatch_get_global_queue(0, 0), ^(size_t y) {
    for (size_t x = 0; x &amp;lt; width; x += 2) {
        // Do something with x and y here
    }
});
</code></p>

<p>代码运行良好的程度取决于你在循环内部做的操作。</p>

<p>block 中运行的工作必须是非常重要的，否则这个头部信息就显得过于繁重了。除非代码受到计算带宽的约束，每个工作单元为了很好适应缓存大小而读写的内存都是临界的。这会对性能会带来显著的影响。受到临界区约束的代码可能不会很好地运行。详细讨论这些问题已经超出了这篇文章的范围。使用 <code>dispatch_apply</code> 可能会对性能提升有所帮助，但是性能优化本身就是个很复杂的主题。维基百科上有一篇关于 <a href="https://en.wikipedia.org/wiki/Memory_bound">Memory-bound function</a> 的文章。内存访问速度在 L2，L3 和主存上变化很显著。当你的数据访问模式与缓存大小不匹配时，10倍性能下降的情况并不少见。</p>

<h2>组</h2>

<p>很多时候，你发现需要将异步的 block 组合起来去完成一个给定的任务。这些任务中甚至有些是并行的。现在，如果你想要在这些任务都执行完成后运行一些代码，"groups" 可以完成这项任务。看这里的例子：</p>

<p>```objc
dispatch_group_t group = dispatch_group_create();</p>

<p>dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
dispatch_group_async(group, queue, ^(){
    // Do something that takes a while
    [self doSomeFoo];
    dispatch_group_async(group, dispatch_get_main_queue(), ^(){
        self.foo = 42;
    });
});
dispatch_group_async(group, queue, ^(){
    // Do something else that takes a while
    [self doSomeBar];
    dispatch_group_async(group, dispatch_get_main_queue(), ^(){
        self.bar = 1;
    });
});</p>

<p>// This block will run once everything above is done:
dispatch_group_notify(group, dispatch_get_main_queue(), ^(){
    NSLog(@”foo: %d”, self.foo);
    NSLog(@”bar: %d”, self.bar);
});
```</p>

<p>需要注意的重要事情是，所有的这些都是非阻塞的。我们从未让当前的线程一直等待直到别的任务做完。恰恰相反，我们只是简单的将多个 block 放入队列。由于代码不会阻塞，所以就不会产生死锁。</p>

<p>同时需要注意的是，在这个小并且简单的例子中，我们是怎么在不同的队列间进切换的。</p>

<h3 id="apidispatch_group_t">对现有API使用 dispatch<em>group</em>t</h3>

<p>一旦你将  groups 作为你的工具箱中的一部分，你可能会怀疑为什么大多数的异步API不把 <code>dispatch_group_t</code> 作为一个可选参数。这没有什么无法接受的理由，仅仅是因为自己添加这个功能太简单了，但是你还是要小心以确保自己使用 groups 的代码是成对出现的。</p>

<p>举例来说，我们可以给 Core Data 的 <code>-performBlock:</code> API 函数添加上 groups，就像这样：</p>

<p><code>objc
- (void)withGroup:(dispatch_group_t)group performBlock:(dispatch_block_t)block
{
    if (group == NULL) {
        [self performBlock:block];
    } else {
        dispatch_group_enter(group);
        [self performBlock:^(){
            block();
            dispatch_group_leave(group);
        }];
    }
}
</code></p>

<p>当 Core Data 上的一系列操作(很可能和其他的代码组合起来)完成以后，我们可以使用 <code>dispatch_group_notify</code> 来运行一个 block 。</p>

<p>很明显，我们可以给 <code>NSURLConnection</code> 做同样的事情：</p>

<p><code>objc
+ (void)withGroup:(dispatch_group_t)group 
        sendAsynchronousRequest:(NSURLRequest *)request 
        queue:(NSOperationQueue *)queue 
        completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler
{
    if (group == NULL) {
        [self sendAsynchronousRequest:request 
                                queue:queue 
                    completionHandler:handler];
    } else {
        dispatch_group_enter(group);
        [self sendAsynchronousRequest:request 
                                queue:queue 
                    completionHandler:^(NSURLResponse *response, NSData *data, NSError *error){
            handler(response, data, error);
            dispatch_group_leave(group);
        }];
    }
}
</code></p>

<p>为了能正常工作，你需要确保:</p>

<ul>
<li><code>dispatch_group_enter()</code> 必须要在 <code>dispatch_group_leave()</code>之前运行。</li>
<li><code>dispatch_group_enter()</code> 和 <code>dispatch_group_leave()</code> 一直是成对出现的（就算有错误产生时）。</li>
</ul>

<h2>事件源</h2>

<p>GCD 有一个较少人知道的特性：事件源 <code>dispatch_source_t</code>。</p>

<p>跟 GCD 一样，它也是很底层的东西。当你需要用到它时，它会变得极其有用。它的一些使用是秘传招数，我们将会接触到一部分的使用。但是大部分事件源在 iOS 平台不是很有用，因为在 iOS 平台有诸多限制，你无法启动进程（因此就没有必要监视进程），也不能在你的 app bundle 之外写数据（因此也就没有必要去监视文件）等等。</p>

<p>GCD 事件源是以极其资源高效的方式实现的。</p>

<h3>监视进程</h3>

<p>如果一些进程正在运行而你想知道他们什么时候存在，GCD 能够做到这些。你也可以使用 GCD 来检测进程什么时候分叉，也就是产生子进程或者传送给了进程的一个信号（比如 <code>SIGTERM</code>）。</p>

<p><code>objc
NSRunningApplication *mail = [NSRunningApplication 
  runningApplicationsWithBundleIdentifier:@"com.apple.mail"];
if (mail == nil) {
    return;
}
pid_t const pid = mail.processIdentifier;
self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid, 
  DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT);
dispatch_source_set_event_handler(self.source, ^(){
    NSLog(@"Mail quit.");
});
dispatch_resume(self.source);
</code></p>

<p>当 Mail.app 退出的时候，这个程序会打印出 <strong>Mail quit.</strong>。</p>

<p>注意：在所有的事件源被传递到你的事件处理器之前，必须调用 <code>dispatch_resume()</code>。</p>

<p><a name="watching_files" id="watching_files"> </a>  </p>

<h3>监视文件</h3>

<p>这种可能性是无穷的。你能直接监视一个文件的改变，并且当改变发生时事件源的事件处理将会被调用。</p>

<p>你也可以使用它来监视文件夹，比如创建一个 <em>watch folder</em>：</p>

<p><code>objc
NSURL *directoryURL; // assume this is set to a directory
int const fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);
if (fd &amp;lt; 0) {
    char buffer[80];
    strerror_r(errno, buffer, sizeof(buffer));
    NSLog(@"Unable to open \"%@\": %s (%d)", [directoryURL path], buffer, errno);
    return;
}
dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd, 
  DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);
dispatch_source_set_event_handler(source, ^(){
    unsigned long const data = dispatch_source_get_data(source);
    if (data &amp;amp; DISPATCH_VNODE_WRITE) {
        NSLog(@"The directory changed.");
    }
    if (data &amp;amp; DISPATCH_VNODE_DELETE) {
        NSLog(@"The directory has been deleted.");
    }
});
dispatch_source_set_cancel_handler(source, ^(){
    close(fd);
});
self.source = source;
dispatch_resume(self.source);
</code></p>

<p>你应该总是添加 <code>DISPATCH_VNODE_DELETE</code> 去检测文件或者文件夹是否已经被删除——然后就停止监听。</p>

<h3>定时器</h3>

<p>大多数情况下，对于定时事件你会选择 <code>NSTimer</code>。定时器的GCD版本是底层的，它会给你更多控制权——但要小心使用。</p>

<p>需要特别重点指出的是，为了让 OS 节省电量，需要为 GCD 的定时器接口指定一个低的余地值(译注：原文leeway value)。如果你不必要的指定了一个低余地值，将会浪费更多的电量。</p>

<p>这里我们设定了一个5秒的定时器，并允许有十分之一秒的余地值：</p>

<p><code>objc
dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 
  0, 0, DISPATCH_TARGET_QUEUE_DEFAULT);
dispatch_source_set_event_handler(source, ^(){
    NSLog(@"Time flies.");
});
dispatch_time_t start
dispatch_source_set_timer(source, DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC, 
  100ull * NSEC_PER_MSEC);
self.source = source;
dispatch_resume(self.source);
</code></p>

<h3>取消</h3>

<p>所有的事件源都允许你添加一个 <em>cancel handler</em> 。这对清理你为事件源创建的任何资源都是很有帮助的，比如关闭文件描述符。GCD 保证在 <em>cancel handle</em>  调用前，所有的事件处理都已经完成调用。</p>

<p>参考上面的<a href="#watching_files">监视文件例子</a>中对 <code>dispatch_source_set_cancel_handler()</code> 的使用。</p>

<p><a id="input_output" name="input_output"> </a>  </p>

<h2>输入输出</h2>

<p>写出能够在繁重的 I/O 处理情况下运行良好的代码是一件非常棘手的事情。GCD 有一些能够帮上忙的地方。不会涉及太多的细节，我们只简单的分析下问题是什么，GCD 是怎么处理的。</p>

<p>习惯上，当你从一个网络套接字中读取数据时，你要么做一个阻塞的读操作，也就是让你个线程一直等待直到数据变得可用，或者是做反复的轮询。这两种方法都是很浪费资源并且无法度量。然而，<code>kqueue</code> 通过当数据变得可用时传递一个事件解决了轮询的问题，GCD 也采用了同样的方法，但是更加优雅。当向套接字写数据时，同样的问题也存在，这时你要么做阻塞的写操作，要么等待套接字直到能够接收数据。</p>

<p>在处理 I/O 时，还有一个问题就是数据是以数据块的形式到达的。当从网络中读取数据时，依据 MTU([]最大传输单元](https://en.wikipedia.org/wiki/Maximum<em>transmission</em>unit))，数据块典型的大小是在1.5K字节左右。这使得数据块内可以是任何内容。一旦数据到达，你通常只是对跨多个数据块的内容感兴趣。而且通常你会在一个大的缓冲区里将数据组合起来然后再进行处理。假设（人为例子）你收到了这样8个数据块：</p>

<pre><code>0: HTTP/1.1 200 OK\r\nDate: Mon, 23 May 2005 22:38
1: :34 GMT\r\nServer: Apache/1.3.3.7 (Unix) (Red-H
2: at/Linux)\r\nLast-Modified: Wed, 08 Jan 2003 23
3: :11:55 GMT\r\nEtag: "3f80f-1b6-3e1cb03b"\r\nCon
4: tent-Type: text/html; charset=UTF-8\r\nContent-
5: Length: 131\r\nConnection: close\r\n\r\n&lt;html&gt;\r
6: \n&lt;head&gt;\r\n  &lt;title&gt;An Example Page&lt;/title&gt;\r\n
7: &lt;/head&gt;\r\n&lt;body&gt;\r\n  Hello World, this is a ve
</code></pre>

<p>如果你是在寻找 HTTP 的头部，将所有数据块组合成一个大的缓冲区并且从中查找 <code>\r\n\r\n</code> 是非常简单的。但是这样做，你会大量地复制这些数据。大量 <em>旧的</em> C 语言 API 存在的另一个问题就是，缓冲区没有所有权的概念，所以函数不得不将数据再次拷贝到自己的缓冲区中——又一次的拷贝。拷贝数据操作看起来是无关紧要的，但是当你正在做大量的 I/O 操作的时候，你会在 profiling tool(Instruments) 中看到这些拷贝操作大量出现。即使你仅仅每个内存区域拷贝一次，你还是使用了两倍的存储带宽并且占用了两倍的内存缓存。</p>

<h3 id="gcd">GCD 和缓冲区</h3>

<p>最直接了当的方法是使用数据缓冲区。GCD 有一个 <code>dispatch_data_t</code> 类型，在某种程度上和 Objective-C 的 <code>NSData</code> 类型很相似。但是它能做别的事情，而且更通用。</p>

<p>注意，<code>dispatch_data_t</code> 可以被 retained 和 releaseed ，并且 <code>dispatch_data_t</code> <em>拥有</em>它持有的对象。</p>

<p>这看起来无关紧要，但是我们必须记住 GCD 只是纯 C 的 API，并且不能使用Objective-C。通常的做法是创建一个缓冲区，这个缓冲区要么是基于栈的，要么是  <code>malloc</code> 操作分配的内存区域 —— 这些都没有所有权。</p>

<p><code>dispatch_data_t</code> 的一个相当独特的属性是它可以基于零碎的内存区域。这解决了我们刚提到的组合内存的问题。当你要将两个数据对象连接起来时：</p>

<p><code>objc
dispatch_data_t a; // Assume this hold some valid data
dispatch_data_t b; // Assume this hold some valid data
dispatch_data_t c = dispatch_data_create_concat(a, b);
</code></p>

<p>数据对象 c 并不会将 a 和 b 拷贝到一个单独的，更大的内存区域里去。相反，它只是简单地 retain 了 a 和 b。你可以使用 <code>dispatch_data_apply</code> 来遍历对象 c 持有的内存区域：</p>

<p><code>objc
dispatch_data_apply(c, ^(dispatch_data_t region, size_t offset, const void *buffer, size_t size) {
    fprintf(stderr, "region with offset %zu, size %zu\n", offset, size);
    return true;
});
</code></p>

<p>类似的，你可以使用 <code>dispatch_data_create_subrange</code> 来创建一个不做任何拷贝操作的子区域。</p>

<h3>读和写</h3>

<p>在 GCD 的核心里，<em>调度 I/O</em>（译注：原文为 Dispatch I/O） 与所谓的<em>通道</em>有关。调度 I/O 通道提供了一种与从文件描述符中读写不同的方式。创建这样一个通道最基本的方式就是调用：</p>

<p><code>objc
dispatch_io_t dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd, 
  dispatch_queue_t queue, void (^cleanup_handler)(int error));
</code></p>

<p>这将返回一个持有文件描述符的创建好的通道。在你通过它创建了通道之后，你不准以任何方式修改这个文件描述符。</p>

<p>有两种从根本上不同类型的通道：流和随机存取。如果你打开了硬盘上的一个文件，你可以使用它来创建一个随机存取的通道（因为这样的文件描述符是可寻址的）。如果你打开了一个套接字，你可以创建一个流通道。</p>

<p>如果你想要为一个文件创建一个通道，你最好使用需要一个路径参数的 <code>dispatch_io_create_with_path</code> ，并且让 GCD 来打开这个文件。这是有益的，因为GCD会延迟打开这个文件以限制相同时间内同时打开的文件数量。</p>

<p>类似通常的 read(2)，write(2) 和 close(2) 的操作，GCD 提供了 <code>dispatch_io_read</code>，<code>dispatch_io_write</code> 和 <code>dispatch_io_close</code>。无论何时数据读完或者写完，读写操作调用一个回调 block 来结束。这些都是以非阻塞，异步 I/O 的形式高效实现的。</p>

<p>在这你得不到所有的细节，但是这里会提供一个创建TCP服务端的例子：</p>

<p>首先我们创建一个监听套接字，并且设置一个接受连接的事件源：</p>

<p>```objc
_isolation = dispatch_queue_create([[self description] UTF8String], 0);
_nativeSocket = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);
struct sockaddr_in sin = {};
sin.sin_len = sizeof(sin);
sin.sin_family = AF_INET6;
sin.sin_port = htons(port);
sin.sin_addr.s_addr= INADDR_ANY;
int err = bind(result.nativeSocket, (struct sockaddr *) &amp;sin, sizeof(sin));
NSCAssert(0 &lt;= err, @””);</p>

<p>_eventSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, _nativeSocket, 0, _isolation);
dispatch_source_set_event_handler(result.eventSource, ^{
    acceptConnection(_nativeSocket);
});
```</p>

<p>当接受了连接，我们创建一个I/O通道：</p>

<p>```objc
typedef union socketAddress {
    struct sockaddr sa;
    struct sockaddr_in sin;
    struct sockaddr_in6 sin6;
} socketAddressUnion;</p>

<p>socketAddressUnion rsa; // remote socket address
socklen_t len = sizeof(rsa);
int native = accept(nativeSocket, &amp;rsa.sa, &amp;len);
if (native == -1) {
    // Error. Ignore.
    return nil;
}</p>

<p>_remoteAddress = rsa;
_isolation = dispatch_queue_create([[self description] UTF8String], 0);
_channel = dispatch_io_create(DISPATCH_IO_STREAM, native, _isolation, ^(int error) {
    NSLog(@”An error occured while listening on socket: %d”, error);
});</p>

<p>//dispatch_io_set_high_water(_channel, 8 * 1024);
dispatch_io_set_low_water(_channel, 1);
dispatch_io_set_interval(_channel, NSEC_PER_MSEC * 10, DISPATCH_IO_STRICT_INTERVAL);</p>

<p>socketAddressUnion lsa; // remote socket address
socklen_t len = sizeof(rsa);
getsockname(native, &amp;lsa.sa, &amp;len);
_localAddress = lsa;
```</p>

<p>如果我们想要设置 <code>SO_KEEPALIVE</code>（如果使用了HTTP的keep-alive），我们需要在调用 <code>dispatch_io_create</code> 前这么做。</p>

<p>创建好 I/O 通道后，我们可以设置读取处理程序：</p>

<p><code>objc
dispatch_io_read(_channel, 0, SIZE_MAX, _isolation, ^(bool done, dispatch_data_t data, int error){
    if (data != NULL) {
        if (_data == NULL) {
            _data = data;
        } else {
            _data = dispatch_data_create_concat(_data, data);
        }
        [self processData];
    }
});
</code></p>

<p>如果所有你想做的只是读取或者写入一个文件，GCD 提供了两个方便的封装： <code>dispatch_read</code> 和 <code>dispatch_write</code> 。你需要传递给 <code>dispatch_read</code> 一个文件路径和一个在所有数据块读取后调用的 block。类似的，<code>dispatch_write</code> 需要一个文件路径和一个被写入的 <code>dispatch_data_t</code> 对象。</p>

<h2>基准测试</h2>

<p>在 GCD 的一个不起眼的角落，你会发现一个适合优化代码的灵巧小工具：</p>

<p><code>objc
uint64_t dispatch_benchmark(size_t count, void (^block)(void));
</code></p>

<p>把这个声明放到你的代码中，你就能够测量给定的代码执行的平均的纳秒数。例子如下：</p>

<p><code>objc
size_t const objectCount = 1000;
uint64_t n = dispatch_benchmark(10000, ^{
    @autoreleasepool {
        id obj = @42;
        NSMutableArray *array = [NSMutableArray array];
        for (size_t i = 0; i &amp;lt; objectCount; ++i) {
            [array addObject:obj];
        }
    }
});
NSLog(@"-[NSMutableArray addObject:] : %llu ns", n);
</code></p>

<p>在我的机器上输出了：</p>

<p><code>objc
-[NSMutableArray addObject:] : 31803 ns
</code></p>

<p>也就是说添加1000个对象到 NSMutableArray 总共消耗了31803纳秒，或者说平均一个对象消耗32纳秒。</p>

<p>正如 <code>dispatch_benchmark</code> 的<a href="http://opensource.apple.com/source/libdispatch/libdispatch-84.5/man/dispatch_benchmark.3">帮助页面</a>指出的，测量性能并非如看起来那样不重要。尤其是当比较并发代码和非并发代码时，你需要注意特定硬件上运行的特定计算带宽和内存带宽。不同的机器会很不一样。如果代码的性能与访问临界区有关，那么我们上面提到的锁竞争问题就会有所影响。</p>

<p>不要把它放到发布代码中，事实上，这是无意义的，它是私有API。它只是在调试和性能分析上起作用。</p>

<p>访问帮助界面：</p>

<pre><code>curl "http://opensource.apple.com/source/libdispatch/libdispatch-84.5/man/dispatch_benchmark.3?txt" 
  | /usr/bin/groffer --tty -T utf8
</code></pre>

<p><a id="atomic_operations" name="atomic_operations"> </a>  </p>

<h2>原子操作</h2>

<p>头文件 <code>libkern/OSAtomic.h</code> 里有许多强大的函数，专门用来底层多线程编程。尽管它是内核头文件的一部分，它也能够在内核之外来帮助编程。</p>

<p>这些函数都是很底层的，并且你需要知道一些额外的事情。就算你已经这样做了，你还可能会发现一两件你不能做，或者不易做的事情。当你正在为编写高性能代码或者正在实现无锁的和无等待的算法工作时，这些函数会吸引你。</p>

<p>这些函数在 <code>atomic(3)</code> 的帮助页里全部有概述——运行 <code>man 3 atomic</code> 命令以得到完整的文档。你会发现里面讨论到了内存屏障。查看维基百科中关于<a href="https://en.wikipedia.org/wiki/Memory_barrier">内存屏障</a>的文章。如果你还存在疑问，那么你很可能需要它。</p>

<h3>计数器</h3>

<p><code>OSAtomicIncrement</code> 和 <code>OSAtomicDecrement</code> 有一个很长的函数列表允许你以原子操作的方式去增加和减少一个整数值 —— 不必使用锁（或者队列）同时也是线程安全的。如果你需要让一个全局的计数器值增加，而这个计数器为了统计目的而由多个线程操作，使用原子操作是很有帮助的。如果你要做的仅仅是增加一个全局计数器，那么无屏障版本的 <code>OSAtomicIncrement</code> 是很合适的，并且当没有锁竞争时，调用它们的代价很小。</p>

<p>类似的，<code>OSAtomicOr</code> ，<code>OSAtomicAnd</code>，<code>OSAtomicXor</code> 的函数能用来进行逻辑运算，而 <code>OSAtomicTest</code> 可以用来设置和清除位。</p>

<h4 id="102">10.2、比较和交换</h4>

<p><code>OSAtomicCompareAndSwap</code> 能用来做无锁的惰性初始化，如下：</p>

<p><code>objc
void * sharedBuffer(void)
{
    static void * buffer;
    if (buffer == NULL) {
        void * newBuffer = calloc(1, 1024);
        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, newBuffer, &amp;amp;buffer)) {
            free(newBuffer);
        }
    }
    return buffer;
}
</code></p>

<p>如果没有 buffer，我们会创建一个，然后原子地将其写到 <code>buffer</code> 中如果 <code>buffer</code> 为NULL。在极少的情况下，其他人在当前线程同时设置了 <code>buffer</code> ，我们简单地将其释放掉。因为比较和交换方法是原子的，所以它是一个线程安全的方式去惰性初始化值。NULL的检测和设置 <code>buffer</code> 都是以原子方式完成的。</p>

<p>明显的，使用 <code>dispatch_once()</code> 我们也可以完成类似的事情。</p>

<h3>原子队列</h3>

<p><code>OSAtomicEnqueue()</code> 和 <code>OSAtomicDequeue()</code> 可以让你以线程安全，无锁的方式实现一个LIFO队列(常见的就是栈)。对有潜在精确要求的代码来说，这会是强大的代码。</p>

<p>还有  <code>OSAtomicFifoEnqueue()</code> 和 <code>OSAtomicFifoDequeue()</code> 函数是为了操作FIFO队列，但这些只有在头文件中才有文档 —— 使用他们的时候要小心。</p>

<h3>自旋锁</h3>

<p>最后，<code>OSAtomic.h</code> 头文件定义了使用自旋锁的函数：<code>OSSpinLock</code>。同样的，维基百科有深入的有关<a href="https://en.wikipedia.org/wiki/Spinlock">自旋锁</a>的信息。使用命令 <code>man 3 spinlock</code> 查看帮助页的 <code>spinlock(3)</code> 。当没有锁竞争时使用自旋锁代价很小。</p>

<p>在合适的情况下，使用自旋锁对性能优化是很有帮助的。一如既往：先测量，然后优化。不要做乐观的优化。</p>

<p>下面是 OSSpinLock 的一个例子：</p>

<p>```objc
@interface MyTableViewCell : UITableViewCell</p>

<p>@property (readonly, nonatomic, copy) NSDictionary *amountAttributes;</p>

<p>@end</p>

<p>@implementation MyTableViewCell
{
    NSDictionary *_amountAttributes;
}</p>

<ul>
  <li>(NSDictionary *)amountAttributes;
{
  if (_amountAttributes == nil) {
      static __weak NSDictionary *cachedAttributes = nil;
      static OSSpinLock lock = OS_SPINLOCK_INIT;
      OSSpinLockLock(&amp;lock);
      _amountAttributes = cachedAttributes;
      if (_amountAttributes == nil) {
          NSMutableDictionary *attributes = [[self subtitleAttributes] mutableCopy];
          attributes[NSFontAttributeName] = [UIFont fontWithName:@”ComicSans” size:36];
          attributes[NSParagraphStyleAttributeName] = [NSParagraphStyle defaultParagraphStyle];
          _amountAttributes = [attributes copy];
          cachedAttributes = _amountAttributes;
      }
      OSSpinLockUnlock(&amp;lock);
  }
  return _amountAttributes;
}
```</li>
</ul>

<p>就上面的例子而言，或许用不着这么麻烦，但它演示了一种理念。我们使用了ARC的 <code>__weak</code> 来确保一旦 <code>MyTableViewCell</code> 所有的实例都不存在， <code>amountAttributes</code> 会调用 <code>dealloc</code> 。因此在所有的实例中，我们可以持有字典的一个单独实例。</p>

<p>这段代码运行良好的原因是我们不太可能访问到方法最里面的部分。这是很深奥的——除非你真正需要，不然不要在你的 App 中使用它。</p>

<hr />

]]></content>
  </entry>
  
</feed>
