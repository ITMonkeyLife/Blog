<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-C | IT Monkey Life]]></title>
  <link href="http://ITMonkeyLife.github.io/Blog/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://ITMonkeyLife.github.io/Blog/"/>
  <updated>2015-12-23T14:02:47+08:00</updated>
  <id>http://ITMonkeyLife.github.io/Blog/</id>
  <author>
    <name><![CDATA[Rick]]></name>
    <email><![CDATA[382542165@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JSPatch用法剖析]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2015/12/23/jspatchyong-fa-pou-xi/"/>
    <updated>2015-12-23T09:51:39+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2015/12/23/jspatchyong-fa-pou-xi</id>
    <content type="html"><![CDATA[<h2 id="目录"><a name="jspatchIntroducton">目录</a></h2>
<ol>
<li><a href="#jspatchIntroducton"><strong>JSPatch介绍</strong></a></li>
<li><a href="#jspatch-wax"><strong>JSPatch VS Wax lua</strong></a></li>
<li><a href="#jspatch-core"><strong>JSPatch的原理和核心</strong></a></li>
<li><a href="#jspatch-Extension"><strong>JSPatch Extension机制</strong></a></li>
<li><a href="#jspatch-Tech"><strong>JSPatch中的实现技巧总结</strong></a> </li>
<li><a href="#jspatch-problem"><strong>遇到的问题与解决方法</strong></a></li>
</ol>
<h2 id="一、JSPatch介绍"><a name="jspatchIntroducton">一、JSPatch介绍</a></h2>
<h3 id="用途">用途</h3>
<p>iOS产品开发之中常常会遇到这种情况: 新版本上线后发现有个严重的bug，可能会导致crash率激增，可能会使网络请求无法发出，这时能做的只是赶紧修复bug然后提交等待漫长的AppStore审核，再盼望用户快点升级，付出巨大的人力和时间成本，才能完成此次bug的修复。</p>
<p>JSPatch的出现解决了这样的问题，只需要在项目中引入极小的JSPatch引擎，就可以使用JavaScript语言调用Objective-C的原生接口，获得脚本语言的能力：动态更新iOS APP，替换项目原生代码、快速修复bug。      </p>
<h3 id="技术核心">技术核心</h3>
<p>JSPatch核心主要是JSBinding和Objective-C中的runtime技术。一方面，它采用Apple在iOS7中发布的JavaScriptCore.framework作为Javascript引擎解析JavaScript脚本，执行JavaSript代码并与Objective-C端的代码进行桥接。另一方面则是使用Objective-C runtime中的method swizzling的方式达到使用JavaScript脚本动态替换原有Objective-C方法的目的，并利用ForwardInvocation标准消息转发机制使得在JavaScript脚本中调用Objective-C的方法成为可能。</p>
<h2 id="二、JSPatch_VS_lua_Wax"><a name="jspatch-wax">二、JSPatch VS lua Wax</a></h2>
<p>wax是可以实现动态打补丁快速修补Crash的另外一种解决方案，初衷是为了使用lua来编写iOS原生应用而诞生的一个框架。它利用lua的C语言API(可以让C代码与lua进行交互的函数集，包括读写lua全局变量的函数，调用lua函数的函数，运行lua代码片段的函数，注册C函数然后可以在lua中被调用的函数，等等)和 Objective-C 强大的runtime使lua能调用原生Objective-C接口，可以使用lua创建，继承，扩展oc类，使用lua实现oc所能实现的所有功能。</p>
<p>lua wax由几个部分组成:</p>
<ol>
<li><p>wax stdLib，是一个lua脚本库，利用前面提到的C API和Objective-C runtime向lua脚本提供与Objective-C类交互的接口;</p>
</li>
<li><p>Wax Engine，提供使用Objective-C加载运行lua脚本和传递变量给lua脚本的接口;</p>
</li>
<li><p>lua Compiler，即lua解释器，wax Engine调用解释器加载并编译运行lua脚本。<br /><img src="http://ww1.sinaimg.cn/bmiddle/68e55315gw1eu0af1y3asj20dp0ec3z0.jpg" alt="Wax lua" /></p>
</li>
</ol>
<p>相比于wax，    JSPatch有以下的优势</p>
<ol>
<li><p>Javascript比lua在应用开发领域有更广泛的应用。 目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JavaScript是不二之选。</p>
</li>
<li><p>更符合Apple的规则。iOS Developer Program License Agreement里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。</p>
</li>
<li><p>小巧。 使用系统内置的JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。而Wax需要导入c代码写的lua引擎。</p>
</li>
<li><p>支持block。<br />wax在几年前就停止了开发和维护，不支持Objective-C里block跟lua程序的互传，虽然一些第三方已经实现block，但使用时参数上也有比较多的限制。</p>
<p>wax年久失修，多年之前作者便不作更新，并留下这样一句话就离开了iOS界:<br />
<blockquota>
<p>
I am no longer developing iOS applications and don’t have time to work on Wax. If you would like to take over as the maintainer, fork Wax and maintain it there. If your fork becomes popular I will add a link to it to this Readme.
</p>
</blockquota><br />
这明显是财产自由了才跑了吧- -||。
</p>
</li>
<li><p>不需要担心内存回收的问题。JavascriptCore.framework通过GC来对垃圾进行回收。而lua wax需要显式调用内存回收方法。</p>
</li>
<li><p>支持armv7 armv7s arm64框架。wax并不支持arm64框架。</p>
</li>
</ol>
<p>而JSPatch也有自身的缺点:</p>
<ol>
<li><p>不支持iOS6及以下，因为JSPatch依赖于iOS7及以后的JavascriptCore.framework (这点现在可以忽略，因为微信最低的版本要求已经是iOS7)</p>
</li>
<li><p>调用OC方法的性能慢于lua wax</p>
</li>
<li><p>启动JSPatch所占用的内存多于wax</p>
</li>
</ol>
<h2 id="三、JSPatch核心原理解析"><a name="jspatch-core">三、JSPatch核心原理解析</a></h2>
<h3 id="startEngine">startEngine</h3>
<p><code>objc
[JPEngine startEngine];
NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@"demo" ofType:@"js"];
NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil];
[JPEngine evaluateScript:script];
</code></p>
<p>使用JSPatch框架首先要调用<code>JPEngine</code>中的类方法<code>startEngine</code>，这个方法的是为了初始化JSContext，JSContext是JS脚本的运行环境。JS脚本可以调用在JSContext中预先定义的方法，方法的参数/返回值都会被JavaScriptCore.framework自动转换，OC里的NSArray，NSDictionary，NSString，NSNumber，NSBlock，[NSNull null]会分别转为JS端的Array/Object/String/Number/function/null。</p>
<p>那其他无法通过JavascriptCore.framework进行bridge转换的数据类型，比如自定义的类的对象，Class类型，指针，要如何在JS和OC两端进行传递呢？</p>
<p>JSPatch中使用了一个叫做JPBoxing的类去封装id、指针、Class类型变量，封装完以后这个Boxing对象会被放在一个NSDictionary里(NSDictionary可转化为JS中的Object类型)，传递给JS代码。<a href="#jspatch-boxing">后面</a>会对JPBoxing进行详细的介绍.</p>
<p>回到startEngine方法:</p>
<p>```objc
context[@”_OC_defineClass”] = ^(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods) {
        return defineClass(classDeclaration, instanceMethods, classMethods);
    };</p>

<p>context[@”_OC_callI”] = ^id(JSValue *obj, NSString *selectorName, JSValue *arguments, BOOL isSuper) {
        return callSelector(nil, selectorName, arguments, obj, isSuper);
    };</p>

<p>context[@”_OC_callC”] = ^id(NSString *className, NSString *selectorName, JSValue *arguments) {
        return callSelector(className, selectorName, arguments, nil, NO);
    };
```</p>
<p>在这里定义的函数主要是负责处理转换从JS端传过来的参数，然后在OC端运用runtime里的方法实现生成新的类、替换旧的类、调用方法等等功能。</p>
<p>其中<code>_OC_defineClass</code>负责定义新的类或替换原有的类，<code>_OC_callI</code>负责调用实例方法，<code>_OC_callC</code>负责调用类方法。</p>
<p>除了这三个函数之外，startEngine中还封装了一些常用GCD方法、console.log、sizeof、Javascript异常捕获函数等等。</p>
<p>准备完JSContext之后，就可以加载从网络中下载的JS补丁，调用<code>[JPEngeine evaluateScript:script]</code>方法执行脚本。</p>
<h3 id="defineClass">defineClass</h3>
<p>接下来讲解JSPatch中如何定义一个类以及怎么覆盖原方法或新增一个方法。</p>
<p><code>javascript
defineClass('JPViewController', {
  handleBtn: function(sender) {
    var tableViewCtrl = JPTableViewController.alloc().init()
    self.navigationController().pushViewController_animated(tableViewCtrl, YES)
  }
}, {})
</code></p>
<p><code>defineClass</code>函数可接受三个参数：</p>
<ol>
<li>字符串:”需要替换或者新增的类名:继承的父类名 &lt;实现的协议1，实现的协议2&gt;”</li>
<li>{实例方法}</li>
<li>{类方法}</li>
</ol>
<p>将这三个参数通过bridging传入到OC后，执行以下步骤:</p>
<ol>
<li>使用NSScanner分离classDeclaration，分离成三部分<ul>
<li>类名 : className</li>
<li>父类名 : superClassName</li>
<li>实现的协议名 : protocalNames</li>
</ul>
</li>
<li>使用NSClassFromString(className)获得该Class对象。<ul>
<li>若该Class对象为nil，则说明JS端要添加一个新的类，使用<code>objc_allocateClassPair</code>与<code>objc_registerClassPair</code>注册一个新的类。</li>
<li>若该Class对象不为nil，则说明JS端要替换一个原本已存在的类</li>
</ul>
</li>
<li>根据从JS端传递来的实例方法与类方法参数，为这个类对象添加/替换实例方法与类方法<ul>
<li>添加实例方法时，直接使用上一步得到class对象; 添加类方法时需要调用<code>objc_getMetaClass</code>方法获得元类。</li>
<li>如果要替换的类已经定义了该方法，则直接对该方法替换和实现消息转发。</li>
<li>否则根据以下两种情况进行判断<ul>
<li>遍历protocalNames，通过<code>objc_getProtocol</code>方法获得协议对象，再使用<code>protocol_copyMethodDescriptionList</code>来获得协议中方法的type和name。匹配JS中传入的selectorName，获得typeDescription字符串，对该协议方法的实现消息转发。</li>
<li>若不是上述两种情况，则js端请求添加一个新的方法。构造一个typeDescription为”@@:\@****”(返回类型为id，参数值根据JS定义的参数个数来决定。新增方法的返回类型和参数类型只能为id类型，因为在JS端只能定义对象)的IMP。将这个IMP添加到类中。</li>
</ul>
</li>
</ul>
</li>
<li>为该类添加<code>setProp:forKey</code>和<code>getProp:</code>方法，使用<code>objc_getAssociatedObject</code>与<code>objc_setAssociatedObject</code>让JS脚本拥有设置property的能力</li>
<li>返回{className:cls}回JS脚本。</li>
</ol>
<h3 id="overrideMethod方法">overrideMethod方法</h3>
<p>不管是替换方法还是新增方法，都是使用<code>overrideMethod</code>方法。<br />它接受五个参数:</p>
<ul>
<li>类名</li>
<li>要替换的方法名</li>
<li>JS中定义的方法</li>
<li>是否类方法</li>
<li>方法的typeDescription</li>
</ul>
<p>原型如下</p>
<p><code>objc
static void overrideMethod(Class cls, NSString *selectorName, JSValue *function, BOOL isClassMethod, const char *typeDescription)
</code></p>
<p>逻辑步骤如下</p>
<ol>
<li>初始化：更具selectorName获取对应的Selector；typeDescription获得NSMethodSignature方法签名。</li>
<li>保存原有方法的IMP，添加名为<code>@&quot;ORIG&quot; + selectorName</code>的方法，IMP为原方法的IMP。</li>
<li>将原方法的IMP设置为消息转发<ul>
<li>若该方法的返回值为特殊的struct类型，则需要将IMP设置为<code>(IMP)_objc_msgForward_stret</code></li>
<li>否则的话将IMP设置为<code>_objc_msgForward</code></li>
</ul>
</li>
<li>保存原有转发方法<code>forwardInvocation:</code>的IMP，添加selectorName为@”ORIGforwardInvocation:”，IMP为原转发方法IMP的方法。</li>
<li>将原转发方法替换为自己的转发方法<code>JPForwardInvocation</code></li>
<li>根据替换/添加方法的返回类型，选择不同的替换IMP(使用宏的形式定义)，替换原方法。</li>
</ol>
<h3 id="callSelector方法">callSelector方法</h3>
<p>在JS端调用OC方法时，都需要通过在OC端通过<code>callSelector</code>方法进行方法的查找以及参数类型、返回类型的转换和处理。</p>
<p>该方法接受五个参数</p>
<ul>
<li>调用对象的类名</li>
<li>被调用的selectorName</li>
<li>JS中传递过来的参数</li>
<li>JS端封装的实例对象</li>
<li>是否调用的是super类的方法</li>
</ul>
<p>方法的原型：</p>
<p><code>objc
static id callSelector(NSString *className, NSString *selectorName, JSValue *arguments, JSValue *instance, BOOL isSuper)
</code></p>
<p>逻辑步骤如下</p>
<ol>
<li>初始化<ul>
<li>将JS封装的instance对象进行拆装，得到OC的对象；</li>
<li>根据类名与selectorName获得对应的类对象与selector；</li>
<li>通过类对象与selector构造对应的NSMethodSignature签名，再根据签名构造NSInvocation对象，并为invocation对象设置target与Selector</li>
</ul>
</li>
<li>根据方法签名，获悉方法每个参数的实际类型，将JS传递过来的参数进行对应的转换(比如说参数的实际类型为int类型，但是JS只能传递NSNumber对象，需要通过<code>[[jsObj toNumber] intValue]</code>进行转换)。转换后使用<code>setArgument方法</code>为NSInvocation对象设置参数。</li>
<li>执行invoke方法。</li>
<li>通过getReturnValue方法获取到返回值。</li>
<li>根据返回值类型，封装成JS中对应的对象(因为JS并不识别OC对象，所以返回值为OC对象的话需封装成{<strong>className:className, </strong>obj:obj})返回给JS端。</li>
</ol>
<h3 id="JPForwardInvocation方法">JPForwardInvocation方法</h3>
<p>JPForwardInvocation方法替换了原有<code>-forwardInvocation</code>方法的实现，使得消息转发都通过该方法，并将消息转发给JS脚本中定义的方法，通过JavascriptCore.frameWork中提供的<code>callWithArguments</code>方法调用JS方法达到替换原方法，添加新方法的目的。是实现替换和新增方法的核心。</p>
<p>它的原型与ForwardInvocation方法相同</p>
<p><code>objc
static void JPForwardInvocation(id slf, SEL selector, NSInvocation *invocation)
</code></p>
<p>它的内部逻辑并不复杂，主要是读取出传入的invocation对象中的所有参数，根据实际参数的类型将JSValue类型的参数转换成对应的OC类型，最后将参数添加到_TMPInvocationArguments数组以供JS调用。</p>
<p>那如果有一些类确实有用到这个方法进行消息转发（比如为了实现多继承），那原来的逻辑该怎么办？ </p>
<p>JSPatch在替换<code>-forwardInvocation:</code>方法前会新建一个方法<code>-ORIGforwardInvocation:</code>，保存原来的实现IMP，在新的<code>-forwardInvocation:</code>实现里做了个判断，如果转发的方法是JS脚本中想改写的，就走<code>-JPForwardInvocation:</code>逻辑，若不是，就调用<code>-ORIGforwardInvocation:</code>走原来的流程。</p>
<h3 id="对象的持有/转换"><a name="jspatch-convert"></a>对象的持有/转换</h3>
<p>原作者bang在<a href="http://blog.cnbang.net/tech/2808/" target="_blank" rel="external">他的博文中</a>，有较为详细的说明。下面引用了他文章中关于对象持有/转换的细节.</p>
<p>UIView.alloc() 通过上述消息传递后会到OC执行 [UIView alloc]，并返回一个UIView实例对象给JS，这个OC实例对象在JS是怎样表示的呢？怎样可以在JS拿到这个实例对象后可以直接调用它的实例方法 (UIView.alloc().init())？</p>
<p>对于一个自定义id对象，JavaScriptCore会把这个自定义对象的指针传给JS，这个对象在JS无法使用，但在回传给OC时OC可以找到这个对象。对于这个对象生命周期的管理，按我的理解如果JS有变量引用时，这个OC对象引用计数就加1 ，JS变量的引用释放了就减1，如果OC上没别的持有者，这个OC对象的生命周期就跟着JS走了，会在JS进行垃圾回收时释放。<br />传回给JS的变量是这个OC对象的指针，如果不经过任何处理，是无法通过这个变量去调用实例方法的。所以在返回对象时，JSPatch会对这个对象进行封装。</p>
<p>首先，告诉JS这是一个OC对象：</p>
<p><code>objc
static NSDictionary *toJSObj(id obj)
{
    if (!obj) return nil;
    return @{@"__isObj": @(YES), @"cls": NSStringFromClass([obj class]), @"obj": obj};
}
</code></p>
<p>用__isObj表示这是一个OC对象，对象指针也一起返回。接着在JS端会把这个对象转为一个 JSClass 实例：</p>
<p><code>javascript
var _formatOCToJS = function(obj) {
    if (obj === undefined || obj === null) return false
    if (typeof obj == "object") {
      if (obj.__obj) return obj
      if (obj.__isNull) return false  //注:这里是为了让JS能够链式调用
    }
    if (obj instanceof Array) {
      var ret = []
      obj.forEach(function(o) {
        ret.push(_formatOCToJS(o))
      })
      return ret
    }
    if (obj instanceof Function) {
      return function() {
        var args = Array.prototype.slice.call(arguments)
        return obj.apply(obj，_OC_formatJSToOC(args))
      }
    }
    if (obj instanceof Object) {
      var ret = {}
      for (var key in obj) {
        ret[key] = _formatOCToJS(obj[key])
      }
      return ret
    }
    return obj
  }
</code></p>
<p>接着看看对象是怎样回传给OC的。上述例子中，view.setBackgroundColor(require(‘UIColor’).grayColor())，这里生成了一个 UIColor 实例对象，并作为参数回传给OC。根据上面说的，这个 UIColor 实例在JS中的表示是一个 JSClass 实例，所以不能直接回传给OC，这里的参数实际上会在 <strong>c 函数进行处理，会把对象的 .</strong>obj 原指针回传给OC。</p>
<p>整个对象的持有/转换的流程图如下:</p>
<p><img src="http://blog.cnbang.net/wp-content/uploads/2015/06/JSPatch1.png" alt="convertpng" /></p>
<h2 id="四、JSPatch_Extension机制"><a name="jspatch-Extension">四、JSPatch Extension机制</a></h2>
<h3 id="如何在JSPatch中预定义C_API供JS调用">如何在JSPatch中预定义C API供JS调用</h3>
<p>上面已经介绍过JSPatch是运用Objective-C runtime和JSBinding技术来在JS中调用Objective-C的方法，但是C API是没法通过runtime技术来获取的。一开始的时候我想使用<code>dlsym</code>函数通过函数名来获取对应的函数指针，通过JS脚本传入C函数的函数名来进行函数调用。但实际上还需要预先定义一个相同类型的函数指针才能调用，做不到完全的动态调用。而且还有一个问题就是像CGRectMake这种，实质上是内联函数，并没有对应的函数地址。更关键的是，没有办法获取C函数的签名，而JS中调用函数是没有具体类型的，传递到OC是以JSValue对象的形式，必须通过转换才能调用对应的C函数。最后的解决方法便是预先在JSContext中提供JS方法和C函数的桥接方法。</p>
<p>这里以定义CGRectMake()来作为例子，如果想在JS中使用CGRectMake()函数，则需要在JPEngine启动的时候，将CGRectMake预定义在JSContext之中。</p>
<p>而且有一点要注意的，CGRectMake返回的并不是一个对象，而是一个struct类型的变量。struct类型是无法返回到JS环境的，所以要转换成NSDictionary的形式。</p>
<p>Extension中需要定义对应的方法来将struct转换成NSDictionary</p>
<p><code>objc
+ (NSDictionary *)dictOfStruct:(void *)structData typeString:(const char*)type
{
    if (strcmp(type，@encode(CGRect)) == 0) {
        CGRect *rect = structData;
        return @{@"x": @(rect-&gt;origin.x), @"y": @(rect-&gt;origin.y), @"width": @(rect-&gt;size.width)，@"height": @(rect-&gt;size.height)};
    }
    //下面接着定义其他类型的Struct
    return nil;
}
</code></p>
<p>这样就可以在startEngine中定义CGRectMake方法了，具体如下</p>
<p><code>objc
context[@"CGRectMake"] = ^id(JSValue *x，JSValue *y，JSValue *width，JSValue *height){
        CGRect rect = CGRectMake([x toDouble], [y toDouble], [width toDouble], [height toDouble]);
        return [JPEngine dictOfStruct:&amp;rect typeString:@encode(CGRect)];
    };
</code></p>
<p>在JS中就可以如此调用桥接函数</p>
<p><code>javascript
var frame = CGRectMake(0, 0, 200, 200)
</code></p>
<p><a name="jspatch-boxing"></a>但是如果返回的值是一个<strong>指针或者参数值为指针</strong>要如何解决？</p>
<p>这时候就需要一个Boxing对象对指针和Class这些在JS中无法使用的变量类型进行装箱(box);在JS中调用OC或C方法后，传递回到Objective-C端的再进行拆箱(unbox)。</p>
<p>Boxing对象的定义如下:</p>
<p>```objc
@interface JPBoxing : NSObject
@property (nonatomic) id obj;
@property (nonatomic) void *pointer;
@property (nonatomic) Class cls;
- (id)unbox;
- (void *)unboxPointer;
- (Class)unboxClass;
@end</p>

<p>@implementation JPBoxing</p>

<h1 id="define-jpboxinggenname-prop-type-">define JPBOXING_GEN(_name, _prop, _type) \</h1>
<ul>
  <li>(instancetype)_name:(_type)obj  \
{   \
  JPBoxing *boxing = [[JPBoxing alloc] init]; \
  boxing._prop = obj;   \
  return boxing;  \
}</li>
</ul>

<p>JPBOXING_GEN(boxObj, obj, id)
JPBOXING_GEN(boxPointer, pointer, void *)
JPBOXING_GEN(boxClass, cls, Class)</p>

<ul>
  <li>(id)unbox
{
  if (self.obj) return self.obj;
  return self;
}</li>
  <li>(void *)unboxPointer
{
  return self.pointer;
}</li>
  <li>(Class)unboxClass
{
  return self.cls;
}
@end
```</li>
</ul>
<p>注意到unbox里的一个<code>return self</code>的写法，这里是一个trick。因为前面介绍到的<code>formatJSToOC</code>函数的定义如下</p>
<p><code>objc
id formatJSToOC(JSValue *jsval)
</code></p>
<p>这个函数需要负责处理JS到OC端的类型转换，但是如果变量类型是指针或者Class类型的话就和无法和id类型写在同一个处理函数里。所以如果是JPBoxing中的obj为nil，则说明是非id类型，直接返回这个JPBoxing。外部得到的这个JPBoxing对象，则再进行相应类型拆箱。</p>
<p>使用这个Boxing类，调用Extension中的C API时，对指针拆箱，再调用实际的C方法; 返回时，对JS中无法使用的类型进行装箱后再返回; 根据这个机制便可实现对大部分C API的封装。下面以<code>UIGraphicsGetCurrentContext()</code>为例:</p>
<p><img src="http://ww1.sinaimg.cn/mw1024/68e55315gw1eu0bbdxplrj20e5026mxg.jpg" alt="jpboxing1" /><br /><img src="http://ww4.sinaimg.cn/mw1024/68e55315gw1eu0bb95xx3j20ez0aa75n.jpg" alt="jpboxing2" /></p>
<p>效果如下：</p>
<p><img src="http://ww1.sinaimg.cn/mw1024/68e55315gw1eu0bb1sjvsj208w0geaa7.jpg" alt="jpboxing3" /></p>
<h3 id="使用JPExtesnion扩展机制对C_API和Struct进行扩展">使用JPExtesnion扩展机制对C API和Struct进行扩展</h3>
<p>在上一节，我对如何在JSPatch中调用C API进行了介绍。 但是面对大量的C API，需要一个满足以下需求的扩展机制：</p>
<ol>
<li>可模块化加载</li>
<li>js脚本可动态加载</li>
<li>可以在extension中添加struct类型</li>
</ol>
<p>以下是JPExtension协议的定义，所有的C API扩展都需要继承JPExtension协议</p>
<p>```objc
@protocol JPExtensionProtocol <nsobject>
@optional
- (void)main:(JSContext *)context;</nsobject></p>

<ul>
  <li>(size_t)sizeOfStructWithTypeName:(NSString *)typeName;</li>
  <li>(NSDictionary *)dictOfStruct:(void *)structData typeName:(NSString *)typeName;</li>
  <li>(void)structData:(void *)structData ofDict:(NSDictionary *)dict typeName:(NSString *)typeName;
@end
```</li>
</ul>
<p>开发者可在<code>- (void)main:(JSContext * )context</code>中添加C API，C API会被添加到JS所在的执行环境中。而后面的三个方法从方法名可以知道，extension中如果要定义struct的话则需要实现这三个方法。因为JS中是无法定义和使用c struct的，所以需要提供相应的互相转换方法(struct与NSDictionary互相转换)，具体实现以<code>CGAffineTransform</code>为例：</p>
<p>```objc
- (size_t)sizeOfStructWithTypeName:(NSString *)typeName
{
    if ([typeName rangeOfString:@”CGAffineTransform”].location != NSNotFound) {
        return sizeof(CGAffineTransform);
    }
    return 0;
}</p>

<ul>
  <li>
    <p>(NSDictionary *)dictOfStruct:(void *)structData typeName:(NSString *)typeName
{
  if ([typeName rangeOfString:@”CGAffineTransform”].location != NSNotFound) {
      CGAffineTransform *trans = (CGAffineTransform *)structData;
      return [JPCGTransform transDictOfStruct:trans];
  }
  return nil;
}</p>
  </li>
  <li>
    <p>(void)structData:(void *)structData ofDict:(NSDictionary *)dict typeName:(NSString *)typeName
{
  if ([typeName rangeOfString:@”CGAffineTransform”].location != NSNotFound) {
      [JPCGTransform transStruct:structData ofDict:dict];
  }
}
```</p>
  </li>
</ul>
<p>实现了这三个方法后，JPEngine会将实现了这三个方法extesnion放入_structExtension内。当在JS中调用含有相关struct的方法时，JSEngine会遍历整个_structExtension，找到相应的转换方法。</p>
<p>根据JPExtension协议，模块化加载就变得非常简单：</p>
<p><code>objc
- (void)main:(JSContext *)context
{
    NSArray *extensionArray = @[[JPCGTransform instance], [JPCGContext instance],
                                            [JPCGGeometry instance], [JPCGBitmapContext instance],
                                            [JPCGColor instance], [JPCGImage instance], [JPCGPath instance]];
    [JPEngine addExtensions:extensionArray];
}
</code></p>
<p>在JS脚本则可以这样调用：</p>
<p><code>javascript
(function init() {
    var extensionArr = [require('JPCoreGraphics').instance(), require('JPUIKit').instance()]
    require('JPEngine').addExtensions(extensionArr)
})()
</code></p>
<p>当然，为了提高项目的性能，你也可以只调用你需要的模块。</p>
<h3 id="C_API定义时需要注意的问题">C API定义时需要注意的问题</h3>
<p>C API中，有大量的参数或者是返回类型都是指针，包括像CGContextRef这种也是指针，而OC对象在JS环境中也是无法使用的。上面的章节已经提到了从OC端返回给JS端时必须用一个封装对象(JPBoxing)来将指针和对象封装起来。JPExtension提供了以下API来封装OC中的对象和指针成JPBoxing和将JPBoxing对象。</p>
<p><code>objc
- (void *)formatPointerJSToOC:(JSValue *)val;
- (id)formatPointerOCToJS:(void *)pointer;
- (id)formatJSToOC:(JSValue *)val;
- (id)formatOCToJS:(id)obj;
</code></p>
<p>C API封装实例:</p>
<p>```objc
context[@”UIGraphicsGetCurrentContext”] = ^id() {
        CGContextRef c = UIGraphicsGetCurrentContext();
        return [self formatPointerOCToJS:c];
    };</p>

<p>context[@”UIGraphicsBeginImageContext”] = ^void(NSDictionary *sizeDict) {
        CGSize size;
        [JPCGGeometry sizeStruct:&amp;size ofDict:sizeDict];
        UIGraphicsBeginImageContext(size);
    };
```</p>
<p>注意到<code>UIGraphicsGetCurrentContext()</code>中返回的是一个CGContextRef类型，所以添加这个扩展API的时候需要将返回类型改为id类型，并将CGContextRef指针封装在JPBoxing中。而<code>UIGraphicsBeginImageContext()</code>需要的是一个CGSize参数，这时候需要在JS端传入一个<code>{x:100, y:100}</code>的Javascript object，这个object会在OC中被转换为NSDictionary.</p>
<p>C API的返回值也需要判断返回值的类型来进行不同的封装，当返回的结果是JavascriptCore.Framework所不支持转换的类型(NSArray，NSDictionary，NSString，NSNumber，NSBlock)，则需要通过<code>formatOCToJS:</code>方法来封装返回。而且返回类型是NSArray，NSDictionary，NSString时，如果你直接返回，JavascriptCore会将返回值转换为JS中的Array，Object，String，你就无法再使用OC的方法。如果你想在JS中使用这三种类型的方法，也需要用<code>formatOCToJS:</code>方法进行封装。</p>
<h3 id="在JSPatch中的操作内存与&amp;取地址运算符">在JSPatch中的操作内存与&amp;取地址运算符</h3>
<p>与C语言不同，Javascript不能显式的声明一个指向某块内存的指针，也没有<code>&amp;</code>取地址运算符，Javascript是根据参数是引用类型还是基本类型决定传递引用还是传参。但是指针与取地址在C语言以及OC中都会时常被用到。比如如下的情况:</p>
<p><code>objc
......
NSString *str = @"littleliang";
[invocation setArgument:&amp;str atIndex:2];
......
</code></p>
<p>JPMemory扩展解决了这个问题，其中封装了内存操作中常用的一些常用的c函数。包括<code>malloc</code>，<code>memset</code>，<code>free</code>，<code>memcpy</code>，<code>memncpy</code>，<code>memmove</code>。</p>
<p>而对<code>&amp;</code>取地址运算符，JPMemory扩展也进行了函数封装，在JS补丁中可以对调用<code>getpointer</code>方法获取对象的指针、指针的指针，针对上述的代码，现在便可以以以下的形式调用。</p>
<p><code>javascript
......
var str = require('NSString').stringWithString('littleliang')
invocation.setArgument_atIndex(getpointer(str)，2)
......
</code></p>
<p>getpointer的底层源码如下:</p>
<p><code>objc
- (void *)getPointerFromJS:(JSValue *)val
{
    void **p = malloc(sizeof(void *));
    if ([[val toObject] isKindOfClass:[NSDictionary class]]) {
        if ([[val toObject][@"__obj"] isKindOfClass:[JPBoxing class]]) {
            void *pointer = [(JPBoxing *)[val toObject][@"__obj"] unboxPointer];
            if (pointer != NULL) {
                *p = pointer;
            }else {
                id jpobj = [(JPBoxing *)[val toObject][@"__obj"] unbox];
                *p = (__bridge void *)jpobj;
            }
        }else {
            id obj = [val toObject][@"__obj"];
            *p     = (__bridge void *)obj;
        }
        return p;
    }else {
        NSAssert(NO, @"getpointer only support pointer and id type!");
        return NULL;
    }
}
</code></p>
<p>而通过JPMemory中的pval或添加pvalWithXXX便可获得指针所指的对象或XXX类型的变量。</p>
<p>```objc
context[@”pval”]    = ^id(JSValue *jsVal) {
        void *m = [self formatPointerJSToOC:jsVal];
        id obj = *((__unsafe_unretained id *)m);
        return [self formatOCToJS:obj];
    };</p>

<p>context[@”pvalWithBool”] = ^id(JSValue *jsVal) {
        void *m = [self formatPointerJSToOC:jsVal];
        BOOL b = *((BOOL *)m);
        return [self formatOCToJS:[NSNumber numberWithBool:b]];
    };
```
&lt;h3 id="include函数"&gt;include函数&lt;/h3&gt;&lt;p&gt;在JSPatch最新的更新中，支持了在JS中调用include方法。可以在一个JS文件中加载其他JS文件，包括补丁脚本、第三方脚本。&lt;/p&gt;</p>
<p>使用方法如下:</p>
<p><code>javascript
(function init() {
    var extensionArr = [require('JPInclude').instance()]
    require('JPEngine').addExtensions(extensionArr)
    include('another.js')
})()
</code></p>
<p>在我自己的分支中，include函数支持加载选项。默认加载选项是兼容方式加载（为满足支持OC，会通过正则表达式替换部分函数的调用方法），而第三方库是不需要被改变的。第二个参数是加载选项，默认是0或者不传入第二个参数，加载第三方库是1。</p>
<p><code>javascript
(function init() {
    include('thridparty.js', 1)
})()
</code>
&lt;h2 id="五、JSPatch中的实现技巧"&gt;<a name="jspatch-Tech">五、JSPatch中的实现技巧</a>&lt;/h2&gt;&lt;h3 id="GCD的实现"&gt;GCD的实现&lt;/h3&gt;&lt;p&gt;JSPatch采用的是预先在JSContext中封装了对GCD的调用，才能在JS中使用GCD，其代码如下。&lt;/p&gt;
<code>objc
__weak JSContext *weakCtx = context;
  context[@"dispatch_after"] = ^(double time, JSValue *func) {
      JSValue *currSelf = weakCtx[@"self"];
      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(time * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
          JSValue *prevSelf = weakCtx[@"self"];
          weakCtx[@"self"] = currSelf;
          [func callWithArguments:nil];
          weakCtx[@"self"] = prevSelf;
      });
  };
  context[@"dispatch_async_main"] = ^(JSValue *func) {
      JSValue *currSelf = weakCtx[@"self"];
      dispatch_async(dispatch_get_main_queue(), ^{
          JSValue *prevSelf = weakCtx[@"self"];
          weakCtx[@"self"] = currSelf;
          [func callWithArguments:nil];
          weakCtx[@"self"] = prevSelf;
      });
  };
  context[@"dispatch_sync_main"] = ^(JSValue *func) {
      if ([NSThread currentThread].isMainThread) {
          [func callWithArguments:nil];
      } else {
          dispatch_sync(dispatch_get_main_queue(), ^{
              [func callWithArguments:nil];
          });
      }
  };
  context[@"dispatch_async_global_queue"] = ^(JSValue *func) {
      JSValue *currSelf = weakCtx[@"self"];
      dispatch_async(dispatch_get_global_queue(0, 0), ^{
          JSValue *prevSelf = weakCtx[@"self"];
          weakCtx[@"self"] = currSelf;
          [func callWithArguments:nil];
          weakCtx[@"self"] = prevSelf;
      });
  };
</code></p>
<p>其中有三点需要注意：</p>
<ol>
<li><p>在block里是不能直接使用context的，因为会造成循环引用。所以在这里有两个处理方式，要么是使用__weak修饰符，要么就是使用JavascriptCore.framework提供的api<br /><code>[JSContext currentContext]</code>。</p>
</li>
<li><p>在调用JSContext的<code>callWithArguments:</code>实例方法时，需要先保存JSContext中的实例对象<code>self</code>，调用完之后再重新赋值回去。否则在调用完JS方法后，<code>self</code>会变成nil</p>
</li>
<li><p>还有一点就是在<code>dispatch_sync_main</code>这个方法里，作者对代码所在的运行线程进行了一个判断，如果已经在主线程中就直接执行这个block，防止了死锁的发生。</p>
</li>
</ol>
<h3 id="处理JS脚本的异常">处理JS脚本的异常</h3>
<p>如果JS脚本出现了异常的话，在OC这边是不会知道的，需要使用JavaScriptCore.framwork中的exceptionHandler才能捕获这个异常，具体代码如下</p>
<p><code>objc
context.exceptionHandler = ^(JSContext *con, JSValue *exception) {
        NSLog(@"%@", exception);
        NSAssert(NO, @"js exception: %@", exception);
    };
</code>
&lt;h3 id="使用#pragma来抑制warning"&gt;使用#pragma来抑制warning&lt;/h3&gt;</p>
<p>作者使用#pargama宏来对一些warning进行了抑制，详细的介绍可以看参考<a href="http://nshipster.cn/clang-diagnostics/" target="_ blank" rel="external">Matt Thomson写的一篇关于clang diagnostics的文章</a>，里面提供了一个<a href="http://fuckingclangwarnings.com/" target="_ blank" rel="external">网站</a>详细地记录了抑制各种warning的写法。</p>
<h3 id="使用宏来预定义IMP函数">使用宏来预定义IMP函数</h3>
<p>由于要替换原有的函数实现，所以要预先定义好各种返回类型的IMP函数。如果全部写出来的话，将会耗费大量篇幅来写差不多的函数实现，这里作者使用了宏来进行替换，具体代码如下</p>
<p>```objc
#define JPMETHOD_IMPLEMENTATION(_type, _typeString, _typeSelector) \
    JPMETHOD_IMPLEMENTATION_RET(_type, _typeString, return [[ret toObject] _typeSelector]) \</p>

<h1 id="define-jpmethodimplementationrettype-typestring-ret-">define JPMETHOD_IMPLEMENTATION_RET(_type, _typeString, _ret) \</h1>
<p>static _type JPMETHOD_IMPLEMENTATION_NAME(_typeString) (id slf, SEL selector) {    \
    JSValue *fun = getJSFunctionInObjectHierachy(slf, selector);    \
    JSValue *ret = [fun callWithArguments:_TMPInvocationArguments];  \
    _ret;    \
}   \</p>

<h1 id="define-jpmethodimplementationnametypestring-jpmethodimplementtypestring">define JPMETHOD_IMPLEMENTATION_NAME(<em>typeString) JPMethodImplement</em>##_typeString</h1>

<h1 id="pragma-clang-diagnostic-push">pragma clang diagnostic push</h1>
<p>#pragma clang diagnostic ignored “-Wunused-variable”</p>

<h1 id="define-jpmethodretid-">define JPMETHOD_RET_ID \</h1>
<pre><code>id obj = formatJSToOC(ret); \
if ([obj isKindOfClass:[NSNull class]]) return nil;  \
return obj;
</code></pre>

<h1 id="define-jpmethodretstructmethodname----">define JPMETHOD_RET_STRUCT(_methodName)    \</h1>
<pre><code>id dict = formatJSToOC(ret);   \
return _methodName(dict);
</code></pre>

<p>JPMETHOD_IMPLEMENTATION_RET(void, v, nil)
JPMETHOD_IMPLEMENTATION_RET(id, id, JPMETHOD_RET_ID)
JPMETHOD_IMPLEMENTATION_RET(CGRect, rect, JPMETHOD_RET_STRUCT(dictToRect))
JPMETHOD_IMPLEMENTATION_RET(CGSize, size, JPMETHOD_RET_STRUCT(dictToSize))
JPMETHOD_IMPLEMENTATION_RET(CGPoint, point, JPMETHOD_RET_STRUCT(dictToPoint))
JPMETHOD_IMPLEMENTATION_RET(NSRange, range, JPMETHOD_RET_STRUCT(dictToRange))
……
```
&lt;h2 id="六、遇到的问题与解决方法"&gt;<a name="jspatch-problem">六、遇到的问题与解决方法</a>&lt;/h2&gt;&lt;p&gt;在与bang维护与开发JSPatch的过程中，也遇到过一些比较棘手的问题，这里总结一下。&lt;/p&gt;
&lt;h3 id="1-_在JSPatch中初始化UIWebView导致HTML无法渲染"&gt;1. 在JSPatch中初始化UIWebView导致HTML无法渲染&lt;/h3&gt;&lt;p&gt;这个问题最初是由一个JSPatch用户在<a href="https://github.com/bang590/JSPatch/issues/61" target="_blank" rel="external">issue</a>中提出。具体的表现是当在JSPatch中声明一个UIWebView，并对一个URL调用loadRequest方法后，无法渲染该HTML页面。<br /><img src="https://cloud.githubusercontent.com/assets/7334742/8666691/731b0354-2a27-11e5-95cc-90df45fac11f.png" alt="图片" /><br />后来经过查资料发现在JSContext中初始化UIWebView就会<a href="http://stackoverflow.com/questions/28638293/creating-a-uiwebview-from-a-jscontext-block-prevents-assets-from-loading-on-ios8" target="_blank" rel="external">出现这个问题</a>。&lt;/p&gt;</p>
<p>我猜测是<code>UIWebView</code>在初始化的过程中会初始化一个全局的<code>JSContext</code>对象，但是JSPatch也有用到<code>JSContext</code>，这其中造成了某种冲突。导致在<code>UIWebView</code>初始化JSContext失败。</p>
<p><strong>解决方法:</strong></p>
<p>1、在JSPatch之外启动调用一次<code>UIWebView</code>的<code>init</code>方法。</p>
<p>```objc
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    UIWebView *view = [[UIWebView alloc]init];   //Useless. Just to load the UIWebview framework.
    view.frame = CGRectZero;</p>

<pre><code>[JPEngine startEngine];    //.......

return YES; } ```
</code></pre>
<p>2、在JSPatch中显式地创建UIWebView的JSContext</p>
<p><code>javascript
defineClass('UIWebView',{
	 loadRequest :function(request){
	 	self.valueForKeyPath("documentView.webView.mainFrame.javaScriptContext")  		
	 	self.ORIGloadRequest(request)
 }
})
</code>
&lt;h3 id="2-_无法调用参数为id_*类型的方法"&gt;2. 无法调用参数为id * 类型的方法&lt;/h3&gt;&lt;p&gt;在上面的章节中我介绍了我是如何在JS中调用一个参数是指针的方法:&lt;/p&gt;</p>
<ol>
<li>通过<code>JPMemoery</code>Extension中的<code>malloc</code>声明一个指针或者调用<code>getpointer</code>去获得一个对象的地址。</li>
<li>调用方法后使用<code>pval</code>方法来获得指针所指的对象。</li>
</ol>
<p>这种方法调用像NSInvocation中的<code>- (void)getReturnValue:(void * )retLoc</code>、<code>- (void)setArgument:(void * )argumentLocation atIndex:(NSInteger)idx;</code>以及一些C API没有任何问题。</p>
<p>但是如果调用NSString中的<code>- (BOOL)writeToFile:(NSString * )path atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError * * )error</code>则会发现传进去的指针参数所指向的NSError对象在回到JS环境的时候已经被释放了。</p>
<p>实际上NSError <em>* 参数在编译器中会被解释成NSError \</em>--__ autoreleasing*类型，该对象生成后将会被加入到autoreleasing- pool中，开发者无法控制他的释放时机。随后，我对各个关键点进行打断点对这个自动释放对象进行跟中，发现这个对象一回到JSContext的执行环境就会被释放。</p>
<p><strong>解决方法：</strong></p>
<p>解决这个问题的思路是在调用完参数为id * 类型的方法后(<code>callSelector</code>中调用完<code>[invocation inoke]</code>后)，对该自动释放对象进行强引用，使得这个对象在回到JS环境的时候依然存在。这里我使用了一个NSDictonry作为临时自动释放对象的内存池，当生成一个自动释放对象后，将其添加到内存池中(key为其内存地址)，使得这个自动释放对象被内存池强引用。保证了在JS环境中可以访问到该对象，不需要该对象时再手动释放该对象(remove掉内存池的对象)。具体逻辑如下:</p>
<p><code>objc
case '^': {
                if ([valObj isKindOfClass:[JPBoxing class]]) {
                    void *value = [((JPBoxing *)valObj) unboxPointer];
                    if (argumentType[1] == '@') {
                        memset(value, 0, sizeof(id));
                        [_markArray addObject:valObj];
                    }
                    [invocation setArgument:&amp;value atIndex:i];
                    break;
                }
            }
</code></p>
<p>当参数类型是指针的时候进行一个判断，如果指针所指的是id类型。则将JPBoxing加入到一个_markArray中。</p>
<p><code>objc
//...
[invocation invoke];
    if ([_markArray count] &gt; 0) {
        for (JPBoxing *box in _markArray) {
            void *pointer = [box unboxPointer];
            id obj = *((__unsafe_unretained id *)pointer);
            if (obj) {
                @synchronized(_TMPMemoryPool) {
                    [_TMPMemoryPool setObject:obj forKey:[NSNumber numberWithInteger:[obj hash]]];
                }
            }
        }
    }
</code></p>
<p>如果_markArray大小不为零，则将数组中的JPBoxing中指针所指对象加入到内存池中（key为对象的hashCode），使得自动释放对象被强引用。</p>
<p><code>objc
context[@"releaseTmpObj"] = ^void(JSValue *jsVal) {
        if ([[jsVal toObject] isKindOfClass:[NSDictionary class]]) {
            void *pointer =  [(JPBoxing *)([jsVal toObject][@"__obj"]) unboxPointer];
            id obj = *((__unsafe_unretained id *)pointer);
            @synchronized(_TMPMemoryPool) {
                [_TMPMemoryPool removeObjectForKey:[NSNumber numberWithInteger:[obj hash]]];
            }
        }
    };
</code>    </p>
<p>JSPatch脚本中调用<code>releaseTmpObj</code>方法手动释放该临时对象。</p>
<h2 id="七、总结"><a name="conclusion">七、总结</a></h2>
<p>JSPatch中我的总结如下：</p>
<p>1、 为支持C API的扩展，增加了对指针和Class变量的封装以及拆解。因为JS中并不能使用以及声明一个指针，而在C API中，指针作为参数是非常常见的，所以需要将指针封装在一个JPBoxing中，并以{“__ className”:”JPBoxing”，”__ obj”:[JPBoxing boxPointer:pointer]}的形式回传回JS。下次调用的时候再将__obj中的指针拆解出来。</p>
<p>2、 支持对第三方库的调用。在include方法中增加了对第三方js库调用的支持。</p>
<p>3、 添加了sizeof方法。通过遍历加载到JS中的Extension中实现JPExtension协议的<code>- (size_t)sizeOfStructWithTypeName:(NSString * )typeName</code>方法，使得在JS端可以通过传入一个字符串的形式:<code>sizeof(&#39;CGRect&#39;)</code>来获取不同strut类型变量的大小，配合JPMemory扩展中的方法可以malloc出一块指定大小的内存，传入到某些C API中。</p>
<p>4、 添加JPMemory扩展，Javascript中是无法操作具体的内存也没有指针的概念，但是通过JPMemory扩展，可以让JSPatch拥有操作与访问内存的功能，以及获取对象的指针、指针的指针的功能。</p>
<p>5、 添加了保存的__autoreleasing对象机制，使自动释放对象在返回到JS运行环境的时候不会被自动释放，在JS脚本可以继续访问。使用一个NSDictonry作为临时自动释放对象的内存池，当生成一个自动释放对象后，将其添加到内存池中(key为其内存地址)，使得这个自动释放对象被内存池强引用。保证了在JS环境中可以访问到该对象，不需要的时候再手动释放该对象(remove掉内存池的对象)。</p>
<h4 id="维护："><strong>维护：</strong></h4>
<p>1、 修复了在JS中<a href="https://github.com/bang590/JSPatch/commit/3c9a10cd86fc13f7e0909bb3a2a93bba286aa1c9" target="_ blank" rel="external">传递nil参数时造成的崩溃</a>。JavaScript中并没有nil这个类型的参数，只有undefined以及null类型。桥接的时候JavascriptCore.framework会将js中的null类型转换为OC中的[NSNull null]类型，所以在调用方法时必须加以判断，将[NSNull null]转换为nil。为了防止真需要传递[NSNull null]参数，在JS中设置了一个名为nsnull的全局变量，开发者如要传递[NSNull null]则可以使用nsnull。</p>
<p>2、 修复了使用JSPatch判断struct时造成的<a href="https://github.com/bang590/JSPatch/commit/6df89bec6c8f4217500be316832fecbd898d1b46" target="_ blank" rel="external">误判</a>。原作者bang原本使用的@encode()方法产生的C字符串来遍历加载到JS中的所有extension的<code>- (size_t)sizeOfStructWithTypeEncode:(NSString * )typeName</code>方法，@encode产生结果是这样的形式:<code>{CGPoint=dd}</code>，并使用</p>
<p><code>objc
typeEncode rangeOfString:@"CGPoint"].location != NSNotFound;
</code></p>
<p>进行匹配。但事实上这样的方法是会导致CGPoint被误判为CGRect，因为CGRect进行@encode的结果为<code>{CGRect={CGPoint=dd}{CGSize=dd}}</code>。而后bang提议改为</p>
<p><code>objc
[typeEncode rangeOfString:@"CGPoint"].location == 1;
</code></p>
<p>但是这样会与sizeof功能有所冲突，而且在随后的测试中我发现@encode(NSRange)的结果为<code>{_NSRange=QQ}</code>，所以检测location==1也是不可以行的。最后我通过<a href="https://github.com/bang590/JSPatch/blob/6df89bec6c8f4217500be316832fecbd898d1b46/JSPatch/JPEngine.m#L1003" target="_ blank" rel="external">提取出typeEncode中第一个Struct的名字</a>解决了这一问题</p>
<p>3、 修复了JSPatch添加Extension时造成<a href="https://github.com/bang590/JSPatch/commit/c20e2910ee8e73e3ae22db071a43072c9e6ca149" target="_ blank" rel="external">无限循环加载</a>的问题。</p>
<p>代码提交情况: <a href="https://github.com/bang590/JSPatch/graphs/contributors" target="_ blank" rel="external">1916++ / 348—</a> 及 <a href="https://github.com/bang590/JSPatch/commits/master" target="_ blank" rel="external">commit log</a></p>
<h4 id="未来计划">未来计划</h4>
<p>JSPatch功能上已能满足hot fix动态修复的基本需求。接下来的工作重点主要添加脚本的传输和脚本加密的机制，防止未授权的第三方对脚本进行串改；集成进项目中测试实际性能和内存占用情况，改善性能；根据业务需求继续添加常用扩展API。</p>
<p>（持续更新中…）</p>
]]></content>
  </entry>
  
</feed>
