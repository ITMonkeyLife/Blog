<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: React Native | IT Monkey Life]]></title>
  <link href="http://ITMonkeyLife.github.io/Blog/blog/categories/react-native/atom.xml" rel="self"/>
  <link href="http://ITMonkeyLife.github.io/Blog/"/>
  <updated>2016-11-22T14:08:56+08:00</updated>
  <id>http://ITMonkeyLife.github.io/Blog/</id>
  <author>
    <name><![CDATA[Rick]]></name>
    <email><![CDATA[382542165@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Native的Text]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2016/11/22/react-nativede-text/"/>
    <updated>2016-11-22T10:24:38+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2016/11/22/react-nativede-text</id>
    <content type="html"><![CDATA[<p>
用于显示文本的React组件。

文本支持嵌套，样式和触摸处理。

在以下示例中，嵌套标题和正文文本将从styles.baseText继承fontFamily，但标题提供了自己的附加样式。 标题和主体将叠加在一起，因为文字换行：
```javascript
import React, { Component } from 'react';
import { AppRegistry, Text, StyleSheet } from 'react-native';

class TextInANest extends Component {
  constructor(props) {
    super(props);
    this.state = {
      titleText: "Bird's Nestaaa",
      bodyText: 'This is not really a bird nest.'
    };
  }

  render() {
    return (
      &lt;Text style={styles.baseText}&gt;
        &lt;Text style={styles.titleText} onPress={this.onPressTitle}&gt;
          {this.state.titleText}{'\n'}{'\n'}
        
        &lt;Text numberOfLines={5}&gt;
          {this.state.bodyText}
        
      
    );
  }
}

const styles = StyleSheet.create({
  baseText: {
    fontFamily: 'Cochin',
  },
  titleText: {
    fontSize: 20,
    fontWeight: 'bold',
  },
});

// App registration and rendering
AppRegistry.registerComponent('TextInANest', () =&gt; TextInANest);
```
</p>
<!--more-->
<h3>
处理文本输入
</h3>
<p>
TextInput是一个基本组件，允许用户输入文本。 它有一个onChangeText prop，它接受一个函数，每次文本改变时被调用，和一个onSubmitEditing prop，当一个函数被提交时被调用。

例如，让我们说，当用户键入时，您将他们的词翻译成不同的语言。 在这种新语言中，每个单词的写法都是一样的：🍕。 所以句子“Hello there Bob”将翻译为“🍕🍕🍕”。
```javascript
import React, { Component } from 'react';
import { AppRegistry, Text, TextInput, View } from 'react-native';

class PizzaTranslator extends Component {
  constructor(props) {
    super(props);
    this.state = {text: ''};
  }

  render() {
    return (
      &lt;View style=&gt;
        &lt;TextInput
          style=
          placeholder="Type here to translate!"
          onChangeText={(text) =&gt; this.setState({text})}
        /&gt;
        &lt;Text style=&gt;
          {this.state.text.split(' ').map((word) =&gt; word &amp;&amp; '🍕').join(' ')}
        
      
    );
  }
}

AppRegistry.registerComponent('PizzaTranslator', () =&gt; PizzaTranslator);
```
在这个例子中，我们将文本存储在状态中，因为它随时间而变化。

还有很多事情你可能想做一个文本输入。 例如，您可以在用户键入时验证内部的文本。 有关更多详细示例，请参阅受控组件上的React文档，或TextInput的参考文档。

文本输入可能是其状态随时间自然改变的组件的最简单的示例。
</p>
<h3>
嵌套文本
</h3>
<p>
iOS和Android都允许通过使用粗体或彩色文本（在iOS上为NSAttributedString，Android上为SpannableString）等特定格式设置字符串的范围来显示格式化的文本。 在实践中，这是非常乏味。 对于React Native，我们决定使用Web范例，在这里你可以嵌套文本来实现相同的效果。
```javascript
import React, { Component } from 'react';
import { AppRegistry, Text } from 'react-native';

class BoldAndBeautiful extends Component {
  render() {
    return (
      &lt;Text style=&gt;
        I am bold
        &lt;Text style=&gt;
          and red
        
      
    );
  }
}

AppRegistry.registerComponent('BoldAndBeautiful', () =&gt; BoldAndBeautiful);
```
在幕后，React Native将其转换为包含以下信息的平面NSAttributedString或SpannableString：
```
"I am bold and red"
0-9: bold
9-17: bold, red
```
</p>
<h3>
嵌套视图（仅限iOS）
</h3>
<p>
在iOS上，您可以在文本组件中嵌套视图。 这里有一个例子：
```javascript
import React, { Component } from 'react';
import { AppRegistry, Text, View } from 'react-native';

class BlueIsCool extends Component {
  render() {
    return (
      <text>
        There is a blue square
        &lt;View style= /&gt;
        in between my text.
      </text>
    );
  }
}

AppRegistry.registerComponent('BlueIsCool', () =&gt; BlueIsCool);
```
<blockquote>
为了使用此功能，您必须给视图一个宽度和高度。
</blockquote>
</p>
<h3>
容器
</h3>
<p>
<text>元素相对于布局是特殊的：内部的一切不再使用flexbox布局，而是使用文本布局。 这意味着<text>中的元素不再是矩形，而是当它们看到行的末尾时换行。
```html
<text>
  <text>First part and </text>
  <text>second part</text>
</text>
// Text container: all the text flows as if it was one
// |First part |
// |and second |
// |part       |

<view>
  <text>First part and </text>
  <text>second part</text>
</view>
// View container: each text is its own block
// |First part |
// |and        |
// |second part|
```

<h3>
有限样式继承
</h3>
<p>
在网络上，设置整个文档的字体系列和大小的通常方法是写：
```css
/* CSS, *not* React Native */
html {
  font-family: 'lucida grande', tahoma, verdana, arial, sans-serif;
  font-size: 11px;
  color: #141823;
}
```
当浏览器试图渲染文本节点时，它将一直到树的根元素，并找到一个具有font-size属性的元素。 这个系统的一个意想不到的属性是任何节点都可以有font-size属性，包括一个<div>。 这是为了方便，即使不是真的语义正确。

在React Native中，我们对它更严格：你必须将所有的文本节点包装在<text>组件内; 您不能在<view>下直接放置文本节点。
```html
// BAD: will raise exception, can't have a text node as child of a <view>
<view>
  Some text
</view>

// GOOD
<view>
  <text>
    Some text
  </text>
</view>
```
您还失去为整个子树设置默认字体的能力。 在应用程序中使用一致的字体和大小的建议方法是创建一个包含它们的组件MyAppText，并在整个应用程序中使用此组件。 您还可以使用此组件为其他类型的文本创建更具体的组件，如MyAppHeaderText。
```html
<view>
  <myapptext>Text styled with the default font for the entire application</myapptext>
  <myappheadertext>Text styled as a header</myappheadertext>
</view>
```
假设MyAppText是一个通过样式简单地将其子代渲染为Text组件的组件，则MyAppHeaderText可以定义如下：
```javascript
class MyAppHeaderText extends Component {
  render() {
    <myapptext>
      &lt;Text style=&gt;
        {this.props.children}
      
    </myapptext>
  }
}
```
以这种方式组合MyAppText确保我们从顶级组件获取样式，但让我们能够在特定用例中添加/覆盖它们。

React Native仍然具有样式继承的概念，但仅限于文本子树。 在这种情况下，第二部分将是粗体和红色。
```html
&lt;Text style=&gt;
  I am bold
  &lt;Text style=&gt;
    and red
  

```
我们相信，这种更受限制的样式文本的方式将产生更好的应用程序：
<ul>
<li>（开发者）React组件的设计考虑了强烈的隔离：你应该能够在应用程序的任何地方放置一个组件，相信只要<code>props</code>是相同的，它将看起来和行为相同的方式。 可以从<code>props</code>外继承的文本属性会破坏这种隔离。</li>
<li>（实现者）React Native的实现也被简化。 我们不需要在每个单个元素上都有一个fontFamily字段，并且我们不需要在每次显示文本节点时都将树遍历到根。 样式继承仅在原生Text组件内编码，不会泄漏到其他组件或系统本身。</li>
</ul>

</view></view></text></div></p></text></text></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native的布局]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2016/11/22/react-nativede-style/"/>
    <updated>2016-11-22T09:48:39+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2016/11/22/react-nativede-style</id>
    <content type="html"><![CDATA[<h2>
Style样式
</h2>
<p>
使用React Native，不要使用特殊语言或语法来定义样式。 你只需使用JavaScript来设计你的应用程序。 所有的核心组件接受<code>props</code>命名风格。 样式名称和值通常匹配CSS在Web上的工作方式，除了名称被写为<em>backgroundColor</em>而不是像<em>background-color</em>。

样式prop可以是一个普通的旧JavaScript对象。 这是最简单的，我们通常用于示例代码。 您还可以传递样式数组 - 数组中的最后一个样式具有优先级，因此可以使用它来继承样式。

由于组件的复杂性增加，使用<em>StyleSheet.create</em>在一个位置定义多个样式通常更加清晰。 这里有一个例子：
```javascript
import React, { Component } from 'react';
import { AppRegistry, StyleSheet, Text, View } from 'react-native';

class LotsOfStyles extends Component {
  render() {
    return (
      <view>
        &lt;Text style={styles.red}&gt;just red
        &lt;Text style={styles.bigblue}&gt;just bigblue
        &lt;Text style={[styles.bigblue, styles.red]}&gt;bigblue, then red
        &lt;Text style={[styles.red, styles.bigblue]}&gt;red, then bigblue
      </view>
    );
  }
}

const styles = StyleSheet.create({
  bigblue: {
    color: 'blue',
    fontWeight: 'bold',
    fontSize: 30,
  },
  red: {
    color: 'red',
  },
});

AppRegistry.registerComponent('LotsOfStyles', () =&gt; LotsOfStyles);
```
一个常见的模式是使你的组件接受一个样式属性，反过来，它被用于样式子组件。 你可以使用它来使样式“级联”他们在CSS中的方式。
<!--more-->
有很多自定义文本样式的方法。 查看<a href="">Text组件引用</a>以获取完整列表。

现在你可以让你的文本美丽。 成为风格大师的下一步是学习如何控制组件大小。
</p>
<h2>
高和宽
</h2>
<p>
组件的高度和宽度决定了其在屏幕上的大小。
</p>
<h3>
固定尺寸
</h3>
<p>
设置组件尺寸的最简单的方法是通过向样式添加固定的宽度和高度。 React Native中的所有维都是无单位的，表示与密度无关的像素。
```html
import React, { Component } from 'react';
import { AppRegistry, View } from 'react-native';

class FixedDimensionsBasics extends Component {
  render() {
    return (
      <view>
        &lt;View style={ {width: 50, height: 50, backgroundColor: 'powderblue'} } /&gt;
        &lt;View style={ {width: 100, height: 100, backgroundColor: 'skyblue'} } /&gt;
        &lt;View style={ {width: 150, height: 150, backgroundColor: 'steelblue'} } /&gt;
      </view>
    );
  }
};

AppRegistry.registerComponent('AwesomeProject', () =&gt; FixedDimensionsBasics);
```
以此方式设置尺寸对于始终按照完全相同的大小呈现的组件而言是常见的，而不管屏幕尺寸如何。
</p>
<h3>
Flex尺寸
</h3>
<p>
在组件的样式中使用flex，以根据可用空间动态地展开和缩小组件。 通常你将使用flex：1，它告诉组件填充所有可用空间，在相同的父组件之间均匀分配。 给定的flex越大，组件与其兄弟节点相比所需的空间比例越高。
<blockquote>
如果组件的父级的尺寸大于0，则组件只能扩展以填充可用空间。如果父级组件不具有固定宽度和高度或flex，则父级的尺寸为0，而flex子组件将不可见。
</blockquote>
```html
import React, { Component } from 'react';
import { AppRegistry, View } from 'react-native';

class FlexDimensionsBasics extends Component {
  render() {
    return (
      // Try removing the `flex: 1` on the parent View.
      // The parent will not have dimensions, so the children can't expand.
      // What if you add `height: 300` instead of `flex: 1`?
      &lt;View style={ {flex: 1} }&gt;
        &lt;View style={ {flex: 1, backgroundColor: 'powderblue'} } /&gt;
        &lt;View style={ {flex: 2, backgroundColor: 'skyblue'} } /&gt;
        &lt;View style={ {flex: 3, backgroundColor: 'steelblue'} } /&gt;
      
    );
  }
};

AppRegistry.registerComponent('AwesomeProject', () =&gt; FlexDimensionsBasics);
```
在您可以控制组件的大小后，下一步是学习如何将其放在屏幕上。
</p>
<h2>
使用Flexbox布局
</h2>
<p>
组件可以使用flexbox算法指定其子项的布局。 Flexbox旨在在不同的屏幕尺寸上提供一致的布局。

你通常会使用flexDirection，alignItems和justifyContent的组合来实现正确的布局。
<blockquote>
Flexbox在React Native中的工作方式与在Web上的CSS中的工作方式相同，但有一些例外。 默认值不同，flexDirection默认为column而不是row，alignItems默认为stretch而不是flex-start，flex参数只支持一个数字。
</blockquote>
</p>
<h3>
Flex方向
</h3>
<p>
将flexDirection添加到组件的样式确定其布局的主轴。 孩子们应该是水平（行）还是垂直（列）组织？ 默认值为column。
```html
import React, { Component } from 'react';
import { AppRegistry, View } from 'react-native';

class FlexDirectionBasics extends Component {
  render() {
    return (
      // Try setting `flexDirection` to `column`.
      &lt;View style={ {flex: 1, flexDirection: 'row'} }&gt;
        &lt;View style={ {width: 50, height: 50, backgroundColor: 'powderblue'} } /&gt;
        &lt;View style={ {width: 50, height: 50, backgroundColor: 'skyblue'} } /&gt;
        &lt;View style={ {width: 50, height: 50, backgroundColor: 'steelblue'} } /&gt;
      
    );
  }
};

AppRegistry.registerComponent('AwesomeProject', () =&gt; FlexDirectionBasics);
```
</p>
<h3>
证明内容
</h3>
<p>
将justifyContent添加到组件的样式确定沿主轴的子项分布。 是否应该在开始，中心，结束或均匀分布children？ 可用选项包括flex-start，center，flex-end，space-around和space-between。
```html
import React, { Component } from 'react';
import { AppRegistry, View } from 'react-native';

class JustifyContentBasics extends Component {
  render() {
    return (
      // Try setting `justifyContent` to `center`.
      // Try setting `flexDirection` to `row`.
      &lt;View style={ {
        flex: 1,
        flexDirection: 'column',
        justifyContent: 'space-between',
      } }&gt;
        &lt;View style={ {width: 50, height: 50, backgroundColor: 'powderblue'} } /&gt;
        &lt;View style={ {width: 50, height: 50, backgroundColor: 'skyblue'} } /&gt;
        &lt;View style={ {width: 50, height: 50, backgroundColor: 'steelblue'} } /&gt;
      
    );
  }
};

AppRegistry.registerComponent('AwesomeProject', () =&gt; JustifyContentBasics);
```
</p>
<h3>
对齐
</h3>
<p>
将alignItems添加到组件的样式确定沿辅助轴的子对齐（如果主轴是行，则辅助轴是列，反之亦然）。 children应该在开始，中心，结束，还是伸展填充？ 可用选项有flex-start，center，flex-end和stretch。
<blockquote>
为了拉伸有效果，children不得沿着辅助轴具有固定尺寸。 在下面的示例中，设置alignItems：stretch不执行任何操作，直到宽度：50从子项中删除。
</blockquote>
```html
import React, { Component } from 'react';
import { AppRegistry, View } from 'react-native';

class AlignItemsBasics extends Component {
  render() {
    return (
      // Try setting `alignItems` to 'flex-start'
      // Try setting `justifyContent` to `flex-end`.
      // Try setting `flexDirection` to `row`.
      &lt;View style={ {
        flex: 1,
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
      } }&gt;
        &lt;View style={ {width: 50, height: 50, backgroundColor: 'powderblue'} } /&gt;
        &lt;View style={ {width: 50, height: 50, backgroundColor: 'skyblue'} } /&gt;
        &lt;View style={ {width: 50, height: 50, backgroundColor: 'steelblue'} } /&gt;
      
    );
  }
};

AppRegistry.registerComponent('AwesomeProject', () =&gt; AlignItemsBasics);
```
</p>
<h3>
深入探讨
</h3>
<p>
我们已经介绍了基础知识，但是有许多其他样式可能需要布局。 控制布局的道具的完整列表在<a href="http://facebook.github.io/react-native/docs/layout-props.html">这里</a>记录。

我们正在接近能够构建一个真正的应用程序。 我们还缺少一个方法来接受用户输入，所以让我们继续学习如何使用TextInput组件处理文本输入。
</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native的State]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2016/11/22/react-nativede-state/"/>
    <updated>2016-11-22T09:45:39+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2016/11/22/react-nativede-state</id>
    <content type="html"><![CDATA[<p>
有两种类型的数据控制组件：props和state。 props由父节点设置，它们在组件的整个生命周期中都是固定的。 对于要改变的数据，我们必须使用状态。

一般来说，你应该在构造函数中初始化状态，然后当你想改变它时调用setState。

例如，假设我们想让文本一直闪烁。 文本本身在创建闪烁组件时设置一次，因此文本本身是一个<code>props</code>。 “文本是否当前打开或关闭”随时间改变，所以应保持状态。
```javascript
import React, { Component } from 'react';
import { AppRegistry, Text, View } from 'react-native';

class Blink extends Component {
  constructor(props) {
    super(props);
    this.state = {showText: true};

    // Toggle the state every second
    setInterval(() =&gt; {
      this.setState({ showText: !this.state.showText });
    }, 1000);
  }

  render() {
    let display = this.state.showText ? this.props.text : ' ';
    return (
      <text>{display}</text>
    );
  }
}

class BlinkApp extends Component {
  render() {
    return (
      <view>
        <blink text="I love to blink" />
        <blink text="Yes blinking is so great" />
        <blink text="Why did they ever take this out of HTML" />
        <blink text="Look at me look at me look at me" />
      </view>
    );
  }
}

AppRegistry.registerComponent('BlinkApp', () =&gt; BlinkApp);
```
在实际应用中，您可能不会使用计时器设置状态。 您可以在从服务器收到新数据或用户输入时设置状态。 您还可以使用状态容器（如<a href="http://redux.js.org/index.html">Redux</a>）来控制数据流。 在这种情况下，您将使用Redux来修改状态，而不是直接调用setState。
<!--more-->
State的工作方式与React中的相同，因此有关处理状态的更多详细信息，可以查看<a href="https://facebook.github.io/react/docs/component-api.html">React.Component API</a>。

在这一点上，你可能会感到懊恼，我们的大多数示例迄今为止使用无聊的默认黑色文本。 为了使事情更美丽，你必须学习风格。
</p>
<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native的Props]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2016/11/22/react-nativede-props/"/>
    <updated>2016-11-22T09:37:53+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2016/11/22/react-nativede-props</id>
    <content type="html"><![CDATA[<p>
大多数组件可以在创建时使用不同的参数进行自定义。 这些创建参数称为<code>props</code>。

例如，一个基本的React Native组件是Image。 当您创建图像时，可以使用prop命名<code>source</code>来控制其显示的图像。
```javascript
import React, { Component } from 'react';
import { AppRegistry, Image } from 'react-native';

class Bananas extends Component {
  render() {
    let pic = {
      uri: 'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg'
    };
    return (
      &lt;Image source={pic} style=/&gt;
    );
  }
}

AppRegistry.registerComponent('Bananas', () =&gt; Bananas);
```
注意<em>{pic}</em>被大括号括起来，以将变量<em>pic</em>嵌入到JSX中。 你可以把任何JavaScript表达式放在大括号内JSX。

你自己的组件也可以使用<em>props</em>。 这样，您可以在应用程序的许多不同位置创建单个组件，每个位置的属性略有不同。 只需在<em>render</em>函数中引用<em>this.props</em>。 这里有一个例子：
```javascript
import React, { Component } from 'react';
import { AppRegistry, Text, View } from 'react-native';

class Greeting extends Component {
  render() {
    return (
      <text>Hello {this.props.name}!</text>
    );
  }
}

class LotsOfGreetings extends Component {
  render() {
    return (
      &lt;View style=&gt;
        <greeting name="Rexxar" />
        <greeting name="Jaina" />
        <greeting name="Valeera" />
      
    );
  }
}

AppRegistry.registerComponent('LotsOfGreetings', () =&gt; LotsOfGreetings);
```
使用名称作为<code>props</code>，我们可以自定义<em>Greeting</em>组件，因此我们可以为每个问候重复使用该组件。 此示例还在JSX中使用Greeting组件，就像内置组件一样。 做到这一点的力量是什么使React这么酷 - 如果你发现自己希望有一组不同的UI原语来工作，你只是发明新的。
<!--more-->
另一个新的东西在这里是视图组件。 视图可用作其他组件的容器，以帮助控制样式和布局。

使用<code>props</code>和基本的文本，图像和视图组件，您可以构建各种各样的静态屏幕。 要了解如何让您的应用随时间变化，您需要了解状态。
</p>
<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSX从0到1]]></title>
    <link href="http://ITMonkeyLife.github.io/Blog/blog/2016/11/21/jsxcong-0dao-1/"/>
    <updated>2016-11-21T17:45:01+08:00</updated>
    <id>http://ITMonkeyLife.github.io/Blog/blog/2016/11/21/jsxcong-0dao-1</id>
    <content type="html"><![CDATA[<p>
什么是JSX。我们先看一段代码,考虑这个变量声明：
```javascript
const element = <h1>Hello, world!</h1>;
```
这个有趣的标签语法既不是字符串也不是HTML。

它被称为JSX，它是JavaScript的语法扩展。 我们建议使用它与React来描述UI应该是什么样子。 JSX可以提醒你一个模板语言，但它伴随着JavaScript的全部力量。

JSX产生React“元素”。 我们将在下一节中探讨将它们渲染到DOM。 下面，你可以找到JSX的基础知识，让你开始。
</p>
<h3>
在JSX中嵌入表达式
</h3>
<p>
您可以通过将其包含在大括号中来在JSX中嵌入任何<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions">JavaScript表达式</a>。

例如，2 + 2，user.name和formatName（user）都是有效的表达式：
```javascript
function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

const user = {
  firstName: 'Harper',
  lastName: 'Perez'
};

const element = (
  <h1>
    Hello, {formatName(user)}!
  </h1>
);

ReactDOM.render(
  element,
  document.getElementById('root')
);
```
我们将JSX拆分为多行以提高可读性。 虽然这不是强制性的，但当执行此操作时，我们还建议将其括在括号中，以避免<a href="http://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi">自动分号插入</a>的陷阱。
</p>
<h3>
JSX是一个表达式
</h3>
<p>
编译后，JSX表达式成为常规JavaScript对象。这意味着您可以在if语句和for循环中使用JSX，将其分配给变量，将其接受为参数，然后从函数中返回：
```javascript
function getGreeting(user) {
  if (user) {
    return <h1>Hello, {formatName(user)}!</h1>;
  }
  return <h1>Hello, Stranger.</h1>;
}
```
</p>
<!--more-->
<h3>
使用JSX指定属性
</h3>
<p>
您可以使用引号将字符串文字指定为属性：
```javascript
const element = <div tabindex="0"></div>;
```
您还可以使用大括号在属性中嵌入JavaScript表达式：
```javascript
const element = &lt;img src={user.avatarUrl}&gt;;
```
</p>
<h3>
使用JSX指定子项
</h3>
<p>
如果标记为空，您可以使用<code>/&gt;</code>立即关闭它，例如XML：
```javascript
const element = &lt;img src={user.avatarUrl} /&gt;;
```
JSX标签可能包含子元素：
```javascript
const element = (
  <div>
    <h1>Hello!</h1>
    <h2>Good to see you here.</h2>
  </div>
);
```
<blockquote>
警告：
由于JSX比HTML更接近JavaScript，React DOM使用camelCase属性命名约定而不是HTML属性名称。
例如，类在JSX中变为<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/className"><code>className</code></a>，tabindex变为<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex"><code>tabIndex</code></a>。
</blockquote>
</p>
<h3>
JSX防止注入攻击
</h3>
<p>
在JSX中嵌入用户输入是安全的：
```javascript
const title = response.potentiallyMaliciousInput;
// This is safe:
const element = <h1>{title}</h1>;
```
默认情况下，React DOM在渲染它们之前转义嵌入在JSX中的<a href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html">任何值</a>。 因此，它确保你不能注入没有明确写在你的应用程序中的任何东西。 在渲染之前，一切都转换为字符串。 这有助于防止<a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS（跨站点脚本）</a>攻击。
</p>
<h3>
JSX表示对象
</h3>
<p>
Babel将JSX编译为React.createElement（）调用。

这两个例子是相同的：
```javascript
const element = (
  <h1 classname="greeting">
    Hello, world!
  </h1>
);
```
```javascript
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
```
React.createElement（）执行一些检查，以帮助您编写无错误的代码，但本质上，它创建一个对象像这样：
```javascript
// Note: this structure is simplified
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world'
  }
};
```
这些对象称为“React元素”。 你可以把它们想象成你想在屏幕上看到的描述。 React读取这些对象，并使用它们构造DOM并保持其为最新。

我们将在下一节中探索渲染React元素到DOM。
<blockquote>
提示：
我们建议为您选择的编辑器搜索“Babel”语法方案，以便正确突出显示ES6和JSX代码。
</blockquote>
</p>
<h2>
更深层次解读JSX
</h2>
<p>
从根本上说，JSX只是为React.createElement（component，props，... children）函数提供语法更方便。 JSX代码：
```javascript
&lt;MyButton color="blue" shadowSize={2}&gt;
  Click Me

```
编译成
```javascript
React.createElement(
  MyButton,
  {color: 'blue', shadowSize: 2},
  'Click Me'
)
```
如果没有子代，也可以使用标记的自关闭形式。 所以：
```javascript
<div classname="sidebar"></div>
```
编译成
```javascript
React.createElement(
  'div',
  {className: 'sidebar'},
  null
)
```
如果你想测试一些特定的JSX是如何转换成JavaScript，你可以试试<a href="https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-0&amp;code=function%20hello()%20%7B%0A%20%20return%20%3Cdiv%3EHello%20world!%3C%2Fdiv%3E%3B%0A%7D">在线Babel编译器</a>。
</p>
<h3>
指定React元素类型
</h3>
<p>
JSX标记的第一部分决定了React元素的类型。

大写的类型表示JSX标记指的是React组件。 这些标签被编译为对指定变量的直接引用，因此如果使用JSX<code> <foo /> </code>表达式，Foo必须在范围内。
</p>
<h4>
React必须在范围内
</h4>
<p>
由于JSX编译为对React.createElement的调用，因此React库也必须始终在JSX代码的作用域中。

例如，这两个导入在这段代码中是必要的，即使React和CustomButton没有直接从JavaScript引用：
```javascript
import React from 'react';
import CustomButton from './CustomButton';

function WarningButton() {
  // return React.createElement(CustomButton, {color: 'red'}, null);
  return <custombutton color="red" />;
}
```
如果不使用JavaScript绑定器并将React添加为脚本标记，则它已作为<code>React</code>全局范围。
</p>
<h3>
对JSX类型使用点表示法
</h3>
<p>
您还可以使用JSX中的点表示法来引用React组件。 如果您有一个模块导出许多React组件，这很方便。 例如，如果MyComponents.DatePicker是一个组件，您可以直接从JSX使用它：
```javascript
import React from 'react';

const MyComponents = {
  DatePicker: function DatePicker(props) {
    return <div>Imagine a {props.color} datepicker here.</div>;
  }
}

function BlueDatePicker() {
  return <mycomponents.datepicker color="blue" />;
}
```
</p>
<h3>
用户定义的组件必须大写
</h3>
<p>
当元素类型以小写字母开头时，它指向一个内置组件，如<div>或<span>，并生成一个字符串'div'或'span'传递给React.createElement。 以大写字母开头的类型，如<code><foo /></code>编译为React.createElement（Foo），并且对应于在JavaScript文件中定义或导入的组件。

我们建议使用大写字母命名组件。 如果你有一个以小写字母开头的组件，请在JSX中使用它之前将它分配给大写的变量。

例如，此代码不会按预期运行：
```javascript
import React from 'react';

// Wrong! This is a component and should have been capitalized:
function hello(props) {
  // Correct! This use of <div> is legitimate because div is a valid HTML tag:
  return <div>Hello {props.toWhat}</div>;
}

function HelloWorld() {
  // Wrong! React thinks <hello /> is an HTML tag because it's not capitalized:
  return <hello towhat="World" />;
}
```
要解决这个问题，我们将hello重命名为Hello，并在引用它时使用<code><hello /></code>：
```javascript
import React from 'react';

// Correct! This is a component and should be capitalized:
function Hello(props) {
  // Correct! This use of <div> is legitimate because div is a valid HTML tag:
  return <div>Hello {props.toWhat}</div>;
}

function HelloWorld() {
  // Correct! React knows <hello /> is a component because it's capitalized.
  return <hello towhat="World" />;
}
```

<h3>
在运行时选择类型
</h3>
<p>
不能将常规表达式用作React元素类型。 如果你想使用一个通用表达式来表示元素的类型，只需首先将它分配给一个大写的变量。 这通常出现在当你想基于一个道具渲染一个不同的组件：
```javascript
import React from 'react';
import { PhotoStory, VideoStory } from './stories';

const components = {
  photo: PhotoStory,
  video: VideoStory
};

function Story(props) {
  // Wrong! JSX type can't be an expression.
  return &lt;components[props.storyType] story={props.story} /&gt;;
}
```
为了解决这个问题，我们将首先将类型指定为大写变量：
```javascript
import React from 'react';
import { PhotoStory, VideoStory } from './stories';

const components = {
  photo: PhotoStory,
  video: VideoStory
};

function Story(props) {
  // Correct! JSX type can be a capitalized variable.
  const SpecificStory = components[props.storyType];
  return &lt;SpecificStory story={props.story} /&gt;;
}
```
</p>
<h2>
在JSX中的props
</h2>
<p>
在JSX中指定props有几种不同的方法。
</p>
<h3>
JavaScript表达式
</h3>
<p>
你可以传递任何JavaScript表达式作为props，用{}包围它。 例如，在这个JSX中：
```javascript
&lt;MyComponent foo={1 + 2 + 3 + 4} /&gt;
```
对于MyComponent，props.foo的值将为10，因为表达式1 + 2 + 3 + 4得到计算。

if语句和for循环在JavaScript中不是表达式，因此它们不能在JSX中直接使用。 相反，你可以把这些在周围的代码。 例如：
```javascript
function NumberDescriber(props) {
  let description;
  if (props.number % 2 == 0) {
    description = <strong>even</strong>;
  } else {
    description = <i>odd</i>;
  }
  return <div>{props.number} is an {description} number</div>;
}
```
</p>
<h3>
字符串字面量
</h3>
<p>
你可以传递一个字符串文字作为props。 这两个JSX表达式是等价的：
```javascript
<mycomponent message="hello world" />

&lt;MyComponent message={'hello world'} /&gt;
```
当你传递一个字符串字面量时，它的值是HTML-unescaped。 所以这两个JSX表达式是等价的：
```javascript
&lt;MyComponent message =“＆lt; 3”/&gt;

&lt;MyComponent message = {'&lt;3'} /&gt;
```
此行为通常不相关。 这里只提到完整性。
</p>
<h3>
Props默认为“True”
</h3>
<p>
如果你不传递prop的值，它默认为true。 这两个JSX表达式是等价的：
```javascript
<mytextbox autocomplete="" />

&lt;MyTextbox autocomplete = {true} /&gt;
```
一般来说，我们不建议使用它，因为它可以与ES6对象简写{foo}，这是{foo：foo}的简称，而不是{foo：true}混淆。 这种行为只是在那里，以便它匹配HTML的行为。
</p>
<h3>
扩展属性
</h3>
<p>
如果你已经有props作为对象，并且你想在JSX中传递它，你可以使用...作为一个“spread”运算符传递整个props对象。 这两个组件是等效的：
```javascript
function App1() {
  return <greeting firstname="Ben" lastname="Hector" />;
}

function App2() {
  const props = {firstName: 'Ben', lastName: 'Hector'};
  return &lt;Greeting {...props} /&gt;;
}
```
当构建通用容器时，扩展属性可能很有用。 然而，他们也可以让你的代码凌乱，通过使很容易将大量不相关的props传递给不关心它们的组件。 我们建议您谨慎使用此语法。
</p>
<h2>
JSX中的子类
</h2>
<p>
在包含开始标记和结束标记的JSX表达式中，这些标记之间的内容作为特殊prop：props.children传递。 有几种不同的方式传递子类：
</p>
<h3>
字符串字面量
</h3>
<p>
你可以在开始和结束标签之间放一个字符串，props.children就是那个字符串。 这对许多内置的HTML元素很有用。 例如：
```javascript
<mycomponent>Hello world!</mycomponent>
```
这是有效的JSX，并且MyComponent中的props.children将只是字符串“Hello world！”。 HTML是非转义的，所以你一般可以写JSX就像你这样写HTML：
```javascript
<div>这是有效的HTML＆amp; JSX同时。&lt;/ div&gt;
```
JSX删除行的开始和结尾处的空格。 它也删除空白行。 与标签相邻的新行被删除; 在字符串文本中间出现的新行会缩合到单个空间中。 所以这些都渲染相同的事情：
```javascript
<div>Hello World</div>

<div>
  Hello World
</div>

<div>
  Hello
  World
</div>

<div>

  Hello World
</div>
```

<h3>
JSX 子类
</h3>
<p>
你可以提供更多的JSX元素作为孩子。 这对显示嵌套组件很有用：
```javascript
<mycontainer>
  <myfirstcomponent />
  <mysecondcomponent />
</mycontainer>
```
您可以将不同类型的子项混合在一起，因此可以与JSX子项一起使用字符串字面值。 这是JSX的另一种方式，就像HTML，所以这是有效的JSX和有效的HTML：
```javascript
<div>
  Here is a list:
  <ul>
    <li>Item 1</li>
    <li>Item 2</li>
  </ul>
</div>
```
React组件不能返回多个React元素，但是一个JSX表达式可以有多个子元素，因此如果你想要一个组件呈现多个东西，你可以将它包装在这样的div中。
</p>
<h3>
JS表达式
</h3>
<p>
您可以将任何JavaScript表达式作为子表达式传递，将其放在{}中。 例如，这些表达式是等价的：
```javascript
<mycomponent>foo</mycomponent>

<mycomponent>{'foo'}</mycomponent>
```
这通常用于呈现任意长度的JSX表达式的列表。 例如，这将呈现一个HTML列表：
```javascript
function Item(props) {
  return <li>{props.message}</li>;
}

function TodoList() {
  const todos = ['finish doc', 'submit pr', 'nag dan to review'];
  return (
    <ul>
      {todos.map((message) =&gt; &lt;Item key={message} message={message} /&gt;)}
    </ul>
  );
}
```
JS表达式可以与其他类型的孩子混合使用。 这通常用于替换字符串模板：
```javascript
function Hello(props) {
  return <div>Hello {props.addressee}!</div>;
}
```
</p>
<h3>
作为子类的函数
</h3>
<p>
通常，插入JSX中的JavaScript表达式将求值为字符串，React元素或这些事物的列表。 然而，props.children像任何其他道具一样工作，它可以传递任何类型的数据，而不只是React知道如何render的类。 例如，如果您有一个自定义组件，您可以将其作为props.children进行回调：
```javascript
function ListOfTenThings() {
  return (
    &lt;Repeat numTimes={10}&gt;
      {(index) =&gt; &lt;div key={index}&gt;This is item {index} in the list}
    
  );
}

// Calls the children callback numTimes to produce a repeated component
function Repeat(props) {
  let items = [];
  for (let i = 0; i &lt; props.numTimes; i++) {
    items.push(props.children(i));
  }
  return <div>{items}</div>;
}
```
传递给自定义组件的子项可以是任何东西，只要该组件将它们转换为React在render之前可以理解的东西即可。 这种用法不常见，但它的工作原理，如果你想扩展什么JSX的能力。
</p>
<h3>
忽略布尔值，空值和未定义
</h3>
<p>
false，null，undefined和true是有效的子类。 他们根本不render。 这些JSX表达式将呈现相同的东西：
```javascript
<div></div>

<div></div>

<div>{false}</div>

<div>{null}</div>

<div>{true}</div>
```
这对于有条件地呈现React元素很有用。 这个JSX只渲染一个<code><header /></code>如果showHeader为true：
```javascript
<div>
  {showHeader &amp;&amp; <header />}
  <content />
&lt;/div
```
一个警告是，一些<a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">“falsy”值</a>，如0号，仍然由React渲染。 例如，此代码将不会像您预期的那样工作，因为当props.messages是空数组时将打印0：
```javascript
<div>
  {props.messages.length &amp;&amp;
    &lt;MessageList messages={props.messages} /&gt;
  }
</div>
```
要解决这个问题，请确保&amp;&amp;之前的表达式始终是布尔值：
```javascript
<div>
  {props.messages.length &gt; 0 &amp;&amp;
    &lt;MessageList messages={props.messages} /&gt;
  }
</div>
```
相反，如果你想要一个值如false，true，null或undefined出现在输出中，你必须先将它<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#String_conversion">转换为字符串</a>：
```javascript
<div>
  My JavaScript variable is {String(myVariable)}.
</div>
```

<hr />
</div></p></div></p></div></div></span></div></p>
]]></content>
  </entry>
  
</feed>
