
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>JSPatch用法剖析 - IT Monkey Life</title>
	<meta name="author" content="Rick">

	
	<meta name="description" content="目录 JSPatch介绍
JSPatch VS Wax lua
JSPatch的原理和核心
JSPatch Extension机制
JSPatch中的实现技巧总结 遇到的问题与解决方法 一、JSPatch介绍
用途
iOS产品开发之中常常会遇到这种情况: 新版本上线后发现有个严重的bug， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/Blog/atom.xml" rel="alternate" title="IT Monkey Life" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">IT Monkey Life</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:ITMonkeyLife.github.io/Blog/">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
		<a class="rss" href="/Blog/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:ITMonkeyLife.github.io/Blog/">
	</form>
</nav>


</header>
	
		
	
	<div id="content" class="inner"><article class="post">
	<h2 class="title">JSPatch用法剖析</h2>
	<div class="entry-content"><h2 id="目录"><a name="jspatchIntroducton">目录</a></h2>
<ol>
<li><a href="#jspatchIntroducton"><strong>JSPatch介绍</strong></a></li>
<li><a href="#jspatch-wax"><strong>JSPatch VS Wax lua</strong></a></li>
<li><a href="#jspatch-core"><strong>JSPatch的原理和核心</strong></a></li>
<li><a href="#jspatch-Extension"><strong>JSPatch Extension机制</strong></a></li>
<li><a href="#jspatch-Tech"><strong>JSPatch中的实现技巧总结</strong></a> </li>
<li><a href="#jspatch-problem"><strong>遇到的问题与解决方法</strong></a></li>
</ol>
<h2 id="一、JSPatch介绍"><a name="jspatchIntroducton">一、JSPatch介绍</a></h2>
<h3 id="用途">用途</h3>
<p>iOS产品开发之中常常会遇到这种情况: 新版本上线后发现有个严重的bug，可能会导致crash率激增，可能会使网络请求无法发出，这时能做的只是赶紧修复bug然后提交等待漫长的AppStore审核，再盼望用户快点升级，付出巨大的人力和时间成本，才能完成此次bug的修复。</p>
<p>JSPatch的出现解决了这样的问题，只需要在项目中引入极小的JSPatch引擎，就可以使用JavaScript语言调用Objective-C的原生接口，获得脚本语言的能力：动态更新iOS APP，替换项目原生代码、快速修复bug。      </p>
<h3 id="技术核心">技术核心</h3>
<p>JSPatch核心主要是JSBinding和Objective-C中的runtime技术。一方面，它采用Apple在iOS7中发布的JavaScriptCore.framework作为Javascript引擎解析JavaScript脚本，执行JavaSript代码并与Objective-C端的代码进行桥接。另一方面则是使用Objective-C runtime中的method swizzling的方式达到使用JavaScript脚本动态替换原有Objective-C方法的目的，并利用ForwardInvocation标准消息转发机制使得在JavaScript脚本中调用Objective-C的方法成为可能。</p>
<!-- more -->
<h2 id="二、JSPatch_VS_lua_Wax"><a name="jspatch-wax">二、JSPatch VS lua Wax</a></h2>
<p>wax是可以实现动态打补丁快速修补Crash的另外一种解决方案，初衷是为了使用lua来编写iOS原生应用而诞生的一个框架。它利用lua的C语言API(可以让C代码与lua进行交互的函数集，包括读写lua全局变量的函数，调用lua函数的函数，运行lua代码片段的函数，注册C函数然后可以在lua中被调用的函数，等等)和 Objective-C 强大的runtime使lua能调用原生Objective-C接口，可以使用lua创建，继承，扩展oc类，使用lua实现oc所能实现的所有功能。</p>
<p>lua wax由几个部分组成:</p>
<ol>
<li><p>wax stdLib，是一个lua脚本库，利用前面提到的C API和Objective-C runtime向lua脚本提供与Objective-C类交互的接口;</p>
</li>
<li><p>Wax Engine，提供使用Objective-C加载运行lua脚本和传递变量给lua脚本的接口;</p>
</li>
<li><p>lua Compiler，即lua解释器，wax Engine调用解释器加载并编译运行lua脚本。<br /><img src="http://ww1.sinaimg.cn/bmiddle/68e55315gw1eu0af1y3asj20dp0ec3z0.jpg" alt="Wax lua" /></p>
</li>
</ol>
<p>相比于wax，    JSPatch有以下的优势</p>
<ol>
<li><p>Javascript比lua在应用开发领域有更广泛的应用。 目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JavaScript是不二之选。</p>
</li>
<li><p>更符合Apple的规则。iOS Developer Program License Agreement里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。</p>
</li>
<li><p>小巧。 使用系统内置的JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。而Wax需要导入c代码写的lua引擎。</p>
</li>
<li><p>不需要担心内存回收的问题。JavascriptCore.framework通过GC来对垃圾进行回收。而lua wax需要显式调用内存回收方法。</p>
</li>
<li><p>支持armv7 armv7s arm64框架。wax并不支持arm64框架。</p>
</li>
</ol>
<p>而JSPatch也有自身的缺点:</p>
<ol>
<li><p>不支持iOS6及以下，因为JSPatch依赖于iOS7及以后的JavascriptCore.framework (这点现在可以忽略，因为微信最低的版本要求已经是iOS7)</p>
</li>
<li><p>调用OC方法的性能慢于lua wax</p>
</li>
<li><p>启动JSPatch所占用的内存多于wax</p>
</li>
</ol>
<h2 id="三、JSPatch核心原理解析"><a name="jspatch-core">三、JSPatch核心原理解析</a></h2>
<h3 id="startEngine">startEngine</h3>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">JPEngine</span> <span class="n">startEngine</span><span class="p">];</span>
</span><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">sourcePath</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSBundle</span> <span class="n">mainBundle</span><span class="p">]</span> <span class="nl">pathForResource:</span><span class="s">@&quot;demo&quot;</span> <span class="nl">ofType:</span><span class="s">@&quot;js&quot;</span><span class="p">];</span>
</span><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">script</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithContentsOfFile:</span><span class="n">sourcePath</span> <span class="nl">encoding:</span><span class="n">NSUTF8StringEncoding</span> <span class="nl">error:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line"><span class="p">[</span><span class="n">JPEngine</span> <span class="nl">evaluateScript:</span><span class="n">script</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>使用JSPatch框架首先要调用<code>JPEngine</code>中的类方法<code>startEngine</code>，这个方法的是为了初始化JSContext，JSContext是JS脚本的运行环境。JS脚本可以调用在JSContext中预先定义的方法，方法的参数/返回值都会被JavaScriptCore.framework自动转换，OC里的NSArray，NSDictionary，NSString，NSNumber，NSBlock，[NSNull null]会分别转为JS端的Array/Object/String/Number/function/null。</p>
<p>那其他无法通过JavascriptCore.framework进行bridge转换的数据类型，比如自定义的类的对象，Class类型，指针，要如何在JS和OC两端进行传递呢？</p>
<p>JSPatch中使用了一个叫做JPBoxing的类去封装id、指针、Class类型变量，封装完以后这个Boxing对象会被放在一个NSDictionary里(NSDictionary可转化为JS中的Object类型)，传递给JS代码。<a href="#jspatch-boxing">后面</a>会对JPBoxing进行详细的介绍.</p>
<p>回到startEngine方法:</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">context</span><span class="p">[</span><span class="s">@&quot;_OC_defineClass&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">classDeclaration</span><span class="p">,</span> <span class="n">JSValue</span> <span class="o">*</span><span class="n">instanceMethods</span><span class="p">,</span> <span class="n">JSValue</span> <span class="o">*</span><span class="n">classMethods</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">defineClass</span><span class="p">(</span><span class="n">classDeclaration</span><span class="p">,</span> <span class="n">instanceMethods</span><span class="p">,</span> <span class="n">classMethods</span><span class="p">);</span>
</span><span class="line">    <span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="n">context</span><span class="p">[</span><span class="s">@&quot;_OC_callI&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="n">JSValue</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">selectorName</span><span class="p">,</span> <span class="n">JSValue</span> <span class="o">*</span><span class="n">arguments</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="n">isSuper</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">callSelector</span><span class="p">(</span><span class="nb">nil</span><span class="p">,</span> <span class="n">selectorName</span><span class="p">,</span> <span class="n">arguments</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">isSuper</span><span class="p">);</span>
</span><span class="line">    <span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="n">context</span><span class="p">[</span><span class="s">@&quot;_OC_callC&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">className</span><span class="p">,</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">selectorName</span><span class="p">,</span> <span class="n">JSValue</span> <span class="o">*</span><span class="n">arguments</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">callSelector</span><span class="p">(</span><span class="n">className</span><span class="p">,</span> <span class="n">selectorName</span><span class="p">,</span> <span class="n">arguments</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="n">NO</span><span class="p">);</span>
</span><span class="line">    <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>在这里定义的函数主要是负责处理转换从JS端传过来的参数，然后在OC端运用runtime里的方法实现生成新的类、替换旧的类、调用方法等等功能。</p>
<p>其中<code>_OC_defineClass</code>负责定义新的类或替换原有的类，<code>_OC_callI</code>负责调用实例方法，<code>_OC_callC</code>负责调用类方法。</p>
<p>除了这三个函数之外，startEngine中还封装了一些常用GCD方法、console.log、sizeof、Javascript异常捕获函数等等。</p>
<p>准备完JSContext之后，就可以加载从网络中下载的JS补丁，调用<code>[JPEngeine evaluateScript:script]</code>方法执行脚本。</p>
<h3 id="defineClass">defineClass</h3>
<p>接下来讲解JSPatch中如何定义一个类以及怎么覆盖原方法或新增一个方法。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="nx">defineClass</span><span class="p">(</span><span class="s1">&#39;JPViewController&#39;</span><span class="p">,</span> <span class="p">{</span>
</span><span class="line">  <span class="nx">handleBtn</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">sender</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kd">var</span> <span class="nx">tableViewCtrl</span> <span class="o">=</span> <span class="nx">JPTableViewController</span><span class="p">.</span><span class="nx">alloc</span><span class="p">().</span><span class="nx">init</span><span class="p">()</span>
</span><span class="line">    <span class="nx">self</span><span class="p">.</span><span class="nx">navigationController</span><span class="p">().</span><span class="nx">pushViewController_animated</span><span class="p">(</span><span class="nx">tableViewCtrl</span><span class="p">,</span> <span class="nx">YES</span><span class="p">)</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">},</span> <span class="p">{})</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><code>defineClass</code>函数可接受三个参数：</p>
<ol>
<li>字符串:”需要替换或者新增的类名:继承的父类名 &lt;实现的协议1，实现的协议2&gt;”</li>
<li>{实例方法}</li>
<li>{类方法}</li>
</ol>
<p>将这三个参数通过bridging传入到OC后，执行以下步骤:</p>
<ol>
<li>使用NSScanner分离classDeclaration，分离成三部分<ul>
<li>类名 : className</li>
<li>父类名 : superClassName</li>
<li>实现的协议名 : protocalNames</li>
</ul>
</li>
<li>使用NSClassFromString(className)获得该Class对象。<ul>
<li>若该Class对象为nil，则说明JS端要添加一个新的类，使用<code>objc_allocateClassPair</code>与<code>objc_registerClassPair</code>注册一个新的类。</li>
<li>若该Class对象不为nil，则说明JS端要替换一个原本已存在的类</li>
</ul>
</li>
<li>根据从JS端传递来的实例方法与类方法参数，为这个类对象添加/替换实例方法与类方法<ul>
<li>添加实例方法时，直接使用上一步得到class对象; 添加类方法时需要调用<code>objc_getMetaClass</code>方法获得元类。</li>
<li>如果要替换的类已经定义了该方法，则直接对该方法替换和实现消息转发。</li>
<li>否则根据以下两种情况进行判断<ul>
<li>遍历protocalNames，通过<code>objc_getProtocol</code>方法获得协议对象，再使用<code>protocol_copyMethodDescriptionList</code>来获得协议中方法的type和name。匹配JS中传入的selectorName，获得typeDescription字符串，对该协议方法的实现消息转发。</li>
<li>若不是上述两种情况，则js端请求添加一个新的方法。构造一个typeDescription为”@@:\@****”(返回类型为id，参数值根据JS定义的参数个数来决定。新增方法的返回类型和参数类型只能为id类型，因为在JS端只能定义对象)的IMP。将这个IMP添加到类中。</li>
</ul>
</li>
</ul>
</li>
<li>为该类添加<code>setProp:forKey</code>和<code>getProp:</code>方法，使用<code>objc_getAssociatedObject</code>与<code>objc_setAssociatedObject</code>让JS脚本拥有设置property的能力</li>
<li>返回{className:cls}回JS脚本。</li>
</ol>
<h3 id="overrideMethod方法">overrideMethod方法</h3>
<p>不管是替换方法还是新增方法，都是使用<code>overrideMethod</code>方法。<br />它接受五个参数:</p>
<ul>
<li>类名</li>
<li>要替换的方法名</li>
<li>JS中定义的方法</li>
<li>是否类方法</li>
<li>方法的typeDescription</li>
</ul>
<p>原型如下</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="n">overrideMethod</span><span class="p">(</span><span class="n">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">selectorName</span><span class="p">,</span> <span class="n">JSValue</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="n">isClassMethod</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">typeDescription</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>逻辑步骤如下</p>
<ol>
<li>初始化：更具selectorName获取对应的Selector；typeDescription获得NSMethodSignature方法签名。</li>
<li>保存原有方法的IMP，添加名为<code>@&quot;ORIG&quot; + selectorName</code>的方法，IMP为原方法的IMP。</li>
<li>将原方法的IMP设置为消息转发<ul>
<li>若该方法的返回值为特殊的struct类型，则需要将IMP设置为<code>(IMP)_objc_msgForward_stret</code></li>
<li>否则的话将IMP设置为<code>_objc_msgForward</code></li>
</ul>
</li>
<li>保存原有转发方法<code>forwardInvocation:</code>的IMP，添加selectorName为@”ORIGforwardInvocation:”，IMP为原转发方法IMP的方法。</li>
<li>将原转发方法替换为自己的转发方法<code>JPForwardInvocation</code></li>
<li>根据替换/添加方法的返回类型，选择不同的替换IMP(使用宏的形式定义)，替换原方法。</li>
</ol>
<h3 id="callSelector方法">callSelector方法</h3>
<p>在JS端调用OC方法时，都需要通过在OC端通过<code>callSelector</code>方法进行方法的查找以及参数类型、返回类型的转换和处理。</p>
<p>该方法接受五个参数</p>
<ul>
<li>调用对象的类名</li>
<li>被调用的selectorName</li>
<li>JS中传递过来的参数</li>
<li>JS端封装的实例对象</li>
<li>是否调用的是super类的方法</li>
</ul>
<p>方法的原型：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">static</span> <span class="kt">id</span> <span class="n">callSelector</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">className</span><span class="p">,</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">selectorName</span><span class="p">,</span> <span class="n">JSValue</span> <span class="o">*</span><span class="n">arguments</span><span class="p">,</span> <span class="n">JSValue</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="n">isSuper</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>逻辑步骤如下</p>
<ol>
<li>初始化<ul>
<li>将JS封装的instance对象进行拆装，得到OC的对象；</li>
<li>根据类名与selectorName获得对应的类对象与selector；</li>
<li>通过类对象与selector构造对应的NSMethodSignature签名，再根据签名构造NSInvocation对象，并为invocation对象设置target与Selector</li>
</ul>
</li>
<li>根据方法签名，获悉方法每个参数的实际类型，将JS传递过来的参数进行对应的转换(比如说参数的实际类型为int类型，但是JS只能传递NSNumber对象，需要通过<code>[[jsObj toNumber] intValue]</code>进行转换)。转换后使用<code>setArgument方法</code>为NSInvocation对象设置参数。</li>
<li>执行invoke方法。</li>
<li>通过getReturnValue方法获取到返回值。</li>
<li>根据返回值类型，封装成JS中对应的对象(因为JS并不识别OC对象，所以返回值为OC对象的话需封装成{<strong>className:className, </strong>obj:obj})返回给JS端。</li>
</ol>
<h3 id="JPForwardInvocation方法">JPForwardInvocation方法</h3>
<p>JPForwardInvocation方法替换了原有<code>-forwardInvocation</code>方法的实现，使得消息转发都通过该方法，并将消息转发给JS脚本中定义的方法，通过JavascriptCore.frameWork中提供的<code>callWithArguments</code>方法调用JS方法达到替换原方法，添加新方法的目的。是实现替换和新增方法的核心。</p>
<p>它的原型与ForwardInvocation方法相同</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="n">JPForwardInvocation</span><span class="p">(</span><span class="kt">id</span> <span class="n">slf</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">selector</span><span class="p">,</span> <span class="n">NSInvocation</span> <span class="o">*</span><span class="n">invocation</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>它的内部逻辑并不复杂，主要是读取出传入的invocation对象中的所有参数，根据实际参数的类型将JSValue类型的参数转换成对应的OC类型，最后将参数添加到_TMPInvocationArguments数组以供JS调用。</p>
<p>那如果有一些类确实有用到这个方法进行消息转发（比如为了实现多继承），那原来的逻辑该怎么办？ </p>
<p>JSPatch在替换<code>-forwardInvocation:</code>方法前会新建一个方法<code>-ORIGforwardInvocation:</code>，保存原来的实现IMP，在新的<code>-forwardInvocation:</code>实现里做了个判断，如果转发的方法是JS脚本中想改写的，就走<code>-JPForwardInvocation:</code>逻辑，若不是，就调用<code>-ORIGforwardInvocation:</code>走原来的流程。</p>
<h3 id="对象的持有/转换"><a name="jspatch-convert"></a>对象的持有/转换</h3>
<p>原作者bang在<a href="http://blog.cnbang.net/tech/2808/" target="_blank" rel="external">他的博文中</a>，有较为详细的说明。下面引用了他文章中关于对象持有/转换的细节.</p>
<p>UIView.alloc() 通过上述消息传递后会到OC执行 [UIView alloc]，并返回一个UIView实例对象给JS，这个OC实例对象在JS是怎样表示的呢？怎样可以在JS拿到这个实例对象后可以直接调用它的实例方法 (UIView.alloc().init())？</p>
<p>对于一个自定义id对象，JavaScriptCore会把这个自定义对象的指针传给JS，这个对象在JS无法使用，但在回传给OC时OC可以找到这个对象。对于这个对象生命周期的管理，按我的理解如果JS有变量引用时，这个OC对象引用计数就加1 ，JS变量的引用释放了就减1，如果OC上没别的持有者，这个OC对象的生命周期就跟着JS走了，会在JS进行垃圾回收时释放。<br />传回给JS的变量是这个OC对象的指针，如果不经过任何处理，是无法通过这个变量去调用实例方法的。所以在返回对象时，JSPatch会对这个对象进行封装。</p>
<p>首先，告诉JS这是一个OC对象：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">static</span> <span class="n">NSDictionary</span> <span class="o">*</span><span class="nf">toJSObj</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="err">@</span><span class="p">{</span><span class="s">@&quot;__isObj&quot;</span><span class="o">:</span> <span class="err">@</span><span class="p">(</span><span class="n">YES</span><span class="p">),</span> <span class="s">@&quot;cls&quot;</span><span class="o">:</span> <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">obj</span> <span class="n">class</span><span class="p">]),</span> <span class="s">@&quot;obj&quot;</span><span class="o">:</span> <span class="n">obj</span><span class="p">};</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>用__isObj表示这是一个OC对象，对象指针也一起返回。接着在JS端会把这个对象转为一个 JSClass 实例：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="kd">var</span> <span class="nx">_formatOCToJS</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">obj</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">obj</span> <span class="o">==</span> <span class="s2">&quot;object&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">__obj</span><span class="p">)</span> <span class="k">return</span> <span class="nx">obj</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">__isNull</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span>  <span class="c1">//注:这里是为了让JS能够链式调用</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Array</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class="line">      <span class="nx">obj</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="nx">ret</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">_formatOCToJS</span><span class="p">(</span><span class="nx">o</span><span class="p">))</span>
</span><span class="line">      <span class="p">})</span>
</span><span class="line">      <span class="k">return</span> <span class="nx">ret</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Function</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">        <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj</span><span class="err">，</span><span class="nx">_OC_formatJSToOC</span><span class="p">(</span><span class="nx">args</span><span class="p">))</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Object</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class="line">      <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="nx">ret</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_formatOCToJS</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">      <span class="k">return</span> <span class="nx">ret</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="nx">obj</span>
</span><span class="line">  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>接着看看对象是怎样回传给OC的。上述例子中，view.setBackgroundColor(require(‘UIColor’).grayColor())，这里生成了一个 UIColor 实例对象，并作为参数回传给OC。根据上面说的，这个 UIColor 实例在JS中的表示是一个 JSClass 实例，所以不能直接回传给OC，这里的参数实际上会在 <strong>c 函数进行处理，会把对象的 .</strong>obj 原指针回传给OC。</p>
<p>整个对象的持有/转换的流程图如下:</p>
<p><img src="http://blog.cnbang.net/wp-content/uploads/2015/06/JSPatch1.png" alt="convertpng" /></p>
<h2 id="四、JSPatch_Extension机制"><a name="jspatch-Extension">四、JSPatch Extension机制</a></h2>
<h3 id="如何在JSPatch中预定义C_API供JS调用">如何在JSPatch中预定义C API供JS调用</h3>
<p>上面已经介绍过JSPatch是运用Objective-C runtime和JSBinding技术来在JS中调用Objective-C的方法，但是C API是没法通过runtime技术来获取的。一开始的时候我想使用<code>dlsym</code>函数通过函数名来获取对应的函数指针，通过JS脚本传入C函数的函数名来进行函数调用。但实际上还需要预先定义一个相同类型的函数指针才能调用，做不到完全的动态调用。而且还有一个问题就是像CGRectMake这种，实质上是内联函数，并没有对应的函数地址。更关键的是，没有办法获取C函数的签名，而JS中调用函数是没有具体类型的，传递到OC是以JSValue对象的形式，必须通过转换才能调用对应的C函数。最后的解决方法便是预先在JSContext中提供JS方法和C函数的桥接方法。</p>
<p>这里以定义CGRectMake()来作为例子，如果想在JS中使用CGRectMake()函数，则需要在JPEngine启动的时候，将CGRectMake预定义在JSContext之中。</p>
<p>而且有一点要注意的，CGRectMake返回的并不是一个对象，而是一个struct类型的变量。struct类型是无法返回到JS环境的，所以要转换成NSDictionary的形式。</p>
<p>Extension中需要定义对应的方法来将struct转换成NSDictionary</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">+</span> <span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nf">dictOfStruct:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">structData</span> <span class="nf">typeString:</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="nv">type</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">type</span><span class="err">，</span><span class="k">@encode</span><span class="p">(</span><span class="n">CGRect</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">CGRect</span> <span class="o">*</span><span class="n">rect</span> <span class="o">=</span> <span class="n">structData</span><span class="p">;</span>
</span><span class="line">        <span class="k">return</span> <span class="err">@</span><span class="p">{</span><span class="s">@&quot;x&quot;</span><span class="o">:</span> <span class="err">@</span><span class="p">(</span><span class="n">rect</span><span class="o">-&gt;</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">),</span> <span class="s">@&quot;y&quot;</span><span class="o">:</span> <span class="err">@</span><span class="p">(</span><span class="n">rect</span><span class="o">-&gt;</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="s">@&quot;width&quot;</span><span class="o">:</span> <span class="err">@</span><span class="p">(</span><span class="n">rect</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">)</span><span class="err">，</span><span class="s">@&quot;height&quot;</span><span class="o">:</span> <span class="err">@</span><span class="p">(</span><span class="n">rect</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)};</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//下面接着定义其他类型的Struct</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这样就可以在startEngine中定义CGRectMake方法了，具体如下</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">context</span><span class="p">[</span><span class="s">@&quot;CGRectMake&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="n">JSValue</span> <span class="o">*</span><span class="n">x</span><span class="err">，</span><span class="n">JSValue</span> <span class="o">*</span><span class="n">y</span><span class="err">，</span><span class="n">JSValue</span> <span class="o">*</span><span class="n">width</span><span class="err">，</span><span class="n">JSValue</span> <span class="o">*</span><span class="n">height</span><span class="p">){</span>
</span><span class="line">        <span class="n">CGRect</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">([</span><span class="n">x</span> <span class="n">toDouble</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span> <span class="n">toDouble</span><span class="p">],</span> <span class="p">[</span><span class="n">width</span> <span class="n">toDouble</span><span class="p">],</span> <span class="p">[</span><span class="n">height</span> <span class="n">toDouble</span><span class="p">]);</span>
</span><span class="line">        <span class="k">return</span> <span class="p">[</span><span class="n">JPEngine</span> <span class="nl">dictOfStruct:</span><span class="o">&amp;</span><span class="n">rect</span> <span class="nl">typeString:</span><span class="k">@encode</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)];</span>
</span><span class="line">    <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>在JS中就可以如此调用桥接函数</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="kd">var</span> <span class="nx">frame</span> <span class="o">=</span> <span class="nx">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><a name="jspatch-boxing"></a>但是如果返回的值是一个<strong>指针或者参数值为指针</strong>要如何解决？</p>
<p>这时候就需要一个Boxing对象对指针和Class这些在JS中无法使用的变量类型进行装箱(box);在JS中调用OC或C方法后，传递回到Objective-C端的再进行拆箱(unbox)。</p>
<p>Boxing对象的定义如下:</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@interface</span> <span class="nc">JPBoxing</span> : <span class="nc">NSObject</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="kt">id</span> <span class="n">obj</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pointer</span><span class="p">;</span>
</span><span class="line"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">Class</span> <span class="n">cls</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">unbox</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nf">unboxPointer</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">unboxClass</span><span class="p">;</span>
</span><span class="line"><span class="k">@end</span>
</span><span class="line">
</span><span class="line"><span class="k">@implementation</span> <span class="nc">JPBoxing</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define JPBOXING_GEN(_name, _prop, _type) \</span>
</span><span class="line"><span class="cp">+ (instancetype)_name:(_type)obj  \</span>
</span><span class="line"><span class="cp">{   \</span>
</span><span class="line"><span class="cp">    JPBoxing *boxing = [[JPBoxing alloc] init]; \</span>
</span><span class="line"><span class="cp">    boxing._prop = obj;   \</span>
</span><span class="line"><span class="cp">    return boxing;  \</span>
</span><span class="line"><span class="cp">}</span>
</span><span class="line">
</span><span class="line"><span class="n">JPBOXING_GEN</span><span class="p">(</span><span class="n">boxObj</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">id</span><span class="p">)</span>
</span><span class="line"><span class="n">JPBOXING_GEN</span><span class="p">(</span><span class="n">boxPointer</span><span class="p">,</span> <span class="n">pointer</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
</span><span class="line"><span class="n">JPBOXING_GEN</span><span class="p">(</span><span class="n">boxClass</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">Class</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">unbox</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">obj</span><span class="p">)</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">obj</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">unboxPointer</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">pointer</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="o">-</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="n">unboxClass</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">cls</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>注意到unbox里的一个<code>return self</code>的写法，这里是一个trick。因为前面介绍到的<code>formatJSToOC</code>函数的定义如下</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="kt">id</span> <span class="n">formatJSToOC</span><span class="p">(</span><span class="n">JSValue</span> <span class="o">*</span><span class="n">jsval</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这个函数需要负责处理JS到OC端的类型转换，但是如果变量类型是指针或者Class类型的话就和无法和id类型写在同一个处理函数里。所以如果是JPBoxing中的obj为nil，则说明是非id类型，直接返回这个JPBoxing。外部得到的这个JPBoxing对象，则再进行相应类型拆箱。</p>
<p>使用这个Boxing类，调用Extension中的C API时，对指针拆箱，再调用实际的C方法; 返回时，对JS中无法使用的类型进行装箱后再返回; 根据这个机制便可实现对大部分C API的封装。下面以<code>UIGraphicsGetCurrentContext()</code>为例:</p>
<p><img src="http://ww1.sinaimg.cn/mw1024/68e55315gw1eu0bbdxplrj20e5026mxg.jpg" alt="jpboxing1" /><br /><img src="http://ww4.sinaimg.cn/mw1024/68e55315gw1eu0bb95xx3j20ez0aa75n.jpg" alt="jpboxing2" /></p>
<p>效果如下：</p>
<p><img src="http://ww1.sinaimg.cn/mw1024/68e55315gw1eu0bb1sjvsj208w0geaa7.jpg" alt="jpboxing3" /></p>
<h3 id="使用JPExtesnion扩展机制对C_API和Struct进行扩展">使用JPExtesnion扩展机制对C API和Struct进行扩展</h3>
<p>在上一节，我对如何在JSPatch中调用C API进行了介绍。 但是面对大量的C API，需要一个满足以下需求的扩展机制：</p>
<ol>
<li>可模块化加载</li>
<li>js脚本可动态加载</li>
<li>可以在extension中添加struct类型</li>
</ol>
<p>以下是JPExtension协议的定义，所有的C API扩展都需要继承JPExtension协议</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">@protocol</span> <span class="nc">JPExtensionProtocol</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">@optional</span>
</span><span class="line"><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">main:</span><span class="p">(</span><span class="n">JSContext</span> <span class="o">*</span><span class="p">)</span><span class="n">context</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span><span class="nf">sizeOfStructWithTypeName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">typeName</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nf">dictOfStruct:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">structData</span> <span class="nf">typeName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">typeName</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">structData:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">structData</span> <span class="nf">ofDict:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">dict</span> <span class="nf">typeName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">typeName</span><span class="p">;</span>
</span><span class="line"><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>开发者可在<code>- (void)main:(JSContext * )context</code>中添加C API，C API会被添加到JS所在的执行环境中。而后面的三个方法从方法名可以知道，extension中如果要定义struct的话则需要实现这三个方法。因为JS中是无法定义和使用c struct的，所以需要提供相应的互相转换方法(struct与NSDictionary互相转换)，具体实现以<code>CGAffineTransform</code>为例：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span><span class="nf">sizeOfStructWithTypeName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">typeName</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">typeName</span> <span class="nl">rangeOfString:</span><span class="s">@&quot;CGAffineTransform&quot;</span><span class="p">].</span><span class="n">location</span> <span class="o">!=</span> <span class="n">NSNotFound</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CGAffineTransform</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nf">dictOfStruct:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">structData</span> <span class="nf">typeName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">typeName</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">typeName</span> <span class="nl">rangeOfString:</span><span class="s">@&quot;CGAffineTransform&quot;</span><span class="p">].</span><span class="n">location</span> <span class="o">!=</span> <span class="n">NSNotFound</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">CGAffineTransform</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="p">(</span><span class="n">CGAffineTransform</span> <span class="o">*</span><span class="p">)</span><span class="n">structData</span><span class="p">;</span>
</span><span class="line">        <span class="k">return</span> <span class="p">[</span><span class="n">JPCGTransform</span> <span class="nl">transDictOfStruct:</span><span class="n">trans</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">structData:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">structData</span> <span class="nf">ofDict:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">dict</span> <span class="nf">typeName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">typeName</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">typeName</span> <span class="nl">rangeOfString:</span><span class="s">@&quot;CGAffineTransform&quot;</span><span class="p">].</span><span class="n">location</span> <span class="o">!=</span> <span class="n">NSNotFound</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="p">[</span><span class="n">JPCGTransform</span> <span class="nl">transStruct:</span><span class="n">structData</span> <span class="nl">ofDict:</span><span class="n">dict</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>实现了这三个方法后，JPEngine会将实现了这三个方法extesnion放入_structExtension内。当在JS中调用含有相关struct的方法时，JSEngine会遍历整个_structExtension，找到相应的转换方法。</p>
<p>根据JPExtension协议，模块化加载就变得非常简单：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">main:</span><span class="p">(</span><span class="n">JSContext</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">NSArray</span> <span class="o">*</span><span class="n">extensionArray</span> <span class="o">=</span> <span class="err">@</span><span class="p">[[</span><span class="n">JPCGTransform</span> <span class="n">instance</span><span class="p">],</span> <span class="p">[</span><span class="n">JPCGContext</span> <span class="n">instance</span><span class="p">],</span>
</span><span class="line">                                            <span class="p">[</span><span class="n">JPCGGeometry</span> <span class="n">instance</span><span class="p">],</span> <span class="p">[</span><span class="n">JPCGBitmapContext</span> <span class="n">instance</span><span class="p">],</span>
</span><span class="line">                                            <span class="p">[</span><span class="n">JPCGColor</span> <span class="n">instance</span><span class="p">],</span> <span class="p">[</span><span class="n">JPCGImage</span> <span class="n">instance</span><span class="p">],</span> <span class="p">[</span><span class="n">JPCGPath</span> <span class="n">instance</span><span class="p">]];</span>
</span><span class="line">    <span class="p">[</span><span class="n">JPEngine</span> <span class="nl">addExtensions:</span><span class="n">extensionArray</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>在JS脚本则可以这样调用：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="p">(</span><span class="kd">function</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">    <span class="kd">var</span> <span class="nx">extensionArr</span> <span class="o">=</span> <span class="p">[</span><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;JPCoreGraphics&#39;</span><span class="p">).</span><span class="nx">instance</span><span class="p">(),</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;JPUIKit&#39;</span><span class="p">).</span><span class="nx">instance</span><span class="p">()]</span>
</span><span class="line">    <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;JPEngine&#39;</span><span class="p">).</span><span class="nx">addExtensions</span><span class="p">(</span><span class="nx">extensionArr</span><span class="p">)</span>
</span><span class="line"><span class="p">})()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>当然，为了提高项目的性能，你也可以只调用你需要的模块。</p>
<h3 id="C_API定义时需要注意的问题">C API定义时需要注意的问题</h3>
<p>C API中，有大量的参数或者是返回类型都是指针，包括像CGContextRef这种也是指针，而OC对象在JS环境中也是无法使用的。上面的章节已经提到了从OC端返回给JS端时必须用一个封装对象(JPBoxing)来将指针和对象封装起来。JPExtension提供了以下API来封装OC中的对象和指针成JPBoxing和将JPBoxing对象。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nf">formatPointerJSToOC:</span><span class="p">(</span><span class="n">JSValue</span> <span class="o">*</span><span class="p">)</span><span class="nv">val</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">formatPointerOCToJS:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">pointer</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">formatJSToOC:</span><span class="p">(</span><span class="n">JSValue</span> <span class="o">*</span><span class="p">)</span><span class="nv">val</span><span class="p">;</span>
</span><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">formatOCToJS:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">obj</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>C API封装实例:</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">context</span><span class="p">[</span><span class="s">@&quot;UIGraphicsGetCurrentContext&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">^</span><span class="kt">id</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">        <span class="n">CGContextRef</span> <span class="n">c</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class="line">        <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nl">formatPointerOCToJS:</span><span class="n">c</span><span class="p">];</span>
</span><span class="line">    <span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="n">context</span><span class="p">[</span><span class="s">@&quot;UIGraphicsBeginImageContext&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">^</span><span class="kt">void</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">sizeDict</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">CGSize</span> <span class="n">size</span><span class="p">;</span>
</span><span class="line">        <span class="p">[</span><span class="n">JPCGGeometry</span> <span class="nl">sizeStruct:</span><span class="o">&amp;</span><span class="n">size</span> <span class="nl">ofDict:</span><span class="n">sizeDict</span><span class="p">];</span>
</span><span class="line">        <span class="n">UIGraphicsBeginImageContext</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class="line">    <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>注意到<code>UIGraphicsGetCurrentContext()</code>中返回的是一个CGContextRef类型，所以添加这个扩展API的时候需要将返回类型改为id类型，并将CGContextRef指针封装在JPBoxing中。而<code>UIGraphicsBeginImageContext()</code>需要的是一个CGSize参数，这时候需要在JS端传入一个<code>{x:100, y:100}</code>的Javascript object，这个object会在OC中被转换为NSDictionary.</p>
<p>C API的返回值也需要判断返回值的类型来进行不同的封装，当返回的结果是JavascriptCore.Framework所不支持转换的类型(NSArray，NSDictionary，NSString，NSNumber，NSBlock)，则需要通过<code>formatOCToJS:</code>方法来封装返回。而且返回类型是NSArray，NSDictionary，NSString时，如果你直接返回，JavascriptCore会将返回值转换为JS中的Array，Object，String，你就无法再使用OC的方法。如果你想在JS中使用这三种类型的方法，也需要用<code>formatOCToJS:</code>方法进行封装。</p>
<h3 id="在JSPatch中的操作内存与&amp;取地址运算符">在JSPatch中的操作内存与&amp;取地址运算符</h3>
<p>与C语言不同，Javascript不能显式的声明一个指向某块内存的指针，也没有<code>&amp;</code>取地址运算符，Javascript是根据参数是引用类型还是基本类型决定传递引用还是传参。但是指针与取地址在C语言以及OC中都会时常被用到。比如如下的情况:</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">......</span>
</span><span class="line"><span class="n">NSString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">@&quot;littleliang&quot;</span><span class="p">;</span>
</span><span class="line"><span class="p">[</span><span class="n">invocation</span> <span class="nl">setArgument:</span><span class="o">&amp;</span><span class="n">str</span> <span class="nl">atIndex:</span><span class="mi">2</span><span class="p">];</span>
</span><span class="line"><span class="p">......</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>JPMemory扩展解决了这个问题，其中封装了内存操作中常用的一些常用的c函数。包括<code>malloc</code>，<code>memset</code>，<code>free</code>，<code>memcpy</code>，<code>memncpy</code>，<code>memmove</code>。</p>
<p>而对<code>&amp;</code>取地址运算符，JPMemory扩展也进行了函数封装，在JS补丁中可以对调用<code>getpointer</code>方法获取对象的指针、指针的指针，针对上述的代码，现在便可以以以下的形式调用。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="p">......</span>
</span><span class="line"><span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;NSString&#39;</span><span class="p">).</span><span class="nx">stringWithString</span><span class="p">(</span><span class="s1">&#39;littleliang&#39;</span><span class="p">)</span>
</span><span class="line"><span class="nx">invocation</span><span class="p">.</span><span class="nx">setArgument_atIndex</span><span class="p">(</span><span class="nx">getpointer</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span><span class="err">，</span><span class="mi">2</span><span class="p">)</span>
</span><span class="line"><span class="p">......</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>getpointer的底层源码如下:</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nf">getPointerFromJS:</span><span class="p">(</span><span class="n">JSValue</span> <span class="o">*</span><span class="p">)</span><span class="nv">val</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">void</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([[</span><span class="n">val</span> <span class="n">toObject</span><span class="p">]</span> <span class="nl">isKindOfClass:</span><span class="p">[</span><span class="n">NSDictionary</span> <span class="n">class</span><span class="p">]])</span> <span class="p">{</span>
</span><span class="line">        <span class="k">if</span> <span class="p">([[</span><span class="n">val</span> <span class="n">toObject</span><span class="p">][</span><span class="s">@&quot;__obj&quot;</span><span class="p">]</span> <span class="nl">isKindOfClass:</span><span class="p">[</span><span class="n">JPBoxing</span> <span class="n">class</span><span class="p">]])</span> <span class="p">{</span>
</span><span class="line">            <span class="kt">void</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="p">[(</span><span class="n">JPBoxing</span> <span class="o">*</span><span class="p">)[</span><span class="n">val</span> <span class="n">toObject</span><span class="p">][</span><span class="s">@&quot;__obj&quot;</span><span class="p">]</span> <span class="n">unboxPointer</span><span class="p">];</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">pointer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">;</span>
</span><span class="line">            <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
</span><span class="line">                <span class="kt">id</span> <span class="n">jpobj</span> <span class="o">=</span> <span class="p">[(</span><span class="n">JPBoxing</span> <span class="o">*</span><span class="p">)[</span><span class="n">val</span> <span class="n">toObject</span><span class="p">][</span><span class="s">@&quot;__obj&quot;</span><span class="p">]</span> <span class="n">unbox</span><span class="p">];</span>
</span><span class="line">                <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">jpobj</span><span class="p">;</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">        <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
</span><span class="line">            <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="n">toObject</span><span class="p">][</span><span class="s">@&quot;__obj&quot;</span><span class="p">];</span>
</span><span class="line">            <span class="o">*</span><span class="n">p</span>     <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
</span><span class="line">        <span class="n">NSAssert</span><span class="p">(</span><span class="n">NO</span><span class="p">,</span> <span class="s">@&quot;getpointer only support pointer and id type!&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>而通过JPMemory中的pval或添加pvalWithXXX便可获得指针所指的对象或XXX类型的变量。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">context</span><span class="p">[</span><span class="s">@&quot;pval&quot;</span><span class="p">]</span>    <span class="o">=</span> <span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="n">JSValue</span> <span class="o">*</span><span class="n">jsVal</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="kt">void</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">formatPointerJSToOC:</span><span class="n">jsVal</span><span class="p">];</span>
</span><span class="line">        <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">__unsafe_unretained</span> <span class="kt">id</span> <span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nl">formatOCToJS:</span><span class="n">obj</span><span class="p">];</span>
</span><span class="line">    <span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="n">context</span><span class="p">[</span><span class="s">@&quot;pvalWithBool&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="n">JSValue</span> <span class="o">*</span><span class="n">jsVal</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="kt">void</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">formatPointerJSToOC:</span><span class="n">jsVal</span><span class="p">];</span>
</span><span class="line">        <span class="kt">BOOL</span> <span class="n">b</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">BOOL</span> <span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nl">formatOCToJS:</span><span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithBool:</span><span class="n">b</span><span class="p">]];</span>
</span><span class="line">    <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<h3 id="include函数">include函数</h3>
<p>在JSPatch最新的更新中，支持了在JS中调用include方法。可以在一个JS文件中加载其他JS文件，包括补丁脚本、第三方脚本。</p>
<p>使用方法如下:</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="p">(</span><span class="kd">function</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">    <span class="kd">var</span> <span class="nx">extensionArr</span> <span class="o">=</span> <span class="p">[</span><span class="nx">require</span><span class="p">(</span><span class="s1">&#39;JPInclude&#39;</span><span class="p">).</span><span class="nx">instance</span><span class="p">()]</span>
</span><span class="line">    <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;JPEngine&#39;</span><span class="p">).</span><span class="nx">addExtensions</span><span class="p">(</span><span class="nx">extensionArr</span><span class="p">)</span>
</span><span class="line">    <span class="nx">include</span><span class="p">(</span><span class="s1">&#39;another.js&#39;</span><span class="p">)</span>
</span><span class="line"><span class="p">})()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>在我自己的分支中，include函数支持加载选项。默认加载选项是兼容方式加载（为满足支持OC，会通过正则表达式替换部分函数的调用方法），而第三方库是不需要被改变的。第二个参数是加载选项，默认是0或者不传入第二个参数，加载第三方库是1。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="p">(</span><span class="kd">function</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">    <span class="nx">include</span><span class="p">(</span><span class="s1">&#39;thridparty.js&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line"><span class="p">})()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<h2 id="五、JSPatch中的实现技巧"><a name="jspatch-Tech">五、JSPatch中的实现技巧</a></h2>
<h3 id="GCD的实现">GCD的实现</h3>
<p>JSPatch采用的是预先在JSContext中封装了对GCD的调用，才能在JS中使用GCD，其代码如下。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">__weak</span> <span class="n">JSContext</span> <span class="o">*</span><span class="n">weakCtx</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
</span><span class="line">  <span class="n">context</span><span class="p">[</span><span class="s">@&quot;dispatch_after&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">double</span> <span class="n">time</span><span class="p">,</span> <span class="n">JSValue</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">JSValue</span> <span class="o">*</span><span class="n">currSelf</span> <span class="o">=</span> <span class="n">weakCtx</span><span class="p">[</span><span class="s">@&quot;self&quot;</span><span class="p">];</span>
</span><span class="line">      <span class="n">dispatch_after</span><span class="p">(</span><span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="n">int64_t</span><span class="p">)(</span><span class="n">time</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">)),</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">          <span class="n">JSValue</span> <span class="o">*</span><span class="n">prevSelf</span> <span class="o">=</span> <span class="n">weakCtx</span><span class="p">[</span><span class="s">@&quot;self&quot;</span><span class="p">];</span>
</span><span class="line">          <span class="n">weakCtx</span><span class="p">[</span><span class="s">@&quot;self&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">currSelf</span><span class="p">;</span>
</span><span class="line">          <span class="p">[</span><span class="n">func</span> <span class="nl">callWithArguments:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line">          <span class="n">weakCtx</span><span class="p">[</span><span class="s">@&quot;self&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prevSelf</span><span class="p">;</span>
</span><span class="line">      <span class="p">});</span>
</span><span class="line">  <span class="p">};</span>
</span><span class="line">  <span class="n">context</span><span class="p">[</span><span class="s">@&quot;dispatch_async_main&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">JSValue</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">JSValue</span> <span class="o">*</span><span class="n">currSelf</span> <span class="o">=</span> <span class="n">weakCtx</span><span class="p">[</span><span class="s">@&quot;self&quot;</span><span class="p">];</span>
</span><span class="line">      <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">          <span class="n">JSValue</span> <span class="o">*</span><span class="n">prevSelf</span> <span class="o">=</span> <span class="n">weakCtx</span><span class="p">[</span><span class="s">@&quot;self&quot;</span><span class="p">];</span>
</span><span class="line">          <span class="n">weakCtx</span><span class="p">[</span><span class="s">@&quot;self&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">currSelf</span><span class="p">;</span>
</span><span class="line">          <span class="p">[</span><span class="n">func</span> <span class="nl">callWithArguments:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line">          <span class="n">weakCtx</span><span class="p">[</span><span class="s">@&quot;self&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prevSelf</span><span class="p">;</span>
</span><span class="line">      <span class="p">});</span>
</span><span class="line">  <span class="p">};</span>
</span><span class="line">  <span class="n">context</span><span class="p">[</span><span class="s">@&quot;dispatch_sync_main&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">JSValue</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="k">if</span> <span class="p">([</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">].</span><span class="n">isMainThread</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">          <span class="p">[</span><span class="n">func</span> <span class="nl">callWithArguments:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">          <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">              <span class="p">[</span><span class="n">func</span> <span class="nl">callWithArguments:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line">          <span class="p">});</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">  <span class="p">};</span>
</span><span class="line">  <span class="n">context</span><span class="p">[</span><span class="s">@&quot;dispatch_async_global_queue&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">JSValue</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">JSValue</span> <span class="o">*</span><span class="n">currSelf</span> <span class="o">=</span> <span class="n">weakCtx</span><span class="p">[</span><span class="s">@&quot;self&quot;</span><span class="p">];</span>
</span><span class="line">      <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class="line">          <span class="n">JSValue</span> <span class="o">*</span><span class="n">prevSelf</span> <span class="o">=</span> <span class="n">weakCtx</span><span class="p">[</span><span class="s">@&quot;self&quot;</span><span class="p">];</span>
</span><span class="line">          <span class="n">weakCtx</span><span class="p">[</span><span class="s">@&quot;self&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">currSelf</span><span class="p">;</span>
</span><span class="line">          <span class="p">[</span><span class="n">func</span> <span class="nl">callWithArguments:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class="line">          <span class="n">weakCtx</span><span class="p">[</span><span class="s">@&quot;self&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prevSelf</span><span class="p">;</span>
</span><span class="line">      <span class="p">});</span>
</span><span class="line">  <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>其中有三点需要注意：</p>
<ol>
<li><p>在block里是不能直接使用context的，因为会造成循环引用。所以在这里有两个处理方式，要么是使用__weak修饰符，要么就是使用JavascriptCore.framework提供的api<br /><code>[JSContext currentContext]</code>。</p>
</li>
<li><p>在调用JSContext的<code>callWithArguments:</code>实例方法时，需要先保存JSContext中的实例对象<code>self</code>，调用完之后再重新赋值回去。否则在调用完JS方法后，<code>self</code>会变成nil</p>
</li>
<li><p>还有一点就是在<code>dispatch_sync_main</code>这个方法里，作者对代码所在的运行线程进行了一个判断，如果已经在主线程中就直接执行这个block，防止了死锁的发生。</p>
</li>
</ol>
<h3 id="处理JS脚本的异常">处理JS脚本的异常</h3>
<p>如果JS脚本出现了异常的话，在OC这边是不会知道的，需要使用JavaScriptCore.framwork中的exceptionHandler才能捕获这个异常，具体代码如下</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">context</span><span class="p">.</span><span class="n">exceptionHandler</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">JSContext</span> <span class="o">*</span><span class="n">con</span><span class="p">,</span> <span class="n">JSValue</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
</span><span class="line">        <span class="n">NSAssert</span><span class="p">(</span><span class="n">NO</span><span class="p">,</span> <span class="s">@&quot;js exception: %@&quot;</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
</span><span class="line">    <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<h3 id="使用#pragma来抑制warning">使用#pragma来抑制warning</h3>
<p>作者使用#pargama宏来对一些warning进行了抑制，详细的介绍可以看参考<a href="http://nshipster.cn/clang-diagnostics/" target="_ blank" rel="external">Matt Thomson写的一篇关于clang diagnostics的文章</a>，里面提供了一个<a href="http://fuckingclangwarnings.com/" target="_ blank" rel="external">网站</a>详细地记录了抑制各种warning的写法。</p>
<h3 id="使用宏来预定义IMP函数">使用宏来预定义IMP函数</h3>
<p>由于要替换原有的函数实现，所以要预先定义好各种返回类型的IMP函数。如果全部写出来的话，将会耗费大量篇幅来写差不多的函数实现，这里作者使用了宏来进行替换，具体代码如下</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="cp">#define JPMETHOD_IMPLEMENTATION(_type, _typeString, _typeSelector) \</span>
</span><span class="line"><span class="cp">    JPMETHOD_IMPLEMENTATION_RET(_type, _typeString, return [[ret toObject] _typeSelector]) \</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define JPMETHOD_IMPLEMENTATION_RET(_type, _typeString, _ret) \</span>
</span><span class="line"><span class="cp">static _type JPMETHOD_IMPLEMENTATION_NAME(_typeString) (id slf, SEL selector) {    \</span>
</span><span class="line"><span class="cp">    JSValue *fun = getJSFunctionInObjectHierachy(slf, selector);    \</span>
</span><span class="line"><span class="cp">    JSValue *ret = [fun callWithArguments:_TMPInvocationArguments];  \</span>
</span><span class="line"><span class="cp">    _ret;    \</span>
</span><span class="line"><span class="cp">}   \</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define JPMETHOD_IMPLEMENTATION_NAME(_typeString) JPMethodImplement_##_typeString</span>
</span><span class="line">
</span><span class="line"><span class="cp">#pragma clang diagnostic push</span>
</span><span class="line"><span class="cp">#pragma clang diagnostic ignored &quot;-Wunused-variable&quot;</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define JPMETHOD_RET_ID \</span>
</span><span class="line"><span class="cp">    id obj = formatJSToOC(ret); \</span>
</span><span class="line"><span class="cp">    if ([obj isKindOfClass:[NSNull class]]) return nil;  \</span>
</span><span class="line"><span class="cp">    return obj;</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define JPMETHOD_RET_STRUCT(_methodName)    \</span>
</span><span class="line"><span class="cp">    id dict = formatJSToOC(ret);   \</span>
</span><span class="line"><span class="cp">    return _methodName(dict);</span>
</span><span class="line">
</span><span class="line"><span class="n">JPMETHOD_IMPLEMENTATION_RET</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class="line"><span class="n">JPMETHOD_IMPLEMENTATION_RET</span><span class="p">(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">id</span><span class="p">,</span> <span class="n">JPMETHOD_RET_ID</span><span class="p">)</span>
</span><span class="line"><span class="n">JPMETHOD_IMPLEMENTATION_RET</span><span class="p">(</span><span class="n">CGRect</span><span class="p">,</span> <span class="n">rect</span><span class="p">,</span> <span class="n">JPMETHOD_RET_STRUCT</span><span class="p">(</span><span class="n">dictToRect</span><span class="p">))</span>
</span><span class="line"><span class="n">JPMETHOD_IMPLEMENTATION_RET</span><span class="p">(</span><span class="n">CGSize</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">JPMETHOD_RET_STRUCT</span><span class="p">(</span><span class="n">dictToSize</span><span class="p">))</span>
</span><span class="line"><span class="n">JPMETHOD_IMPLEMENTATION_RET</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">JPMETHOD_RET_STRUCT</span><span class="p">(</span><span class="n">dictToPoint</span><span class="p">))</span>
</span><span class="line"><span class="n">JPMETHOD_IMPLEMENTATION_RET</span><span class="p">(</span><span class="n">NSRange</span><span class="p">,</span> <span class="n">range</span><span class="p">,</span> <span class="n">JPMETHOD_RET_STRUCT</span><span class="p">(</span><span class="n">dictToRange</span><span class="p">))</span>
</span><span class="line"><span class="p">......</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<h2 id="六、遇到的问题与解决方法"><a name="jspatch-problem">六、遇到的问题与解决方法</a></h2>
<p>在了解JSPatch的过程中，也遇到过一些比较棘手的问题，这里总结一下。</p>
<h3 id="1-_在JSPatch中初始化UIWebView导致HTML无法渲染">1. 在JSPatch中初始化UIWebView导致HTML无法渲染</h3>
<p>这个问题最初是由一个JSPatch用户在<a href="https://github.com/bang590/JSPatch/issues/61" target="_blank" rel="external">issue</a>中提出。具体的表现是当在JSPatch中声明一个UIWebView，并对一个URL调用loadRequest方法后，无法渲染该HTML页面。<br /><img src="https://cloud.githubusercontent.com/assets/7334742/8666691/731b0354-2a27-11e5-95cc-90df45fac11f.png" alt="图片" /><br />后来经过查资料发现在JSContext中初始化UIWebView就会<a href="http://stackoverflow.com/questions/28638293/creating-a-uiwebview-from-a-jscontext-block-prevents-assets-from-loading-on-ios8" target="_blank" rel="external">出现这个问题</a>。</p>
<p>我猜测是<code>UIWebView</code>在初始化的过程中会初始化一个全局的<code>JSContext</code>对象，但是JSPatch也有用到<code>JSContext</code>，这其中造成了某种冲突。导致在<code>UIWebView</code>初始化JSContext失败。</p>
<p><strong>解决方法:</strong></p>
<p>1、在JSPatch之外启动调用一次<code>UIWebView</code>的<code>init</code>方法。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">didFinishLaunchingWithOptions:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">launchOptions</span> <span class="p">{</span>
</span><span class="line">    <span class="n">UIWebView</span> <span class="o">*</span><span class="n">view</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIWebView</span> <span class="n">alloc</span><span class="p">]</span><span class="n">init</span><span class="p">];</span>   <span class="c1">//Useless. Just to load the UIWebview framework.</span>
</span><span class="line">    <span class="n">view</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectZero</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="p">[</span><span class="n">JPEngine</span> <span class="n">startEngine</span><span class="p">];</span>
</span><span class="line">   <span class="c1">//.......</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>2、在JSPatch中显式地创建UIWebView的JSContext</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="javascript"><span class="line"><span class="nx">defineClass</span><span class="p">(</span><span class="s1">&#39;UIWebView&#39;</span><span class="p">,{</span>
</span><span class="line">	 <span class="nx">loadRequest</span> <span class="o">:</span><span class="kd">function</span><span class="p">(</span><span class="nx">request</span><span class="p">){</span>
</span><span class="line">	 	<span class="nx">self</span><span class="p">.</span><span class="nx">valueForKeyPath</span><span class="p">(</span><span class="s2">&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span><span class="p">)</span>  		
</span><span class="line">	 	<span class="nx">self</span><span class="p">.</span><span class="nx">ORIGloadRequest</span><span class="p">(</span><span class="nx">request</span><span class="p">)</span>
</span><span class="line"> <span class="p">}</span>
</span><span class="line"><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<h3 id="2-_无法调用参数为id_*类型的方法">2. 无法调用参数为id * 类型的方法</h3>
<p>在上面的章节中我介绍了我是如何在JS中调用一个参数是指针的方法:</p>
<ol>
<li>通过<code>JPMemoery</code>Extension中的<code>malloc</code>声明一个指针或者调用<code>getpointer</code>去获得一个对象的地址。</li>
<li>调用方法后使用<code>pval</code>方法来获得指针所指的对象。</li>
</ol>
<p>这种方法调用像NSInvocation中的<code>- (void)getReturnValue:(void * )retLoc</code>、<code>- (void)setArgument:(void * )argumentLocation atIndex:(NSInteger)idx;</code>以及一些C API没有任何问题。</p>
<p>但是如果调用NSString中的<code>- (BOOL)writeToFile:(NSString * )path atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError * * )error</code>则会发现传进去的指针参数所指向的NSError对象在回到JS环境的时候已经被释放了。</p>
<p>实际上NSError <em>* 参数在编译器中会被解释成NSError \</em>&#8211;__ autoreleasing*类型，该对象生成后将会被加入到autoreleasing- pool中，开发者无法控制他的释放时机。随后，我对各个关键点进行打断点对这个自动释放对象进行跟中，发现这个对象一回到JSContext的执行环境就会被释放。</p>
<p><strong>解决方法：</strong></p>
<p>解决这个问题的思路是在调用完参数为id * 类型的方法后(<code>callSelector</code>中调用完<code>[invocation inoke]</code>后)，对该自动释放对象进行强引用，使得这个对象在回到JS环境的时候依然存在。这里我使用了一个NSDictonry作为临时自动释放对象的内存池，当生成一个自动释放对象后，将其添加到内存池中(key为其内存地址)，使得这个自动释放对象被内存池强引用。保证了在JS环境中可以访问到该对象，不需要该对象时再手动释放该对象(remove掉内存池的对象)。具体逻辑如下:</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="k">case</span> <span class="sc">&#39;^&#39;</span><span class="o">:</span> <span class="p">{</span>
</span><span class="line">                <span class="k">if</span> <span class="p">([</span><span class="n">valObj</span> <span class="nl">isKindOfClass:</span><span class="p">[</span><span class="n">JPBoxing</span> <span class="n">class</span><span class="p">]])</span> <span class="p">{</span>
</span><span class="line">                    <span class="kt">void</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="p">[((</span><span class="n">JPBoxing</span> <span class="o">*</span><span class="p">)</span><span class="n">valObj</span><span class="p">)</span> <span class="n">unboxPointer</span><span class="p">];</span>
</span><span class="line">                    <span class="k">if</span> <span class="p">(</span><span class="n">argumentType</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;@&#39;</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                        <span class="n">memset</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">id</span><span class="p">));</span>
</span><span class="line">                        <span class="p">[</span><span class="n">_markArray</span> <span class="nl">addObject:</span><span class="n">valObj</span><span class="p">];</span>
</span><span class="line">                    <span class="p">}</span>
</span><span class="line">                    <span class="p">[</span><span class="n">invocation</span> <span class="nl">setArgument:</span><span class="o">&amp;</span><span class="n">value</span> <span class="nl">atIndex:</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">                    <span class="k">break</span><span class="p">;</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">            <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>当参数类型是指针的时候进行一个判断，如果指针所指的是id类型。则将JPBoxing加入到一个_markArray中。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="c1">//...</span>
</span><span class="line"><span class="p">[</span><span class="n">invocation</span> <span class="n">invoke</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">([</span><span class="n">_markArray</span> <span class="n">count</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">JPBoxing</span> <span class="o">*</span><span class="n">box</span> <span class="k">in</span> <span class="n">_markArray</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="kt">void</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="p">[</span><span class="n">box</span> <span class="n">unboxPointer</span><span class="p">];</span>
</span><span class="line">            <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">__unsafe_unretained</span> <span class="kt">id</span> <span class="o">*</span><span class="p">)</span><span class="n">pointer</span><span class="p">);</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="k">@synchronized</span><span class="p">(</span><span class="n">_TMPMemoryPool</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                    <span class="p">[</span><span class="n">_TMPMemoryPool</span> <span class="nl">setObject:</span><span class="n">obj</span> <span class="nl">forKey:</span><span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithInteger:</span><span class="p">[</span><span class="n">obj</span> <span class="n">hash</span><span class="p">]]];</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>如果_markArray大小不为零，则将数组中的JPBoxing中指针所指对象加入到内存池中（key为对象的hashCode），使得自动释放对象被强引用。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">context</span><span class="p">[</span><span class="s">@&quot;releaseTmpObj&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">^</span><span class="kt">void</span><span class="p">(</span><span class="n">JSValue</span> <span class="o">*</span><span class="n">jsVal</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">if</span> <span class="p">([[</span><span class="n">jsVal</span> <span class="n">toObject</span><span class="p">]</span> <span class="nl">isKindOfClass:</span><span class="p">[</span><span class="n">NSDictionary</span> <span class="n">class</span><span class="p">]])</span> <span class="p">{</span>
</span><span class="line">            <span class="kt">void</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span>  <span class="p">[(</span><span class="n">JPBoxing</span> <span class="o">*</span><span class="p">)([</span><span class="n">jsVal</span> <span class="n">toObject</span><span class="p">][</span><span class="s">@&quot;__obj&quot;</span><span class="p">])</span> <span class="n">unboxPointer</span><span class="p">];</span>
</span><span class="line">            <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">__unsafe_unretained</span> <span class="kt">id</span> <span class="o">*</span><span class="p">)</span><span class="n">pointer</span><span class="p">);</span>
</span><span class="line">            <span class="k">@synchronized</span><span class="p">(</span><span class="n">_TMPMemoryPool</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="p">[</span><span class="n">_TMPMemoryPool</span> <span class="nl">removeObjectForKey:</span><span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithInteger:</span><span class="p">[</span><span class="n">obj</span> <span class="n">hash</span><span class="p">]]];</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>JSPatch脚本中调用<code>releaseTmpObj</code>方法手动释放该临时对象。</p>
<h2 id="七、总结"><a name="conclusion">七、总结</a></h2>
<p>JSPatch中我的总结如下：</p>
<p>1、 为支持C API的扩展，增加了对指针和Class变量的封装以及拆解。因为JS中并不能使用以及声明一个指针，而在C API中，指针作为参数是非常常见的，所以需要将指针封装在一个JPBoxing中，并以{“__ className”:”JPBoxing”，”__ obj”:[JPBoxing boxPointer:pointer]}的形式回传回JS。下次调用的时候再将__obj中的指针拆解出来。</p>
<p>2、 支持对第三方库的调用。在include方法中增加了对第三方js库调用的支持。</p>
<p>3、 添加了sizeof方法。通过遍历加载到JS中的Extension中实现JPExtension协议的<code>- (size_t)sizeOfStructWithTypeName:(NSString * )typeName</code>方法，使得在JS端可以通过传入一个字符串的形式:<code>sizeof(&#39;CGRect&#39;)</code>来获取不同strut类型变量的大小，配合JPMemory扩展中的方法可以malloc出一块指定大小的内存，传入到某些C API中。</p>
<p>4、 添加JPMemory扩展，Javascript中是无法操作具体的内存也没有指针的概念，但是通过JPMemory扩展，可以让JSPatch拥有操作与访问内存的功能，以及获取对象的指针、指针的指针的功能。</p>
<p>5、 添加了保存的__autoreleasing对象机制，使自动释放对象在返回到JS运行环境的时候不会被自动释放，在JS脚本可以继续访问。使用一个NSDictonry作为临时自动释放对象的内存池，当生成一个自动释放对象后，将其添加到内存池中(key为其内存地址)，使得这个自动释放对象被内存池强引用。保证了在JS环境中可以访问到该对象，不需要的时候再手动释放该对象(remove掉内存池的对象)。</p>
<h4 id="维护："><strong>维护：</strong></h4>
<p>1、 修复了在JS中<a href="https://github.com/bang590/JSPatch/commit/3c9a10cd86fc13f7e0909bb3a2a93bba286aa1c9" target="_ blank" rel="external">传递nil参数时造成的崩溃</a>。JavaScript中并没有nil这个类型的参数，只有undefined以及null类型。桥接的时候JavascriptCore.framework会将js中的null类型转换为OC中的[NSNull null]类型，所以在调用方法时必须加以判断，将[NSNull null]转换为nil。为了防止真需要传递[NSNull null]参数，在JS中设置了一个名为nsnull的全局变量，开发者如要传递[NSNull null]则可以使用nsnull。</p>
<p>2、 修复了使用JSPatch判断struct时造成的<a href="https://github.com/bang590/JSPatch/commit/6df89bec6c8f4217500be316832fecbd898d1b46" target="_ blank" rel="external">误判</a>。原作者bang原本使用的@encode()方法产生的C字符串来遍历加载到JS中的所有extension的<code>- (size_t)sizeOfStructWithTypeEncode:(NSString * )typeName</code>方法，@encode产生结果是这样的形式:<code>{CGPoint=dd}</code>，并使用</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="n">typeEncode</span> <span class="nl">rangeOfString:</span><span class="s">@&quot;CGPoint&quot;</span><span class="p">].</span><span class="n">location</span> <span class="o">!=</span> <span class="n">NSNotFound</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>进行匹配。但事实上这样的方法是会导致CGPoint被误判为CGRect，因为CGRect进行@encode的结果为<code>{CGRect={CGPoint=dd}{CGSize=dd}}</code>。而后bang提议改为</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="objc"><span class="line"><span class="p">[</span><span class="n">typeEncode</span> <span class="nl">rangeOfString:</span><span class="s">@&quot;CGPoint&quot;</span><span class="p">].</span><span class="n">location</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>但是这样会与sizeof功能有所冲突，而且在随后的测试中我发现@encode(NSRange)的结果为<code>{_NSRange=QQ}</code>，所以检测location==1也是不可以行的。最后我通过<a href="https://github.com/bang590/JSPatch/blob/6df89bec6c8f4217500be316832fecbd898d1b46/JSPatch/JPEngine.m#L1003" target="_ blank" rel="external">提取出typeEncode中第一个Struct的名字</a>解决了这一问题</p>
<p>3、 修复了JSPatch添加Extension时造成<a href="https://github.com/bang590/JSPatch/commit/c20e2910ee8e73e3ae22db071a43072c9e6ca149" target="_ blank" rel="external">无限循环加载</a>的问题。</p>
<p>代码提交情况: <a href="https://github.com/bang590/JSPatch/graphs/contributors" target="_ blank" rel="external">1916++ / 348—</a> 及 <a href="https://github.com/bang590/JSPatch/commits/master" target="_ blank" rel="external">commit log</a></p>
<h4 id="未来计划">未来计划</h4>
<p>JSPatch功能上已能满足hot fix动态修复的基本需求。接下来的工作重点主要添加脚本的传输和脚本加密的机制，防止未授权的第三方对脚本进行串改；集成进项目中测试实际性能和内存占用情况，改善性能；根据业务需求继续添加常用扩展API。</p>
<p>（持续更新中…）</p>
<p class="post-footer">
                        written by <a href="http://ITMonkeyLife.github.io/Blog/">Rick</a>&nbsp;posted at <a href="http://ITMonkeyLife.github.io/Blog/">http://ITMonkeyLife.github.io/Blog/</a></p>
</div>


<div class="meta">
	<div class="date">




</div>
	<div class="tags">

</div>
	
	<div class="comments"><a href="#disqus_thread">Comments</a></div>
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
		
		
		
		<a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
		
		
	</div>
	
</div>



<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2016

    Rick

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'ITMonkeyLife';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://ITMonkeyLife.github.io/Blog//Blog/blog/2015/12/23/jspatchyong-fa-pou-xi/';
        var disqus_url = 'http://ITMonkeyLife.github.io/Blog//Blog/blog/2015/12/23/jspatchyong-fa-pou-xi/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-52658428-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>
